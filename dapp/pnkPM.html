<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>pnkPM - PNKSTR Bets</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='600' fill='%23ec4899' text-anchor='middle'>Pnk</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='600' fill='%233b82f6' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --blue-dim: rgba(59, 130, 246, 0.15);
            --amber: #f59e0b;
            --amber-dim: rgba(245, 158, 11, 0.15);
            --pink: #ec4899;
            --pink-dim: rgba(236, 72, 153, 0.15);
            --purple: #a855f7;
            --gray: #27272a;
            --light-gray: #3f3f46;
            --black: #09090b;

            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;
            --font-mono: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--pink); }

        .tagline {
            font-size: var(--font-xs);
            color: var(--text-dim);
            margin-left: 0.75rem;
        }

        .tagline:hover {
            color: var(--pink);
        }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.pink { color: var(--pink); }
        .live-stat-value.green { color: var(--green); }
        .live-stat-value.blue { color: var(--blue); }
        .live-stat-value.amber { color: var(--amber); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--pink);
            color: var(--bg);
            border-color: var(--pink);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* HERO SECTION */
        .hero-section {
            padding: 2rem 1.5rem;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        .hero-title {
            font-size: var(--font-2xl);
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .hero-subtitle {
            color: var(--text-muted);
            font-size: var(--font-sm);
            margin-bottom: 1.5rem;
        }

        .treasury-display {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--surface);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .treasury-balance {
            font-size: var(--font-2xl);
            font-weight: 700;
            color: var(--pink);
        }

        .treasury-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .stats-summary {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 0.875rem;
            margin-bottom: 1rem;
            background: var(--surface);
            border-radius: var(--radius);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1rem;
        }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--pink);
        }

        .bet-card.resolved {
            opacity: 0.7;
        }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
            color: var(--pink);
        }

        .bet-status {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 3px;
        }

        .bet-status.active {
            background: var(--green-dim);
            color: var(--green);
        }

        .bet-status.resolved {
            background: var(--surface-2);
            color: var(--text-muted);
        }

        .bet-status.ready {
            background: rgba(245, 158, 11, 0.15);
            color: var(--amber);
        }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
        }

        .onchain-details {
            margin-top: 0.25rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .onchain-details:hover {
            opacity: 0.8;
        }
        .onchain-details[open] {
            opacity: 0.8;
        }
        .onchain-details summary {
            font-size: 9px;
            color: var(--text-dim);
            cursor: pointer;
            user-select: none;
            list-style: none;
        }
        .onchain-details summary::-webkit-details-marker {
            display: none;
        }
        .onchain-details summary:hover {
            color: var(--text-muted);
        }
        .onchain-desc {
            font-size: 9px;
            color: var(--text-dim);
            background: var(--surface-2);
            padding: 0.4rem;
            border-radius: var(--radius);
            margin-top: 0.25rem;
            word-break: break-all;
            margin-bottom: 0.75rem;
            font-family: monospace;
        }

        .condition-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .condition-point { text-align: center; }

        .condition-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .condition-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .condition-op {
            font-size: 1.25rem;
            color: var(--text-muted);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { background: var(--surface-2); }

        .bet-btn.yes { border-color: var(--green); }
        .bet-btn.yes:hover { background: var(--green-dim); }
        .bet-btn.no { border-color: var(--red); }
        .bet-btn.no:hover { background: var(--red-dim); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.yes .bet-btn-label { color: var(--green); }
        .bet-btn.no .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .liquidity-stats {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-top: 1px solid var(--border);
            margin-top: 0.5rem;
            font-size: var(--font-xs);
            color: var(--text-muted);
        }

        .resolve-btn {
            width: 100%;
            margin-top: 0.5rem;
            padding: 0.75rem;
            background: var(--amber);
            color: var(--black);
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .resolve-btn:hover { opacity: 0.9; }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            max-width: 500px;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--pink);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--pink);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--pink);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-yes { background: var(--green); color: var(--bg); }
        .trade-submit.buy-no { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Wallet Options */
        .wallet-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--gray);
            border: 1px solid var(--light-gray);
            border-radius: var(--radius);
            cursor: pointer;
            margin-bottom: var(--spacing-xs);
            transition: all 0.15s ease;
        }
        .wallet-option:hover { border-color: var(--pink); }
        .wallet-option-icon { font-size: 1.5rem; }
        .wallet-option-name { font-weight: 600; }
        .wallet-option.disconnect {
            border-color: var(--red);
            color: var(--red);
            justify-content: center;
        }
        .wallet-option.disconnect:hover {
            background: var(--red);
            color: var(--black);
        }

        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 380px;
            pointer-events: none;
        }
        .toast {
            padding: 1rem 1.25rem;
            border-radius: var(--radius);
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: var(--font-sm);
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-in forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toast-out {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); }
        }
        .toast-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        .toast.pending .toast-header { color: var(--blue); }
        .toast.success .toast-header { color: var(--green); }
        .toast.error .toast-header { color: var(--red); }
        .toast-body {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }
        .toast-body a {
            color: var(--blue);
            text-decoration: underline;
        }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* EMPTY STATE */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* MOBILE */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; flex-wrap: wrap; }
            .header-center { gap: 1rem; }
            .tagline { display: none; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .hero-section { padding: 1rem; }
            .treasury-display { padding: 0.75rem 1rem; }
            .modal {
                margin: 0.5rem;
                padding: 0.75rem;
                max-width: calc(100vw - 1rem);
            }
            .modal-header { padding: 0.5rem 0.75rem; }
            .modal-body { padding: 0.5rem !important; }
        }

        @media (max-width: 480px) {
            .header-center {
                order: 3;
                width: 100%;
                justify-content: space-around;
                padding-top: 0.5rem;
                border-top: 1px solid var(--border);
                margin-top: 0.5rem;
            }
            .bets-grid { grid-template-columns: 1fr; }
            /* Trade modal position info - stack on mobile */
            #tradeMarketInfo > div { flex-direction: column; gap: 0.5rem; }
            #tradeMarketInfo > div > div:last-child { text-align: left; }
            /* Compact mode buttons */
            .mode-toggle-btn { padding: 0.4rem !important; font-size: 10px !important; }
            /* Limit price buttons - smaller */
            #limitSection .trade-input-group button { padding: 0.4rem 0.5rem; font-size: 10px; }
            /* My Orders - smaller buttons */
            #myOrdersList button { padding: 1px 4px; font-size: 9px; }
        }

        @media (max-width: 380px) {
            /* Extra small screens */
            .bet-buttons { flex-direction: column; gap: 0.5rem; }
            .bet-btn { width: 100%; }
            /* Depth ladder - narrower center column */
            #depthLadder > div { grid-template-columns: 1fr 44px 1fr !important; }
        }
    </style>
</head>
<body>
    <!-- Toast Notifications Container -->
    <div id="toastContainer" class="toast-container"></div>

    <header class="header">
        <div style="display:flex;align-items:center;">
            <div class="logo">pnk<span>PM</span></div>
            <a href="https://www.punkstrategy.fun/" target="_blank" rel="noopener" class="tagline" style="text-decoration: none; transition: color 0.2s;">PNKSTR Prediction Markets ‚Üó</a>
        </div>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">PNKSTR Punks</div>
                <div class="live-stat-value pink" id="livePunks">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Markets</div>
                <div class="live-stat-value blue" id="marketCount">0</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">TVL</div>
                <div class="live-stat-value green" id="totalTvl">--</div>
            </div>
        </div>
        <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
    </header>

    <main class="main">
        <!-- Hero Section -->
        <section class="hero-section">
            <h1 class="hero-title">PNKSTR Treasury CryptoPunks</h1>
            <p class="hero-subtitle">Prediction markets on PNKSTR's CryptoPunks holdings</p>
            <div class="treasury-display">
                <div>
                    <div class="treasury-label">Current Balance</div>
                    <div class="treasury-balance"><span id="heroBalance">--</span> Punks</div>
                </div>
                <div style="border-left:1px solid var(--border);padding-left:1rem;">
                    <div class="treasury-label">Treasury</div>
                    <a href="https://etherscan.io/address/0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838" target="_blank" style="color:var(--text-muted);font-size:var(--font-xs);text-decoration:none;display:flex;align-items:center;gap:4px;">
                        0x1244...4838 <span style="opacity:0.5;">‚Üó</span>
                    </a>
                </div>
                <div style="border-left:1px solid var(--border);padding-left:1rem;">
                    <div class="treasury-label">Token</div>
                    <a href="https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB" target="_blank" style="color:var(--text-muted);font-size:var(--font-xs);text-decoration:none;display:flex;align-items:center;gap:4px;">
                        CryptoPunks <span style="opacity:0.5;">‚Üó</span>
                    </a>
                </div>
            </div>
        </section>

        <!-- Active Markets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Markets</h2>
            <div class="stats-summary">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Active</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Ready to Resolve</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="readyCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Resolved</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--text-muted);" id="resolvedCount">0</div>
                </div>
            </div>
            <div class="bets-grid" id="marketsGrid">
                <div class="empty-state">
                    <div class="empty-state-icon">üîç</div>
                    <p>Loading markets...</p>
                </div>
            </div>
        </section>

        <!-- Create Section (hidden for now - demo market created) -->
        <section class="create-section" id="createSection" style="display:none !important;">
            <h2 class="section-title">Create Market</h2>
            <div class="create-card">
                <div class="create-card-title">PNKSTR Punks Balance Market</div>
                <div class="create-card-desc">Create a market on whether PNKSTR treasury will hold more than a target number of CryptoPunks by a deadline.</div>

                <div class="create-input-group">
                    <label class="create-label">Target Punks (Greater Than)</label>
                    <input type="number" class="create-input" id="createThreshold" value="40" min="1" step="1">
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadline">
                        <option value="eoy2025">End of 2025 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroup" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadline" placeholder="1735689599">
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanClose">
                        <option value="true">Yes - Resolve early when condition met</option>
                        <option value="false">No - Wait until deadline</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeed" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreview" style="color:var(--text);">
                        PNKSTR CryptoPunks balance > 40 by Dec 31, 2025
                    </div>
                </div>

                <button class="create-btn" onclick="createMarket()">Create Market</button>
            </div>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>PNKSTR Treasury:</strong> These markets track the CryptoPunks balance of the PNKSTR treasury address (0x1244...4838). The balance is read directly from the CryptoPunks contract on-chain.<br><br>
                <strong>Resolution:</strong> If the condition is met (e.g., balance >= 40), YES wins. Otherwise, NO wins. Markets with early close can resolve as soon as the condition passes.<br><br>
                <strong>Trading:</strong> Price = Probability. If YES shows 60%, one share costs ~0.60 ETH and pays 1 ETH if YES wins. Losing shares pay nothing.
            </div>
        </section>

        <!-- Footer -->
        <footer style="text-align:center;padding:2rem 0;margin-top:1rem;border-top:1px solid var(--border);color:var(--text-dim);font-size:var(--font-xs);">
            <div style="display:flex;justify-content:center;align-items:center;gap:1.5rem;">
                <a href="https://cryptopunks.app/" target="_blank" style="color:var(--text-muted);text-decoration:none;">CryptoPunks</a>
                <a href="https://etherscan.io/address/0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838" target="_blank" style="color:var(--text-muted);text-decoration:none;">PNKSTR Treasury</a>
                <a href="https://zamm.finance/" target="_blank" style="display:flex;align-items:center;gap:0.5rem;color:var(--text-muted);text-decoration:none;">
                    <img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:20px;height:20px;border-radius:4px;">
                    Built on zAMM
                </a>
            </div>
        </footer>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal" style="max-width:360px;">
            <div class="modal-header">
                <div class="modal-title">Connect Wallet</div>
                <button class="modal-close" onclick="closeWalletModal()">&times;</button>
            </div>
            <div class="modal-body" id="walletOptions"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal">
        <div class="modal" style="max-width:420px;">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeTradeModal()">&times;</button>
            </div>

            <!-- Market Info -->
            <div id="tradeMarketInfo" style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                        <div style="color:var(--text-dim);margin-bottom:0.25rem;">Market</div>
                        <div id="tradeMarketDesc" style="color:var(--text);">--</div>
                    </div>
                    <div style="text-align:right;">
                        <div style="font-size:var(--font-xs);color:var(--text-dim);">Your Position</div>
                        <div style="font-size:var(--font-xs);">
                            <span style="color:var(--green);">YES: <span id="tradeModalYes">0</span></span>
                            <span style="margin-left:0.5rem;color:var(--red);">NO: <span id="tradeModalNo">0</span></span>
                            <span style="margin-left:0.5rem;color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Orderbook Preview (Coinbase-style best prices) -->
            <div id="orderbookPreview" style="background:var(--surface);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                <div style="text-align:center;font-size:var(--font-xs);color:var(--text-dim);">Loading orderbook...</div>
            </div>

            <!-- My Orders Section (only visible when user has orders) -->
            <div id="myOrdersSection" style="display:none;background:var(--amber-dim);border:1px solid var(--amber);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);font-weight:600;color:var(--amber);">Your Active Orders</span>
                    <span id="myOrdersCount" style="font-size:10px;color:var(--amber);background:rgba(245,158,11,0.2);padding:2px 6px;border-radius:4px;">0</span>
                </div>
                <div id="myOrdersList" style="font-size:11px;max-height:120px;overflow-y:auto;">
                </div>
            </div>

            <!-- Mode Toggle -->
            <div style="display:flex;gap:4px;margin-bottom:1rem;background:var(--surface);padding:4px;border-radius:var(--radius);">
                <button id="tradeModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('trade')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green);color:var(--bg);">Trade</button>
                <button id="swapModeBtn" class="mode-toggle-btn" onclick="setTradeMode('swap')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">Swap</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">LP</button>
            </div>

            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <!-- Buy/Sell Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="buyBtn" class="mode-toggle-btn active-buy" onclick="setTradeDirection('buy')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green-dim);color:var(--green);border:1px solid var(--green);">Buy</button>
                    <button id="sellBtn" class="mode-toggle-btn" onclick="setTradeDirection('sell')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Sell</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;flex-wrap:wrap;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="tradeSlip5" class="slip-btn" onclick="setTradeSlippage(5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">5%</button>
                    <button id="tradeSlip10" class="slip-btn slip-active" onclick="setTradeSlippage(10)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">10%</button>
                    <button id="tradeSlip20" class="slip-btn" onclick="setTradeSlippage(20)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">20%</button>
                    <input type="number" id="tradeSlipCustom" placeholder="%" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);border-radius:4px;" onchange="setTradeSlippage(parseFloat(this.value)||10)">
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="tradeAmountLabel">Amount (ETH)</span>
                        <span style="display:flex;align-items:center;gap:0.5rem;">
                            Balance: <span id="tradeBalance">--</span>
                            <button id="tradeMaxBtn" onclick="setTradeMax()" style="display:none;padding:0.25rem 0.5rem;background:var(--red-dim);border:1px solid var(--red);border-radius:var(--radius);color:var(--red);font-weight:600;font-size:10px;cursor:pointer;">Max</button>
                        </span>
                    </div>
                    <input type="number" class="trade-input" id="tradeAmount" placeholder="0.1" step="0.01" min="0" oninput="handleTradeInput()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. Shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPriceLabel">Avg. Price</span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">If you win</span>
                        <span id="previewPayout" style="color:var(--green);">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="font-size:11px;">--</span>
                    </div>
                </div>
                <button class="trade-submit buy-yes" id="tradeSubmit" onclick="executeTrade()">Buy YES</button>
            </div>

            <!-- Swap Section (YES‚ÜîNO) -->
            <div id="swapSection" style="display:none;">
                <div style="font-size:var(--font-xs);color:var(--text-dim);margin-bottom:0.75rem;">
                    Swap shares directly via the pool. No ETH needed - trade one outcome for the other.
                </div>

                <!-- Swap Direction Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="yesToNoBtn" class="mode-toggle-btn active-buy" onclick="setSwapDirection(true)" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green-dim);color:var(--green);border:1px solid var(--green);">YES ‚Üí NO</button>
                    <button id="noToYesBtn" class="mode-toggle-btn" onclick="setSwapDirection(false)" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">NO ‚Üí YES</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="swapSlip05" class="slip-btn slip-active" onclick="setSwapSlippage(0.5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">0.5%</button>
                    <button id="swapSlip1" class="slip-btn" onclick="setSwapSlippage(1)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">1%</button>
                    <button id="swapSlip2" class="slip-btn" onclick="setSwapSlippage(2)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">2%</button>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="swapInputLabel">YES Amount</span>
                        <span>Balance: <span id="swapBalance">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="swapAmount" placeholder="0.1" step="0.01" min="0" oninput="swapMaxRaw=null;updateSwapPreview()" style="flex:1;">
                        <button onclick="setSwapMax()" style="padding:0.5rem 1rem;background:var(--pink-dim);border:1px solid var(--pink);border-radius:var(--radius);color:var(--pink);font-weight:600;font-size:var(--font-xs);cursor:pointer;">Max</button>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="swapOutput">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Swap Fee (0.3%)</span>
                        <span id="swapFee">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Min Output</span>
                        <span id="swapMinOutput">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="swapSubmit" onclick="executeSwap()" style="background:var(--pink);">Swap YES ‚Üí NO</button>
            </div>

            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div style="font-size:var(--font-xs);color:var(--text-dim);margin-bottom:0.75rem;">
                    Add or remove liquidity from the prediction market pool.
                </div>

                <!-- Add/Remove Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="lpAddBtn" class="mode-toggle-btn active-add" onclick="setLpMode('add')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--blue);color:white;">Add</button>
                    <button id="lpRemoveBtn" class="mode-toggle-btn" onclick="setLpMode('remove')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Remove</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;flex-wrap:wrap;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="lpSlip5" class="slip-btn" onclick="setLpSlippage(5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">5%</button>
                    <button id="lpSlip10" class="slip-btn slip-active" onclick="setLpSlippage(10)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">10%</button>
                    <button id="lpSlip20" class="slip-btn" onclick="setLpSlippage(20)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">20%</button>
                    <input type="number" id="lpSlipCustom" placeholder="%" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);border-radius:4px;" onchange="setLpSlippage(parseFloat(this.value)||10)">
                </div>

                <div style="background:var(--surface);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                    <div style="display:flex;justify-content:space-between;font-size:var(--font-xs);">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span style="color:var(--blue);font-weight:600;" id="lpPosition">0 LP</span>
                    </div>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="lpAmountLabel">ETH to Add</span>
                        <span style="display:flex;align-items:center;gap:0.5rem;">
                            Balance: <span id="lpBalance">--</span>
                            <button id="lpMaxBtn" onclick="setLpMax()" style="padding:0.25rem 0.5rem;background:var(--blue-dim);border:1px solid var(--blue);border-radius:var(--radius);color:var(--blue);font-weight:600;font-size:10px;cursor:pointer;">Max</button>
                        </span>
                    </div>
                    <input type="number" class="trade-input" id="lpAmount" placeholder="0.1" step="0.01" min="0" oninput="lpMaxRaw=null;updateLpPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">Est. LP Tokens</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Your Pool Share</span>
                        <span><span id="lpPoolShare">--%</span> <span id="lpShareChange" style="font-size:10px;"></span></span>
                    </div>
                </div>
                <button class="trade-submit" id="lpSubmit" onclick="executeLp()" style="background:var(--blue);">Deposit Liquidity</button>
            </div>

            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <!-- Side indicator -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                    <span id="limitSideIndicator" style="padding:0.25rem 0.75rem;border-radius:4px;font-size:var(--font-xs);font-weight:700;background:var(--green-dim);color:var(--green);">YES</span>
                    <span style="font-size:var(--font-xs);color:var(--text-dim);" id="limitExplainerText">Bid below pool price to get better odds. ETH escrowed until filled.</span>
                </div>

                <!-- Buy/Sell Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="limitBuyBtn" class="mode-toggle-btn active-add" onclick="setLimitSide('buy')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:#8b5cf6;color:white;">Buy Order</button>
                    <button id="limitSellBtn" class="mode-toggle-btn" onclick="setLimitSide('sell')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Sell Order</button>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span>Your Odds</span>
                        <span id="limitOddsDisplay" style="font-weight:600;color:var(--text);">--</span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="limitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99" oninput="updateLimitPreview()" style="flex:1;">
                        <button onclick="adjustLimitPrice(-0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--red);font-weight:600;cursor:pointer;font-size:var(--font-sm);">-1%</button>
                        <button onclick="adjustLimitPrice(0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-sm);">+1%</button>
                    </div>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="limitAmountLabel">Spend (ETH)</span>
                        <span>Balance: <span id="limitBalance">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="limitAmount" placeholder="0.1" step="0.01" min="0" oninput="limitMaxRaw=null;updateLimitPreview()" style="flex:1;">
                        <button onclick="setLimitMax()" style="padding:0.5rem 1rem;background:var(--surface-2);border:1px solid #8b5cf6;border-radius:var(--radius);color:#8b5cf6;font-weight:600;font-size:var(--font-xs);cursor:pointer;">Max</button>
                    </div>
                </div>

                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitResultLabel">You receive</span>
                        <span id="limitResult">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="limitPoolPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="limitSavingsLabel">vs Pool</span>
                        <span id="limitSavings" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" onclick="executeLimitOrder()" style="background:#8b5cf6;">Place Buy Order</button>

                <!-- Compact Orderbook for Limit Tab -->
                <div style="margin-top:1rem;border-top:1px solid var(--border);padding-top:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <span style="font-size:var(--font-xs);font-weight:600;color:var(--text-muted);">Open Orders</span>
                        <button onclick="openOrderbookModal()" style="font-size:10px;color:var(--pink);background:none;border:none;cursor:pointer;text-decoration:underline;">Full Depth ‚Üí</button>
                    </div>
                    <div id="limitBookPreview" style="font-size:11px;max-height:120px;overflow-y:auto;">
                        <div style="color:var(--text-dim);text-align:center;padding:0.5rem;">No orders</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Orderbook Modal - Probability Ladder Design -->
    <div class="modal-overlay" id="orderbookModal">
        <div class="modal" style="max-width:580px;">
            <div class="modal-header">
                <div class="modal-title">Market Depth</div>
                <button class="modal-close" onclick="closeOrderbookModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding:0.75rem;">
                <!-- Header with AMM prices -->
                <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;margin-bottom:0.25rem;padding-bottom:0.25rem;border-bottom:2px solid var(--border);">
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--green);font-size:13px;">YES</div>
                        <div id="yesAmmRef" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                    <div style="text-align:center;font-size:9px;color:var(--text-dim);display:flex;align-items:center;justify-content:center;">Odds</div>
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--red);font-size:13px;">NO</div>
                        <div id="noAmmRef" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                </div>
                <!-- Probability Ladder -->
                <div id="depthLadder" style="background:var(--surface);border-radius:var(--radius);padding:0.5rem;max-height:400px;overflow-y:auto;">
                    <div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading...</div>
                </div>
                <!-- Actions -->
                <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
                    <button onclick="closeOrderbookModal(); openTrade(currentTrade.marketId.toString(), true)" style="flex:1;padding:0.5rem;background:var(--green);color:var(--bg);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade YES</button>
                    <button onclick="closeOrderbookModal(); openTrade(currentTrade.marketId.toString(), false)" style="flex:1;padding:0.5rem;background:var(--red);color:white;border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade NO</button>
                </div>
                <!-- Legend -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);font-size:9px;color:var(--text-dim);">
                    <span><span style="color:var(--green);">‚ñ†</span> Bids</span>
                    <span>Click row to fill | <span style="color:var(--blue);">AMM</span> = pool</span>
                    <span><span style="color:var(--red);">‚ñ†</span> Asks</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const CRYPTOPUNKS_ADDRESS = '0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB';
        const PNKSTR_TREASURY = '0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838';
        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const PMROUTER_ADDRESS = '0x000000000055fF709f26efB262fba8B0AE8c35Dc';
        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        const FEE_TIER = 30n; // 0.30%
        const EOY_2025 = 1767225599; // Dec 31, 2025 23:59:59 UTC

        // balanceOf(address) selector
        const BALANCE_OF_SELECTOR = '0x70a08231';
        // Expected callData for PNKSTR treasury balance check
        const PNKSTR_BALANCE_CALLDATA = BALANCE_OF_SELECTOR + '000000000000000000000000' + PNKSTR_TREASURY.slice(2).toLowerCase();

        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc, 1, { staticNetwork: true });
                    await Promise.race([
                        p.getBlockNumber(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000))
                    ]);
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const CRYPTOPUNKS_ABI = [
            'function balanceOf(address owner) view returns (uint256)'
        ];

        const RESOLVER_ABI = [
            'function conditions(uint256 marketId) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)',
            'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
            'function resolveMarket(uint256 marketId)',
            'function createNumericMarketAndSeed(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose, tuple(uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) seed) payable returns (uint256 marketId, uint256 noId, uint256 shares, uint256 liquidity)',
            'event ConditionCreated(uint256 indexed marketId, address indexed targetA, uint8 op, uint256 threshold, uint64 close, bool canClose, bool isRatio, string description)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function balanceOf(address owner, uint256 id) view returns (uint256)',
            'function getNoId(uint256 marketId) pure returns (uint256)',
            'function isOperator(address owner, address operator) view returns (bool)',
            'function setOperator(address operator, bool approved) returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
            'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
            'function multicall(bytes[] data) returns (bytes[])'
        ];

        const PMROUTER_ABI = [
            'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
            'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)',
            'function claim(uint256 marketId, address to) returns (uint256 payout)',
            'function placeOrder(uint256 marketId, bool isYes, bool isBuy, uint96 shares, uint96 collateral, uint56 deadline, bool partialFill) payable returns (bytes32)',
            'function cancelOrder(bytes32 orderHash)',
            'function claimProceeds(bytes32 orderHash)',
            'function fillOrdersThenSwap(uint256 marketId, bool isYes, bool isBuy, uint256 totalAmount, uint256 minOutput, bytes32[] orderHashes, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
            'function getOrderbook(uint256 marketId, bool isYes, uint256 depth) view returns (bytes32[] bidHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] bidOrders, bytes32[] askHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] askOrders)',
            'function getOrder(bytes32 orderHash) view returns (tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId) order, uint96 sharesFilled, uint96 sharesRemaining, uint96 collateralFilled, uint96 collateralRemaining, bool active)'
        ];

        const ZAMM_ABI = [
            'function isOperator(address owner, address operator) view returns (bool)',
            'function setOperator(address operator, bool approved) returns (bool)',
            'function balanceOf(address owner, uint256 id) view returns (uint256)',
            'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)',
            'function pools(uint256 poolId) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // Compute pool ID from pool key (keccak256 of encoded key)
        function computePoolId(id0, id1, token0, token1, feeOrHook) {
            const abiCoder = ethers.AbiCoder.defaultAbiCoder();
            const encoded = abiCoder.encode(
                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                [id0, id1, token0, token1, feeOrHook]
            );
            return ethers.keccak256(encoded);
        }

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let connectedWalletProvider = null;
        let walletConnectProvider = null;
        let isConnecting = false;
        let walletEventHandlers = null;
        const eip6963Providers = new Map();

        let pnkstrMarkets = []; // Markets related to PNKSTR
        let currentTrade = { marketId: null, isYes: true, yesId: null, noId: null, rYes: 0n, rNo: 0n };
        let pendingToasts = new Map(); // Track pending toasts by ID
        let toastIdCounter = 0;

        // Trade mode state
        let currentTradeMode = 'trade'; // 'trade', 'swap', 'limit', 'lp'
        let currentTradeDirection = 'buy'; // 'buy' or 'sell'
        let currentLpMode = 'add'; // 'add' or 'remove'
        let currentSwapDirection = true; // true = YES‚ÜíNO, false = NO‚ÜíYES
        let limitIsBuy = true;
        let slippageTolerance = 10; // 10% default for small pools
        let swapSlippage = 0.5; // 0.5%

        // User position state
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };

        // Orderbook state - stores both YES and NO orderbooks
        let currentOrderbook = {
            yes: { bids: [], asks: [], ammPrice: null },
            no: { bids: [], asks: [], ammPrice: null }
        };

        // ======================== INIT ========================
        async function init() {
            initEIP6963();

            // Auto-reconnect wallet if previously connected
            const savedWallet = localStorage.getItem('pnkpm_wallet');
            if (savedWallet) {
                // Small delay to let EIP-6963 providers announce themselves
                setTimeout(async () => {
                    try {
                        await connectWithWallet(savedWallet);
                    } catch (e) {
                        console.warn('Auto-reconnect failed:', e);
                        localStorage.removeItem('pnkpm_wallet');
                    }
                }, 100);
            }

            await loadData();
            setInterval(loadData, 60000);

            // Setup create form listeners
            document.getElementById('createDeadline').addEventListener('change', updateCreatePreview);
            document.getElementById('createThreshold').addEventListener('input', updateCreatePreview);
            document.getElementById('createCanClose').addEventListener('change', updateCreatePreview);
        }

        // ======================== DATA LOADING ========================
        // Always use public RPC for reading (more reliable than wallet provider)
        let readProvider = null;
        async function getReadProvider() {
            if (readProvider) return readProvider;
            readProvider = await getRpcProvider();
            return readProvider;
        }

        async function loadData() {
            try {
                const rpc = await getReadProvider();

                // Load PNKSTR balance
                const punks = new ethers.Contract(CRYPTOPUNKS_ADDRESS, CRYPTOPUNKS_ABI, rpc);
                const balance = await punks.balanceOf(PNKSTR_TREASURY);
                const balanceNum = Number(balance);

                document.getElementById('livePunks').textContent = balanceNum;
                document.getElementById('heroBalance').textContent = balanceNum;

                // Find PNKSTR-related markets by scanning ConditionCreated events
                await loadPnkstrMarkets(rpc);

            } catch (error) {
                console.error('Failed to load data:', error);
                // Reset read provider on error to try a different RPC next time
                readProvider = null;
            }
        }

        // Known PNKSTR market IDs (hardcoded for stability)
        const KNOWN_PNKSTR_MARKETS = [
            32134417008196240812336678454075505952526867228548827945664500580851657114937n
        ];

        async function loadPnkstrMarkets(rpc) {
            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const punks = new ethers.Contract(CRYPTOPUNKS_ADDRESS, CRYPTOPUNKS_ABI, rpc);
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const resolverInterface = new ethers.Interface(RESOLVER_ABI);

                // Use known market IDs for stability
                const marketIds = KNOWN_PNKSTR_MARKETS;

                // Batch fetch market data via multicall: getMarket + conditions for each
                const marketCalls = marketIds.flatMap(id => [
                    { target: PAMM_ADDRESS, allowFailure: true, callData: pammInterface.encodeFunctionData('getMarket', [id]) },
                    { target: RESOLVER_ADDRESS, allowFailure: true, callData: resolverInterface.encodeFunctionData('conditions', [id]) }
                ]);

                const marketRaw = await multicall.aggregate3(marketCalls);

                // Parse market data
                let allMarketsData = [];
                for (let i = 0; i < marketIds.length; i++) {
                    const marketResult = marketRaw[i * 2];
                    const conditionResult = marketRaw[i * 2 + 1];

                    if (!marketResult.success || !conditionResult.success) continue;

                    try {
                        const market = pammInterface.decodeFunctionResult('getMarket', marketResult.returnData);
                        const condition = resolverInterface.decodeFunctionResult('conditions', conditionResult.returnData);

                        allMarketsData.push({
                            marketId: marketIds[i],
                            resolved: market.resolved,
                            outcome: market.outcome,
                            canClose: market.canClose,
                            close: Number(market.close),
                            collateralLocked: market.collateralLocked,
                            description: market.description,
                            condition
                        });
                    } catch { continue; }
                }

                // Batch fetch pool states, noIds, previews, and punk balance via multicall
                const punksInterface = new ethers.Interface(CRYPTOPUNKS_ABI);

                const dataCalls = [];
                // Pool state calls for each market
                for (const m of allMarketsData) {
                    dataCalls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('getPoolState', [m.marketId, FEE_TIER])
                    });
                }
                // NoId calls for each candidate (for ZAMM pool link)
                for (const m of allMarketsData) {
                    dataCalls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('getNoId', [m.marketId])
                    });
                }
                // Preview calls for unresolved markets
                for (const m of allMarketsData) {
                    if (!m.resolved) {
                        dataCalls.push({
                            target: RESOLVER_ADDRESS,
                            allowFailure: true,
                            callData: resolverInterface.encodeFunctionData('preview', [m.marketId])
                        });
                    }
                }
                // Punk balance call
                dataCalls.push({
                    target: CRYPTOPUNKS_ADDRESS,
                    allowFailure: true,
                    callData: punksInterface.encodeFunctionData('balanceOf', [PNKSTR_TREASURY])
                });

                const dataRaw = dataCalls.length > 0 ? await multicall.aggregate3(dataCalls) : [];

                // Parse results
                const poolResults = [];
                const noIdResults = [];
                const previewResults = [];
                let idx = 0;

                // Pool states
                for (const m of allMarketsData) {
                    const r = dataRaw[idx++];
                    if (r.success) {
                        try {
                            poolResults.push(pammInterface.decodeFunctionResult('getPoolState', r.returnData));
                        } catch { poolResults.push(null); }
                    } else {
                        poolResults.push(null);
                    }
                }
                // NoIds
                for (const m of allMarketsData) {
                    const r = dataRaw[idx++];
                    if (r.success) {
                        try {
                            noIdResults.push(pammInterface.decodeFunctionResult('getNoId', r.returnData)[0]);
                        } catch { noIdResults.push(null); }
                    } else {
                        noIdResults.push(null);
                    }
                }
                // Previews
                for (const m of allMarketsData) {
                    if (!m.resolved) {
                        const r = dataRaw[idx++];
                        if (r.success) {
                            try {
                                previewResults.push(resolverInterface.decodeFunctionResult('preview', r.returnData));
                            } catch { previewResults.push(null); }
                        } else {
                            previewResults.push(null);
                        }
                    } else {
                        previewResults.push(null);
                    }
                }
                // Punk balance
                const balanceR = dataRaw[idx];
                const currentBalance = balanceR?.success
                    ? punksInterface.decodeFunctionResult('balanceOf', balanceR.returnData)[0]
                    : 0n;

                // Build final market list
                const markets = [];
                let totalTvl = 0n;

                for (let i = 0; i < allMarketsData.length; i++) {
                    const m = allMarketsData[i];
                    const poolState = poolResults[i];
                    const preview = previewResults[i];
                    const noId = noIdResults[i];

                    let yesOdds = 50;
                    if (poolState) {
                        const rYes = poolState.rYes;
                        const rNo = poolState.rNo;
                        if (rYes + rNo > 0n) {
                            yesOdds = Number(rNo * 100n / (rYes + rNo));
                        }
                    }

                    const tvl = m.collateralLocked;
                    totalTvl += tvl;

                    // Compute poolId for ZAMM link
                    const yesId = m.marketId;
                    const id0 = yesId < noId ? yesId : noId;
                    const id1 = yesId < noId ? noId : yesId;
                    const poolId = noId ? computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER) : null;

                    markets.push({
                        id: m.marketId,
                        noId: noId,
                        poolId: poolId,
                        description: m.description,
                        resolved: m.resolved,
                        outcome: m.outcome,
                        canClose: m.canClose,
                        close: m.close,
                        collateralLocked: m.collateralLocked,
                        threshold: m.condition.threshold || 0n,
                        op: Number(m.condition.op) || 1,
                        currentValue: preview?.value ?? currentBalance,
                        conditionMet: preview?.condTrue ?? false,
                        ready: preview?.ready ?? false,
                        yesOdds,
                        tvl
                    });
                }

                // Sort by close time (newest first)
                markets.sort((a, b) => b.close - a.close);
                pnkstrMarkets = markets;

                // Update UI
                const active = markets.filter(m => !m.resolved);
                const ready = markets.filter(m => !m.resolved && m.ready);
                const resolved = markets.filter(m => m.resolved);

                document.getElementById('marketCount').textContent = markets.length;
                document.getElementById('activeCount').textContent = active.length;
                document.getElementById('readyCount').textContent = ready.length;
                document.getElementById('resolvedCount').textContent = resolved.length;
                document.getElementById('totalTvl').textContent = formatEth(totalTvl) + ' ETH';

                renderMarkets(markets);

            } catch (error) {
                console.error('Failed to load PNKSTR markets:', error);
                document.getElementById('marketsGrid').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <p>Failed to load markets. Please refresh.</p>
                    </div>
                `;
            }
        }

        function renderMarkets(markets) {
            const grid = document.getElementById('marketsGrid');

            if (markets.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì≠</div>
                        <p>No PNKSTR markets found. Create one below!</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = markets.map(m => renderMarketCard(m)).join('');
        }

        function renderMarketCard(market) {
            const now = Math.floor(Date.now() / 1000);
            const timeLeft = market.close - now;

            let status, statusClass;
            if (market.resolved) {
                status = market.outcome ? 'YES Won' : 'NO Won';
                statusClass = 'resolved';
            } else if (market.ready) {
                status = 'Ready to Resolve';
                statusClass = 'ready';
            } else {
                status = 'Active';
                statusClass = 'active';
            }

            const opSymbol = ['<', '>', '<=', '>=', '==', '!='][market.op] || '?';
            const noOdds = 100 - market.yesOdds;

            return `
                <div class="bet-card ${market.resolved ? 'resolved' : ''}">
                    <div class="bet-header">
                        <span class="bet-type">PNKSTR</span>
                        <span class="bet-status ${statusClass}">${status}</span>
                    </div>
                    <div class="bet-title">Punks ${opSymbol} ${market.threshold.toString()}</div>
                    <div class="bet-question">Will PNKSTR hold ${opSymbol} ${market.threshold} punks by ${formatDate(market.close)}?</div>
                    <details class="onchain-details">
                        <summary>on-chain ‚Üì</summary>
                        <div class="onchain-desc">${escapeHtml(market.description)}</div>
                    </details>

                    <div class="condition-display">
                        <div class="condition-point">
                            <div class="condition-label">Current</div>
                            <a href="https://etherscan.io/token/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB?a=0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838" target="_blank" style="text-decoration:none;">
                                <div class="condition-value" style="color:var(--pink);">${market.currentValue.toString()} <span style="opacity:0.4;font-size:0.6em;">‚Üó</span></div>
                            </a>
                        </div>
                        <div class="condition-op">${opSymbol}</div>
                        <div class="condition-point">
                            <div class="condition-label">Target</div>
                            <div class="condition-value">${market.threshold.toString()}</div>
                        </div>
                    </div>

                    ${!market.resolved ? `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0.75rem;margin-bottom:0.75rem;background:${market.yesOdds > 50 ? 'var(--green-dim)' : market.yesOdds < 50 ? 'var(--red-dim)' : 'var(--surface-2)'};border-radius:var(--radius);font-size:var(--font-xs);">
                            <div>
                                <span style="color:${market.yesOdds > 50 ? 'var(--green)' : market.yesOdds < 50 ? 'var(--red)' : 'var(--text-muted)'};">
                                    ${market.yesOdds > 50 ? '‚ñ≤ Market favors YES' : market.yesOdds < 50 ? '‚ñº Market favors NO' : '‚óÜ Market is neutral'}
                                </span>
                                <span style="color:var(--text-dim);margin-left:0.5rem;">(${Math.abs(market.yesOdds - 50)}% edge)</span>
                            </div>
                            <button onclick="viewMarketDepth('${market.id}')" style="background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:2px 8px;font-size:10px;color:var(--text-muted);cursor:pointer;">Depth</button>
                        </div>
                        <div class="bet-buttons">
                            <button class="bet-btn yes" onclick="openTrade('${market.id}', true)">
                                <div class="bet-btn-label">Yes</div>
                                <div class="bet-btn-odds">${market.yesOdds}%</div>
                                <div class="bet-btn-price">${(market.yesOdds / 100).toFixed(2)} ETH</div>
                            </button>
                            <button class="bet-btn no" onclick="openTrade('${market.id}', false)">
                                <div class="bet-btn-label">No</div>
                                <div class="bet-btn-odds">${noOdds}%</div>
                                <div class="bet-btn-price">${(noOdds / 100).toFixed(2)} ETH</div>
                            </button>
                        </div>
                    ` : `
                        <div style="padding:1rem;text-align:center;background:var(--surface-2);border-radius:var(--radius);margin-bottom:1rem;">
                            <div style="font-size:var(--font-2xl);font-weight:700;color:${market.outcome ? 'var(--green)' : 'var(--red)'};">
                                ${market.outcome ? 'YES' : 'NO'} Won
                            </div>
                            <button class="resolve-btn" style="margin-top:0.75rem;background:var(--green);color:var(--bg);" onclick="claimWinnings('${market.id}')">
                                Claim Winnings
                            </button>
                        </div>
                    `}

                    <div class="bet-countdown">
                        <span>${market.canClose ? 'May close early' : 'Closes'}</span>
                        <span class="countdown-value">${formatCountdown(timeLeft)}</span>
                    </div>

                    <div class="liquidity-stats">
                        <span>TVL: <span style="color:var(--blue);">${formatEth(market.tvl)} ETH</span></span>
                        <span>ID: ${truncateId(market.id.toString())}</span>
                        ${market.poolId ? `<a href="https://zamm.finance/p/${BigInt(market.poolId).toString()}" target="_blank" title="View on ZAMM" style="display:flex;align-items:center;gap:3px;color:var(--text-muted);text-decoration:none;font-size:10px;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"><img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:12px;height:12px;border-radius:2px;">ZAMM</a>` : ''}
                    </div>

                    ${market.ready && !market.resolved ? `
                        <button class="resolve-btn" onclick="resolveMarket('${market.id}')">Resolve Market</button>
                    ` : ''}
                </div>
            `;
        }

        // ======================== WALLET ========================
        const WALLET_CONFIG = {
            metamask: { name: 'MetaMask', icon: 'ü¶ä', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
            coinbase: { name: 'Coinbase', icon: 'üîµ', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
            rabby: { name: 'Rabby', icon: 'üê∞', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
            rainbow: { name: 'Rainbow', icon: 'üåà', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
            walletconnect: { name: 'WalletConnect', icon: 'üì±' }
        };

        function initEIP6963() {
            if (typeof window === 'undefined') return;
            window.addEventListener('eip6963:announceProvider', (event) => {
                const { info, provider } = event.detail;
                eip6963Providers.set(info.uuid, { info, provider });
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

        function detectWallets() {
            const detected = [];
            const seenNames = new Set();

            for (const [key, config] of Object.entries(WALLET_CONFIG)) {
                if (key === 'walletconnect') continue;
                if (config.detect && config.detect()) {
                    detected.push({ key, ...config });
                    seenNames.add(config.name.toLowerCase());
                }
            }

            for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
                if (!seenNames.has(info.name.toLowerCase())) {
                    const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
                    const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
                    detected.push({
                        key: `eip6963_${uuid}`,
                        name: safeName,
                        icon: iconUrl ? `<img src="${iconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'üîå',
                        getProvider: () => provider
                    });
                    seenNames.add(info.name.toLowerCase());
                }
            }

            if (detected.length === 0 && window.ethereum) {
                detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'üîó', getProvider: () => window.ethereum });
            }

            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            if (wcModule?.EthereumProvider) {
                detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'üì±', isWalletConnect: true });
            }

            return detected;
        }

        function showWalletModal() {
            const wallets = detectWallets();
            const container = document.getElementById('walletOptions');

            if (connectedAddress) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: var(--gray); border-radius: var(--radius); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Connected</div>
                        <div style="font-size: 0.9rem; word-break: break-all; color: var(--pink);">${connectedAddress}</div>
                    </div>
                    <div class="wallet-option disconnect" onclick="disconnectWallet()">
                        <span class="wallet-option-name">Disconnect</span>
                    </div>
                `;
            } else {
                container.innerHTML = wallets.length > 0 ? wallets.map(w => `
                    <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
                        <span class="wallet-option-icon">${w.icon}</span>
                        <span class="wallet-option-name">${w.name}</span>
                    </div>
                `).join('') : '<div style="padding:1rem;text-align:center;color:var(--text-muted);">No wallets detected. Install MetaMask or use WalletConnect.</div>';
            }

            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        async function connectWallet() {
            showWalletModal();
        }

        async function connectWithWallet(walletKey) {
            if (isConnecting) return;
            isConnecting = true;

            const connectBtn = document.getElementById('connectBtn');
            const originalText = connectBtn.textContent;
            connectBtn.textContent = 'Connecting...';
            connectBtn.disabled = true;

            try {
                closeWalletModal();
                let walletProvider;

                if (walletKey === 'walletconnect') {
                    const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
                    const WCProvider = wcModule?.EthereumProvider;
                    if (!WCProvider?.init) throw new Error('WalletConnect not available');

                    if (walletConnectProvider) {
                        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
                        walletConnectProvider = null;
                    }

                    walletConnectProvider = await WCProvider.init({
                        projectId: '1e8390ef1c1d8a185e035912a1409749',
                        chains: [1],
                        showQrModal: true,
                        rpcMap: { 1: 'https://1rpc.io/eth' },
                        metadata: {
                            name: 'pnkPM',
                            description: 'PNKSTR CryptoPunks Prediction Markets',
                            url: window.location.origin,
                            icons: []
                        }
                    });

                    await walletConnectProvider.enable();
                    walletProvider = walletConnectProvider;
                } else if (walletKey.startsWith('eip6963_')) {
                    const uuid = walletKey.replace('eip6963_', '');
                    walletProvider = eip6963Providers.get(uuid)?.provider;
                } else {
                    walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
                }

                if (!walletProvider) throw new Error('Wallet not found');

                if (walletKey !== 'walletconnect') {
                    await walletProvider.request({ method: 'eth_requestAccounts' });
                }

                provider = new ethers.BrowserProvider(walletProvider);

                // Check network is Ethereum mainnet
                let network = await provider.getNetwork();
                if (network.chainId !== 1n) {
                    try {
                        await walletProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x1' }]
                        });
                        // Re-create provider after network switch and verify
                        provider = new ethers.BrowserProvider(walletProvider);
                        network = await provider.getNetwork();
                    } catch (e) {
                        // Switch failed or was rejected
                    }
                    if (network.chainId !== 1n) {
                        throw new Error('Please switch to Ethereum mainnet');
                    }
                }

                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                connectedWalletProvider = walletProvider;

                document.getElementById('connectBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                document.getElementById('connectBtn').classList.add('connected');

                // Remove old listeners if any
                if (walletEventHandlers) {
                    try {
                        walletEventHandlers.provider.removeListener('accountsChanged', walletEventHandlers.onAccountsChanged);
                        walletEventHandlers.provider.removeListener('chainChanged', walletEventHandlers.onChainChanged);
                    } catch (e) {}
                }

                // Store and add new listeners
                walletEventHandlers = {
                    provider: walletProvider,
                    onAccountsChanged: () => window.location.reload(),
                    onChainChanged: () => window.location.reload()
                };
                walletProvider.on('accountsChanged', walletEventHandlers.onAccountsChanged);
                walletProvider.on('chainChanged', walletEventHandlers.onChainChanged);

                localStorage.setItem('pnkpm_wallet', walletKey);

                // Reload data with new provider
                await loadData();

            } catch (error) {
                console.error('Connection failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Connection Failed', error.message || 'Could not connect wallet', 'error');
                }
                connectBtn.textContent = originalText;
            } finally {
                connectBtn.disabled = false;
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            // Remove event listeners
            if (walletEventHandlers) {
                try {
                    walletEventHandlers.provider.removeListener('accountsChanged', walletEventHandlers.onAccountsChanged);
                    walletEventHandlers.provider.removeListener('chainChanged', walletEventHandlers.onChainChanged);
                } catch (e) {}
                walletEventHandlers = null;
            }
            if (walletConnectProvider) {
                try { walletConnectProvider.disconnect(); } catch (e) {}
                walletConnectProvider = null;
            }
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletProvider = null;
            document.getElementById('connectBtn').textContent = 'Connect';
            document.getElementById('connectBtn').classList.remove('connected');
            closeWalletModal();
            localStorage.removeItem('pnkpm_wallet');
        }

        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== TRADING ========================
        async function openTrade(marketId, isYes) {
            if (!connectedAddress) {
                showWalletModal();
                return;
            }

            const market = pnkstrMarkets.find(m => m.id.toString() === marketId.toString());
            if (!market) return;

            const isResolved = market.resolved;

            // Batch getNoId + getPoolState via multicall
            const rpc = await getReadProvider();
            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
            const pammInterface = new ethers.Interface(PAMM_ABI);

            const results = await multicall.aggregate3([
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getNoId', [marketId]) },
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [marketId, FEE_TIER]) }
            ]);

            const noId = pammInterface.decodeFunctionResult('getNoId', results[0].returnData)[0];
            const poolState = pammInterface.decodeFunctionResult('getPoolState', results[1].returnData);

            currentTrade = {
                marketId: BigInt(marketId),
                isYes,
                yesId: BigInt(marketId),
                noId: BigInt(noId),
                rYes: poolState.rYes,
                rNo: poolState.rNo,
                resolved: isResolved,
                outcome: market.outcome
            };

            document.getElementById('tradeTitle').textContent = `${isYes ? 'YES' : 'NO'} Shares`;
            const opSymbol = ['<', '>', '<=', '>=', '==', '!='][market.op] || '?';
            document.getElementById('tradeMarketDesc').textContent = `Punks ${opSymbol} ${market.threshold} by ${formatDate(market.close)}`;

            // For resolved markets, allow LP withdrawal and swaps (for position exit)
            if (isResolved) {
                setTradeMode('lp');
                setLpMode('remove');
                // Disable trade and limit modes, but keep swap enabled for position exit
                ['tradeModeBtn', 'limitModeBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.style.opacity = '0.4';
                    btn.style.pointerEvents = 'none';
                });
                // Keep swap enabled
                const swapBtn = document.getElementById('swapModeBtn');
                swapBtn.style.opacity = '1';
                swapBtn.style.pointerEvents = 'auto';
                showToast('Market Resolved', `${market.outcome ? 'YES' : 'NO'} won. Swap to winning side, withdraw LP, or claim.`, 'info');
            } else {
                // Reset mode to trade
                setTradeMode('trade');
                setTradeDirection('buy');
                // Ensure mode buttons are enabled
                ['tradeModeBtn', 'swapModeBtn', 'limitModeBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                });
            }

            // Load user position and orderbook in parallel
            await Promise.all([
                loadUserPosition(),
                loadOrderbook()
            ]);

            // Update balances for all modes
            await loadBalance();

            document.getElementById('tradeModal').classList.add('active');
        }

        function closeTradeModal() {
            document.getElementById('tradeModal').classList.remove('active');
        }

        // View market depth without opening trade modal
        async function viewMarketDepth(marketId) {
            const market = pnkstrMarkets.find(m => m.id.toString() === marketId.toString());
            if (!market) return;

            // Load pool state for AMM prices
            const rpc = await getReadProvider();
            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
            const pammInterface = new ethers.Interface(PAMM_ABI);

            const results = await multicall.aggregate3([
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getNoId', [marketId]) },
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [marketId, FEE_TIER]) }
            ]);

            const noId = pammInterface.decodeFunctionResult('getNoId', results[0].returnData)[0];
            const poolState = pammInterface.decodeFunctionResult('getPoolState', results[1].returnData);

            // Set currentTrade so orderbook loads correctly
            currentTrade = {
                marketId: BigInt(marketId),
                isYes: true,
                yesId: BigInt(marketId),
                noId: BigInt(noId),
                rYes: poolState.rYes,
                rNo: poolState.rNo
            };

            // Load orderbook and show modal
            await loadOrderbook();
            openOrderbookModal();
        }

        // ======================== MODE SWITCHING ========================
        function setTradeMode(mode) {
            currentTradeMode = mode;

            // Update mode buttons
            ['trade', 'swap', 'limit', 'lp'].forEach(m => {
                const btn = document.getElementById(`${m}ModeBtn`);
                if (m === mode) {
                    btn.style.background = m === 'trade' ? 'var(--green)' : m === 'swap' ? 'var(--pink)' : m === 'limit' ? '#8b5cf6' : 'var(--blue)';
                    btn.style.color = m === 'trade' ? 'var(--bg)' : 'white';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                }
            });

            // Show/hide sections
            document.getElementById('tradeSection').style.display = mode === 'trade' ? 'block' : 'none';
            document.getElementById('swapSection').style.display = mode === 'swap' ? 'block' : 'none';
            document.getElementById('lpSection').style.display = mode === 'lp' ? 'block' : 'none';
            document.getElementById('limitSection').style.display = mode === 'limit' ? 'block' : 'none';

            // Initialize limit mode defaults
            if (mode === 'limit') {
                // Update side indicator
                const sideIndicator = document.getElementById('limitSideIndicator');
                const isYes = currentTrade.isYes;
                sideIndicator.textContent = isYes ? 'YES' : 'NO';
                sideIndicator.style.background = isYes ? 'var(--green-dim)' : 'var(--red-dim)';
                sideIndicator.style.color = isYes ? 'var(--green)' : 'var(--red)';

                // Initialize with buy side (also sets button text with YES/NO)
                setLimitSide(limitIsBuy ? 'buy' : 'sell');

                // Refresh the compact orderbook display
                updateLimitBookPreview();
            }

            loadBalance();
        }

        function setTradeDirection(dir) {
            currentTradeDirection = dir;
            tradeMaxRaw = null; // Clear max when switching direction
            const buyBtn = document.getElementById('buyBtn');
            const sellBtn = document.getElementById('sellBtn');
            const maxBtn = document.getElementById('tradeMaxBtn');

            if (dir === 'buy') {
                buyBtn.style.background = 'var(--green-dim)';
                buyBtn.style.color = 'var(--green)';
                buyBtn.style.borderColor = 'var(--green)';
                sellBtn.style.background = 'transparent';
                sellBtn.style.color = 'var(--text-muted)';
                sellBtn.style.borderColor = 'var(--border)';
                document.getElementById('tradeAmountLabel').textContent = 'Amount (ETH)';
                document.getElementById('previewSharesLabel').textContent = 'Est. Shares';
                document.getElementById('previewPriceLabel').textContent = 'Avg. Price';
                document.getElementById('previewPayoutLabel').textContent = 'If you win';
                maxBtn.style.display = 'none';
            } else {
                sellBtn.style.background = 'var(--red-dim)';
                sellBtn.style.color = 'var(--red)';
                sellBtn.style.borderColor = 'var(--red)';
                buyBtn.style.background = 'transparent';
                buyBtn.style.color = 'var(--text-muted)';
                buyBtn.style.borderColor = 'var(--border)';
                document.getElementById('tradeAmountLabel').textContent = 'Shares to Sell';
                document.getElementById('previewSharesLabel').textContent = 'ETH Received';
                document.getElementById('previewPriceLabel').textContent = 'Price/Share';
                document.getElementById('previewPayoutLabel').textContent = 'Min Received';
                maxBtn.style.display = 'inline-block';
            }

            updateTradeButton();
            loadBalance();
            handleTradeInput();
        }

        function setSwapDirection(yesToNo) {
            currentSwapDirection = yesToNo;
            const yesBtn = document.getElementById('yesToNoBtn');
            const noBtn = document.getElementById('noToYesBtn');

            if (yesToNo) {
                yesBtn.style.background = 'var(--green-dim)';
                yesBtn.style.color = 'var(--green)';
                yesBtn.style.borderColor = 'var(--green)';
                noBtn.style.background = 'transparent';
                noBtn.style.color = 'var(--text-muted)';
                noBtn.style.borderColor = 'var(--border)';
                document.getElementById('swapInputLabel').textContent = 'YES Amount';
                document.getElementById('swapSubmit').textContent = 'Swap YES ‚Üí NO';
            } else {
                noBtn.style.background = 'var(--red-dim)';
                noBtn.style.color = 'var(--red)';
                noBtn.style.borderColor = 'var(--red)';
                yesBtn.style.background = 'transparent';
                yesBtn.style.color = 'var(--text-muted)';
                yesBtn.style.borderColor = 'var(--border)';
                document.getElementById('swapInputLabel').textContent = 'NO Amount';
                document.getElementById('swapSubmit').textContent = 'Swap NO ‚Üí YES';
            }

            loadBalance();
            updateSwapPreview();
        }

        function setSwapSlippage(pct) {
            swapSlippage = pct;
            [0.5, 1, 2].forEach(p => {
                const btn = document.getElementById(`swapSlip${p === 0.5 ? '05' : p}`);
                if (p === pct) {
                    btn.style.background = 'var(--pink-dim)';
                    btn.style.color = 'var(--pink)';
                    btn.style.borderColor = 'var(--pink)';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                    btn.style.borderColor = 'var(--border)';
                }
            });
            updateSwapPreview();
        }

        function setTradeSlippage(pct) {
            slippageTolerance = pct;
            // Update both trade and LP buttons since they share slippageTolerance
            [5, 10, 20].forEach(p => {
                ['tradeSlip', 'lpSlip'].forEach(prefix => {
                    const btn = document.getElementById(`${prefix}${p}`);
                    if (!btn) return;
                    if (p === pct) {
                        btn.style.background = 'var(--pink-dim)';
                        btn.style.color = 'var(--pink)';
                        btn.style.borderColor = 'var(--pink)';
                    } else {
                        btn.style.background = 'transparent';
                        btn.style.color = 'var(--text-muted)';
                        btn.style.borderColor = 'var(--border)';
                    }
                });
            });
            // Clear custom inputs if a preset was clicked, or highlight if custom
            const isPreset = [5, 10, 20].includes(pct);
            ['tradeSlipCustom', 'lpSlipCustom'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    if (isPreset) {
                        input.value = '';
                        input.style.borderColor = 'var(--border)';
                    } else {
                        input.value = pct;
                        input.style.borderColor = 'var(--pink)';
                    }
                }
            });
        }

        function setLpSlippage(pct) {
            setTradeSlippage(pct); // LP and trade share slippageTolerance
        }

        let swapMaxRaw = null; // Store raw BigInt for exact max swaps
        let limitMaxRaw = null; // Store raw BigInt for exact max limit orders
        let tradeMaxRaw = null; // Store raw BigInt for exact max sells
        let lpMaxRaw = null; // Store raw BigInt for exact max LP operations

        function setTradeMax() {
            // Only works for sell mode - fills with user's share balance
            if (currentTradeDirection !== 'sell') return;

            const balance = currentTrade.isYes
                ? currentUserPosition.yesBalance
                : currentUserPosition.noBalance;

            if (balance && balance > 0n) {
                tradeMaxRaw = balance;
                document.getElementById('tradeAmount').value = ethers.formatEther(balance);
                updateTradePreview(); // Don't call handleTradeInput which clears tradeMaxRaw
            }
        }

        function setSwapMax() {
            // Get the balance of the source token (YES or NO based on swap direction)
            const sourceBalance = currentSwapDirection
                ? currentUserPosition.yesBalance
                : currentUserPosition.noBalance;

            if (sourceBalance && sourceBalance > 0n) {
                swapMaxRaw = sourceBalance; // Store exact value for execution
                const maxAmount = ethers.formatEther(sourceBalance);
                document.getElementById('swapAmount').value = maxAmount;
                updateSwapPreview();
            }
        }

        async function setLimitMax() {
            if (limitIsBuy) {
                // For buys, max is ETH balance
                if (!connectedAddress) return;
                const rpc = await getReadProvider();
                const bal = await rpc.getBalance(connectedAddress);
                if (bal > 0n) {
                    // Leave a little for gas (0.001 ETH)
                    const maxBal = bal > ethers.parseEther('0.001') ? bal - ethers.parseEther('0.001') : bal;
                    limitMaxRaw = maxBal;
                    document.getElementById('limitAmount').value = ethers.formatEther(maxBal);
                    updateLimitPreview();
                }
            } else {
                // For sells, max is share balance (YES or NO based on currentTrade.isYes)
                const balance = currentTrade.isYes
                    ? currentUserPosition.yesBalance
                    : currentUserPosition.noBalance;
                if (balance && balance > 0n) {
                    limitMaxRaw = balance;
                    document.getElementById('limitAmount').value = ethers.formatEther(balance);
                    updateLimitPreview();
                }
            }
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            lpMaxRaw = null; // Clear max when switching mode
            const addBtn = document.getElementById('lpAddBtn');
            const removeBtn = document.getElementById('lpRemoveBtn');

            if (mode === 'add') {
                addBtn.style.background = 'var(--blue)';
                addBtn.style.color = 'white';
                removeBtn.style.background = 'transparent';
                removeBtn.style.color = 'var(--text-muted)';
                document.getElementById('lpAmountLabel').textContent = 'ETH to Add';
                document.getElementById('lpPreviewLabel').textContent = 'Est. LP Tokens';
                document.getElementById('lpSubmit').textContent = 'Deposit Liquidity';
            } else {
                removeBtn.style.background = 'var(--blue)';
                removeBtn.style.color = 'white';
                addBtn.style.background = 'transparent';
                addBtn.style.color = 'var(--text-muted)';
                document.getElementById('lpAmountLabel').textContent = 'LP to Remove';
                document.getElementById('lpPreviewLabel').textContent = 'Est. ETH Out';
                document.getElementById('lpSubmit').textContent = 'Withdraw Liquidity';
            }

            loadBalance();
            updateLpPreview();
        }

        async function setLpMax() {
            if (currentLpMode === 'add') {
                // For add, max is ETH balance (leave some for gas)
                if (!connectedAddress) return;
                const rpc = await getReadProvider();
                const bal = await rpc.getBalance(connectedAddress);
                if (bal > 0n) {
                    const maxBal = bal > ethers.parseEther('0.001') ? bal - ethers.parseEther('0.001') : bal;
                    lpMaxRaw = maxBal;
                    document.getElementById('lpAmount').value = ethers.formatEther(maxBal);
                    updateLpPreview();
                }
            } else {
                // For remove, max is LP balance
                const lpBal = currentUserPosition.lpBalance;
                if (lpBal && lpBal > 0n) {
                    lpMaxRaw = lpBal;
                    document.getElementById('lpAmount').value = ethers.formatEther(lpBal);
                    updateLpPreview();
                }
            }
        }

        function setLimitSide(side) {
            limitIsBuy = side === 'buy';
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const sideName = currentTrade.isYes ? 'YES' : 'NO';

            if (limitIsBuy) {
                buyBtn.style.background = '#8b5cf6';
                buyBtn.style.color = 'white';
                sellBtn.style.background = 'transparent';
                sellBtn.style.color = 'var(--text-muted)';
                document.getElementById('limitExplainerText').textContent = `Bid below pool odds for better price. ETH locked until filled.`;
                document.getElementById('limitAmountLabel').textContent = 'Spend (ETH)';
                document.getElementById('limitResultLabel').textContent = `${sideName} shares you get`;
                document.getElementById('limitSavingsLabel').textContent = 'vs Pool';
                document.getElementById('limitSubmit').textContent = `Buy ${sideName} @ Limit`;
            } else {
                sellBtn.style.background = '#8b5cf6';
                sellBtn.style.color = 'white';
                buyBtn.style.background = 'transparent';
                buyBtn.style.color = 'var(--text-muted)';
                document.getElementById('limitExplainerText').textContent = `Ask above pool odds for better price. Shares locked until filled.`;
                document.getElementById('limitAmountLabel').textContent = `Sell (${sideName} shares)`;
                document.getElementById('limitResultLabel').textContent = 'ETH you receive';
                document.getElementById('limitSavingsLabel').textContent = 'vs Pool';
                document.getElementById('limitSubmit').textContent = `Sell ${sideName} @ Limit`;
            }

            // Set default price based on pool price
            setDefaultLimitPrice();
            loadBalance();
            updateLimitPreview();
        }

        function setDefaultLimitPrice() {
            if (currentTrade.rYes === 0n || currentTrade.rNo === 0n) return;

            const yesPrice = Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo);
            const poolPrice = currentTrade.isYes ? yesPrice : (1 - yesPrice);

            // For buy orders: suggest 2% below pool (better for buyer)
            // For sell orders: suggest 2% above pool (better for seller)
            const adjustment = limitIsBuy ? -0.02 : 0.02;
            const suggestedPrice = Math.max(0.01, Math.min(0.99, poolPrice + adjustment));

            document.getElementById('limitPrice').value = suggestedPrice.toFixed(2);
        }

        function adjustLimitPrice(delta) {
            const input = document.getElementById('limitPrice');
            const current = parseFloat(input.value) || 0.5;
            const newVal = Math.max(0.01, Math.min(0.99, current + delta));
            input.value = newVal.toFixed(2);
            updateLimitPreview();
        }

        function updateTradeButton() {
            const btn = document.getElementById('tradeSubmit');
            const side = currentTrade.isYes ? 'YES' : 'NO';
            if (currentTradeDirection === 'buy') {
                btn.textContent = `Buy ${side}`;
                btn.className = `trade-submit ${currentTrade.isYes ? 'buy-yes' : 'buy-no'}`;
            } else {
                btn.textContent = `Sell ${side}`;
                btn.className = 'trade-submit';
                btn.style.background = 'var(--red)';
            }
        }

        // ======================== USER POSITION ========================
        async function loadUserPosition() {
            if (!connectedAddress || !currentTrade.marketId) return;

            try {
                const rpc = await getReadProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const zammInterface = new ethers.Interface(ZAMM_ABI);

                const yesId = currentTrade.yesId;
                const noId = currentTrade.noId;

                // Compute pool ID
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;
                const poolId = computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER);

                // Batch all 4 calls: YES bal, NO bal, LP bal, pool data
                const results = await multicall.aggregate3([
                    { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, yesId]) },
                    { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId]) },
                    { target: ZAMM_ADDRESS, allowFailure: false, callData: zammInterface.encodeFunctionData('balanceOf', [connectedAddress, poolId]) },
                    { target: ZAMM_ADDRESS, allowFailure: false, callData: zammInterface.encodeFunctionData('pools', [poolId]) }
                ]);

                const yesBal = pammInterface.decodeFunctionResult('balanceOf', results[0].returnData)[0];
                const noBal = pammInterface.decodeFunctionResult('balanceOf', results[1].returnData)[0];
                const lpBal = zammInterface.decodeFunctionResult('balanceOf', results[2].returnData)[0];
                const poolData = zammInterface.decodeFunctionResult('pools', results[3].returnData);
                // poolData: [reserve0, reserve1, blockTimestampLast, price0CumulativeLast, price1CumulativeLast, kLast, supply]
                const lpTotalSupply = poolData[6];

                currentUserPosition = {
                    yesBalance: yesBal,
                    noBalance: noBal,
                    lpBalance: lpBal,
                    lpTotalSupply: lpTotalSupply
                };

                // Update UI
                document.getElementById('tradeModalYes').textContent = formatEth(yesBal);
                document.getElementById('tradeModalNo').textContent = formatEth(noBal);
                document.getElementById('tradeModalLP').textContent = formatEth(lpBal);
                document.getElementById('lpPosition').textContent = formatEth(lpBal) + ' LP';

            } catch (e) {
                console.error('Failed to load user position:', e);
            }
        }

        async function loadBalance() {
            if (!connectedAddress) return;

            try {
                const rpc = await getReadProvider();

                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        const bal = await rpc.getBalance(connectedAddress);
                        document.getElementById('lpBalance').textContent = formatEth(bal) + ' ETH';
                    } else {
                        document.getElementById('lpBalance').textContent = formatEth(currentUserPosition.lpBalance) + ' LP';
                    }
                } else if (currentTradeMode === 'swap') {
                    const bal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('swapBalance').textContent = formatEth(bal);
                } else if (currentTradeMode === 'trade') {
                    if (currentTradeDirection === 'buy') {
                        const bal = await rpc.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = formatEth(bal) + ' ETH';
                    } else {
                        const bal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('tradeBalance').textContent = formatEth(bal);
                    }
                } else if (currentTradeMode === 'limit') {
                    if (limitIsBuy) {
                        const bal = await rpc.getBalance(connectedAddress);
                        document.getElementById('limitBalance').textContent = formatEth(bal) + ' ETH';
                    } else {
                        const bal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('limitBalance').textContent = formatEth(bal);
                    }
                }
            } catch (e) {
                console.error('Failed to load balance:', e);
            }
        }

        // ======================== ORDERBOOK ========================
        async function loadOrderbook() {
            if (!currentTrade.marketId) return;

            try {
                const rpc = await getReadProvider();
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                // Load orderbooks for both YES and NO sides in parallel
                const [[yesBidHashes, yesBidOrders, yesAskHashes, yesAskOrders],
                       [noBidHashes, noBidOrders, noAskHashes, noAskOrders]] = await Promise.all([
                    pmRouter.getOrderbook(currentTrade.marketId, true, 10),
                    pmRouter.getOrderbook(currentTrade.marketId, false, 10)
                ]);

                // Parse orders helper
                const parseOrders = (hashes, orders, sortAsc) => {
                    const now = Math.floor(Date.now() / 1000);
                    const parsed = orders.map((order, i) => ({
                        hash: hashes[i],
                        price: Number(order.shares) > 0 ? Number(order.collateral) / Number(order.shares) : 0,
                        shares: order.shares,
                        collateral: order.collateral,
                        owner: order.owner,
                        deadline: Number(order.deadline),
                        isOwn: connectedAddress && order.owner.toLowerCase() === connectedAddress.toLowerCase(),
                        isExpired: Number(order.deadline) <= now
                    })).filter(o =>
                        o.price > 0 &&
                        isFinite(o.price) &&
                        !o.isExpired // Only filter expired orders, keep own orders for display
                    );
                    return sortAsc
                        ? parsed.sort((a, b) => a.price - b.price)
                        : parsed.sort((a, b) => b.price - a.price);
                };

                // Calculate AMM prices
                const ammYesPrice = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                    ? Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo)
                    : null;
                const ammNoPrice = ammYesPrice !== null ? 1 - ammYesPrice : null;

                currentOrderbook = {
                    yes: {
                        bids: parseOrders(yesBidHashes, yesBidOrders, false),
                        asks: parseOrders(yesAskHashes, yesAskOrders, true),
                        ammPrice: ammYesPrice
                    },
                    no: {
                        bids: parseOrders(noBidHashes, noBidOrders, false),
                        asks: parseOrders(noAskHashes, noAskOrders, true),
                        ammPrice: ammNoPrice
                    }
                };

                // Fetch fill status for user's own orders via multicall
                if (connectedAddress) {
                    const allOrders = [
                        ...currentOrderbook.yes.bids,
                        ...currentOrderbook.yes.asks,
                        ...currentOrderbook.no.bids,
                        ...currentOrderbook.no.asks
                    ];
                    const ownOrders = allOrders.filter(o => o.isOwn);

                    if (ownOrders.length > 0) {
                        try {
                            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                            const pmRouterInterface = new ethers.Interface(PMROUTER_ABI);

                            const calls = ownOrders.map(o => ({
                                target: PMROUTER_ADDRESS,
                                allowFailure: true,
                                callData: pmRouterInterface.encodeFunctionData('getOrder', [o.hash])
                            }));

                            const results = await multicall.aggregate3(calls);

                            results.forEach((r, i) => {
                                if (r.success) {
                                    try {
                                        const status = pmRouterInterface.decodeFunctionResult('getOrder', r.returnData);
                                        ownOrders[i].sharesFilled = status.sharesFilled;
                                        ownOrders[i].collateralFilled = status.collateralFilled;
                                    } catch { /* ignore decode errors */ }
                                }
                            });
                        } catch (e) {
                            console.warn('Failed to fetch order fill status:', e);
                        }
                    }
                }

                updateOrderbookUI();
                updateLimitBookPreview();

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                currentOrderbook = {
                    yes: { bids: [], asks: [], ammPrice: null },
                    no: { bids: [], asks: [], ammPrice: null }
                };
            }
        }

        function updateLimitBookPreview() {
            const container = document.getElementById('limitBookPreview');
            if (!container) return;

            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            const { bids, asks, ammPrice } = book;
            const side = currentTrade.isYes ? 'YES' : 'NO';

            if (bids.length === 0 && asks.length === 0) {
                container.innerHTML = `<div style="color:var(--text-dim);text-align:center;padding:0.5rem;">No ${side} orders yet</div>`;
                return;
            }

            // Show top 3 bids and asks in a compact format
            const topAsks = asks.slice(0, 3).reverse();
            const topBids = bids.slice(0, 3);

            let html = '<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:2px 8px;font-family:var(--font-mono);">';

            // Header
            html += `<div style="color:var(--text-dim);font-size:10px;">Size</div>`;
            html += `<div style="color:var(--text-dim);font-size:10px;text-align:center;">Price</div>`;
            html += `<div style="color:var(--text-dim);font-size:10px;text-align:right;">Size</div>`;

            // Asks (sell orders) - show in red
            for (const ask of topAsks) {
                const size = (Number(ask.shares) / 1e18).toFixed(2);
                const price = (ask.price * 100).toFixed(1) + '%';
                html += `<div></div>`;
                html += `<div style="color:var(--red);text-align:center;">${price}</div>`;
                html += `<div style="color:var(--red);text-align:right;">${size}</div>`;
            }

            // AMM price line
            if (ammPrice) {
                html += `<div style="border-top:1px dashed var(--border);grid-column:span 3;margin:2px 0;"></div>`;
                html += `<div style="font-size:10px;color:var(--text-dim);">AMM</div>`;
                html += `<div style="color:var(--text);text-align:center;font-weight:600;">${(ammPrice * 100).toFixed(1)}%</div>`;
                html += `<div style="font-size:10px;color:var(--text-dim);text-align:right;">AMM</div>`;
                html += `<div style="border-bottom:1px dashed var(--border);grid-column:span 3;margin:2px 0;"></div>`;
            }

            // Bids (buy orders) - show in green
            for (const bid of topBids) {
                const size = (Number(bid.shares) / 1e18).toFixed(2);
                const price = (bid.price * 100).toFixed(1) + '%';
                html += `<div style="color:var(--green);">${size}</div>`;
                html += `<div style="color:var(--green);text-align:center;">${price}</div>`;
                html += `<div></div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function updateOrderbookUI() {
            const container = document.getElementById('orderbookPreview');
            if (!container) return;

            // Get data for current trade side
            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            const { bids, asks, ammPrice } = book;
            const bestBidPrice = bids.length > 0 ? bids[0].price : null;
            const bestAskPrice = asks.length > 0 ? asks[0].price : null;
            const side = currentTrade.isYes ? 'YES' : 'NO';

            // Format best prices
            const ammStr = ammPrice ? (ammPrice * 100).toFixed(1) + '%' : '--';
            const bestBidStr = bestBidPrice ? (bestBidPrice * 100).toFixed(1) + '%' : '--';
            const bestAskStr = bestAskPrice ? (bestAskPrice * 100).toFixed(1) + '%' : '--';

            // Determine best price for buying (compare AMM vs best ask)
            let bestBuySource = 'AMM';
            if (bestAskPrice && (!ammPrice || bestAskPrice < ammPrice)) {
                bestBuySource = 'Limit';
            }

            // Determine best price for selling (compare AMM vs best bid)
            let bestSellSource = 'AMM';
            if (bestBidPrice && (!ammPrice || bestBidPrice > ammPrice)) {
                bestSellSource = 'Limit';
            }

            // Count total orders and liquidity across both books
            const totalOrders = currentOrderbook.yes.bids.length + currentOrderbook.yes.asks.length +
                               currentOrderbook.no.bids.length + currentOrderbook.no.asks.length;

            // Calculate orderbook liquidity (ETH in bids = buy orders escrowed)
            const bidLiquidity = [...currentOrderbook.yes.bids, ...currentOrderbook.no.bids]
                .reduce((sum, o) => sum + Number(o.collateral) / 1e18, 0);
            const bidLiqStr = bidLiquidity > 0 ? formatEth(BigInt(Math.floor(bidLiquidity * 1e18))) : '0';

            container.innerHTML = `
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.5rem;font-size:var(--font-xs);">
                    <div style="text-align:center;padding:0.5rem;background:var(--green-dim);border-radius:4px;">
                        <div style="color:var(--text-dim);font-size:10px;">${side} Best Bid</div>
                        <div style="color:var(--green);font-weight:600;">${bestBidStr}</div>
                        <div style="color:var(--text-dim);font-size:10px;">${bids.length} order${bids.length !== 1 ? 's' : ''}</div>
                    </div>
                    <div style="text-align:center;padding:0.5rem;background:var(--red-dim);border-radius:4px;">
                        <div style="color:var(--text-dim);font-size:10px;">${side} Best Ask</div>
                        <div style="color:var(--red);font-weight:600;">${bestAskStr}</div>
                        <div style="color:var(--text-dim);font-size:10px;">${asks.length} order${asks.length !== 1 ? 's' : ''}</div>
                    </div>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;flex-wrap:wrap;gap:0.25rem;">
                    <span style="font-size:10px;color:var(--text-dim);">AMM: ${ammStr}${bidLiquidity > 0 ? ` | Book: ${bidLiqStr} ETH` : ''}</span>
                    <button onclick="openOrderbookModal()" style="font-size:10px;padding:2px 8px;background:var(--surface-2);border:1px solid var(--border);border-radius:4px;color:var(--text-muted);cursor:pointer;">${totalOrders > 0 ? `Depth (${totalOrders})` : 'View Depth'}</button>
                </div>
            `;

            // Update My Orders section
            updateMyOrders();
        }

        function updateMyOrders() {
            const section = document.getElementById('myOrdersSection');
            const list = document.getElementById('myOrdersList');
            const countEl = document.getElementById('myOrdersCount');

            if (!section || !list) return;

            // Collect all user's orders from both YES and NO sides
            const myOrders = [];

            // YES Bids (user wants to buy YES at limit price)
            for (const order of currentOrderbook.yes.bids.filter(o => o.isOwn)) {
                myOrders.push({ ...order, side: 'YES', type: 'BID' });
            }
            // YES Asks (user is selling YES)
            for (const order of currentOrderbook.yes.asks.filter(o => o.isOwn)) {
                myOrders.push({ ...order, side: 'YES', type: 'ASK' });
            }
            // NO Bids (user wants to buy NO at limit price)
            for (const order of currentOrderbook.no.bids.filter(o => o.isOwn)) {
                myOrders.push({ ...order, side: 'NO', type: 'BID' });
            }
            // NO Asks (user is selling NO)
            for (const order of currentOrderbook.no.asks.filter(o => o.isOwn)) {
                myOrders.push({ ...order, side: 'NO', type: 'ASK' });
            }

            if (myOrders.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            countEl.textContent = myOrders.length;

            // Sort by price descending
            myOrders.sort((a, b) => b.price - a.price);

            let html = '';
            for (const order of myOrders) {
                const priceStr = (order.price * 100).toFixed(1) + '%';
                const sharesStr = formatEth(order.shares);
                const sideColor = order.side === 'YES' ? 'var(--green)' : 'var(--red)';
                const typeColor = order.type === 'BID' ? 'var(--green)' : 'var(--red)';

                // Check if there are proceeds to claim
                // For buy orders (BID): sharesFilled > 0 means shares to claim
                // For sell orders (ASK): collateralFilled > 0 means ETH to claim
                const isBuyOrder = order.type === 'BID';
                const hasClaimable = isBuyOrder
                    ? (order.sharesFilled && order.sharesFilled > 0n)
                    : (order.collateralFilled && order.collateralFilled > 0n);

                const claimableInfo = hasClaimable
                    ? (isBuyOrder
                        ? `${formatEth(order.sharesFilled)} filled`
                        : `${formatEth(order.collateralFilled)} ETH filled`)
                    : '';

                html += `
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid rgba(245,158,11,0.2);">
                        <div>
                            <span style="color:${sideColor};font-weight:600;">${order.side}</span>
                            <span style="color:${typeColor};margin-left:4px;">${order.type === 'BID' ? 'Buy' : 'Sell'}</span>
                            <span style="color:var(--text-muted);margin-left:4px;">@ ${priceStr}</span>
                            ${hasClaimable ? `<span style="color:var(--green);margin-left:4px;font-size:10px;">(${claimableInfo})</span>` : ''}
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="color:var(--text);">${sharesStr}</span>
                            ${hasClaimable ? `<button onclick="claimProceeds('${order.hash}')" style="padding:2px 6px;font-size:10px;background:var(--green-dim);border:1px solid var(--green);border-radius:4px;color:var(--green);cursor:pointer;">Claim</button>` : ''}
                            <button onclick="cancelOrder('${order.hash}')" style="padding:2px 6px;font-size:10px;background:var(--surface);border:1px solid var(--amber);border-radius:4px;color:var(--amber);cursor:pointer;">Cancel</button>
                        </div>
                    </div>
                `;
            }

            list.innerHTML = html;
        }

        function openOrderbookModal() {
            renderDepthLadder();
            document.getElementById('orderbookModal').classList.add('active');
        }

        function renderDepthLadder() {
            const ladder = document.getElementById('depthLadder');
            const yesBook = currentOrderbook.yes;
            const noBook = currentOrderbook.no;

            // Update header AMM prices
            document.getElementById('yesAmmRef').textContent = yesBook.ammPrice ? `AMM ${(yesBook.ammPrice * 100).toFixed(1)}%` : '--';
            document.getElementById('noAmmRef').textContent = noBook.ammPrice ? `AMM ${(noBook.ammPrice * 100).toFixed(1)}%` : '--';

            // Collect all price levels and compute cumulative depth
            const levels = new Map(); // price -> { yesBids, yesAsks, noBids, noAsks, orders[] }

            // Helper to add orders with cumulative ETH calculation
            const addOrders = (orders, side, isYes) => {
                let cumulative = 0;
                // Bids: highest price first (best bid). Asks: lowest price first (best ask)
                const sorted = [...orders].sort((a, b) => side === 'bids' ? b.price - a.price : a.price - b.price);
                sorted.forEach(order => {
                    const price = Math.round(order.price * 1000) / 1000; // Round to 0.1% precision
                    const eth = Number(order.shares) / 1e18 * order.price;
                    cumulative += eth;
                    if (!levels.has(price)) levels.set(price, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [] });
                    const key = isYes ? (side === 'bids' ? 'yesBids' : 'yesAsks') : (side === 'bids' ? 'noBids' : 'noAsks');
                    levels.get(price)[key] = cumulative;
                    levels.get(price).orders.push({ ...order, side, isYes, eth });
                });
            };

            addOrders(yesBook.bids, 'bids', true);
            addOrders(yesBook.asks, 'asks', true);
            addOrders(noBook.bids, 'bids', false);
            addOrders(noBook.asks, 'asks', false);

            // Sort levels by price descending (high odds to low)
            const sortedLevels = [...levels.entries()].sort((a, b) => b[0] - a[0]);

            // Check if we have any actual orders
            const hasOrders = sortedLevels.some(([, data]) => data.orders.length > 0);

            if (!hasOrders) {
                // Show AMM prices as reference even without orders
                const yesAmm = yesBook.ammPrice ? (yesBook.ammPrice * 100).toFixed(1) : '--';
                const noAmm = noBook.ammPrice ? (noBook.ammPrice * 100).toFixed(1) : '--';
                ladder.innerHTML = `
                    <div style="text-align:center;padding:1.5rem;color:var(--text-dim);">
                        <div style="font-size:12px;margin-bottom:1rem;">No limit orders</div>
                        <div style="display:flex;justify-content:center;gap:2rem;font-size:11px;">
                            <span><span style="color:var(--green);">YES</span> AMM: ${yesAmm}%</span>
                            <span><span style="color:var(--red);">NO</span> AMM: ${noAmm}%</span>
                        </div>
                    </div>
                `;
                return;
            }

            // Find max cumulative for bar scaling
            let maxDepth = 0.001;
            sortedLevels.forEach(([, data]) => {
                maxDepth = Math.max(maxDepth, data.yesBids, data.yesAsks, data.noBids, data.noAsks);
            });

            // Render ladder rows
            ladder.innerHTML = sortedLevels.map(([price, data]) => {
                const pct = (price * 100).toFixed(1);
                const yesDepth = Math.max(data.yesBids, data.yesAsks);
                const noDepth = Math.max(data.noBids, data.noAsks);
                const yesBarWidth = (yesDepth / maxDepth * 100).toFixed(1);
                const noBarWidth = (noDepth / maxDepth * 100).toFixed(1);
                const yesIsAsk = data.yesAsks > data.yesBids;
                const noIsAsk = data.noAsks > data.noBids;

                // Check if this is near AMM price (highlight row)
                const isYesAmm = yesBook.ammPrice && Math.abs(price - yesBook.ammPrice) < 0.005;
                const isNoAmm = noBook.ammPrice && Math.abs(price - noBook.ammPrice) < 0.005;
                const isAmmRow = isYesAmm || isNoAmm;

                // Get clickable order info (prefer the order type that has depth)
                const yesOrder = data.orders.find(o => o.isYes && ((yesIsAsk && o.side === 'asks') || (!yesIsAsk && o.side === 'bids')));
                const noOrder = data.orders.find(o => !o.isYes && ((noIsAsk && o.side === 'asks') || (!noIsAsk && o.side === 'bids')));

                // For own orders, show cancel button; for others, show fill action
                const yesIsOwn = yesOrder?.isOwn;
                const noIsOwn = noOrder?.isOwn;
                const yesClick = yesOrder ? (yesIsOwn
                    ? `onclick="cancelOrder('${yesOrder.hash}')"`
                    : `onclick="fillOrderFromBook('${yesOrder.hash}', ${yesOrder.price}, '${yesOrder.shares.toString()}', ${yesOrder.side === 'bids'}, true)"`) : '';
                const noClick = noOrder ? (noIsOwn
                    ? `onclick="cancelOrder('${noOrder.hash}')"`
                    : `onclick="fillOrderFromBook('${noOrder.hash}', ${noOrder.price}, '${noOrder.shares.toString()}', ${noOrder.side === 'bids'}, false)"`) : '';

                // Format depth display
                const yesDepthStr = yesDepth > 0 ? (yesDepth >= 1 ? yesDepth.toFixed(2) : yesDepth.toFixed(3)) : '';
                const noDepthStr = noDepth > 0 ? (noDepth >= 1 ? noDepth.toFixed(2) : noDepth.toFixed(3)) : '';

                return `
                    <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;align-items:center;height:26px;border-bottom:1px solid var(--border);${isAmmRow ? 'background:var(--surface-2);' : ''}">
                        <!-- YES side (bars grow right-to-left) -->
                        <div ${yesClick} style="position:relative;height:100%;display:flex;align-items:center;justify-content:flex-end;padding-right:8px;${yesOrder ? 'cursor:pointer;' : ''}overflow:hidden;"
                             ${yesOrder ? `onmouseover="this.style.background='var(--${yesIsOwn ? 'amber' : (yesIsAsk ? 'red' : 'green')}-dim)'" onmouseout="this.style.background='transparent'"` : ''}>
                            ${yesDepth > 0 ? `<div style="position:absolute;right:0;top:0;bottom:0;width:${yesBarWidth}%;background:${yesIsOwn ? 'var(--amber)' : (yesIsAsk ? 'var(--red)' : 'var(--green)')};opacity:${yesIsOwn ? '0.4' : '0.3'};"></div>` : ''}
                            ${yesIsOwn ? '<span style="font-size:8px;color:var(--amber);margin-right:4px;z-index:1;font-weight:600;">YOU</span>' : ''}
                            ${isYesAmm ? '<span style="font-size:8px;color:var(--blue);margin-right:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                            <span style="font-size:10px;color:${yesIsOwn ? 'var(--amber)' : (yesIsAsk ? 'var(--red)' : 'var(--green)')};z-index:1;font-weight:600;">${yesDepthStr}</span>
                        </div>
                        <!-- Center odds -->
                        <div style="text-align:center;font-size:11px;font-weight:700;color:var(--text);background:${isAmmRow ? 'var(--surface-2)' : 'var(--surface)'};height:100%;display:flex;align-items:center;justify-content:center;border-left:1px solid var(--border);border-right:1px solid var(--border);">${pct}%</div>
                        <!-- NO side (bars grow left-to-right) -->
                        <div ${noClick} style="position:relative;height:100%;display:flex;align-items:center;padding-left:8px;${noOrder ? 'cursor:pointer;' : ''}overflow:hidden;"
                             ${noOrder ? `onmouseover="this.style.background='var(--${noIsOwn ? 'amber' : (noIsAsk ? 'red' : 'green')}-dim)'" onmouseout="this.style.background='transparent'"` : ''}>
                            ${noDepth > 0 ? `<div style="position:absolute;left:0;top:0;bottom:0;width:${noBarWidth}%;background:${noIsOwn ? 'var(--amber)' : (noIsAsk ? 'var(--red)' : 'var(--green)')};opacity:${noIsOwn ? '0.4' : '0.3'};"></div>` : ''}
                            <span style="font-size:10px;color:${noIsOwn ? 'var(--amber)' : (noIsAsk ? 'var(--red)' : 'var(--green)')};z-index:1;font-weight:600;">${noDepthStr}</span>
                            ${noIsOwn ? '<span style="font-size:8px;color:var(--amber);margin-left:4px;z-index:1;font-weight:600;">YOU</span>' : ''}
                            ${isNoAmm ? '<span style="font-size:8px;color:var(--blue);margin-left:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function closeOrderbookModal() {
            document.getElementById('orderbookModal').classList.remove('active');
        }

        async function fillOrderFromBook(orderHash, price, sharesStr, isBid, isYes) {
            if (!signer) {
                showWalletModal();
                return;
            }

            // For bids (buy orders): user is selling to fill them
            // For asks (sell orders): user is buying to fill them
            const isBuying = !isBid;
            const shares = BigInt(sharesStr); // Parse string back to BigInt for precision
            const shareAmount = Number(shares) / 1e18;
            const ethAmount = shareAmount * price;
            const side = isYes ? 'YES' : 'NO';

            // Validate user can fill (fetch fresh balances)
            const rpc = await getReadProvider();
            if (isBuying) {
                // Buying: need ETH
                const ethBal = await rpc.getBalance(connectedAddress);
                if (Number(ethBal) / 1e18 < ethAmount) {
                    showToast('Insufficient ETH', `Need ${ethAmount.toFixed(4)} ETH to fill this order`, 'error');
                    return;
                }
            } else {
                // Selling: need shares - fetch fresh balance
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const shareId = isYes ? currentTrade.yesId : currentTrade.noId;
                const userShares = await pamm.balanceOf(connectedAddress, shareId);
                if (Number(userShares) / 1e18 < shareAmount) {
                    showToast('Insufficient Shares', `Need ${shareAmount.toFixed(4)} ${side} shares to fill this order`, 'error');
                    return;
                }
            }

            closeOrderbookModal();

            // Execute fill directly via fillOrdersThenSwap with the specific order
            try {
                if (!isBuying) {
                    // Need PMRouter approval for selling
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);
                const amtWei = isBuying
                    ? ethers.parseEther(ethAmount.toFixed(18))
                    : ethers.parseEther(shareAmount.toFixed(18));

                // Calculate minOutput with slippage protection
                const expectedOutput = isBuying
                    ? ethers.parseEther(shareAmount.toFixed(18))
                    : ethers.parseEther(ethAmount.toFixed(18));
                const minOutput = expectedOutput * BigInt(100 - slippageTolerance) / 100n;

                const txPromise = pmRouter.fillOrdersThenSwap(
                    currentTrade.marketId,
                    isYes,
                    isBuying,
                    amtWei,
                    minOutput,
                    [orderHash],
                    FEE_TIER,
                    connectedAddress,
                    deadline,
                    isBuying ? { value: amtWei } : {}
                );

                await monitorTransaction(txPromise, {
                    pending: { title: `Filling ${side} Order`, body: `${isBuying ? 'Buying' : 'Selling'} at ${(price * 100).toFixed(1)}%...` },
                    submitted: { title: `Filling ${side} Order`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Filled!', body: `${isBuying ? 'Bought' : 'Sold'} ${shareAmount.toFixed(4)} ${side} shares` },
                    error: { title: 'Fill Failed', body: 'Order may have been filled or expired' },
                    onSuccess: async () => {
                        await Promise.all([loadUserPosition(), loadOrderbook(), loadData()]);
                        loadBalance();
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Fill order error:', e);
                    showToast('Fill Failed', 'Order may have been filled or expired', 'error');
                }
            }
        }

        async function cancelOrder(orderHash) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);

                await monitorTransaction(
                    pmRouter.cancelOrder(orderHash),
                    {
                        pending: { title: 'Cancelling Order', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Cancelling Order', body: 'Waiting for confirmation...' },
                        success: { title: 'Order Cancelled', body: 'Your order has been cancelled and funds returned' },
                        error: { title: 'Cancel Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([loadUserPosition(), loadOrderbook()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Cancel order error:', e);
                    showToast('Cancel Failed', 'Could not cancel order', 'error');
                }
            }
        }

        async function claimProceeds(orderHash) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);

                await monitorTransaction(
                    pmRouter.claimProceeds(orderHash),
                    {
                        pending: { title: 'Claiming Proceeds', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Claiming Proceeds', body: 'Waiting for confirmation...' },
                        success: { title: 'Proceeds Claimed!', body: 'Your filled order proceeds have been transferred' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([loadUserPosition(), loadOrderbook()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Claim proceeds error:', e);
                    showToast('Claim Failed', 'Could not claim proceeds', 'error');
                }
            }
        }

        // ======================== PREVIEW FUNCTIONS ========================
        function handleTradeInput() {
            tradeMaxRaw = null; // Clear max when user manually edits input
            if (currentTradeMode === 'trade') updateTradePreview();
        }

        function updateTradePreview() {
            const amount = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const routeEl = document.getElementById('previewRoute');

            if (!currentTrade.marketId || amount <= 0 || currentTrade.rYes === 0n) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                document.getElementById('previewPayout').style.color = 'var(--text-muted)';
                routeEl.textContent = '--';
                return;
            }

            const amtWei = ethers.parseEther(amount.toString());
            const isBuy = currentTradeDirection === 'buy';

            // Calculate AMM execution price (with price impact) for routing
            const ammOutput = isBuy
                ? (currentTrade.isYes ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo))
                : (currentTrade.isYes ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo));
            const ammOutputNum = Number(ammOutput) / 1e18;
            // Guard against division by zero
            const ammExecutionPrice = (ammOutputNum > 0 && amount > 0)
                ? (isBuy ? amount / ammOutputNum : ammOutputNum / amount)
                : null;

            // Check orderbook for better prices (use current side's book)
            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            const { bids, asks } = book;
            const relevantOrders = isBuy ? asks : bids;

            // Simulate routing through limit orders then AMM
            let betterOrders = [];
            let sharesFromOrders = 0;  // Shares received (buy) or ETH received (sell)
            let ethFromOrders = 0;     // ETH received from selling to bids
            let remainingAmount = amount;

            if (relevantOrders && relevantOrders.length > 0 && ammExecutionPrice !== null) {
                for (const order of relevantOrders) {
                    // Skip own orders - can't fill your own orders
                    if (order.isOwn) continue;
                    // Compare against execution price (with impact), not spot
                    const isBetter = isBuy ? order.price <= ammExecutionPrice : order.price >= ammExecutionPrice;
                    if (!isBetter || remainingAmount <= 0) continue;

                    const orderShares = Number(order.shares) / 1e18;
                    const orderPrice = order.price;

                    if (isBuy) {
                        // Buy: we spend ETH to get shares from asks
                        const orderCost = orderShares * orderPrice;
                        if (remainingAmount >= orderCost) {
                            sharesFromOrders += orderShares;
                            remainingAmount -= orderCost;
                        } else {
                            // Partial fill
                            const partialShares = remainingAmount / orderPrice;
                            sharesFromOrders += partialShares;
                            remainingAmount = 0;
                        }
                    } else {
                        // Sell: we sell shares to bids to get ETH
                        if (remainingAmount >= orderShares) {
                            ethFromOrders += orderShares * orderPrice;
                            remainingAmount -= orderShares;
                        } else {
                            ethFromOrders += remainingAmount * orderPrice;
                            remainingAmount = 0;
                        }
                    }
                    betterOrders.push(order);
                }
            }

            // Calculate final output including both orderbook and AMM portions
            let totalShares, avgPrice, profit;

            if (isBuy) {
                // Remaining ETH goes to AMM
                let ammShares = 0n;
                if (remainingAmount > 0) {
                    const remainingWei = ethers.parseEther(remainingAmount.toFixed(18));
                    ammShares = currentTrade.isYes
                        ? quoteBuyYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                }
                totalShares = sharesFromOrders + Number(ammShares) / 1e18;
                avgPrice = totalShares > 0 ? amount / totalShares : 0;
                profit = totalShares - amount;
            } else {
                // Remaining shares go to AMM
                let ammEth = 0n;
                if (remainingAmount > 0) {
                    const remainingWei = ethers.parseEther(remainingAmount.toFixed(18));
                    ammEth = currentTrade.isYes
                        ? quoteSellYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                }
                const totalEth = ethFromOrders + Number(ammEth) / 1e18;
                totalShares = amount; // shares sold
                avgPrice = totalEth / amount;
                profit = totalEth;
            }

            // Update route indicator with savings info
            if (betterOrders.length > 0) {
                // Calculate AMM-only output for comparison
                let ammOnlyOutput;
                if (isBuy) {
                    ammOnlyOutput = currentTrade.isYes
                        ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                } else {
                    ammOnlyOutput = currentTrade.isYes
                        ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                }
                const ammOnlyNum = Number(ammOnlyOutput) / 1e18;
                const savings = ammOnlyNum > 0
                    ? (isBuy ? ((totalShares / ammOnlyNum - 1) * 100).toFixed(1) : ((profit / ammOnlyNum - 1) * 100).toFixed(1))
                    : '0.0';
                const savingsStr = parseFloat(savings) > 0 ? ` (+${savings}%)` : '';
                const routeText = remainingAmount > 0
                    ? `${betterOrders.length} order${betterOrders.length > 1 ? 's' : ''} + AMM`
                    : `${betterOrders.length} order${betterOrders.length > 1 ? 's' : ''}`;
                routeEl.innerHTML = `<span style="color:var(--green);">${routeText}</span><span style="color:var(--green);font-size:10px;">${savingsStr}</span>`;
            } else {
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--text-muted)';
            }

            if (isBuy) {
                document.getElementById('previewShares').textContent = totalShares.toFixed(4);
                document.getElementById('previewPrice').textContent = avgPrice.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').textContent = (profit > 0 ? '+' : '') + profit.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').style.color = 'var(--green)';
            } else {
                // For sells: profit = totalEth received
                document.getElementById('previewShares').textContent = profit.toFixed(4) + ' ETH';
                document.getElementById('previewPrice').textContent = avgPrice.toFixed(4) + ' ETH';
                const minReceived = profit * (100 - slippageTolerance) / 100;
                document.getElementById('previewPayout').textContent = minReceived.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').style.color = 'var(--text-muted)';
            }
        }

        function updateSwapPreview() {
            const amount = parseFloat(document.getElementById('swapAmount').value) || 0;

            if (!currentTrade.marketId || amount <= 0 || currentTrade.rYes === 0n) {
                document.getElementById('swapOutput').textContent = '--';
                document.getElementById('swapFee').textContent = '--';
                document.getElementById('swapMinOutput').textContent = '--';
                return;
            }

            const amtWei = ethers.parseEther(amount.toString());
            const output = currentSwapDirection
                ? getAmountOut(amtWei, currentTrade.rYes, currentTrade.rNo)
                : getAmountOut(amtWei, currentTrade.rNo, currentTrade.rYes);
            const outputNum = Number(output) / 1e18;
            const fee = amount * 0.003;
            const minOut = outputNum * (1 - swapSlippage / 100);

            document.getElementById('swapOutput').textContent = outputNum.toFixed(4) + (currentSwapDirection ? ' NO' : ' YES');
            document.getElementById('swapFee').textContent = fee.toFixed(6) + ' shares';
            document.getElementById('swapMinOutput').textContent = minOut.toFixed(4);
        }

        function updateLpPreview() {
            const amount = parseFloat(document.getElementById('lpAmount').value) || 0;
            const rYes = currentTrade.rYes || 0n;
            const rNo = currentTrade.rNo || 0n;
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;

            // Get total LP supply and user LP balance
            const totalLpSupply = currentUserPosition.lpTotalSupply
                ? Number(currentUserPosition.lpTotalSupply) / 1e18
                : Math.sqrt(rYesNum * rNoNum);
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;

            // Pool TVL (approximate as average of reserves, which equals collateral locked)
            const poolTvl = (rYesNum + rNoNum) / 2;

            if (!currentTrade.marketId || amount <= 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                document.getElementById('lpShareChange').textContent = '';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP provider
                document.getElementById('lpPreview').textContent = '~' + amount.toFixed(4) + ' LP';
                document.getElementById('lpPoolShare').textContent = '100%';
                document.getElementById('lpShareChange').textContent = '(+100%)';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: estimate LP tokens proportional to contribution
                // estLp = (amount / poolTvl) * totalLpSupply
                const estLp = poolTvl > 0 ? (amount / poolTvl) * totalLpSupply : amount;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = '~' + estLp.toFixed(4) + ' LP';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta > 0 ? `(+${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
            } else {
                // Removing liquidity: LP tokens -> ETH
                if (amount > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    document.getElementById('lpShareChange').textContent = '';
                    return;
                }

                // Calculate ETH out from burning LP
                const shareOfPool = totalLpSupply > 0 ? amount / totalLpSupply : 0;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;
                const ethOut = Math.min(yesOut, noOut);

                // Calculate new share after removal
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newUserLp = userLp - amount;
                const newTotalLp = totalLpSupply - amount;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = '~' + ethOut.toFixed(4) + ' ETH';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta !== 0 ? `(${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = shareDelta < 0 ? 'var(--red)' : 'var(--text-muted)';
            }
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const amount = parseFloat(document.getElementById('limitAmount').value) || 0;

            // Update odds display (price as percentage)
            const oddsDisplay = document.getElementById('limitOddsDisplay');
            if (price > 0 && price < 1) {
                oddsDisplay.textContent = (price * 100).toFixed(0) + '%';
            } else {
                oddsDisplay.textContent = '--';
            }

            // Calculate pool price
            let poolPrice = null;
            if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                const yesPrice = Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo);
                poolPrice = currentTrade.isYes ? yesPrice : (1 - yesPrice);
                document.getElementById('limitPoolPrice').textContent = (poolPrice * 100).toFixed(1) + '%';
            } else {
                document.getElementById('limitPoolPrice').textContent = '--';
            }

            if (price <= 0 || amount <= 0) {
                document.getElementById('limitResult').textContent = '--';
                document.getElementById('limitSavings').textContent = '--';
                return;
            }

            if (limitIsBuy) {
                // BUY: User spends ETH, receives shares
                // shares = ETH / price
                const shares = amount / price;
                document.getElementById('limitResult').textContent = shares.toFixed(4) + ' shares';

                // Compare to pool: how many shares would pool give for same ETH?
                if (poolPrice && poolPrice > 0) {
                    const poolShares = amount / poolPrice;
                    const extraShares = shares - poolShares;
                    if (extraShares > 0) {
                        document.getElementById('limitSavings').textContent = '+' + extraShares.toFixed(4) + ' shares';
                        document.getElementById('limitSavings').style.color = 'var(--green)';
                    } else {
                        document.getElementById('limitSavings').textContent = extraShares.toFixed(4) + ' shares';
                        document.getElementById('limitSavings').style.color = 'var(--red)';
                    }
                } else {
                    document.getElementById('limitSavings').textContent = '--';
                }
            } else {
                // SELL: User sells shares, receives ETH
                // ETH = shares * price
                const ethReceived = amount * price;
                document.getElementById('limitResult').textContent = ethReceived.toFixed(4) + ' ETH';

                // Compare to pool: how much ETH would pool give for same shares?
                if (poolPrice && poolPrice > 0) {
                    const poolEth = amount * poolPrice;
                    const extraEth = ethReceived - poolEth;
                    if (extraEth > 0) {
                        document.getElementById('limitSavings').textContent = '+' + extraEth.toFixed(4) + ' ETH';
                        document.getElementById('limitSavings').style.color = 'var(--green)';
                    } else {
                        document.getElementById('limitSavings').textContent = extraEth.toFixed(4) + ' ETH';
                        document.getElementById('limitSavings').style.color = 'var(--red)';
                    }
                } else {
                    document.getElementById('limitSavings').textContent = '--';
                }
            }
        }

        // ======================== AMM MATH ========================
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            return collateralIn + yesFromSwap;
        }

        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            return collateralIn + noFromSwap;
        }

        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Binary search for optimal swap amount
            // Goal: find x where (yesIn - x) == getAmountOut(x, rYes, rNo)
            if (yesIn === 0n) return 0n;
            let lo = 0n, hi = yesIn;
            for (let i = 0; i < 64; i++) {
                const mid = (lo + hi) / 2n;
                const noFromSwap = getAmountOut(mid, rYes, rNo, feeBps);
                const yesRemaining = yesIn - mid;
                if (yesRemaining > noFromSwap) {
                    lo = mid + 1n;
                } else {
                    hi = mid;
                }
            }
            const noFromSwap = getAmountOut(lo, rYes, rNo, feeBps);
            const yesRemaining = yesIn - lo;
            return yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
        }

        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Binary search for optimal swap amount
            // Goal: find x where (noIn - x) == getAmountOut(x, rNo, rYes)
            if (noIn === 0n) return 0n;
            let lo = 0n, hi = noIn;
            for (let i = 0; i < 64; i++) {
                const mid = (lo + hi) / 2n;
                const yesFromSwap = getAmountOut(mid, rNo, rYes, feeBps);
                const noRemaining = noIn - mid;
                if (noRemaining > yesFromSwap) {
                    lo = mid + 1n;
                } else {
                    hi = mid;
                }
            }
            const yesFromSwap = getAmountOut(lo, rNo, rYes, feeBps);
            const noRemaining = noIn - lo;
            return noRemaining < yesFromSwap ? noRemaining : yesFromSwap;
        }

        // ======================== EXECUTE FUNCTIONS ========================
        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('tradeAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            const isBuy = currentTradeDirection === 'buy';
            const side = currentTrade.isYes ? 'YES' : 'NO';

            // For sells, validate balance first
            if (!isBuy) {
                const balance = currentTrade.isYes
                    ? currentUserPosition.yesBalance
                    : currentUserPosition.noBalance;
                const amtToSell = tradeMaxRaw || ethers.parseEther(amount.toString());
                if (!balance || amtToSell > balance) {
                    showToast('Insufficient Balance', `You don't have enough ${side} shares`, 'error');
                    return;
                }
            }

            try {
                if (!isBuy) {
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                // Use exact raw value if max was clicked, otherwise parse input
                const amtWei = (!isBuy && tradeMaxRaw) ? tradeMaxRaw : ethers.parseEther(amount.toString());
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                // Calculate expected AMM output (with price impact) for routing decisions
                let expectedAmmOutput;
                if (isBuy) {
                    expectedAmmOutput = currentTrade.isYes
                        ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                } else {
                    expectedAmmOutput = currentTrade.isYes
                        ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                }

                // Calculate actual AMM execution price (includes price impact, not just spot)
                // For buys: price = ETH spent / shares received
                // For sells: price = ETH received / shares sold
                const ammOutputNum = Number(expectedAmmOutput) / 1e18;
                const ammExecutionPrice = (ammOutputNum > 0 && amount > 0)
                    ? (isBuy ? amount / ammOutputNum : ammOutputNum / amount)
                    : null;

                // Smart order routing: compare orders against AMM execution price (with impact)
                const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
                const { bids, asks } = book;
                const relevantOrders = isBuy ? asks : bids; // Buy fills asks, sell fills bids
                const betterOrders = [];

                // Track expected output from orders and remaining amount for AMM
                // Use BigInt for all calculations to match contract precision
                let expectedFromOrders = 0n;
                let remainingWei = amtWei; // Track in wei for precision

                if (relevantOrders.length > 0 && ammExecutionPrice !== null) {
                    for (const order of relevantOrders) {
                        // Skip own orders - can't fill your own orders
                        if (order.isOwn) continue;
                        // For buying: ask price <= AMM execution price is better (lower = cheaper)
                        // For selling: bid price >= AMM execution price is better (higher = more ETH back)
                        const isBetterThanAmm = isBuy
                            ? order.price <= ammExecutionPrice
                            : order.price >= ammExecutionPrice;
                        if (isBetterThanAmm && remainingWei > 0n) {
                            betterOrders.push(order.hash);

                            if (isBuy) {
                                // Buy: spend ETH to get shares from asks
                                // orderCost in wei = order.collateral (that's the ETH needed to buy all shares)
                                const orderCostWei = order.collateral;
                                if (remainingWei >= orderCostWei) {
                                    // Full fill
                                    expectedFromOrders += order.shares;
                                    remainingWei -= orderCostWei;
                                } else {
                                    // Partial fill: shares = remainingWei * order.shares / order.collateral
                                    const partialShares = remainingWei * order.shares / order.collateral;
                                    expectedFromOrders += partialShares;
                                    remainingWei = 0n;
                                }
                            } else {
                                // Sell: sell shares to bids to get ETH
                                // remainingWei here is actually remaining shares in wei
                                if (remainingWei >= order.shares) {
                                    // Full fill: ETH out = order.collateral
                                    expectedFromOrders += order.collateral;
                                    remainingWei -= order.shares;
                                } else {
                                    // Partial fill: ETH = remainingWei * order.collateral / order.shares
                                    const partialEth = remainingWei * order.collateral / order.shares;
                                    expectedFromOrders += partialEth;
                                    remainingWei = 0n;
                                }
                            }
                        }
                    }
                }

                // Calculate expected output: orders + AMM for remaining amount
                let expectedOutput;
                if (betterOrders.length > 0 && remainingWei > 0n) {
                    // Mixed route: orders + AMM
                    let ammOutput;
                    if (isBuy) {
                        ammOutput = currentTrade.isYes
                            ? quoteBuyYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                            : quoteBuyNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                    } else {
                        ammOutput = currentTrade.isYes
                            ? quoteSellYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                            : quoteSellNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                    }
                    expectedOutput = expectedFromOrders + ammOutput;
                } else if (betterOrders.length > 0) {
                    // Orders only (consumed full amount)
                    expectedOutput = expectedFromOrders;
                } else {
                    // AMM only
                    expectedOutput = expectedAmmOutput;
                }

                // Apply slippage tolerance
                const minOutput = expectedOutput * BigInt(100 - slippageTolerance) / 100n;

                let txPromise;
                const useFillOrders = betterOrders.length > 0;

                if (useFillOrders) {
                    // Route through fillOrdersThenSwap to fill better limit orders first
                    txPromise = pmRouter.fillOrdersThenSwap(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        isBuy,
                        amtWei,
                        minOutput,
                        betterOrders,
                        FEE_TIER,
                        connectedAddress,
                        deadline,
                        isBuy ? { value: amtWei } : {}
                    );
                } else if (isBuy) {
                    txPromise = pmRouter.buy(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        amtWei,
                        minOutput,
                        FEE_TIER,
                        connectedAddress,
                        deadline,
                        { value: amtWei }
                    );
                } else {
                    txPromise = pmRouter.sell(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        amtWei,
                        minOutput,
                        FEE_TIER,
                        connectedAddress,
                        deadline
                    );
                }

                const routeInfo = useFillOrders ? ` (via ${betterOrders.length} limit order${betterOrders.length > 1 ? 's' : ''})` : '';
                await monitorTransaction(txPromise, {
                    pending: { title: `${isBuy ? 'Buying' : 'Selling'} ${side}`, body: `Confirm in your wallet...${routeInfo}` },
                    submitted: { title: `${isBuy ? 'Buying' : 'Selling'} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Complete!', body: `${isBuy ? 'Bought' : 'Sold'} ${amount} ${side} shares${routeInfo}` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        tradeMaxRaw = null; // Clear max flag
                        await Promise.all([loadUserPosition(), loadOrderbook(), loadData()]);
                        loadBalance();
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) console.error('Trade error:', e);
            } finally {
                tradeMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function executeSwap() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('swapAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            // Check balance - use exact raw value if max was clicked, otherwise parse input
            const sourceBalance = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
            const amtWei = swapMaxRaw || ethers.parseEther(amount.toString());
            if (amtWei > sourceBalance) {
                showToast('Insufficient Balance', `You don't have enough ${currentSwapDirection ? 'YES' : 'NO'} shares`, 'error');
                return;
            }

            const fromLabel = currentSwapDirection ? 'YES' : 'NO';
            const toLabel = currentSwapDirection ? 'NO' : 'YES';

            try {
                // Need ZAMM approved as operator on PAMM
                const approved = await checkAndRequestApprovals('swap');
                if (!approved) return;

                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const yesId = currentTrade.yesId;
                const noId = currentTrade.noId;
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;

                const poolKey = {
                    id0: id0,
                    id1: id1,
                    token0: PAMM_ADDRESS,
                    token1: PAMM_ADDRESS,
                    feeOrHook: FEE_TIER
                };

                const yesIsToken0 = yesId === id0;
                const zeroForOne = currentSwapDirection ? yesIsToken0 : !yesIsToken0;

                // Calculate min output with slippage
                const output = currentSwapDirection
                    ? getAmountOut(amtWei, currentTrade.rYes, currentTrade.rNo)
                    : getAmountOut(amtWei, currentTrade.rNo, currentTrade.rYes);
                const minOut = output * BigInt(Math.floor((1 - swapSlippage / 100) * 10000)) / 10000n;

                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                await monitorTransaction(
                    zamm.swapExactIn(poolKey, amtWei, minOut, zeroForOne, connectedAddress, deadline),
                    {
                        pending: { title: `Swap ${fromLabel} ‚Üí ${toLabel}`, body: 'Confirm in your wallet...' },
                        submitted: { title: `Swap ${fromLabel} ‚Üí ${toLabel}`, body: 'Waiting for confirmation...' },
                        success: { title: 'Swap Complete!', body: `Swapped ${amount} ${fromLabel} ‚Üí ${toLabel}` },
                        error: { title: 'Swap Failed', body: '' },
                        onSuccess: async () => {
                            swapMaxRaw = null; // Clear max flag
                            await loadUserPosition();
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) console.error('Swap error:', e);
            } finally {
                swapMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('lpAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            // Use exact raw value if max was clicked, otherwise parse input
            const amtWei = lpMaxRaw || ethers.parseEther(amount.toString());

            // Validate balance for LP remove
            if (currentLpMode === 'remove') {
                const lpBal = currentUserPosition.lpBalance;
                if (!lpBal || amtWei > lpBal) {
                    showToast('Insufficient LP', 'You don\'t have enough LP tokens', 'error');
                    return;
                }
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                // Calculate expected outputs for slippage protection
                const rYesNum = Number(currentTrade.rYes) / 1e18;
                const rNoNum = Number(currentTrade.rNo) / 1e18;
                const totalLpSupply = currentUserPosition.lpTotalSupply
                    ? Number(currentUserPosition.lpTotalSupply) / 1e18
                    : Math.sqrt(rYesNum * rNoNum);
                const poolTvl = (rYesNum + rNoNum) / 2;

                if (currentLpMode === 'add') {
                    // Expected LP tokens from adding liquidity
                    const estLp = poolTvl > 0 ? (amount / poolTvl) * totalLpSupply : amount;
                    const minLiquidity = ethers.parseEther((estLp * (100 - slippageTolerance) / 100).toFixed(18));

                    await monitorTransaction(
                        pamm.splitAndAddLiquidity(
                            currentTrade.marketId,
                            amtWei,
                            FEE_TIER,
                            0n, 0n, minLiquidity,
                            connectedAddress,
                            deadline,
                            { value: amtWei }
                        ),
                        {
                            pending: { title: 'Adding Liquidity', body: 'Confirm in your wallet...' },
                            submitted: { title: 'Adding Liquidity', body: 'Waiting for confirmation...' },
                            success: { title: 'Liquidity Added!', body: `Added ${amount} ETH to the pool` },
                            error: { title: 'Add Liquidity Failed', body: '' },
                            onSuccess: async () => {
                                lpMaxRaw = null; // Clear max flag
                                await loadUserPosition();
                                loadBalance();
                            }
                        }
                    );
                } else {
                    // Need PAMM approved as operator on ZAMM for LP removal
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    // Calculate minimum collateral out with slippage protection
                    const shareOfPool = totalLpSupply > 0 ? amount / totalLpSupply : 0;
                    const yesOut = shareOfPool * rYesNum;
                    const noOut = shareOfPool * rNoNum;
                    const estEthOut = Math.min(yesOut, noOut);
                    const minCollateral = ethers.parseEther((estEthOut * (100 - slippageTolerance) / 100).toFixed(18));

                    // Check if market is resolved and user has direct winning tokens
                    const market = await pamm.getMarket(currentTrade.marketId);
                    const isResolved = market[2]; // resolved
                    const outcome = market[3]; // outcome (true = YES won)

                    // Check for direct winning token holdings (beyond LP)
                    let hasDirectWinnings = false;
                    if (isResolved) {
                        const winningBalance = outcome
                            ? currentUserPosition.yesBalance
                            : currentUserPosition.noBalance;
                        hasDirectWinnings = winningBalance > 0n;
                    }

                    let txPromise;
                    if (isResolved && hasDirectWinnings) {
                        // Use multicall to batch LP removal + claim
                        const pammInterface = new ethers.Interface(PAMM_ABI);
                        const calls = [
                            pammInterface.encodeFunctionData('removeLiquidityToCollateral', [
                                currentTrade.marketId,
                                FEE_TIER,
                                amtWei,
                                0n, 0n, minCollateral,
                                connectedAddress,
                                deadline
                            ]),
                            pammInterface.encodeFunctionData('claim', [
                                currentTrade.marketId,
                                connectedAddress
                            ])
                        ];
                        txPromise = pamm.multicall(calls);
                    } else {
                        txPromise = pamm.removeLiquidityToCollateral(
                            currentTrade.marketId,
                            FEE_TIER,
                            amtWei,
                            0n, 0n, minCollateral,
                            connectedAddress,
                            deadline
                        );
                    }

                    const actionTitle = hasDirectWinnings ? 'Withdrawing All' : 'Removing Liquidity';
                    const successBody = hasDirectWinnings
                        ? 'LP and winnings returned to your wallet'
                        : 'Withdrew liquidity from the pool';

                    await monitorTransaction(txPromise, {
                        pending: { title: actionTitle, body: 'Confirm in your wallet...' },
                        submitted: { title: actionTitle, body: 'Waiting for confirmation...' },
                        success: { title: 'Success!', body: successBody },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            lpMaxRaw = null; // Clear max flag
                            await loadUserPosition();
                            loadBalance();
                        }
                    });
                }
            } catch (e) {
                if (!isUserRejection(e)) console.error('LP error:', e);
            } finally {
                lpMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function claimWinnings(marketId) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const rpc = await getReadProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);

                // Check if user has any winning tokens to claim
                const market = await pamm.getMarket(marketId);
                const outcome = market[3]; // true = YES won
                const yesId = BigInt(marketId);
                const noId = await pamm.getNoId(marketId);
                const winningId = outcome ? yesId : noId;
                const balance = await pamm.balanceOf(connectedAddress, winningId);

                if (balance === 0n) {
                    showToast('Nothing to Claim', `You don't have any ${outcome ? 'YES' : 'NO'} shares to claim`, 'info');
                    return;
                }

                const pammSigner = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                await monitorTransaction(
                    pammSigner.claim(marketId, connectedAddress),
                    {
                        pending: { title: 'Claiming Winnings', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Claiming Winnings', body: 'Waiting for confirmation...' },
                        success: { title: 'Winnings Claimed!', body: 'Your winnings have been sent to your wallet' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) console.error('Claim failed:', e);
            }
        }

        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) return;

            const price = parseFloat(document.getElementById('limitPrice').value);
            const amount = parseFloat(document.getElementById('limitAmount').value);

            if (!price || price <= 0 || price >= 1) {
                showToast('Invalid Price', 'Enter price between 0.01 and 0.99', 'error');
                return;
            }
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Enter a valid amount', 'error');
                return;
            }

            // Calculate shares and collateral based on order type
            // Use limitMaxRaw for exact BigInt precision when available
            let sharesWei, collateralWei;
            let shares, collateral;

            if (limitIsBuy) {
                // BUY: user provides ETH (amount), wants shares
                collateralWei = limitMaxRaw || ethers.parseEther(amount.toString());
                collateral = Number(ethers.formatEther(collateralWei));
                shares = collateral / price;
                sharesWei = ethers.parseEther(shares.toFixed(18));
            } else {
                // SELL: user provides shares (amount), wants ETH
                sharesWei = limitMaxRaw || ethers.parseEther(amount.toString());
                shares = Number(ethers.formatEther(sharesWei));
                collateral = shares * price;
                collateralWei = ethers.parseEther(collateral.toFixed(18));

                // Check balance
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                if (sharesWei > userShares) {
                    showToast('Insufficient Shares', `You don't have enough shares`, 'error');
                    return;
                }
            }

            try {
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('limit');
                    if (!approved) return;
                }

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                // Get market close time for deadline
                const market = await pamm.getMarket(currentTrade.marketId);
                const closeTime = market[5];

                const orderType = limitIsBuy ? 'Buy' : 'Sell';
                const displayPrice = (price * 100).toFixed(0) + '%';
                let txPromise;

                if (limitIsBuy) {
                    txPromise = pmRouter.placeOrder(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        true, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true, // partialFill
                        { value: collateralWei }
                    );
                } else {
                    txPromise = pmRouter.placeOrder(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        false, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true // partialFill
                    );
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `Placing ${orderType} Order`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Placing ${orderType} Order`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Placed!', body: `${orderType} ${shares.toFixed(2)} shares at ${displayPrice}` },
                    error: { title: 'Order Failed', body: '' },
                    onSuccess: async () => {
                        document.getElementById('limitAmount').value = '';
                        limitMaxRaw = null; // Clear max flag
                        setDefaultLimitPrice();
                        updateLimitPreview();
                        await Promise.all([loadUserPosition(), loadOrderbook()]);
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) console.error('Limit order error:', e);
            }
            limitMaxRaw = null; // Clear max flag regardless of outcome
        }

        // ======================== APPROVALS ========================
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                let success = false;
                await monitorTransaction(contract.setOperator(operatorAddress, true), {
                    pending: { title: `Approving ${operatorName}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Approving ${operatorName}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Approved!', body: `${operatorName} can now manage your shares` },
                    error: { title: 'Approval Failed', body: '' },
                    onSuccess: () => { success = true; }
                });

                return success;
            } catch (e) {
                if (!isUserRejection(e)) console.error('Approval error:', e);
                return false;
            }
        }

        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error');
                return false;
            }

            // PMRouter needs operator on PAMM for: sell, limit orders
            if (operation === 'sell' || operation === 'limit') {
                return await ensureOperatorApproval('pamm', PMROUTER_ADDRESS, 'PMRouter');
            }

            // PAMM needs operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                return await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
            }

            // ZAMM needs operator on PAMM for: swap
            if (operation === 'swap') {
                return await ensureOperatorApproval('pamm', ZAMM_ADDRESS, 'ZAMM');
            }

            return true;
        }

        // ======================== TX MONITORING ========================
        async function monitorTransaction(txPromise, options = {}) {
            const {
                pending = { title: 'Transaction Pending', body: 'Confirm in your wallet...' },
                submitted = { title: 'Transaction Submitted', body: 'Waiting for confirmation...' },
                success = { title: 'Transaction Confirmed', body: '' },
                error = { title: 'Transaction Failed', body: '' },
                onSuccess = null
            } = options;

            const toastId = showToast(pending.title, pending.body, 'pending');
            let txHash = null;

            try {
                const tx = await txPromise;
                txHash = tx.hash;
                const etherscanLink = `<a href="https://etherscan.io/tx/${txHash}" target="_blank" style="color:var(--blue);">View on Etherscan</a>`;
                updateToast(toastId, submitted.title, `${submitted.body}<br>${etherscanLink}`, 'pending');

                // Wait for confirmation using dedicated RPC
                const rpc = await getRpcProvider();
                const receipt = await Promise.race([
                    rpc.waitForTransaction(txHash, 1, 60000),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 65000))
                ]);

                if (receipt && Number(receipt.status) === 1) {
                    updateToast(toastId, success.title, `${success.body}${success.body ? '<br>' : ''}${etherscanLink}`, 'success', 5000);
                    if (onSuccess) await onSuccess(receipt);
                    return receipt;
                } else if (receipt && Number(receipt.status) === 0) {
                    updateToast(toastId, error.title, `Transaction reverted<br>${etherscanLink}`, 'error', 8000);
                    throw new Error('Transaction reverted');
                } else {
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded<br>${etherscanLink}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                }
            } catch (e) {
                console.error('Transaction error:', e);
                if (isUserRejection(e)) {
                    updateToast(toastId, 'Transaction Cancelled', 'You rejected the transaction', 'error', 4000);
                } else if (e.message === 'timeout') {
                    const etherscanLink = txHash ? `<a href="https://etherscan.io/tx/${txHash}" target="_blank" style="color:var(--blue);">View on Etherscan</a>` : '';
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded${etherscanLink ? '<br>' + etherscanLink : ''}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                } else {
                    const errMsg = e.reason || e.message || 'Unknown error';
                    updateToast(toastId, error.title, errMsg.slice(0, 100), 'error', 8000);
                }
                throw e;
            }
        }

        // ======================== MARKET CREATION ========================
        function updateCreatePreview() {
            const threshold = document.getElementById('createThreshold').value || '40';
            const deadlineSelect = document.getElementById('createDeadline').value;
            const canClose = document.getElementById('createCanClose').value === 'true';

            document.getElementById('customDeadlineGroup').style.display = deadlineSelect === 'custom' ? 'block' : 'none';

            let deadlineStr = 'Dec 31, 2025';
            if (deadlineSelect === 'custom') {
                const customTs = document.getElementById('createCustomDeadline').value;
                if (customTs) {
                    deadlineStr = new Date(parseInt(customTs) * 1000).toUTCString();
                }
            }

            document.getElementById('createPreview').textContent =
                `PNKSTR CryptoPunks balance > ${threshold} by ${deadlineStr}` +
                (canClose ? ' (may close early)' : '');
        }

        async function createMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            const threshold = parseInt(document.getElementById('createThreshold').value);
            const deadlineSelect = document.getElementById('createDeadline').value;
            const canClose = document.getElementById('createCanClose').value === 'true';
            const seedEth = parseFloat(document.getElementById('createSeed').value);

            if (!threshold || threshold < 1) {
                showToast('Invalid Threshold', 'Please enter a valid threshold', 'error');
                return;
            }

            if (!seedEth || seedEth < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001 ETH', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eoy2025') {
                close = EOY_2025;
            } else {
                close = parseInt(document.getElementById('createCustomDeadline').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = document.querySelector('.create-btn');
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = ethers.parseEther(seedEth.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // callData for balanceOf(PNKSTR)
                const callData = PNKSTR_BALANCE_CALLDATA;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                // Observable string for on-chain description
                const observable = `PNKSTR Punks (0x1244..4838)`;

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    ethers.ZeroAddress, // ETH collateral
                    CRYPTOPUNKS_ADDRESS,
                    callData,
                    1, // Op.GT (greater than)
                    BigInt(threshold),
                    BigInt(close),
                    canClose,
                    seedParams,
                    { value: seedWei }
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank">View on Etherscan</a>`, 'pending');

                const receipt = await tx.wait();

                showToast('Market Created', 'Your market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Creation Failed', error.reason || error.message || 'Transaction failed', 'error');
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Market';
            }
        }

        // ======================== RESOLUTION ========================
        async function resolveMarket(marketId) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);

                await monitorTransaction(
                    resolver.resolveMarket(marketId),
                    {
                        pending: { title: 'Resolving Market', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Resolving Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Resolved!', body: 'The market has been resolved' },
                        error: { title: 'Resolution Failed', body: '' },
                        onSuccess: () => loadData()
                    }
                );

            } catch (error) {
                console.error('Resolution failed:', error);
            }
        }

        // ======================== UTILITIES ========================
        function formatEth(wei) {
            if (typeof wei === 'bigint') {
                return (Number(wei) / 1e18).toFixed(4);
            }
            return '0.0000';
        }

        function formatCountdown(seconds) {
            if (seconds <= 0) return 'Ended';

            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            return `${mins}m`;
        }

        function formatDate(unixTimestamp) {
            const date = new Date(unixTimestamp * 1000);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function escapeHtml(str) {
            return str.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
        }

        function truncateId(id) {
            if (id.length <= 12) return id;
            return id.slice(0, 6) + '...' + id.slice(-4);
        }

        function showToast(title, message, type = 'info', duration = 5000) {
            const id = ++toastIdCounter;
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.dataset.toastId = id;

            const icons = { pending: '‚è≥', success: '‚úì', error: '‚úï', info: '‚Ñπ' };

            toast.innerHTML = `
                <div class="toast-header">
                    <span class="icon">${icons[type] || icons.info}</span>
                    <span class="toast-title">${title}</span>
                </div>
                <div class="toast-body">${message}</div>
            `;

            container.appendChild(toast);
            pendingToasts.set(id, toast);

            if (type !== 'pending') {
                setTimeout(() => {
                    toast.classList.add('hiding');
                    setTimeout(() => {
                        toast.remove();
                        pendingToasts.delete(id);
                    }, 300);
                }, duration);
            }

            return id;
        }

        function updateToast(toastId, title, message, type = 'info', duration = 5000) {
            const toast = pendingToasts.get(toastId);
            if (!toast) return;

            const icons = { pending: '‚è≥', success: '‚úì', error: '‚úï', info: '‚Ñπ' };
            toast.className = `toast ${type}`;

            const titleEl = toast.querySelector('.toast-title');
            const bodyEl = toast.querySelector('.toast-body');
            const iconEl = toast.querySelector('.icon');

            if (titleEl) titleEl.textContent = title;
            if (bodyEl) bodyEl.innerHTML = message;
            if (iconEl) iconEl.textContent = icons[type] || icons.info;

            if (type !== 'pending' && duration > 0) {
                setTimeout(() => {
                    toast.classList.add('hiding');
                    setTimeout(() => {
                        toast.remove();
                        pendingToasts.delete(toastId);
                    }, 300);
                }, duration);
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
