<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>pnkPM - PNKSTR Bets</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='600' fill='%23ec4899' text-anchor='middle'>Pnk</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='600' fill='%233b82f6' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --blue-dim: rgba(59, 130, 246, 0.15);
            --amber: #f59e0b;
            --amber-dim: rgba(245, 158, 11, 0.15);
            --pink: #ec4899;
            --pink-dim: rgba(236, 72, 153, 0.15);
            --purple: #a855f7;
            --gray: #27272a;
            --light-gray: #3f3f46;
            --black: #09090b;

            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;
            --font-mono: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--pink); }

        .tagline {
            font-size: var(--font-xs);
            color: var(--text-dim);
            margin-left: 0.75rem;
        }

        .tagline:hover {
            color: var(--pink);
        }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.pink { color: var(--pink); }
        .live-stat-value.green { color: var(--green); }
        .live-stat-value.blue { color: var(--blue); }
        .live-stat-value.amber { color: var(--amber); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--pink);
            color: var(--bg);
            border-color: var(--pink);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* HERO SECTION */
        .hero-section {
            padding: 2rem 1.5rem;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        .hero-title {
            font-size: var(--font-2xl);
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .hero-subtitle {
            color: var(--text-muted);
            font-size: var(--font-sm);
            margin-bottom: 1.5rem;
        }

        .treasury-display {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--surface);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .treasury-balance {
            font-size: var(--font-2xl);
            font-weight: 700;
            color: var(--pink);
        }

        .treasury-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .stats-summary {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 0.875rem;
            margin-bottom: 1rem;
            background: var(--surface);
            border-radius: var(--radius);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        .market-row {
            display: grid;
            grid-template-columns: minmax(320px, 400px) 1fr;
            gap: 1rem;
            align-items: start;
        }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--pink);
        }

        .bet-card.resolved {
            opacity: 0.7;
        }

        .inline-orderbook {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1rem;
            min-height: 300px;
        }

        .inline-orderbook-header {
            display: grid;
            grid-template-columns: 1fr 56px 1fr;
            gap: 0;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border);
        }

        .inline-orderbook-ladder {
            font-family: var(--font-mono);
            font-size: 11px;
            max-height: 350px;
            overflow-y: auto;
        }

        .inline-ob-cell {
            transition: background 0.15s ease;
        }

        .inline-ob-cell:hover {
            background: rgba(255, 255, 255, 0.08) !important;
        }

        .inline-ob-yes:hover {
            background: rgba(0, 200, 83, 0.15) !important;
        }

        .inline-ob-no:hover {
            background: rgba(255, 82, 82, 0.15) !important;
        }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
            color: var(--pink);
        }

        .bet-status {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 3px;
        }

        .bet-status.active {
            background: var(--green-dim);
            color: var(--green);
        }

        .bet-status.resolved {
            background: var(--surface-2);
            color: var(--text-muted);
        }

        .bet-status.ready {
            background: rgba(245, 158, 11, 0.15);
            color: var(--amber);
        }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
        }

        .onchain-details {
            margin-top: 0.25rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .onchain-details:hover {
            opacity: 0.8;
        }
        .onchain-details[open] {
            opacity: 0.8;
        }
        .onchain-details summary {
            font-size: 9px;
            color: var(--text-dim);
            cursor: pointer;
            user-select: none;
            list-style: none;
        }
        .onchain-details summary::-webkit-details-marker {
            display: none;
        }
        .onchain-details summary:hover {
            color: var(--text-muted);
        }
        .onchain-desc {
            font-size: 9px;
            color: var(--text-dim);
            background: var(--surface-2);
            padding: 0.4rem;
            border-radius: var(--radius);
            margin-top: 0.25rem;
            word-break: break-all;
            margin-bottom: 0.75rem;
            font-family: monospace;
        }

        .condition-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .condition-point { text-align: center; }

        .condition-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .condition-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .condition-op {
            font-size: 1.25rem;
            color: var(--text-muted);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.3); }

        .bet-btn.yes { border-color: var(--green); background: var(--green-dim); }
        .bet-btn.yes:hover { background: var(--green); }
        .bet-btn.yes:hover .bet-btn-label,
        .bet-btn.yes:hover .bet-btn-odds,
        .bet-btn.yes:hover .bet-btn-price { color: var(--bg); }
        .bet-btn.no { border-color: var(--red); background: var(--red-dim); }
        .bet-btn.no:hover { background: var(--red); }
        .bet-btn.no:hover .bet-btn-label,
        .bet-btn.no:hover .bet-btn-odds,
        .bet-btn.no:hover .bet-btn-price { color: var(--bg); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.yes .bet-btn-label { color: var(--green); }
        .bet-btn.no .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .liquidity-stats {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-top: 1px solid var(--border);
            margin-top: 0.5rem;
            font-size: var(--font-xs);
            color: var(--text-muted);
        }

        .resolve-btn {
            width: 100%;
            margin-top: 0.5rem;
            padding: 0.75rem;
            background: var(--amber);
            color: var(--black);
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .resolve-btn:hover { opacity: 0.9; }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            max-width: 500px;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--pink);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--pink);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--pink);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-yes { background: var(--green); color: var(--bg); }
        .trade-submit.buy-no { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Wallet Options */
        .wallet-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--gray);
            border: 1px solid var(--light-gray);
            border-radius: var(--radius);
            cursor: pointer;
            margin-bottom: var(--spacing-xs);
            transition: all 0.15s ease;
        }
        .wallet-option:hover { border-color: var(--pink); }
        .wallet-option-icon { font-size: 1.5rem; }
        .wallet-option-name { font-weight: 600; }
        .wallet-option.disconnect {
            border-color: var(--red);
            color: var(--red);
            justify-content: center;
        }
        .wallet-option.disconnect:hover {
            background: var(--red);
            color: var(--black);
        }

        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 380px;
            pointer-events: none;
        }
        .toast {
            padding: 1rem 1.25rem;
            border-radius: var(--radius);
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: var(--font-sm);
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-in forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toast-out {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); }
        }
        .toast-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        .toast.pending .toast-header { color: var(--blue); }
        .toast.success .toast-header { color: var(--green); }
        .toast.error .toast-header { color: var(--red); }
        .toast-body {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }
        .toast-body a {
            color: var(--blue);
            text-decoration: underline;
        }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* CHART */
        .chart-container {
            background: #0a0a0a;
            border-radius: var(--radius);
            overflow: hidden;
        }

        .chart-container iframe {
            display: block;
            width: 100%;
            height: 360px;
            border: none;
            background: #0a0a0a;
        }

        /* EMPTY STATE */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* MOBILE */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; flex-wrap: wrap; }
            .header-center { gap: 1rem; }
            .tagline { display: none; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .hero-section { padding: 1rem; }
            .treasury-display { padding: 0.75rem 1rem; }
            .chart-container iframe { height: 300px; }
            .modal {
                margin: 0.5rem;
                padding: 0.75rem;
                max-width: calc(100vw - 1rem);
            }
            .modal-header { padding: 0.5rem 0.75rem; }
            .modal-body { padding: 0.5rem !important; }
        }

        @media (max-width: 480px) {
            .header-center {
                order: 3;
                width: 100%;
                justify-content: space-around;
                padding-top: 0.5rem;
                border-top: 1px solid var(--border);
                margin-top: 0.5rem;
            }
            .bets-grid { grid-template-columns: 1fr; }
            .market-row { grid-template-columns: 1fr; }
            .inline-orderbook { min-height: 200px; }
            .chart-container iframe { height: 240px; }
            /* Trade modal position info - stack on mobile */
            #tradeMarketInfo > div { flex-direction: column; gap: 0.5rem; }
            #tradeMarketInfo > div > div:last-child { text-align: left; }
            /* Compact mode buttons */
            .mode-toggle-btn { padding: 0.4rem !important; font-size: 10px !important; }
            /* Limit price buttons - smaller */
            #limitSection .trade-input-group button { padding: 0.4rem 0.5rem; font-size: 10px; }
            /* My Orders - smaller buttons */
            #myOrdersList button { padding: 1px 4px; font-size: 9px; }
        }

        @media (max-width: 380px) {
            /* Extra small screens */
            .bet-buttons { grid-template-columns: 1fr; gap: 0.5rem; }
            .bet-btn { width: 100%; }
            /* Depth ladder - narrower center column */
            #depthLadder > div { grid-template-columns: 1fr 44px 1fr !important; }
        }
    </style>
</head>
<body>
    <!-- Toast Notifications Container -->
    <div id="toastContainer" class="toast-container"></div>

    <header class="header">
        <div style="display:flex;align-items:center;">
            <div class="logo">pnk<span>PM</span></div>
            <a href="https://www.punkstrategy.fun/" target="_blank" rel="noopener" class="tagline" style="text-decoration: none; transition: color 0.2s;">PNKSTR Prediction Markets ‚Üó</a>
        </div>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">PNKSTR Punks</div>
                <div class="live-stat-value pink" id="livePunks">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Markets</div>
                <div class="live-stat-value blue" id="marketCount">0</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Pool TVL</div>
                <div class="live-stat-value green" id="totalTvl">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Book TVL</div>
                <div class="live-stat-value" style="color:#f59e0b;" id="orderbookTvl">--</div>
            </div>
        </div>
        <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
    </header>

    <main class="main">
        <!-- Hero Section -->
        <section class="hero-section">
            <h1 class="hero-title">PNKSTR Treasury CryptoPunks</h1>
            <p class="hero-subtitle">Prediction markets on PNKSTR's CryptoPunks holdings</p>
            <div class="treasury-display">
                <div>
                    <div class="treasury-label">Current Balance</div>
                    <div class="treasury-balance"><span id="heroBalance">--</span> Punks</div>
                </div>
                <div style="border-left:1px solid var(--border);padding-left:1rem;">
                    <div class="treasury-label">Treasury</div>
                    <a href="https://etherscan.io/address/0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838" target="_blank" style="color:var(--text-muted);font-size:var(--font-xs);text-decoration:none;display:flex;align-items:center;gap:4px;">
                        0x1244...4838 <span style="opacity:0.5;">‚Üó</span>
                    </a>
                </div>
                <div style="border-left:1px solid var(--border);padding-left:1rem;">
                    <div class="treasury-label">Token</div>
                    <a href="https://etherscan.io/address/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB" target="_blank" style="color:var(--text-muted);font-size:var(--font-xs);text-decoration:none;display:flex;align-items:center;gap:4px;">
                        CryptoPunks <span style="opacity:0.5;">‚Üó</span>
                    </a>
                </div>
            </div>
        </section>

        <!-- Chart Section -->
        <section class="bets-section" style="padding-bottom:0;">
            <h2 class="section-title">Odds <span id="featuredOdds" style="font-weight:400;color:var(--text-muted);font-size:var(--font-sm);">--</span></h2>
            <div class="chart-container">
                <iframe
                    src="https://www.zamm.finance/embed/pool/39414537111466279853124615553549368953361141359364927629160955167830963634860?theme=dark"
                    title="PNK Market Odds"
                    loading="lazy"
                ></iframe>
            </div>
        </section>

        <!-- Active Markets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Markets</h2>
            <div class="stats-summary">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Active</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Ready to Resolve</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="readyCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Resolved</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--text-muted);" id="resolvedCount">0</div>
                </div>
            </div>
            <div class="bets-grid" id="marketsGrid">
                <div class="empty-state">
                    <div class="empty-state-icon">üîç</div>
                    <p>Loading markets...</p>
                </div>
            </div>
        </section>

        <!-- Create Section - Admin market creation -->
        <section class="create-section" id="createSection">
            <h2 class="section-title">Create Market</h2>
            <div class="create-card">
                <div class="create-card-title">PNKSTR Punks Balance Market</div>
                <div class="create-card-desc">Create a market on whether PNKSTR treasury will hold &gt;= target CryptoPunks by a deadline.</div>

                <div class="create-input-group">
                    <label class="create-label">Target Punks (Greater Than or Equal)</label>
                    <input type="number" class="create-input" id="createThreshold" value="40" min="1" step="1">
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadline">
                        <option value="eow">End of This Week (Sunday 23:59:59 UTC)</option>
                        <option value="eoy2025">End of 2025 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroup" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadline" placeholder="1735689599">
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanClose">
                        <option value="true">Yes - Resolve early when condition met</option>
                        <option value="false">No - Wait until deadline</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeed" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreview" style="color:var(--text);">
                        PNKSTR CryptoPunks &gt;= 40 by <span id="previewDeadline">--</span>
                    </div>
                </div>

                <button class="create-btn" onclick="createMarket()">Create Market</button>
            </div>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>PNKSTR Treasury:</strong> These markets track the CryptoPunks balance of the PNKSTR treasury address (0x1244...4838). The balance is read directly from the CryptoPunks contract on-chain.<br><br>
                <strong>Resolution:</strong> If the condition is met (e.g., balance >= 40), YES wins. Otherwise, NO wins. Markets with early close can resolve as soon as the condition passes.<br><br>
                <strong>Trading:</strong> Price = Probability. If YES shows 60%, one share costs ~0.60 ETH and pays 1 ETH if YES wins. Losing shares pay nothing.
            </div>
        </section>

        <!-- Footer -->
        <footer style="text-align:center;padding:2rem 0;margin-top:1rem;border-top:1px solid var(--border);color:var(--text-dim);font-size:var(--font-xs);">
            <div style="display:flex;justify-content:center;align-items:center;gap:1.5rem;">
                <a href="https://cryptopunks.app/" target="_blank" style="color:var(--text-muted);text-decoration:none;">CryptoPunks</a>
                <a href="https://etherscan.io/address/0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838" target="_blank" style="color:var(--text-muted);text-decoration:none;">PNKSTR Treasury</a>
                <a href="https://zamm.finance/" target="_blank" style="display:flex;align-items:center;gap:0.5rem;color:var(--text-muted);text-decoration:none;">
                    <img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:20px;height:20px;border-radius:4px;">
                    Built on zAMM
                </a>
            </div>
        </footer>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal" style="max-width:360px;">
            <div class="modal-header">
                <div class="modal-title">Connect Wallet</div>
                <button class="modal-close" onclick="closeWalletModal()">&times;</button>
            </div>
            <div class="modal-body" id="walletOptions"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal">
        <div class="modal" style="max-width:420px;">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeTradeModal()">&times;</button>
            </div>

            <!-- Market Info -->
            <div id="tradeMarketInfo" style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                        <div style="color:var(--text-dim);margin-bottom:0.25rem;">Market</div>
                        <div id="tradeMarketDesc" style="color:var(--text);">--</div>
                    </div>
                    <div style="text-align:right;">
                        <div style="font-size:var(--font-xs);color:var(--text-dim);">Your Position</div>
                        <div style="font-size:var(--font-xs);">
                            <span style="color:var(--green);">YES: <span id="tradeModalYes">0</span></span>
                            <span style="margin-left:0.5rem;color:var(--red);">NO: <span id="tradeModalNo">0</span></span>
                            <span style="margin-left:0.5rem;color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                        </div>
                        <div style="display:none;font-size:var(--font-xs);margin-top:2px;">
                            <span style="color:var(--amber);">Vault LP: <span id="tradeModalVault">--</span></span>
                        </div>
                        <div style="display:none;font-size:var(--font-xs);margin-top:2px;">
                            <span style="color:var(--text-muted);">Limit Orders: <span id="tradeModalLimitOrders">--</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Orderbook Preview (Coinbase-style best prices) -->
            <div id="orderbookPreview" style="background:var(--surface);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                <div style="text-align:center;font-size:var(--font-xs);color:var(--text-dim);">Loading orderbook...</div>
            </div>

            <!-- My Orders Section (only visible when user has orders) -->
            <div id="myOrdersSection" style="display:none;background:var(--amber-dim);border:1px solid var(--amber);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);font-weight:600;color:var(--amber);">Your Active Orders</span>
                    <span id="myOrdersCount" style="font-size:10px;color:var(--amber);background:rgba(245,158,11,0.2);padding:2px 6px;border-radius:4px;">0</span>
                </div>
                <div id="myOrdersList" style="font-size:11px;max-height:120px;overflow-y:auto;">
                </div>
            </div>

            <!-- Mode Toggle -->
            <div style="display:flex;gap:4px;margin-bottom:1rem;background:var(--surface);padding:4px;border-radius:var(--radius);">
                <button id="tradeModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('trade')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green);color:var(--bg);">Trade</button>
                <button id="swapModeBtn" class="mode-toggle-btn" onclick="setTradeMode('swap')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">Swap</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">LP</button>
            </div>

            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <!-- Buy/Sell Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="buyBtn" class="mode-toggle-btn active-buy" onclick="setTradeDirection('buy')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green-dim);color:var(--green);border:1px solid var(--green);">Buy</button>
                    <button id="sellBtn" class="mode-toggle-btn" onclick="setTradeDirection('sell')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Sell</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;flex-wrap:wrap;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="tradeSlip5" class="slip-btn" onclick="setTradeSlippage(5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">5%</button>
                    <button id="tradeSlip10" class="slip-btn slip-active" onclick="setTradeSlippage(10)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">10%</button>
                    <button id="tradeSlip20" class="slip-btn" onclick="setTradeSlippage(20)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">20%</button>
                    <input type="number" id="tradeSlipCustom" placeholder="%" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);border-radius:4px;" onchange="setTradeSlippage(parseFloat(this.value)||10)">
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="tradeAmountLabel">Amount (ETH)</span>
                        <span style="display:flex;align-items:center;gap:0.5rem;">
                            Balance: <span id="tradeBalance">--</span>
                            <button id="tradeMaxBtn" onclick="setTradeMax()" style="display:none;padding:0.25rem 0.5rem;background:var(--red-dim);border:1px solid var(--red);border-radius:var(--radius);color:var(--red);font-weight:600;font-size:10px;cursor:pointer;">Max</button>
                        </span>
                    </div>
                    <input type="number" class="trade-input" id="tradeAmount" value="0.01" step="0.01" min="0" oninput="handleTradeInput()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. Shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPriceLabel">Avg. Price</span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">If you win</span>
                        <span id="previewPayout" style="color:var(--green);">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="font-size:11px;">--</span>
                    </div>
                </div>
                <button class="trade-submit buy-yes" id="tradeSubmit" onclick="executeTrade()">Buy YES</button>
            </div>

            <!-- Swap Section (YES‚ÜîNO) -->
            <div id="swapSection" style="display:none;">
                <div style="font-size:var(--font-xs);color:var(--text-dim);margin-bottom:0.75rem;">
                    Swap shares directly via the pool. No ETH needed - trade one outcome for the other.
                </div>

                <!-- Swap Direction Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="yesToNoBtn" class="mode-toggle-btn active-buy" onclick="setSwapDirection(true)" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green-dim);color:var(--green);border:1px solid var(--green);">YES ‚Üí NO</button>
                    <button id="noToYesBtn" class="mode-toggle-btn" onclick="setSwapDirection(false)" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">NO ‚Üí YES</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="swapSlip05" class="slip-btn slip-active" onclick="setSwapSlippage(0.5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">0.5%</button>
                    <button id="swapSlip1" class="slip-btn" onclick="setSwapSlippage(1)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">1%</button>
                    <button id="swapSlip2" class="slip-btn" onclick="setSwapSlippage(2)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">2%</button>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="swapInputLabel">YES Amount</span>
                        <span>Balance: <span id="swapBalance">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="swapAmount" placeholder="0.1" step="0.01" min="0" oninput="swapMaxRaw=null;updateSwapPreview()" style="flex:1;">
                        <button onclick="setSwapMax()" style="padding:0.5rem 1rem;background:var(--pink-dim);border:1px solid var(--pink);border-radius:var(--radius);color:var(--pink);font-weight:600;font-size:var(--font-xs);cursor:pointer;">Max</button>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="swapOutput">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Swap Fee (0.3%)</span>
                        <span id="swapFee">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Min Output</span>
                        <span id="swapMinOutput">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="swapSubmit" onclick="executeSwap()" style="background:var(--pink);">Swap YES ‚Üí NO</button>
            </div>

            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div style="font-size:var(--font-xs);color:var(--text-dim);margin-bottom:0.75rem;">
                    Add or remove liquidity from the prediction market pool.
                </div>

                <!-- Add/Remove Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="lpAddBtn" class="mode-toggle-btn active-add" onclick="setLpMode('add')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--blue);color:white;">Add</button>
                    <button id="lpRemoveBtn" class="mode-toggle-btn" onclick="setLpMode('remove')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Remove</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;flex-wrap:wrap;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="lpSlip5" class="slip-btn" onclick="setLpSlippage(5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">5%</button>
                    <button id="lpSlip10" class="slip-btn slip-active" onclick="setLpSlippage(10)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">10%</button>
                    <button id="lpSlip20" class="slip-btn" onclick="setLpSlippage(20)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">20%</button>
                    <input type="number" id="lpSlipCustom" placeholder="%" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);border-radius:4px;" onchange="setLpSlippage(parseFloat(this.value)||10)">
                </div>

                <div style="background:var(--surface);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                    <div style="display:flex;justify-content:space-between;font-size:var(--font-xs);">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span style="color:var(--blue);font-weight:600;" id="lpPosition">0 LP</span>
                    </div>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="lpAmountLabel">ETH to Add</span>
                        <span style="display:flex;align-items:center;gap:0.5rem;">
                            Balance: <span id="lpBalance">--</span>
                            <button id="lpMaxBtn" onclick="setLpMax()" style="padding:0.25rem 0.5rem;background:var(--blue-dim);border:1px solid var(--blue);border-radius:var(--radius);color:var(--blue);font-weight:600;font-size:10px;cursor:pointer;">Max</button>
                        </span>
                    </div>
                    <input type="number" class="trade-input" id="lpAmount" placeholder="0.1" step="0.01" min="0" oninput="lpMaxRaw=null;updateLpPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">Est. LP Tokens</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Your Pool Share</span>
                        <span><span id="lpPoolShare">--%</span> <span id="lpShareChange" style="font-size:10px;"></span></span>
                    </div>
                </div>
                <button class="trade-submit" id="lpSubmit" onclick="executeLp()" style="background:var(--blue);">Deposit Liquidity</button>
            </div>

            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <!-- Side indicator -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                    <span id="limitSideIndicator" style="padding:0.25rem 0.75rem;border-radius:4px;font-size:var(--font-xs);font-weight:700;background:var(--green-dim);color:var(--green);">YES</span>
                    <span style="font-size:var(--font-xs);color:var(--text-dim);" id="limitExplainerText">Bid below pool price to get better odds. ETH escrowed until filled.</span>
                </div>

                <!-- Buy/Sell Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="limitBuyBtn" class="mode-toggle-btn active-add" onclick="setLimitSide('buy')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:#8b5cf6;color:white;">Buy Order</button>
                    <button id="limitSellBtn" class="mode-toggle-btn" onclick="setLimitSide('sell')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Sell Order</button>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span>Your Odds</span>
                        <span id="limitOddsDisplay" style="font-weight:600;color:var(--text);">--</span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="limitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99" oninput="updateLimitPreview()" style="flex:1;">
                        <button onclick="adjustLimitPrice(-0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--red);font-weight:600;cursor:pointer;font-size:var(--font-sm);">-1%</button>
                        <button onclick="adjustLimitPrice(0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-sm);">+1%</button>
                    </div>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="limitAmountLabel">Spend (ETH)</span>
                        <span>Balance: <span id="limitBalance">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="limitAmount" value="0.01" step="0.01" min="0" oninput="limitMaxRaw=null;updateLimitPreview()" style="flex:1;">
                        <button onclick="setLimitMax()" style="padding:0.5rem 1rem;background:var(--surface-2);border:1px solid #8b5cf6;border-radius:var(--radius);color:#8b5cf6;font-weight:600;font-size:var(--font-xs);cursor:pointer;">Max</button>
                    </div>
                </div>

                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitResultLabel">You receive</span>
                        <span id="limitResult">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="limitPoolPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="limitSavingsLabel">vs Pool</span>
                        <span id="limitSavings" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" onclick="executeLimitOrder()" style="background:#8b5cf6;">Place Buy Order</button>

                <!-- Compact Orderbook for Limit Tab -->
                <div style="margin-top:1rem;border-top:1px solid var(--border);padding-top:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <span style="font-size:var(--font-xs);font-weight:600;color:var(--text-muted);">Open Orders</span>
                        <button onclick="openOrderbookModal()" style="font-size:10px;color:var(--pink);background:none;border:none;cursor:pointer;text-decoration:underline;">Full Depth ‚Üí</button>
                    </div>
                    <div id="limitBookPreview" style="font-size:11px;max-height:120px;overflow-y:auto;">
                        <div style="color:var(--text-dim);text-align:center;padding:0.5rem;">No orders</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Orderbook Modal - Probability Ladder Design -->
    <div class="modal-overlay" id="orderbookModal">
        <div class="modal" style="max-width:580px;">
            <div class="modal-header">
                <div class="modal-title">Market Depth</div>
                <button class="modal-close" onclick="closeOrderbookModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding:0.75rem;">
                <!-- Header with AMM prices -->
                <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;margin-bottom:0.25rem;padding-bottom:0.25rem;border-bottom:2px solid var(--border);">
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--green);font-size:13px;">YES</div>
                        <div id="yesAmmRef" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                    <div style="text-align:center;font-size:9px;color:var(--text-dim);display:flex;align-items:center;justify-content:center;">Odds</div>
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--red);font-size:13px;">NO</div>
                        <div id="noAmmRef" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                </div>
                <!-- Probability Ladder -->
                <div id="depthLadder" style="background:var(--surface);border-radius:var(--radius);padding:0.5rem;max-height:400px;overflow-y:auto;">
                    <div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading...</div>
                </div>
                <!-- Actions -->
                <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
                    <button onclick="closeOrderbookModal(); openTrade(currentTrade.marketId.toString(), true)" style="flex:1;padding:0.5rem;background:var(--green);color:var(--bg);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade YES</button>
                    <button onclick="closeOrderbookModal(); openTrade(currentTrade.marketId.toString(), false)" style="flex:1;padding:0.5rem;background:var(--red);color:white;border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade NO</button>
                </div>
                <!-- Legend -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);font-size:9px;color:var(--text-dim);">
                    <span><span style="color:var(--green);">‚ñ†</span> Bids (buy)</span>
                    <span>Depth in ETH | Click to fill</span>
                    <span><span style="color:var(--red);">‚ñ†</span> Asks (sell)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const CRYPTOPUNKS_ADDRESS = '0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB';
        const PNKSTR_TREASURY = '0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838';
        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';

        // New routing system (PMHookRouter + MasterRouter)
        const PMHOOKROUTER_ADDRESS = '0x0000000000BADa259Cb860c12ccD9500d9496B3e';
        const PMHOOKQUOTER_ADDRESS = '0x0000000000f0bf4ea3a43560324376e62fe390bc';
        const MASTERROUTER_ADDRESS = '0x000000000055CdB14b66f37B96a571108FFEeA5C';

        // Legacy router removed - using MasterRouter + PMHookRouter

        const FEE_TIER = 30n; // 0.30%
        const EOY_2025 = 1767225599; // Dec 31, 2025 23:59:59 UTC

        // balanceOf(address) selector
        const BALANCE_OF_SELECTOR = '0x70a08231';
        // Expected callData for PNKSTR treasury balance check
        const PNKSTR_BALANCE_CALLDATA = BALANCE_OF_SELECTOR + '000000000000000000000000' + PNKSTR_TREASURY.slice(2).toLowerCase();

        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc, 1, { staticNetwork: true });
                    await Promise.race([
                        p.getBlockNumber(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000))
                    ]);
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const CRYPTOPUNKS_ABI = [
            'function balanceOf(address owner) view returns (uint256)'
        ];

        const RESOLVER_ABI = [
            'function conditions(uint256 marketId) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)',
            'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
            'function resolveMarket(uint256 marketId)',
            'function createNumericMarketAndSeed(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose, tuple(uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) seed) payable returns (uint256 marketId, uint256 noId, uint256 shares, uint256 liquidity)',
            'event ConditionCreated(uint256 indexed marketId, address indexed targetA, uint8 op, uint256 threshold, uint64 close, bool canClose, bool isRatio, string description)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function balanceOf(address owner, uint256 id) view returns (uint256)',
            'function getNoId(uint256 marketId) pure returns (uint256)',
            'function isOperator(address owner, address operator) view returns (bool)',
            'function setOperator(address operator, bool approved) returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
            'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
            'function multicall(bytes[] data) returns (bytes[])'
        ];

        // Legacy PMROUTER_ABI removed - using MasterRouter + PMHookRouter instead

        const ZAMM_ABI = [
            'function isOperator(address owner, address operator) view returns (bool)',
            'function setOperator(address operator, bool approved) returns (bool)',
            'function balanceOf(address owner, uint256 id) view returns (uint256)',
            'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)',
            'function pools(uint256 poolId) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // PMHookRouter - Vault-based routing with bootstrap liquidity
        const PMHOOKROUTER_ABI = [
            'function buyWithBootstrap(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 sharesOut, bytes4 source, uint256 vaultSharesMinted)',
            'function sellWithBootstrap(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, address to) returns (uint256 collateralOut, bytes4 source)',
            'function claim(uint256 marketId, address to) returns (uint256 payout)',
            'function vaultPositions(uint256 marketId, address user) view returns (uint112 yesVaultShares, uint112 noVaultShares, uint32 lastActivity, uint256 yesCollateralDebt, uint256 noCollateralDebt)',
            'function bootstrapVaults(uint256 marketId) view returns (uint112 yesShares, uint112 noShares, uint32 lastActivity)',
            'function totalYesVaultShares(uint256 marketId) view returns (uint256)',
            'function totalNoVaultShares(uint256 marketId) view returns (uint256)',
            'function canonicalPoolId(uint256 marketId) view returns (uint256)',
            'function canonicalFeeOrHook(uint256 marketId) view returns (uint256)',
            'function depositToVault(uint256 marketId, bool isYes, uint256 shares, address receiver, uint256 deadline) returns (uint256 vaultShares)',
            'function withdrawFromVault(uint256 marketId, bool isYes, uint256 vaultShares, address receiver, uint256 deadline) returns (uint256 shares)',
            'function provideLiquidity(uint256 marketId, uint256 collateralAmount, uint256 vaultYesShares, uint256 vaultNoShares, uint256 ammLPShares, uint256 minAmount0, uint256 minAmount1, address receiver, uint256 deadline) payable returns (uint256 yesVaultSharesMinted, uint256 noVaultSharesMinted, uint256 ammLiquidity)'
        ];

        // PMHookQuoter - View functions for quotes and position data
        const PMHOOKQUOTER_ABI = [
            'function getTWAPPrice(uint256 marketId) view returns (uint256 twapBps)',
            'function getMarketSummary(uint256 marketId) view returns (uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammPriceYesBps, uint256 feeBps, uint112 vaultYesShares, uint112 vaultNoShares, uint256 totalYesVaultLP, uint256 totalNoVaultLP, uint256 vaultBudget, uint256 twapPriceYesBps, uint64 closeTime, bool resolved, bool inCloseWindow)',
            'function getUserFullPosition(uint256 marketId, address user) view returns (uint256 yesShareBalance, uint256 noShareBalance, uint112 yesVaultLP, uint112 noVaultLP, uint256 pendingYesCollateral, uint256 pendingNoCollateral, uint256 ammLPBalance)',
            'function getLiquidityBreakdown(uint256 marketId, bool buyYes) view returns (uint256 vaultOtcShares, uint256 vaultOtcPriceBps, bool vaultOtcAvailable, uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammSpotPriceBps, uint256 ammMaxImpactBps, uint256 poolAskDepth, uint256 poolBestAskBps, uint256 poolBidDepth, uint256 poolBestBidBps)',
            'function getActiveLevels(uint256 marketId, bool isYes, uint256 maxLevels) view returns (uint256[] askPrices, uint256[] askDepths, uint256[] bidPrices, uint256[] bidDepths)',
            'function getUserActivePositions(uint256 marketId, bool isYes, address user) view returns (uint256[] askPrices, uint256[] askShares, uint256[] askPendingColl, uint256[] bidPrices, uint256[] bidCollateral, uint256[] bidPendingShares)',
            'function getUserAllLimitOrders(uint256 marketId, address user) view returns (uint256[] yesAskPrices, uint256[] yesAskShares, uint256[] yesAskPending, uint256[] yesBidPrices, uint256[] yesBidCollateral, uint256[] yesBidPending, uint256[] noAskPrices, uint256[] noAskShares, uint256[] noAskPending, uint256[] noBidPrices, uint256[] noBidCollateral, uint256[] noBidPending)',
            'function quoteBootstrapBuy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut) view returns (uint256 totalSharesOut, bool usesVault, bytes4 source, uint256 vaultSharesMinted)',
            'function quoteSellWithBootstrap(uint256 marketId, bool sellYes, uint256 sharesIn) view returns (uint256 collateralOut, bytes4 source)',
            'function quoteBuyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, uint256 pmSharesOut, bytes4 pmSource)',
            'function quoteSellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, uint256 pmCollateralOut, bytes4 pmSource)'
        ];

        // MasterRouter - Pooled orderbook + vault integration
        const MASTERROUTER_ABI = [
            'function buy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 poolPriceInBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, bytes4[] sources)',
            'function buyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, bytes4[] sources)',
            'function sell(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 bidPoolPriceInBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, bytes4[] sources)',
            'function sellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, bytes4[] sources)',
            'function mintAndPool(uint256 marketId, uint256 collateralIn, bool keepYes, uint256 priceInBps, address to) payable returns (bytes32 poolId)',
            'function depositSharesToPool(uint256 marketId, bool isYes, uint256 sharesIn, uint256 priceInBps, address to) returns (bytes32 poolId)',
            'function withdrawFromPool(uint256 marketId, bool isYes, uint256 priceInBps) returns (uint256 sharesOut, uint256 pendingCollateral)',
            'function withdrawFromBidPool(uint256 marketId, bool isYes, uint256 priceInBps) returns (uint256 collateralOut, uint256 pendingShares)',
            'function getBestAsk(uint256 marketId, bool isYes) view returns (uint256 price, uint256 depth)',
            'function getBestBid(uint256 marketId, bool isYes) view returns (uint256 price, uint256 depth)'
        ];

        // Compute pool ID from pool key (keccak256 of encoded key)
        function computePoolId(id0, id1, token0, token1, feeOrHook) {
            const abiCoder = ethers.AbiCoder.defaultAbiCoder();
            const encoded = abiCoder.encode(
                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                [id0, id1, token0, token1, feeOrHook]
            );
            return ethers.keccak256(encoded);
        }

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let connectedWalletProvider = null;
        let walletConnectProvider = null;
        let isConnecting = false;
        let walletEventHandlers = null;
        const eip6963Providers = new Map();

        let pnkstrMarkets = []; // Markets related to PNKSTR
        let currentTrade = { marketId: null, isYes: true, yesId: null, noId: null, rYes: 0n, rNo: 0n };
        let pendingToasts = new Map(); // Track pending toasts by ID
        let toastIdCounter = 0;

        // Trade mode state
        let currentTradeMode = 'trade'; // 'trade', 'swap', 'limit', 'lp'
        let currentTradeDirection = 'buy'; // 'buy' or 'sell'
        let currentLpMode = 'add'; // 'add' or 'remove'
        let currentSwapDirection = true; // true = YES‚ÜíNO, false = NO‚ÜíYES
        let limitIsBuy = true;
        let slippageTolerance = 10; // 10% default for small pools
        let swapSlippage = 0.5; // 0.5%

        // User position state
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n, lpTotalSupply: null, vaultYes: 0n, vaultNo: 0n, limitOrders: null };

        // Orderbook state - stores both YES and NO orderbooks
        let currentOrderbook = {
            yes: { bids: [], asks: [], ammPrice: null },
            no: { bids: [], asks: [], ammPrice: null }
        };

        // ======================== INIT ========================
        async function init() {
            initEIP6963();

            // Auto-reconnect wallet if previously connected
            const savedWallet = localStorage.getItem('pnkpm_wallet');
            if (savedWallet) {
                // Small delay to let EIP-6963 providers announce themselves
                setTimeout(async () => {
                    try {
                        await connectWithWallet(savedWallet);
                    } catch (e) {
                        console.warn('Auto-reconnect failed:', e);
                        localStorage.removeItem('pnkpm_wallet');
                    }
                }, 100);
            }

            await loadData();
            startSmartPolling();

            // Setup create form listeners
            document.getElementById('createDeadline').addEventListener('change', updateCreatePreview);
            document.getElementById('createThreshold').addEventListener('input', updateCreatePreview);
            document.getElementById('createCanClose').addEventListener('change', updateCreatePreview);
        }

        // ======================== DATA LOADING ========================
        // Always use public RPC for reading (more reliable than wallet provider)
        let readProvider = null;
        async function getReadProvider() {
            if (readProvider) return readProvider;
            readProvider = await getRpcProvider();
            return readProvider;
        }

        let loadDataRetries = 0;
        async function loadData() {
            try {
                const rpc = await getReadProvider();

                // Load PNKSTR balance
                const punks = new ethers.Contract(CRYPTOPUNKS_ADDRESS, CRYPTOPUNKS_ABI, rpc);
                const balance = await punks.balanceOf(PNKSTR_TREASURY);
                const balanceNum = Number(balance);

                document.getElementById('livePunks').textContent = balanceNum;
                document.getElementById('heroBalance').textContent = balanceNum;

                // Find PNKSTR-related markets by scanning ConditionCreated events
                await loadPnkstrMarkets(rpc);
                loadDataRetries = 0; // Reset on success

            } catch (error) {
                console.error('Failed to load data:', error);
                // Reset read provider on error to try a different RPC next time
                readProvider = null;
                // Show user-visible error for RPC failures with retry limit
                if (error.message?.includes('RPC') || error.message?.includes('network') || error.message?.includes('timeout')) {
                    if (loadDataRetries < 3) {
                        loadDataRetries++;
                        showToast('Network Error', `Retrying... (${loadDataRetries}/3)`, 'error', 3000);
                        setTimeout(loadData, 5000 * loadDataRetries); // Exponential backoff
                    } else {
                        showToast('Network Error', 'Connection failed. Please refresh.', 'error', 8000);
                    }
                }
            }
        }

        // Smart polling - pauses when tab is hidden, refreshes on return
        let pollInterval = null;
        function startSmartPolling() {
            const ACTIVE_INTERVAL = 60000;   // 60s when active
            const HIDDEN_INTERVAL = 300000;  // 5 min when hidden

            function poll() {
                clearInterval(pollInterval);
                const interval = document.hidden ? HIDDEN_INTERVAL : ACTIVE_INTERVAL;
                pollInterval = setInterval(loadData, interval);
            }

            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    loadDataRetries = 0; // Reset retry counter
                    loadData(); // Refresh immediately when tab becomes visible
                }
                poll(); // Adjust polling interval
            });

            poll(); // Start polling
        }

        // Dynamically discovered PNKSTR market IDs (cached)
        let discoveredPnkstrMarkets = [];
        let lastMarketDiscoveryBlock = 0;
        const MARKET_DISCOVERY_START_BLOCK = 21000000; // Start scanning from this block

        async function loadPnkstrMarkets(rpc) {
            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const punks = new ethers.Contract(CRYPTOPUNKS_ADDRESS, CRYPTOPUNKS_ABI, rpc);
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const resolverInterface = new ethers.Interface(RESOLVER_ABI);

                // Discover PNKSTR markets via ConditionCreated events
                const currentBlock = await rpc.getBlockNumber();
                if (discoveredPnkstrMarkets.length === 0 || currentBlock > lastMarketDiscoveryBlock + 1000) {
                    const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, rpc);
                    const filter = resolver.filters.ConditionCreated();
                    // Scan from start block or last discovery + some buffer
                    const fromBlock = lastMarketDiscoveryBlock > 0 ? lastMarketDiscoveryBlock : MARKET_DISCOVERY_START_BLOCK;
                    const events = await resolver.queryFilter(filter, fromBlock, currentBlock);

                    // Filter for PNKSTR-related markets (targetA == CRYPTOPUNKS)
                    const pnkstrMarketIds = events
                        .filter(e => e.args.targetA.toLowerCase() === CRYPTOPUNKS_ADDRESS.toLowerCase())
                        .map(e => e.args.marketId);

                    if (pnkstrMarketIds.length > 0) {
                        discoveredPnkstrMarkets = pnkstrMarketIds;
                    }
                    lastMarketDiscoveryBlock = currentBlock;
                }

                const marketIds = discoveredPnkstrMarkets;

                if (marketIds.length === 0) {
                    // No markets found - show empty state
                    pnkstrMarkets = [];
                    document.getElementById('marketCount').textContent = '0';
                    document.getElementById('activeCount').textContent = '0';
                    document.getElementById('readyCount').textContent = '0';
                    document.getElementById('resolvedCount').textContent = '0';
                    document.getElementById('totalTvl').textContent = '0 ETH';
                    renderMarkets([]);
                    return;
                }

                // Batch fetch market data via multicall: getMarket + conditions for each
                const marketCalls = marketIds.flatMap(id => [
                    { target: PAMM_ADDRESS, allowFailure: true, callData: pammInterface.encodeFunctionData('getMarket', [id]) },
                    { target: RESOLVER_ADDRESS, allowFailure: true, callData: resolverInterface.encodeFunctionData('conditions', [id]) }
                ]);

                const marketRaw = await multicall.aggregate3(marketCalls);

                // Parse market data
                let allMarketsData = [];
                for (let i = 0; i < marketIds.length; i++) {
                    const marketResult = marketRaw[i * 2];
                    const conditionResult = marketRaw[i * 2 + 1];

                    if (!marketResult.success || !conditionResult.success) continue;

                    try {
                        const market = pammInterface.decodeFunctionResult('getMarket', marketResult.returnData);
                        const condition = resolverInterface.decodeFunctionResult('conditions', conditionResult.returnData);

                        allMarketsData.push({
                            marketId: marketIds[i],
                            resolved: market.resolved,
                            outcome: market.outcome,
                            canClose: market.canClose,
                            close: Number(market.close),
                            collateralLocked: market.collateralLocked,
                            description: market.description,
                            condition
                        });
                    } catch { continue; }
                }

                // Batch fetch pool states, noIds, previews, and punk balance via multicall
                const punksInterface = new ethers.Interface(CRYPTOPUNKS_ABI);

                const dataCalls = [];
                // Pool state calls for each market
                for (const m of allMarketsData) {
                    dataCalls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('getPoolState', [m.marketId, FEE_TIER])
                    });
                }
                // NoId calls for each candidate (for ZAMM pool link)
                for (const m of allMarketsData) {
                    dataCalls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('getNoId', [m.marketId])
                    });
                }
                // Preview calls for unresolved markets
                for (const m of allMarketsData) {
                    if (!m.resolved) {
                        dataCalls.push({
                            target: RESOLVER_ADDRESS,
                            allowFailure: true,
                            callData: resolverInterface.encodeFunctionData('preview', [m.marketId])
                        });
                    }
                }
                // Punk balance call
                dataCalls.push({
                    target: CRYPTOPUNKS_ADDRESS,
                    allowFailure: true,
                    callData: punksInterface.encodeFunctionData('balanceOf', [PNKSTR_TREASURY])
                });

                const dataRaw = dataCalls.length > 0 ? await multicall.aggregate3(dataCalls) : [];

                // Parse results
                const poolResults = [];
                const noIdResults = [];
                const previewResults = [];
                let idx = 0;

                // Pool states
                for (const m of allMarketsData) {
                    const r = dataRaw[idx++];
                    if (r.success) {
                        try {
                            poolResults.push(pammInterface.decodeFunctionResult('getPoolState', r.returnData));
                        } catch { poolResults.push(null); }
                    } else {
                        poolResults.push(null);
                    }
                }
                // NoIds
                for (const m of allMarketsData) {
                    const r = dataRaw[idx++];
                    if (r.success) {
                        try {
                            noIdResults.push(pammInterface.decodeFunctionResult('getNoId', r.returnData)[0]);
                        } catch { noIdResults.push(null); }
                    } else {
                        noIdResults.push(null);
                    }
                }
                // Previews
                for (const m of allMarketsData) {
                    if (!m.resolved) {
                        const r = dataRaw[idx++];
                        if (r.success) {
                            try {
                                previewResults.push(resolverInterface.decodeFunctionResult('preview', r.returnData));
                            } catch { previewResults.push(null); }
                        } else {
                            previewResults.push(null);
                        }
                    } else {
                        previewResults.push(null);
                    }
                }
                // Punk balance
                const balanceR = dataRaw[idx];
                const currentBalance = balanceR?.success
                    ? punksInterface.decodeFunctionResult('balanceOf', balanceR.returnData)[0]
                    : 0n;

                // Build final market list
                const markets = [];
                let totalTvl = 0n;

                for (let i = 0; i < allMarketsData.length; i++) {
                    const m = allMarketsData[i];
                    const poolState = poolResults[i];
                    const preview = previewResults[i];
                    const noId = noIdResults[i];

                    let yesOdds = 50;
                    let rYes = 0n, rNo = 0n;
                    if (poolState) {
                        rYes = poolState.rYes;
                        rNo = poolState.rNo;
                        if (rYes + rNo > 0n) {
                            yesOdds = Number(rNo * 100n / (rYes + rNo));
                        }
                    }

                    const tvl = m.collateralLocked;
                    totalTvl += tvl;

                    // Compute poolId for ZAMM link
                    const yesId = m.marketId;
                    const id0 = yesId < noId ? yesId : noId;
                    const id1 = yesId < noId ? noId : yesId;
                    const poolId = noId ? computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER) : null;

                    markets.push({
                        id: m.marketId,
                        noId: noId,
                        poolId: poolId,
                        rYes: rYes,
                        rNo: rNo,
                        description: m.description,
                        resolved: m.resolved,
                        outcome: m.outcome,
                        canClose: m.canClose,
                        close: m.close,
                        collateralLocked: m.collateralLocked,
                        threshold: m.condition.threshold || 0n,
                        op: Number(m.condition.op) || 1,
                        currentValue: preview?.value ?? currentBalance,
                        conditionMet: preview?.condTrue ?? false,
                        ready: preview?.ready ?? false,
                        yesOdds,
                        tvl
                    });
                }

                // Sort by close time (newest first)
                markets.sort((a, b) => b.close - a.close);
                pnkstrMarkets = markets;

                // Update UI
                const active = markets.filter(m => !m.resolved);
                const ready = markets.filter(m => !m.resolved && m.ready);
                const resolved = markets.filter(m => m.resolved);

                document.getElementById('marketCount').textContent = markets.length;
                document.getElementById('activeCount').textContent = active.length;
                document.getElementById('readyCount').textContent = ready.length;
                document.getElementById('resolvedCount').textContent = resolved.length;
                document.getElementById('totalTvl').textContent = formatEth(totalTvl) + ' ETH';

                // Update featured odds (first active market, or first market if all resolved)
                const featuredMarket = active[0] || markets[0];
                if (featuredMarket) {
                    const yesOdds = featuredMarket.yesOdds;
                    const noOdds = 100 - yesOdds;
                    document.getElementById('featuredOdds').textContent = `YES ${yesOdds}% / NO ${noOdds}%`;
                }

                renderMarkets(markets);

            } catch (error) {
                console.error('Failed to load PNKSTR markets:', error);
                document.getElementById('marketsGrid').innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö†Ô∏è</div>
                        <p>Failed to load markets. Please refresh.</p>
                    </div>
                `;
            }
        }

        function renderMarkets(markets) {
            const grid = document.getElementById('marketsGrid');

            if (markets.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì≠</div>
                        <p>No PNKSTR markets found. Create one below!</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = markets.map(m => renderMarketCard(m)).join('');

            // Load orderbook for first active market to populate inline view
            const activeMarket = markets.find(m => !m.resolved);
            if (activeMarket) {
                loadInlineOrderbook(activeMarket);
            }
        }

        async function loadInlineOrderbook(market) {
            // Set minimal currentTrade data needed for orderbook loading
            currentTrade.marketId = market.id;
            currentTrade.yesId = market.id;
            currentTrade.noId = market.noId;
            currentTrade.rYes = market.rYes || 0n;
            currentTrade.rNo = market.rNo || 0n;
            currentTrade.isYes = true;

            await loadOrderbook();
        }

        function renderMarketCard(market) {
            const now = Math.floor(Date.now() / 1000);
            const timeLeft = market.close - now;

            let status, statusClass;
            if (market.resolved) {
                status = market.outcome ? 'YES Won' : 'NO Won';
                statusClass = 'resolved';
            } else if (market.ready) {
                status = 'Ready to Resolve';
                statusClass = 'ready';
            } else {
                status = 'Active';
                statusClass = 'active';
            }

            const opSymbol = ['<', '>', '<=', '>=', '==', '!='][market.op] || '?';
            const noOdds = 100 - market.yesOdds;

            return `
                <div class="market-row">
                <div class="bet-card ${market.resolved ? 'resolved' : ''}">
                    <div class="bet-header">
                        <span class="bet-type">PNKSTR</span>
                        <span class="bet-status ${statusClass}">${status}</span>
                    </div>
                    <div class="bet-title">Punks ${opSymbol} ${market.threshold.toString()}</div>
                    <div class="bet-question">Will PNKSTR hold ${opSymbol} ${market.threshold} punks by ${formatDate(market.close)}?</div>
                    <details class="onchain-details">
                        <summary>on-chain ‚Üì</summary>
                        <div class="onchain-desc">${escapeHtml(market.description)}</div>
                    </details>

                    <div class="condition-display">
                        <div class="condition-point">
                            <div class="condition-label">Current</div>
                            <a href="https://etherscan.io/token/0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB?a=0x1244EAe9FA2c064453B5F605d708C0a0Bfba4838" target="_blank" style="text-decoration:none;">
                                <div class="condition-value" style="color:var(--pink);">${market.currentValue.toString()} <span style="opacity:0.4;font-size:0.6em;">‚Üó</span></div>
                            </a>
                        </div>
                        <div class="condition-op">${opSymbol}</div>
                        <div class="condition-point">
                            <div class="condition-label">Target</div>
                            <div class="condition-value">${market.threshold.toString()}</div>
                        </div>
                    </div>

                    ${!market.resolved ? `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0.75rem;margin-bottom:0.75rem;background:${market.yesOdds > 50 ? 'var(--green-dim)' : market.yesOdds < 50 ? 'var(--red-dim)' : 'var(--surface-2)'};border-radius:var(--radius);font-size:var(--font-xs);">
                            <div>
                                <span style="color:${market.yesOdds > 50 ? 'var(--green)' : market.yesOdds < 50 ? 'var(--red)' : 'var(--text-muted)'};">
                                    ${market.yesOdds > 50 ? '‚ñ≤ Market favors YES' : market.yesOdds < 50 ? '‚ñº Market favors NO' : '‚óÜ Market is neutral'}
                                </span>
                                <span style="color:var(--text-dim);margin-left:0.5rem;">(${Math.abs(market.yesOdds - 50)}% edge)</span>
                            </div>
                            <button onclick="viewMarketDepth('${market.id}')" style="background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:2px 8px;font-size:10px;color:var(--text-muted);cursor:pointer;">Depth</button>
                        </div>
                        <div class="bet-buttons">
                            <button class="bet-btn yes" onclick="openTrade('${market.id}', true)">
                                <div class="bet-btn-label">Buy Yes</div>
                                <div class="bet-btn-odds">${market.yesOdds}%</div>
                                <div class="bet-btn-price">${(market.yesOdds / 100).toFixed(2)} ETH/share</div>
                            </button>
                            <button class="bet-btn no" onclick="openTrade('${market.id}', false)">
                                <div class="bet-btn-label">Buy No</div>
                                <div class="bet-btn-odds">${noOdds}%</div>
                                <div class="bet-btn-price">${(noOdds / 100).toFixed(2)} ETH/share</div>
                            </button>
                        </div>
                    ` : `
                        <div style="padding:1rem;text-align:center;background:var(--surface-2);border-radius:var(--radius);margin-bottom:1rem;">
                            <div style="font-size:var(--font-2xl);font-weight:700;color:${market.outcome ? 'var(--green)' : 'var(--red)'};">
                                ${market.outcome ? 'YES' : 'NO'} Won
                            </div>
                            <button class="resolve-btn" style="margin-top:0.75rem;background:var(--green);color:var(--bg);" onclick="claimWinnings('${market.id}')">
                                Claim Winnings
                            </button>
                        </div>
                    `}

                    <div class="bet-countdown">
                        <span>${market.canClose ? 'May close early' : 'Closes'}</span>
                        <span class="countdown-value">${formatCountdown(timeLeft)}</span>
                    </div>

                    <div class="liquidity-stats">
                        <span>TVL: <span style="color:var(--blue);">${formatEth(market.tvl)} ETH</span></span>
                        <span>ID: ${truncateId(market.id.toString())}</span>
                        ${market.poolId ? `<a href="https://zamm.finance/p/${BigInt(market.poolId).toString()}" target="_blank" title="View on ZAMM" style="display:flex;align-items:center;gap:3px;color:var(--text-muted);text-decoration:none;font-size:10px;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"><img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:12px;height:12px;border-radius:2px;">ZAMM</a>` : ''}
                    </div>

                    ${market.ready && !market.resolved ? `
                        <button class="resolve-btn" onclick="resolveMarket('${market.id}')">Resolve Market</button>
                    ` : ''}
                </div>
                ${!market.resolved ? `
                <div class="inline-orderbook" id="inlineOrderbook-${market.id}">
                    <div class="inline-orderbook-header">
                        <div style="text-align:center;">
                            <div style="font-weight:700;color:var(--green);font-size:13px;">YES</div>
                            <div style="font-size:10px;color:var(--text-dim);" id="inlineYesAmm-${market.id}">--</div>
                        </div>
                        <div style="text-align:center;font-size:9px;color:var(--text-dim);display:flex;align-items:center;justify-content:center;">Odds</div>
                        <div style="text-align:center;">
                            <div style="font-weight:700;color:var(--red);font-size:13px;">NO</div>
                            <div style="font-size:10px;color:var(--text-dim);" id="inlineNoAmm-${market.id}">--</div>
                        </div>
                    </div>
                    <div class="inline-orderbook-ladder" id="inlineLadder-${market.id}">
                        <div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading orderbook...</div>
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);font-size:9px;color:var(--text-dim);">
                        <span><span style="color:var(--green);">‚ñ†</span> Bids</span>
                        <span>Depth in ETH | Click to trade</span>
                        <span><span style="color:var(--red);">‚ñ†</span> Asks</span>
                    </div>
                </div>
                ` : '<div></div>'}
                </div>
            `;
        }

        // ======================== WALLET ========================
        const WALLET_CONFIG = {
            metamask: { name: 'MetaMask', icon: 'ü¶ä', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
            coinbase: { name: 'Coinbase', icon: 'üîµ', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
            rabby: { name: 'Rabby', icon: 'üê∞', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
            rainbow: { name: 'Rainbow', icon: 'üåà', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
            walletconnect: { name: 'WalletConnect', icon: 'üì±' }
        };

        function initEIP6963() {
            if (typeof window === 'undefined') return;
            window.addEventListener('eip6963:announceProvider', (event) => {
                const { info, provider } = event.detail;
                eip6963Providers.set(info.uuid, { info, provider });
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

        function detectWallets() {
            const detected = [];
            const seenNames = new Set();

            for (const [key, config] of Object.entries(WALLET_CONFIG)) {
                if (key === 'walletconnect') continue;
                if (config.detect && config.detect()) {
                    detected.push({ key, ...config });
                    seenNames.add(config.name.toLowerCase());
                }
            }

            for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
                if (!seenNames.has(info.name.toLowerCase())) {
                    const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
                    const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
                    // Escape URL to prevent XSS via attribute injection
                    const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
                    detected.push({
                        key: `eip6963_${uuid}`,
                        name: safeName,
                        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'üîå',
                        getProvider: () => provider
                    });
                    seenNames.add(info.name.toLowerCase());
                }
            }

            if (detected.length === 0 && window.ethereum) {
                detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'üîó', getProvider: () => window.ethereum });
            }

            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            if (wcModule?.EthereumProvider) {
                detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'üì±', isWalletConnect: true });
            }

            return detected;
        }

        function showWalletModal() {
            const wallets = detectWallets();
            const container = document.getElementById('walletOptions');

            if (connectedAddress) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: var(--gray); border-radius: var(--radius); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Connected</div>
                        <div style="font-size: 0.9rem; word-break: break-all; color: var(--pink);">${connectedAddress}</div>
                    </div>
                    <div class="wallet-option disconnect" onclick="disconnectWallet()">
                        <span class="wallet-option-name">Disconnect</span>
                    </div>
                `;
            } else {
                container.innerHTML = wallets.length > 0 ? wallets.map(w => `
                    <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
                        <span class="wallet-option-icon">${w.icon}</span>
                        <span class="wallet-option-name">${w.name}</span>
                    </div>
                `).join('') : '<div style="padding:1rem;text-align:center;color:var(--text-muted);">No wallets detected. Install MetaMask or use WalletConnect.</div>';
            }

            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        async function connectWallet() {
            showWalletModal();
        }

        async function connectWithWallet(walletKey) {
            if (isConnecting) return;
            isConnecting = true;

            const connectBtn = document.getElementById('connectBtn');
            const originalText = connectBtn.textContent;
            connectBtn.textContent = 'Connecting...';
            connectBtn.disabled = true;

            try {
                closeWalletModal();
                let walletProvider;

                if (walletKey === 'walletconnect') {
                    const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
                    const WCProvider = wcModule?.EthereumProvider;
                    if (!WCProvider?.init) throw new Error('WalletConnect not available');

                    if (walletConnectProvider) {
                        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
                        walletConnectProvider = null;
                    }

                    walletConnectProvider = await WCProvider.init({
                        projectId: '1e8390ef1c1d8a185e035912a1409749',
                        chains: [1],
                        showQrModal: true,
                        rpcMap: { 1: 'https://1rpc.io/eth' },
                        metadata: {
                            name: 'pnkPM',
                            description: 'PNKSTR CryptoPunks Prediction Markets',
                            url: window.location.origin,
                            icons: []
                        }
                    });

                    await walletConnectProvider.enable();
                    walletProvider = walletConnectProvider;
                } else if (walletKey.startsWith('eip6963_')) {
                    const uuid = walletKey.replace('eip6963_', '');
                    walletProvider = eip6963Providers.get(uuid)?.provider;
                } else {
                    walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
                }

                if (!walletProvider) throw new Error('Wallet not found');

                if (walletKey !== 'walletconnect') {
                    await walletProvider.request({ method: 'eth_requestAccounts' });
                }

                provider = new ethers.BrowserProvider(walletProvider);

                // Check network is Ethereum mainnet
                let network = await provider.getNetwork();
                if (network.chainId !== 1n) {
                    try {
                        await walletProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x1' }]
                        });
                        // Re-create provider after network switch and verify
                        provider = new ethers.BrowserProvider(walletProvider);
                        network = await provider.getNetwork();
                    } catch (e) {
                        // Switch failed or was rejected
                    }
                    if (network.chainId !== 1n) {
                        throw new Error('Please switch to Ethereum mainnet');
                    }
                }

                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                connectedWalletProvider = walletProvider;

                document.getElementById('connectBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                document.getElementById('connectBtn').classList.add('connected');

                // Remove old listeners if any
                if (walletEventHandlers) {
                    try {
                        walletEventHandlers.provider.removeListener('accountsChanged', walletEventHandlers.onAccountsChanged);
                        walletEventHandlers.provider.removeListener('chainChanged', walletEventHandlers.onChainChanged);
                    } catch (e) {}
                }

                // Store and add new listeners
                walletEventHandlers = {
                    provider: walletProvider,
                    onAccountsChanged: () => window.location.reload(),
                    onChainChanged: () => window.location.reload()
                };
                walletProvider.on('accountsChanged', walletEventHandlers.onAccountsChanged);
                walletProvider.on('chainChanged', walletEventHandlers.onChainChanged);

                localStorage.setItem('pnkpm_wallet', walletKey);

                // Reload data with new provider
                await loadData();

            } catch (error) {
                console.error('Connection failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Connection Failed', error.message || 'Could not connect wallet', 'error');
                }
                connectBtn.textContent = originalText;
                connectBtn.classList.remove('connected');
            } finally {
                connectBtn.disabled = false;
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            // Remove event listeners
            if (walletEventHandlers) {
                try {
                    walletEventHandlers.provider.removeListener('accountsChanged', walletEventHandlers.onAccountsChanged);
                    walletEventHandlers.provider.removeListener('chainChanged', walletEventHandlers.onChainChanged);
                } catch (e) {}
                walletEventHandlers = null;
            }
            if (walletConnectProvider) {
                try { walletConnectProvider.disconnect(); } catch (e) {}
                walletConnectProvider = null;
            }
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletProvider = null;
            document.getElementById('connectBtn').textContent = 'Connect';
            document.getElementById('connectBtn').classList.remove('connected');
            closeWalletModal();
            localStorage.removeItem('pnkpm_wallet');
        }

        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== TRADING ========================
        async function openTrade(marketId, isYes) {
            if (!connectedAddress) {
                showWalletModal();
                return;
            }

            const market = pnkstrMarkets.find(m => m.id.toString() === marketId.toString());
            if (!market) return;

            const isResolved = market.resolved;

            // Batch getNoId + getPoolState via multicall
            const rpc = await getReadProvider();
            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
            const pammInterface = new ethers.Interface(PAMM_ABI);

            const results = await multicall.aggregate3([
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getNoId', [marketId]) },
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [marketId, FEE_TIER]) }
            ]);

            const noId = pammInterface.decodeFunctionResult('getNoId', results[0].returnData)[0];
            const poolState = pammInterface.decodeFunctionResult('getPoolState', results[1].returnData);

            currentTrade = {
                marketId: BigInt(marketId),
                isYes,
                yesId: BigInt(marketId),
                noId: BigInt(noId),
                rYes: poolState.rYes,
                rNo: poolState.rNo,
                resolved: isResolved,
                outcome: market.outcome
            };

            document.getElementById('tradeTitle').textContent = `${isYes ? 'YES' : 'NO'} Shares`;
            const opSymbol = ['<', '>', '<=', '>=', '==', '!='][market.op] || '?';
            document.getElementById('tradeMarketDesc').textContent = `Punks ${opSymbol} ${market.threshold} by ${formatDate(market.close)}`;

            // For resolved markets, allow LP withdrawal and swaps (for position exit)
            if (isResolved) {
                setTradeMode('lp');
                setLpMode('remove');
                // Disable trade and limit modes, but keep swap enabled for position exit
                ['tradeModeBtn', 'limitModeBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.style.opacity = '0.4';
                    btn.style.pointerEvents = 'none';
                });
                // Keep swap enabled
                const swapBtn = document.getElementById('swapModeBtn');
                swapBtn.style.opacity = '1';
                swapBtn.style.pointerEvents = 'auto';
                showToast('Market Resolved', `${market.outcome ? 'YES' : 'NO'} won. Swap to winning side, withdraw LP, or claim.`, 'info');
            } else {
                // Reset mode to trade
                setTradeMode('trade');
                setTradeDirection('buy');
                // Ensure mode buttons are enabled
                ['tradeModeBtn', 'swapModeBtn', 'limitModeBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                });
            }

            // Load user position and orderbook in parallel
            await Promise.all([
                loadUserPosition(),
                loadOrderbook()
            ]);

            // Update balances for all modes
            await loadBalance();

            document.getElementById('tradeModal').classList.add('active');

            // Trigger preview with default amount
            handleTradeInput();
        }

        function closeTradeModal() {
            document.getElementById('tradeModal').classList.remove('active');
        }

        // Open trade modal with limit tab pre-filled (for inline orderbook clicks)
        async function openTradeWithPrice(marketId, isYes, price) {
            await openTrade(marketId, isYes);
            // Switch to limit mode and pre-fill price
            setTradeMode('limit');
            document.getElementById('limitPrice').value = price.toFixed(2);
            updateLimitPreview();
        }

        // View market depth without opening trade modal
        async function viewMarketDepth(marketId) {
            const market = pnkstrMarkets.find(m => m.id.toString() === marketId.toString());
            if (!market) return;

            // Load pool state for AMM prices
            const rpc = await getReadProvider();
            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
            const pammInterface = new ethers.Interface(PAMM_ABI);

            const results = await multicall.aggregate3([
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getNoId', [marketId]) },
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [marketId, FEE_TIER]) }
            ]);

            const noId = pammInterface.decodeFunctionResult('getNoId', results[0].returnData)[0];
            const poolState = pammInterface.decodeFunctionResult('getPoolState', results[1].returnData);

            // Set currentTrade so orderbook loads correctly
            currentTrade = {
                marketId: BigInt(marketId),
                isYes: true,
                yesId: BigInt(marketId),
                noId: BigInt(noId),
                rYes: poolState.rYes,
                rNo: poolState.rNo
            };

            // Load orderbook and show modal
            await loadOrderbook();
            openOrderbookModal();
        }

        // ======================== MODE SWITCHING ========================
        function setTradeMode(mode) {
            currentTradeMode = mode;

            // Update mode buttons
            ['trade', 'swap', 'limit', 'lp'].forEach(m => {
                const btn = document.getElementById(`${m}ModeBtn`);
                if (m === mode) {
                    btn.style.background = m === 'trade' ? 'var(--green)' : m === 'swap' ? 'var(--pink)' : m === 'limit' ? '#8b5cf6' : 'var(--blue)';
                    btn.style.color = m === 'trade' ? 'var(--bg)' : 'white';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                }
            });

            // Show/hide sections
            document.getElementById('tradeSection').style.display = mode === 'trade' ? 'block' : 'none';
            document.getElementById('swapSection').style.display = mode === 'swap' ? 'block' : 'none';
            document.getElementById('lpSection').style.display = mode === 'lp' ? 'block' : 'none';
            document.getElementById('limitSection').style.display = mode === 'limit' ? 'block' : 'none';

            // Initialize limit mode defaults
            if (mode === 'limit') {
                // Update side indicator
                const sideIndicator = document.getElementById('limitSideIndicator');
                const isYes = currentTrade.isYes;
                sideIndicator.textContent = isYes ? 'YES' : 'NO';
                sideIndicator.style.background = isYes ? 'var(--green-dim)' : 'var(--red-dim)';
                sideIndicator.style.color = isYes ? 'var(--green)' : 'var(--red)';

                // Initialize with buy side (also sets button text with YES/NO)
                setLimitSide(limitIsBuy ? 'buy' : 'sell');

                // Refresh the compact orderbook display
                updateLimitBookPreview();
            }

            loadBalance();
        }

        function setTradeDirection(dir) {
            currentTradeDirection = dir;
            tradeMaxRaw = null; // Clear max when switching direction
            const buyBtn = document.getElementById('buyBtn');
            const sellBtn = document.getElementById('sellBtn');
            const maxBtn = document.getElementById('tradeMaxBtn');

            if (dir === 'buy') {
                buyBtn.style.background = 'var(--green-dim)';
                buyBtn.style.color = 'var(--green)';
                buyBtn.style.borderColor = 'var(--green)';
                sellBtn.style.background = 'transparent';
                sellBtn.style.color = 'var(--text-muted)';
                sellBtn.style.borderColor = 'var(--border)';
                document.getElementById('tradeAmountLabel').textContent = 'Amount (ETH)';
                document.getElementById('previewSharesLabel').textContent = 'Est. Shares';
                document.getElementById('previewPriceLabel').textContent = 'Avg. Price';
                document.getElementById('previewPayoutLabel').textContent = 'If you win';
                maxBtn.style.display = 'none';
            } else {
                sellBtn.style.background = 'var(--red-dim)';
                sellBtn.style.color = 'var(--red)';
                sellBtn.style.borderColor = 'var(--red)';
                buyBtn.style.background = 'transparent';
                buyBtn.style.color = 'var(--text-muted)';
                buyBtn.style.borderColor = 'var(--border)';
                document.getElementById('tradeAmountLabel').textContent = 'Shares to Sell';
                document.getElementById('previewSharesLabel').textContent = 'ETH Received';
                document.getElementById('previewPriceLabel').textContent = 'Price/Share';
                document.getElementById('previewPayoutLabel').textContent = 'Min Received';
                maxBtn.style.display = 'inline-block';
            }

            updateTradeButton();
            loadBalance();
            handleTradeInput();
        }

        function setSwapDirection(yesToNo) {
            currentSwapDirection = yesToNo;
            const yesBtn = document.getElementById('yesToNoBtn');
            const noBtn = document.getElementById('noToYesBtn');

            if (yesToNo) {
                yesBtn.style.background = 'var(--green-dim)';
                yesBtn.style.color = 'var(--green)';
                yesBtn.style.borderColor = 'var(--green)';
                noBtn.style.background = 'transparent';
                noBtn.style.color = 'var(--text-muted)';
                noBtn.style.borderColor = 'var(--border)';
                document.getElementById('swapInputLabel').textContent = 'YES Amount';
                document.getElementById('swapSubmit').textContent = 'Swap YES ‚Üí NO';
            } else {
                noBtn.style.background = 'var(--red-dim)';
                noBtn.style.color = 'var(--red)';
                noBtn.style.borderColor = 'var(--red)';
                yesBtn.style.background = 'transparent';
                yesBtn.style.color = 'var(--text-muted)';
                yesBtn.style.borderColor = 'var(--border)';
                document.getElementById('swapInputLabel').textContent = 'NO Amount';
                document.getElementById('swapSubmit').textContent = 'Swap NO ‚Üí YES';
            }

            loadBalance();
            updateSwapPreview();
        }

        function setSwapSlippage(pct) {
            swapSlippage = pct;
            [0.5, 1, 2].forEach(p => {
                const btn = document.getElementById(`swapSlip${p === 0.5 ? '05' : p}`);
                if (p === pct) {
                    btn.style.background = 'var(--pink-dim)';
                    btn.style.color = 'var(--pink)';
                    btn.style.borderColor = 'var(--pink)';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                    btn.style.borderColor = 'var(--border)';
                }
            });
            updateSwapPreview();
        }

        function setTradeSlippage(pct) {
            slippageTolerance = pct;
            // Update both trade and LP buttons since they share slippageTolerance
            [5, 10, 20].forEach(p => {
                ['tradeSlip', 'lpSlip'].forEach(prefix => {
                    const btn = document.getElementById(`${prefix}${p}`);
                    if (!btn) return;
                    if (p === pct) {
                        btn.style.background = 'var(--pink-dim)';
                        btn.style.color = 'var(--pink)';
                        btn.style.borderColor = 'var(--pink)';
                    } else {
                        btn.style.background = 'transparent';
                        btn.style.color = 'var(--text-muted)';
                        btn.style.borderColor = 'var(--border)';
                    }
                });
            });
            // Clear custom inputs if a preset was clicked, or highlight if custom
            const isPreset = [5, 10, 20].includes(pct);
            ['tradeSlipCustom', 'lpSlipCustom'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    if (isPreset) {
                        input.value = '';
                        input.style.borderColor = 'var(--border)';
                    } else {
                        input.value = pct;
                        input.style.borderColor = 'var(--pink)';
                    }
                }
            });
        }

        function setLpSlippage(pct) {
            setTradeSlippage(pct); // LP and trade share slippageTolerance
        }

        let swapMaxRaw = null; // Store raw BigInt for exact max swaps
        let limitMaxRaw = null; // Store raw BigInt for exact max limit orders
        let tradeMaxRaw = null; // Store raw BigInt for exact max sells
        let lpMaxRaw = null; // Store raw BigInt for exact max LP operations

        function setTradeMax() {
            // Only works for sell mode - fills with user's share balance
            if (currentTradeDirection !== 'sell') return;

            const balance = currentTrade.isYes
                ? currentUserPosition.yesBalance
                : currentUserPosition.noBalance;

            if (balance && balance > 0n) {
                tradeMaxRaw = balance;
                document.getElementById('tradeAmount').value = ethers.formatEther(balance);
                updateTradePreview(); // Don't call handleTradeInput which clears tradeMaxRaw
            }
        }

        function setSwapMax() {
            // Get the balance of the source token (YES or NO based on swap direction)
            const sourceBalance = currentSwapDirection
                ? currentUserPosition.yesBalance
                : currentUserPosition.noBalance;

            if (sourceBalance && sourceBalance > 0n) {
                swapMaxRaw = sourceBalance; // Store exact value for execution
                const maxAmount = ethers.formatEther(sourceBalance);
                document.getElementById('swapAmount').value = maxAmount;
                updateSwapPreview();
            }
        }

        async function setLimitMax() {
            try {
                if (limitIsBuy) {
                    // For buys, max is ETH balance
                    if (!connectedAddress) return;
                    const rpc = await getReadProvider();
                    const bal = await rpc.getBalance(connectedAddress);
                    if (bal > 0n) {
                        // Leave a little for gas (0.001 ETH)
                        const maxBal = bal > ethers.parseEther('0.001') ? bal - ethers.parseEther('0.001') : bal;
                        limitMaxRaw = maxBal;
                        document.getElementById('limitAmount').value = ethers.formatEther(maxBal);
                        updateLimitPreview();
                    }
                } else {
                    // For sells, max is share balance (YES or NO based on currentTrade.isYes)
                    const balance = currentTrade.isYes
                        ? currentUserPosition.yesBalance
                        : currentUserPosition.noBalance;
                    if (balance && balance > 0n) {
                        limitMaxRaw = balance;
                        document.getElementById('limitAmount').value = ethers.formatEther(balance);
                        updateLimitPreview();
                    }
                }
            } catch (e) {
                // Silently fail - max button just won't work
            }
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            lpMaxRaw = null; // Clear max when switching mode
            const addBtn = document.getElementById('lpAddBtn');
            const removeBtn = document.getElementById('lpRemoveBtn');

            if (mode === 'add') {
                addBtn.style.background = 'var(--blue)';
                addBtn.style.color = 'white';
                removeBtn.style.background = 'transparent';
                removeBtn.style.color = 'var(--text-muted)';
                document.getElementById('lpAmountLabel').textContent = 'ETH to Add';
                document.getElementById('lpPreviewLabel').textContent = 'Est. LP Tokens';
                document.getElementById('lpSubmit').textContent = 'Deposit Liquidity';
            } else {
                removeBtn.style.background = 'var(--blue)';
                removeBtn.style.color = 'white';
                addBtn.style.background = 'transparent';
                addBtn.style.color = 'var(--text-muted)';
                document.getElementById('lpAmountLabel').textContent = 'LP to Remove';
                document.getElementById('lpPreviewLabel').textContent = 'Est. ETH Out';
                document.getElementById('lpSubmit').textContent = 'Withdraw Liquidity';
            }

            loadBalance();
            updateLpPreview();
        }

        async function setLpMax() {
            try {
                if (currentLpMode === 'add') {
                    // For add, max is ETH balance (leave some for gas)
                    if (!connectedAddress) return;
                    const rpc = await getReadProvider();
                    const bal = await rpc.getBalance(connectedAddress);
                    if (bal > 0n) {
                        const maxBal = bal > ethers.parseEther('0.001') ? bal - ethers.parseEther('0.001') : bal;
                        lpMaxRaw = maxBal;
                        document.getElementById('lpAmount').value = ethers.formatEther(maxBal);
                        updateLpPreview();
                    }
                } else {
                    // For remove, max is LP balance
                    const lpBal = currentUserPosition.lpBalance;
                    if (lpBal && lpBal > 0n) {
                        lpMaxRaw = lpBal;
                        document.getElementById('lpAmount').value = ethers.formatEther(lpBal);
                        updateLpPreview();
                    }
                }
            } catch (e) {
                // Silently fail - max button just won't work
            }
        }

        function setLimitSide(side) {
            limitIsBuy = side === 'buy';
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const sideName = currentTrade.isYes ? 'YES' : 'NO';

            if (limitIsBuy) {
                buyBtn.style.background = '#8b5cf6';
                buyBtn.style.color = 'white';
                sellBtn.style.background = 'transparent';
                sellBtn.style.color = 'var(--text-muted)';
                document.getElementById('limitExplainerText').textContent = `Bid below pool odds for better price. ETH locked until filled.`;
                document.getElementById('limitAmountLabel').textContent = 'Spend (ETH)';
                document.getElementById('limitResultLabel').textContent = `${sideName} shares you get`;
                document.getElementById('limitSavingsLabel').textContent = 'vs Pool';
                document.getElementById('limitSubmit').textContent = `Buy ${sideName} @ Limit`;
            } else {
                sellBtn.style.background = '#8b5cf6';
                sellBtn.style.color = 'white';
                buyBtn.style.background = 'transparent';
                buyBtn.style.color = 'var(--text-muted)';
                document.getElementById('limitExplainerText').textContent = `Ask above pool odds for better price. Shares locked until filled.`;
                document.getElementById('limitAmountLabel').textContent = `Sell (${sideName} shares)`;
                document.getElementById('limitResultLabel').textContent = 'ETH you receive';
                document.getElementById('limitSavingsLabel').textContent = 'vs Pool';
                document.getElementById('limitSubmit').textContent = `Sell ${sideName} @ Limit`;
            }

            // Set default price based on pool price
            setDefaultLimitPrice();
            loadBalance();
            updateLimitPreview();
        }

        function setDefaultLimitPrice() {
            if (currentTrade.rYes === 0n || currentTrade.rNo === 0n) return;

            const yesPrice = Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo);
            const poolPrice = currentTrade.isYes ? yesPrice : (1 - yesPrice);

            // For buy orders: suggest 2% below pool (better for buyer)
            // For sell orders: suggest 2% above pool (better for seller)
            const adjustment = limitIsBuy ? -0.02 : 0.02;
            const suggestedPrice = Math.max(0.01, Math.min(0.99, poolPrice + adjustment));

            document.getElementById('limitPrice').value = suggestedPrice.toFixed(2);
        }

        function adjustLimitPrice(delta) {
            const input = document.getElementById('limitPrice');
            const current = parseFloat(input.value) || 0.5;
            const newVal = Math.max(0.01, Math.min(0.99, current + delta));
            input.value = newVal.toFixed(2);
            updateLimitPreview();
        }

        function updateTradeButton() {
            const btn = document.getElementById('tradeSubmit');
            const side = currentTrade.isYes ? 'YES' : 'NO';
            if (currentTradeDirection === 'buy') {
                btn.textContent = `Buy ${side}`;
                btn.className = `trade-submit ${currentTrade.isYes ? 'buy-yes' : 'buy-no'}`;
            } else {
                btn.textContent = `Sell ${side}`;
                btn.className = 'trade-submit';
                btn.style.background = 'var(--red)';
            }
        }

        // ======================== USER POSITION ========================
        async function refreshPoolState() {
            if (!currentTrade.marketId) return;
            try {
                const rpc = await getReadProvider();
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const results = await multicall.aggregate3([
                    { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [currentTrade.marketId, FEE_TIER]) }
                ]);
                const poolState = pammInterface.decodeFunctionResult('getPoolState', results[0].returnData);
                currentTrade.rYes = poolState.rYes;
                currentTrade.rNo = poolState.rNo;
            } catch (e) {
                console.error('Failed to refresh pool state:', e);
            }
        }

        // Position cache to reduce RPC calls
        const positionCache = new Map(); // key -> { data, timestamp }
        const POSITION_CACHE_TTL = 30000; // 30 seconds

        async function loadUserPosition(forceRefresh = false) {
            if (!connectedAddress || !currentTrade.marketId) return;

            const cacheKey = `${connectedAddress}-${currentTrade.marketId}`;
            const cached = positionCache.get(cacheKey);

            // Use cache if valid and not forcing refresh
            if (!forceRefresh && cached && Date.now() - cached.timestamp < POSITION_CACHE_TTL) {
                currentUserPosition = cached.data;
                updatePositionUI(cached.data);
                return;
            }

            try {
                const rpc = await getReadProvider();
                const quoterDeployed = PMHOOKQUOTER_ADDRESS !== '0x0000000000000000000000000000000000000000';

                if (quoterDeployed) {
                    // Use quoter for share balances, vault info, and limit orders
                    const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, rpc);

                    const [position, limitOrders] = await Promise.all([
                        quoter.getUserFullPosition(currentTrade.marketId, connectedAddress),
                        quoter.getUserAllLimitOrders(currentTrade.marketId, connectedAddress).catch(() => null)
                    ]);

                    // For legacy markets (not registered with PMHookRouter), quoter returns ammLPBalance=0
                    // Fetch LP balance separately using legacy pool computation
                    let lpBalance = position.ammLPBalance;
                    let lpTotalSupply = null;
                    if (lpBalance === 0n && currentTrade.yesId && currentTrade.noId) {
                        const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, rpc);
                        const yesId = currentTrade.yesId;
                        const noId = currentTrade.noId;
                        const id0 = yesId < noId ? yesId : noId;
                        const id1 = yesId < noId ? noId : yesId;
                        const poolId = computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER);
                        const [lpBal, poolData] = await Promise.all([
                            zamm.balanceOf(connectedAddress, poolId),
                            zamm.pools(poolId)
                        ]);
                        lpBalance = lpBal;
                        lpTotalSupply = poolData[6];
                    }

                    currentUserPosition = {
                        yesBalance: position.yesShareBalance,
                        noBalance: position.noShareBalance,
                        lpBalance: lpBalance,
                        lpTotalSupply: lpTotalSupply,
                        vaultYes: BigInt(position.yesVaultLP),
                        vaultNo: BigInt(position.noVaultLP),
                        pendingYes: position.pendingYesCollateral,
                        pendingNo: position.pendingNoCollateral,
                        limitOrders: limitOrders
                    };
                } else {
                    // Fallback to direct contract calls
                    const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                    const pammInterface = new ethers.Interface(PAMM_ABI);
                    const zammInterface = new ethers.Interface(ZAMM_ABI);

                    const yesId = currentTrade.yesId;
                    const noId = currentTrade.noId;
                    const id0 = yesId < noId ? yesId : noId;
                    const id1 = yesId < noId ? noId : yesId;
                    const poolId = computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER);

                    const results = await multicall.aggregate3([
                        { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, yesId]) },
                        { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId]) },
                        { target: ZAMM_ADDRESS, allowFailure: false, callData: zammInterface.encodeFunctionData('balanceOf', [connectedAddress, poolId]) },
                        { target: ZAMM_ADDRESS, allowFailure: false, callData: zammInterface.encodeFunctionData('pools', [poolId]) }
                    ]);

                    const yesBal = pammInterface.decodeFunctionResult('balanceOf', results[0].returnData)[0];
                    const noBal = pammInterface.decodeFunctionResult('balanceOf', results[1].returnData)[0];
                    const lpBal = zammInterface.decodeFunctionResult('balanceOf', results[2].returnData)[0];
                    const poolData = zammInterface.decodeFunctionResult('pools', results[3].returnData);
                    const lpTotalSupply = poolData[6];

                    currentUserPosition = {
                        yesBalance: yesBal,
                        noBalance: noBal,
                        lpBalance: lpBal,
                        lpTotalSupply: lpTotalSupply,
                        vaultYes: 0n,
                        vaultNo: 0n,
                        limitOrders: null
                    };
                }

                // Cache the result
                positionCache.set(cacheKey, { data: currentUserPosition, timestamp: Date.now() });

                updatePositionUI(currentUserPosition);

                // Load user's pool positions for My Orders section
                await loadUserPoolPositions();
                updateMyOrders();

            } catch (e) {
                console.error('Failed to load user position:', e);
            }
        }

        function updatePositionUI(pos) {
            document.getElementById('tradeModalYes').textContent = formatEth(pos.yesBalance);
            document.getElementById('tradeModalNo').textContent = formatEth(pos.noBalance);
            document.getElementById('tradeModalLP').textContent = formatEth(pos.lpBalance);
            document.getElementById('lpPosition').textContent = formatEth(pos.lpBalance) + ' LP';

            // Show vault positions if user has any
            const vaultEl = document.getElementById('tradeModalVault');
            if (vaultEl) {
                const vaultYes = Number(pos.vaultYes || 0n) / 1e18;
                const vaultNo = Number(pos.vaultNo || 0n) / 1e18;
                if (vaultYes > 0 || vaultNo > 0) {
                    vaultEl.parentElement.style.display = 'flex';
                    vaultEl.innerHTML = `${vaultYes.toFixed(2)} YES / ${vaultNo.toFixed(2)} NO`;
                } else {
                    vaultEl.parentElement.style.display = 'none';
                }
            }

            // Show limit orders if user has any
            updateLimitOrdersDisplay(pos);
        }

        // Display user's limit orders summary
        function updateLimitOrdersDisplay(pos) {
            const limitOrdersEl = document.getElementById('tradeModalLimitOrders');
            if (!limitOrdersEl) return;

            const orders = pos.limitOrders;
            if (!orders) {
                limitOrdersEl.parentElement.style.display = 'none';
                return;
            }

            const yesAskCount = orders.yesAskPrices?.length || 0;
            const yesBidCount = orders.yesBidPrices?.length || 0;
            const noAskCount = orders.noAskPrices?.length || 0;
            const noBidCount = orders.noBidPrices?.length || 0;
            const totalOrders = yesAskCount + yesBidCount + noAskCount + noBidCount;

            if (totalOrders === 0) {
                limitOrdersEl.parentElement.style.display = 'none';
                return;
            }

            let totalAskShares = 0;
            let totalBidCollateral = 0;

            for (let i = 0; i < yesAskCount; i++) totalAskShares += Number(orders.yesAskShares[i]) / 1e18;
            for (let i = 0; i < noAskCount; i++) totalAskShares += Number(orders.noAskShares[i]) / 1e18;
            for (let i = 0; i < yesBidCount; i++) totalBidCollateral += Number(orders.yesBidCollateral[i]) / 1e18;
            for (let i = 0; i < noBidCount; i++) totalBidCollateral += Number(orders.noBidCollateral[i]) / 1e18;

            limitOrdersEl.parentElement.style.display = 'flex';
            let html = `${totalOrders} order${totalOrders > 1 ? 's' : ''}`;
            if (totalAskShares > 0) html += ` ¬∑ ${totalAskShares.toFixed(2)} shares`;
            if (totalBidCollateral > 0) html += ` ¬∑ ${totalBidCollateral.toFixed(4)} ETH`;
            limitOrdersEl.innerHTML = html;
        }

        // Invalidate position cache after transactions
        function invalidatePositionCache() {
            positionCache.clear();
        }

        async function loadBalance() {
            if (!connectedAddress) return;

            try {
                const rpc = await getReadProvider();

                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        const bal = await rpc.getBalance(connectedAddress);
                        document.getElementById('lpBalance').textContent = formatEth(bal) + ' ETH';
                    } else {
                        document.getElementById('lpBalance').textContent = formatEth(currentUserPosition.lpBalance) + ' LP';
                    }
                } else if (currentTradeMode === 'swap') {
                    const bal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('swapBalance').textContent = formatEth(bal);
                } else if (currentTradeMode === 'trade') {
                    if (currentTradeDirection === 'buy') {
                        const bal = await rpc.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = formatEth(bal) + ' ETH';
                    } else {
                        const bal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('tradeBalance').textContent = formatEth(bal);
                    }
                } else if (currentTradeMode === 'limit') {
                    if (limitIsBuy) {
                        const bal = await rpc.getBalance(connectedAddress);
                        document.getElementById('limitBalance').textContent = formatEth(bal) + ' ETH';
                    } else {
                        const bal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('limitBalance').textContent = formatEth(bal);
                    }
                }
            } catch (e) {
                console.error('Failed to load balance:', e);
            }
        }

        // ======================== ORDERBOOK ========================
        // Uses PMHookQuoter.getActiveLevels for orderbook data
        async function loadOrderbook() {
            if (!currentTrade.marketId) return;

            try {
                const rpc = await getReadProvider();
                const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, rpc);

                // Load orderbooks for both YES and NO sides in parallel via quoter
                const [yesLevels, noLevels] = await Promise.all([
                    quoter.getActiveLevels(currentTrade.marketId, true, 10),
                    quoter.getActiveLevels(currentTrade.marketId, false, 10)
                ]);

                // Parse levels from quoter format: (askPrices[], askDepths[], bidPrices[], bidDepths[])
                const parseLevels = (levels) => {
                    const [askPrices, askDepths, bidPrices, bidDepths] = levels;

                    // Convert to orderbook format
                    const asks = [];
                    for (let i = 0; i < askPrices.length; i++) {
                        if (askDepths[i] > 0n) {
                            const priceBps = Number(askPrices[i]);
                            asks.push({
                                price: priceBps / 10000, // Convert BPS to decimal
                                priceBps: priceBps,
                                depth: askDepths[i],
                                shares: askDepths[i], // Depth is in shares for asks
                                collateral: askDepths[i] * BigInt(priceBps) / 10000n
                            });
                        }
                    }

                    const bids = [];
                    for (let i = 0; i < bidPrices.length; i++) {
                        if (bidDepths[i] > 0n) {
                            const priceBps = Number(bidPrices[i]);
                            bids.push({
                                price: priceBps / 10000, // Convert BPS to decimal
                                priceBps: priceBps,
                                depth: bidDepths[i],
                                collateral: bidDepths[i], // Depth is in collateral for bids
                                shares: bidDepths[i] * 10000n / BigInt(priceBps)
                            });
                        }
                    }

                    // Sort asks ascending by price, bids descending
                    asks.sort((a, b) => a.price - b.price);
                    bids.sort((a, b) => b.price - a.price);

                    return { asks, bids };
                };

                const yesParsed = parseLevels(yesLevels);
                const noParsed = parseLevels(noLevels);

                // Calculate AMM prices
                const ammYesPrice = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                    ? Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo)
                    : null;
                const ammNoPrice = ammYesPrice !== null ? 1 - ammYesPrice : null;

                currentOrderbook = {
                    yes: {
                        bids: yesParsed.bids,
                        asks: yesParsed.asks,
                        ammPrice: ammYesPrice
                    },
                    no: {
                        bids: noParsed.bids,
                        asks: noParsed.asks,
                        ammPrice: ammNoPrice
                    }
                };

                // Batch all DOM updates in single animation frame
                requestAnimationFrame(() => {
                    updateOrderbookUI();
                    updateLimitBookPreview();
                    updateInlineOrderbook();
                    updateOrderbookTvl();
                });

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                currentOrderbook = {
                    yes: { bids: [], asks: [], ammPrice: null },
                    no: { bids: [], asks: [], ammPrice: null }
                };
            }
        }

        function updateLimitBookPreview() {
            const container = document.getElementById('limitBookPreview');
            if (!container) return;

            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            const { bids, asks, ammPrice } = book;
            const side = currentTrade.isYes ? 'YES' : 'NO';

            if (bids.length === 0 && asks.length === 0) {
                container.innerHTML = `<div style="color:var(--text-dim);text-align:center;padding:0.5rem;">No ${side} orders yet</div>`;
                return;
            }

            // Show top 3 bids and asks in a compact format
            const topAsks = asks.slice(0, 3).reverse();
            const topBids = bids.slice(0, 3);

            let html = '<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:2px 8px;font-family:var(--font-mono);">';

            // Header
            html += `<div style="color:var(--text-dim);font-size:10px;">Size</div>`;
            html += `<div style="color:var(--text-dim);font-size:10px;text-align:center;">Price</div>`;
            html += `<div style="color:var(--text-dim);font-size:10px;text-align:right;">Size</div>`;

            // Asks (sell orders) - show in red
            for (const ask of topAsks) {
                const size = (Number(ask.shares) / 1e18).toFixed(2) + ' sh';
                const price = (ask.price * 100).toFixed(1) + '%';
                html += `<div></div>`;
                html += `<div style="color:var(--red);text-align:center;">${price}</div>`;
                html += `<div style="color:var(--red);text-align:right;">${size}</div>`;
            }

            // AMM price line
            if (ammPrice) {
                html += `<div style="border-top:1px dashed var(--border);grid-column:span 3;margin:2px 0;"></div>`;
                html += `<div style="font-size:10px;color:var(--text-dim);">AMM</div>`;
                html += `<div style="color:var(--text);text-align:center;font-weight:600;">${(ammPrice * 100).toFixed(1)}%</div>`;
                html += `<div style="font-size:10px;color:var(--text-dim);text-align:right;">AMM</div>`;
                html += `<div style="border-bottom:1px dashed var(--border);grid-column:span 3;margin:2px 0;"></div>`;
            }

            // Bids (buy orders) - show in green
            for (const bid of topBids) {
                const size = (Number(bid.shares) / 1e18).toFixed(2) + ' sh';
                const price = (bid.price * 100).toFixed(1) + '%';
                html += `<div style="color:var(--green);">${size}</div>`;
                html += `<div style="color:var(--green);text-align:center;">${price}</div>`;
                html += `<div></div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function updateInlineOrderbook() {
            if (!currentTrade.marketId) return;

            const ladder = document.getElementById(`inlineLadder-${currentTrade.marketId}`);
            const yesAmmEl = document.getElementById(`inlineYesAmm-${currentTrade.marketId}`);
            const noAmmEl = document.getElementById(`inlineNoAmm-${currentTrade.marketId}`);
            if (!ladder) return;

            const yesBook = currentOrderbook.yes;
            const noBook = currentOrderbook.no;
            if (!yesBook || !noBook) return;
            const yesAmm = yesBook.ammPrice || 0.5;
            const noAmm = noBook.ammPrice || 0.5;

            // Update AMM reference prices
            if (yesAmmEl) yesAmmEl.textContent = yesBook.ammPrice ? `AMM: ${(yesBook.ammPrice * 100).toFixed(1)}%` : '--';
            if (noAmmEl) noAmmEl.textContent = noBook.ammPrice ? `AMM: ${(noBook.ammPrice * 100).toFixed(1)}%` : '--';

            // Collect resting orders only:
            // - Bids below AMM (buyers want cheaper)
            // - Asks above AMM (sellers want more)
            const levels = new Map();

            const addOrders = (orders, side, isYes, ammPrice) => {
                orders.forEach(order => {
                    const price = Math.round(order.price * 1000) / 1000;
                    // Only show resting orders (bids below AMM, asks above AMM)
                    const isResting = side === 'bids' ? price < ammPrice : price > ammPrice;
                    if (!isResting) return;

                    const eth = Number(order.shares) / 1e18 * order.price;
                    if (!levels.has(price)) levels.set(price, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0 });
                    const key = isYes ? (side === 'bids' ? 'yesBids' : 'yesAsks') : (side === 'bids' ? 'noBids' : 'noAsks');
                    levels.get(price)[key] += eth; // Sum depth at each level
                });
            };

            addOrders(yesBook.bids, 'bids', true, yesAmm);
            addOrders(yesBook.asks, 'asks', true, yesAmm);
            addOrders(noBook.bids, 'bids', false, noAmm);
            addOrders(noBook.asks, 'asks', false, noAmm);

            // Add AMM price rows
            const yesAmmRounded = Math.round(yesAmm * 1000) / 1000;
            const noAmmRounded = Math.round(noAmm * 1000) / 1000;
            if (!levels.has(yesAmmRounded)) levels.set(yesAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, isYesAmm: true });
            else levels.get(yesAmmRounded).isYesAmm = true;
            if (!levels.has(noAmmRounded)) levels.set(noAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, isNoAmm: true });
            else levels.get(noAmmRounded).isNoAmm = true;

            const sortedLevels = [...levels.entries()].sort((a, b) => b[0] - a[0]);

            if (sortedLevels.length === 0) {
                ladder.innerHTML = `<div style="text-align:center;color:var(--text-dim);padding:1.5rem;font-size:11px;">No limit orders yet. Trade via AMM or place limit orders.</div>`;
                return;
            }

            let maxDepth = 0.001;
            sortedLevels.forEach(([, data]) => {
                maxDepth = Math.max(maxDepth, data.yesBids, data.yesAsks, data.noBids, data.noAsks);
            });

            ladder.innerHTML = sortedLevels.map(([price, data]) => {
                const pct = (price * 100).toFixed(1);
                // Asks above AMM (red), Bids below AMM (green)
                const yesDepth = data.yesAsks > 0 ? data.yesAsks : data.yesBids;
                const noDepth = data.noAsks > 0 ? data.noAsks : data.noBids;
                const yesBarWidth = (yesDepth / maxDepth * 100).toFixed(1);
                const noBarWidth = (noDepth / maxDepth * 100).toFixed(1);
                const yesIsAsk = data.yesAsks > 0;
                const noIsAsk = data.noAsks > 0;

                const isYesAmm = data.isYesAmm;
                const isNoAmm = data.isNoAmm;
                const isAmmRow = isYesAmm || isNoAmm;

                const yesDepthStr = yesDepth > 0 ? (yesDepth >= 1 ? yesDepth.toFixed(2) : yesDepth.toFixed(3)) + 'Œû' : '';
                const noDepthStr = noDepth > 0 ? (noDepth >= 1 ? noDepth.toFixed(2) : noDepth.toFixed(3)) + 'Œû' : '';

                return `
                    <div class="inline-ob-row" style="display:grid;grid-template-columns:1fr 50px 1fr;gap:0;align-items:center;height:24px;border-bottom:1px solid var(--border);${isAmmRow ? 'background:var(--surface-2);' : ''}">
                        <div class="inline-ob-cell inline-ob-yes" style="position:relative;height:100%;display:flex;align-items:center;justify-content:flex-end;padding-right:6px;overflow:hidden;cursor:pointer;"
                             onclick="openTradeWithPrice('${currentTrade.marketId}', true, ${price})">
                            ${yesDepth > 0 ? `<div style="position:absolute;right:0;top:0;bottom:0;width:${yesBarWidth}%;background:${yesIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            ${isYesAmm ? '<span style="font-size:8px;color:var(--blue);margin-right:4px;z-index:1;font-weight:600;">AMM</span>' : ''}
                            <span style="font-size:10px;color:${yesIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:500;">${yesDepthStr}</span>
                        </div>
                        <div style="text-align:center;font-size:10px;font-weight:600;color:var(--text);height:100%;display:flex;align-items:center;justify-content:center;border-left:1px solid var(--border);border-right:1px solid var(--border);">${pct}%</div>
                        <div class="inline-ob-cell inline-ob-no" style="position:relative;height:100%;display:flex;align-items:center;padding-left:6px;overflow:hidden;cursor:pointer;"
                             onclick="openTradeWithPrice('${currentTrade.marketId}', false, ${price})">
                            ${noDepth > 0 ? `<div style="position:absolute;left:0;top:0;bottom:0;width:${noBarWidth}%;background:${noIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            <span style="font-size:10px;color:${noIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:500;">${noDepthStr}</span>
                            ${isNoAmm ? '<span style="font-size:8px;color:var(--blue);margin-left:4px;z-index:1;font-weight:600;">AMM</span>' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateOrderbookTvl() {
            const el = document.getElementById('orderbookTvl');
            if (!el) return;
            if (!currentOrderbook.yes || !currentOrderbook.no) {
                el.textContent = '--';
                return;
            }

            // Calculate TVL from all orders
            // Bids: collateral (ETH) locked
            // Asks: shares locked, valued at ask price
            let totalEth = 0;

            // Sum bid collateral (ETH locked by buyers)
            [...currentOrderbook.yes.bids, ...currentOrderbook.no.bids].forEach(o => {
                totalEth += Number(o.collateral) / 1e18;
            });

            // Sum ask value (shares * price = ETH equivalent)
            [...currentOrderbook.yes.asks, ...currentOrderbook.no.asks].forEach(o => {
                totalEth += (Number(o.shares) / 1e18) * o.price;
            });

            el.textContent = totalEth >= 1
                ? totalEth.toFixed(2) + ' Œû'
                : totalEth > 0
                    ? totalEth.toFixed(4) + ' Œû'
                    : '0';
        }

        function updateOrderbookUI() {
            const container = document.getElementById('orderbookPreview');
            if (!container) return;

            // Get data for current trade side
            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            if (!book || !currentOrderbook.yes || !currentOrderbook.no) return;
            const { bids, asks, ammPrice } = book;
            const bestBidPrice = bids.length > 0 ? bids[0].price : null;
            const bestAskPrice = asks.length > 0 ? asks[0].price : null;
            const side = currentTrade.isYes ? 'YES' : 'NO';

            // Format best prices
            const ammStr = ammPrice ? (ammPrice * 100).toFixed(1) + '%' : '--';
            const bestBidStr = bestBidPrice ? (bestBidPrice * 100).toFixed(1) + '%' : '--';
            const bestAskStr = bestAskPrice ? (bestAskPrice * 100).toFixed(1) + '%' : '--';

            // Determine best price for buying (compare AMM vs best ask)
            let bestBuySource = 'AMM';
            if (bestAskPrice && (!ammPrice || bestAskPrice < ammPrice)) {
                bestBuySource = 'Limit';
            }

            // Determine best price for selling (compare AMM vs best bid)
            let bestSellSource = 'AMM';
            if (bestBidPrice && (!ammPrice || bestBidPrice > ammPrice)) {
                bestSellSource = 'Limit';
            }

            // Count total orders and liquidity across both books
            const totalOrders = currentOrderbook.yes.bids.length + currentOrderbook.yes.asks.length +
                               currentOrderbook.no.bids.length + currentOrderbook.no.asks.length;

            // Calculate orderbook liquidity (ETH in bids = buy orders escrowed)
            const bidLiquidity = [...currentOrderbook.yes.bids, ...currentOrderbook.no.bids]
                .reduce((sum, o) => sum + Number(o.collateral) / 1e18, 0);
            const bidLiqStr = bidLiquidity > 0 ? formatEth(BigInt(Math.floor(bidLiquidity * 1e18))) : '0';

            container.innerHTML = `
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.5rem;font-size:var(--font-xs);">
                    <div style="text-align:center;padding:0.5rem;background:var(--green-dim);border-radius:4px;">
                        <div style="color:var(--text-dim);font-size:10px;">${side} Best Bid</div>
                        <div style="color:var(--green);font-weight:600;">${bestBidStr}</div>
                        <div style="color:var(--text-dim);font-size:10px;">${bids.length} order${bids.length !== 1 ? 's' : ''}</div>
                    </div>
                    <div style="text-align:center;padding:0.5rem;background:var(--red-dim);border-radius:4px;">
                        <div style="color:var(--text-dim);font-size:10px;">${side} Best Ask</div>
                        <div style="color:var(--red);font-weight:600;">${bestAskStr}</div>
                        <div style="color:var(--text-dim);font-size:10px;">${asks.length} order${asks.length !== 1 ? 's' : ''}</div>
                    </div>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;flex-wrap:wrap;gap:0.25rem;">
                    <span style="font-size:10px;color:var(--text-dim);">AMM: ${ammStr}${bidLiquidity > 0 ? ` | Book: ${bidLiqStr} ETH` : ''}</span>
                    <button onclick="openOrderbookModal()" style="font-size:10px;padding:2px 8px;background:var(--surface-2);border:1px solid var(--border);border-radius:4px;color:var(--text-muted);cursor:pointer;">${totalOrders > 0 ? `Depth (${totalOrders})` : 'View Depth'}</button>
                </div>
            `;

            // Update My Orders section
            updateMyOrders();
        }

        // User pool positions cached from quoter
        let userPoolPositions = { yes: { asks: [], bids: [] }, no: { asks: [], bids: [] } };

        async function loadUserPoolPositions() {
            if (!connectedAddress || !currentTrade.marketId) return;

            try {
                const rpc = await getReadProvider();
                const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, rpc);

                // Fetch user positions for both YES and NO
                const [yesPos, noPos] = await Promise.all([
                    quoter.getUserActivePositions(currentTrade.marketId, true, connectedAddress),
                    quoter.getUserActivePositions(currentTrade.marketId, false, connectedAddress)
                ]);

                // Parse YES positions
                const yesAsks = [];
                for (let i = 0; i < yesPos.askPrices.length; i++) {
                    if (yesPos.askShares[i] > 0n) {
                        yesAsks.push({
                            priceBps: Number(yesPos.askPrices[i]),
                            shares: yesPos.askShares[i],
                            pendingCollateral: yesPos.askPendingColl[i]
                        });
                    }
                }
                const yesBids = [];
                for (let i = 0; i < yesPos.bidPrices.length; i++) {
                    if (yesPos.bidCollateral[i] > 0n) {
                        yesBids.push({
                            priceBps: Number(yesPos.bidPrices[i]),
                            collateral: yesPos.bidCollateral[i],
                            pendingShares: yesPos.bidPendingShares[i]
                        });
                    }
                }

                // Parse NO positions
                const noAsks = [];
                for (let i = 0; i < noPos.askPrices.length; i++) {
                    if (noPos.askShares[i] > 0n) {
                        noAsks.push({
                            priceBps: Number(noPos.askPrices[i]),
                            shares: noPos.askShares[i],
                            pendingCollateral: noPos.askPendingColl[i]
                        });
                    }
                }
                const noBids = [];
                for (let i = 0; i < noPos.bidPrices.length; i++) {
                    if (noPos.bidCollateral[i] > 0n) {
                        noBids.push({
                            priceBps: Number(noPos.bidPrices[i]),
                            collateral: noPos.bidCollateral[i],
                            pendingShares: noPos.bidPendingShares[i]
                        });
                    }
                }

                userPoolPositions = {
                    yes: { asks: yesAsks, bids: yesBids },
                    no: { asks: noAsks, bids: noBids }
                };
            } catch (e) {
                console.error('Failed to load user pool positions:', e);
                userPoolPositions = { yes: { asks: [], bids: [] }, no: { asks: [], bids: [] } };
            }
        }

        function updateMyOrders() {
            const section = document.getElementById('myOrdersSection');
            const list = document.getElementById('myOrdersList');
            const countEl = document.getElementById('myOrdersCount');

            if (!section || !list) return;

            // Collect all user's pool positions
            const myPositions = [];

            // YES asks (user is selling YES)
            for (const pos of userPoolPositions.yes.asks) {
                myPositions.push({ ...pos, isYes: true, type: 'ASK' });
            }
            // YES bids (user wants to buy YES)
            for (const pos of userPoolPositions.yes.bids) {
                myPositions.push({ ...pos, isYes: true, type: 'BID' });
            }
            // NO asks (user is selling NO)
            for (const pos of userPoolPositions.no.asks) {
                myPositions.push({ ...pos, isYes: false, type: 'ASK' });
            }
            // NO bids (user wants to buy NO)
            for (const pos of userPoolPositions.no.bids) {
                myPositions.push({ ...pos, isYes: false, type: 'BID' });
            }

            if (myPositions.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            countEl.textContent = myPositions.length;

            // Sort by price descending
            myPositions.sort((a, b) => b.priceBps - a.priceBps);

            let html = '';
            for (const pos of myPositions) {
                const priceStr = (pos.priceBps / 100).toFixed(1) + '%';
                const sideLabel = pos.isYes ? 'YES' : 'NO';
                const sideColor = pos.isYes ? 'var(--green)' : 'var(--red)';
                const typeColor = pos.type === 'BID' ? 'var(--green)' : 'var(--red)';

                // Amount display
                const amountStr = pos.type === 'ASK'
                    ? formatEth(pos.shares) + ' sh'
                    : formatEth(pos.collateral) + ' ETH';

                // Pending fills
                const hasPending = pos.type === 'ASK'
                    ? (pos.pendingCollateral && pos.pendingCollateral > 0n)
                    : (pos.pendingShares && pos.pendingShares > 0n);
                const pendingStr = hasPending
                    ? (pos.type === 'ASK'
                        ? `${formatEth(pos.pendingCollateral)} ETH pending`
                        : `${formatEth(pos.pendingShares)} sh pending`)
                    : '';

                // Withdraw function based on type
                const withdrawFn = pos.type === 'ASK'
                    ? `withdrawFromAskPool(${pos.isYes}, ${pos.priceBps})`
                    : `withdrawFromBidPool(${pos.isYes}, ${pos.priceBps})`;

                html += `
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid rgba(245,158,11,0.2);">
                        <div>
                            <span style="color:${sideColor};font-weight:600;">${sideLabel}</span>
                            <span style="color:${typeColor};margin-left:4px;">${pos.type === 'BID' ? 'Buy' : 'Sell'}</span>
                            <span style="color:var(--text-muted);margin-left:4px;">@ ${priceStr}</span>
                            ${hasPending ? `<span style="color:var(--green);margin-left:4px;font-size:10px;">(${pendingStr})</span>` : ''}
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="color:var(--text);">${amountStr}</span>
                            <button onclick="${withdrawFn}" style="padding:2px 6px;font-size:10px;background:var(--surface);border:1px solid var(--amber);border-radius:4px;color:var(--amber);cursor:pointer;">Withdraw</button>
                        </div>
                    </div>
                `;
            }

            list.innerHTML = html;
        }

        function openOrderbookModal() {
            renderDepthLadder();
            document.getElementById('orderbookModal').classList.add('active');
        }

        function renderDepthLadder() {
            const ladder = document.getElementById('depthLadder');
            const yesBook = currentOrderbook.yes;
            const noBook = currentOrderbook.no;
            if (!yesBook || !noBook) return;
            const yesAmm = yesBook.ammPrice || 0.5;
            const noAmm = noBook.ammPrice || 0.5;

            // Update header AMM prices
            document.getElementById('yesAmmRef').textContent = yesBook.ammPrice ? `AMM ${(yesBook.ammPrice * 100).toFixed(1)}%` : '--';
            document.getElementById('noAmmRef').textContent = noBook.ammPrice ? `AMM ${(noBook.ammPrice * 100).toFixed(1)}%` : '--';

            // Collect resting orders only (bids below AMM, asks above AMM)
            const levels = new Map(); // price -> { yesBids, yesAsks, noBids, noAsks, orders[] }

            // Helper to add resting orders with depth at each level
            const addOrders = (orders, side, isYes, ammPrice) => {
                orders.forEach(order => {
                    const price = Math.round(order.price * 1000) / 1000; // Round to 0.1% precision
                    // Only show resting orders (bids below AMM, asks above AMM)
                    const isResting = side === 'bids' ? price < ammPrice : price > ammPrice;
                    if (!isResting) return;

                    const eth = Number(order.shares) / 1e18 * order.price;
                    if (!levels.has(price)) levels.set(price, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [] });
                    const key = isYes ? (side === 'bids' ? 'yesBids' : 'yesAsks') : (side === 'bids' ? 'noBids' : 'noAsks');
                    levels.get(price)[key] += eth; // Sum depth at each level
                    levels.get(price).orders.push({ ...order, side, isYes, eth });
                });
            };

            addOrders(yesBook.bids, 'bids', true, yesAmm);
            addOrders(yesBook.asks, 'asks', true, yesAmm);
            addOrders(noBook.bids, 'bids', false, noAmm);
            addOrders(noBook.asks, 'asks', false, noAmm);

            // Add AMM price rows as reference points
            const yesAmmRounded = Math.round(yesAmm * 1000) / 1000;
            const noAmmRounded = Math.round(noAmm * 1000) / 1000;
            if (!levels.has(yesAmmRounded)) levels.set(yesAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [], isYesAmm: true });
            else levels.get(yesAmmRounded).isYesAmm = true;
            if (!levels.has(noAmmRounded)) levels.set(noAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [], isNoAmm: true });
            else levels.get(noAmmRounded).isNoAmm = true;

            // Sort levels by price descending (high odds to low)
            const sortedLevels = [...levels.entries()].sort((a, b) => b[0] - a[0]);

            // Check if we have any actual orders
            const hasOrders = sortedLevels.some(([, data]) => data.orders.length > 0);

            if (!hasOrders) {
                // Show AMM prices as reference even without orders
                const yesAmm = yesBook.ammPrice ? (yesBook.ammPrice * 100).toFixed(1) : '--';
                const noAmm = noBook.ammPrice ? (noBook.ammPrice * 100).toFixed(1) : '--';
                ladder.innerHTML = `
                    <div style="text-align:center;padding:1.5rem;color:var(--text-dim);">
                        <div style="font-size:12px;margin-bottom:1rem;">No limit orders</div>
                        <div style="display:flex;justify-content:center;gap:2rem;font-size:11px;">
                            <span><span style="color:var(--green);">YES</span> AMM: ${yesAmm}%</span>
                            <span><span style="color:var(--red);">NO</span> AMM: ${noAmm}%</span>
                        </div>
                    </div>
                `;
                return;
            }

            // Find max cumulative for bar scaling
            let maxDepth = 0.001;
            sortedLevels.forEach(([, data]) => {
                maxDepth = Math.max(maxDepth, data.yesBids, data.yesAsks, data.noBids, data.noAsks);
            });

            // Render ladder rows - simplified for pooled orderbook (aggregate depth only)
            ladder.innerHTML = sortedLevels.map(([price, data]) => {
                const pct = (price * 100).toFixed(1);
                // Asks (above AMM) or Bids (below AMM) - only one should be non-zero per side
                const yesDepth = data.yesAsks > 0 ? data.yesAsks : data.yesBids;
                const noDepth = data.noAsks > 0 ? data.noAsks : data.noBids;
                const yesBarWidth = (yesDepth / maxDepth * 100).toFixed(1);
                const noBarWidth = (noDepth / maxDepth * 100).toFixed(1);
                const yesIsAsk = data.yesAsks > 0;
                const noIsAsk = data.noAsks > 0;

                // Check if this is AMM price row
                const isYesAmm = data.isYesAmm;
                const isNoAmm = data.isNoAmm;
                const isAmmRow = isYesAmm || isNoAmm;

                // Format depth display (ETH value)
                const yesDepthStr = yesDepth > 0 ? (yesDepth >= 1 ? yesDepth.toFixed(2) : yesDepth.toFixed(3)) + 'Œû' : '';
                const noDepthStr = noDepth > 0 ? (noDepth >= 1 ? noDepth.toFixed(2) : noDepth.toFixed(3)) + 'Œû' : '';

                return `
                    <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;align-items:center;height:26px;border-bottom:1px solid var(--border);${isAmmRow ? 'background:var(--surface-2);' : ''}">
                        <!-- YES side (bars grow right-to-left) -->
                        <div style="position:relative;height:100%;display:flex;align-items:center;justify-content:flex-end;padding-right:8px;overflow:hidden;">
                            ${yesDepth > 0 ? `<div style="position:absolute;right:0;top:0;bottom:0;width:${yesBarWidth}%;background:${yesIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            ${isYesAmm ? '<span style="font-size:8px;color:var(--blue);margin-right:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                            <span style="font-size:10px;color:${yesIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:600;">${yesDepthStr}</span>
                        </div>
                        <!-- Center odds -->
                        <div style="text-align:center;font-size:11px;font-weight:700;color:var(--text);background:${isAmmRow ? 'var(--surface-2)' : 'var(--surface)'};height:100%;display:flex;align-items:center;justify-content:center;border-left:1px solid var(--border);border-right:1px solid var(--border);">${pct}%</div>
                        <!-- NO side (bars grow left-to-right) -->
                        <div style="position:relative;height:100%;display:flex;align-items:center;padding-left:8px;overflow:hidden;">
                            ${noDepth > 0 ? `<div style="position:absolute;left:0;top:0;bottom:0;width:${noBarWidth}%;background:${noIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            <span style="font-size:10px;color:${noIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:600;">${noDepthStr}</span>
                            ${isNoAmm ? '<span style="font-size:8px;color:var(--blue);margin-left:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function closeOrderbookModal() {
            document.getElementById('orderbookModal').classList.remove('active');
        }

        // Withdraw from a sell pool (ask order) - returns shares
        async function withdrawFromAskPool(isYes, priceBps) {
            if (!signer || !currentTrade.marketId) {
                showWalletModal();
                return;
            }

            const side = isYes ? 'YES' : 'NO';
            const priceDisplay = (priceBps / 100).toFixed(0) + '%';

            try {
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);

                await monitorTransaction(
                    masterRouter.withdrawFromPool(currentTrade.marketId, isYes, priceBps),
                    {
                        pending: { title: `Withdrawing ${side} Order`, body: `Cancelling ask at ${priceDisplay}...` },
                        submitted: { title: `Withdrawing ${side} Order`, body: 'Waiting for confirmation...' },
                        success: { title: 'Order Withdrawn', body: `Your ${side} shares have been returned` },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([loadUserPosition(), loadOrderbook()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Withdraw from pool error:', e);
                    showToast('Withdraw Failed', 'Could not withdraw from pool', 'error');
                }
            }
        }

        // Withdraw from a buy pool (bid order) - returns collateral
        async function withdrawFromBidPool(isYes, priceBps) {
            if (!signer || !currentTrade.marketId) {
                showWalletModal();
                return;
            }

            const side = isYes ? 'YES' : 'NO';
            const priceDisplay = (priceBps / 100).toFixed(0) + '%';

            try {
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);

                await monitorTransaction(
                    masterRouter.withdrawFromBidPool(currentTrade.marketId, isYes, priceBps),
                    {
                        pending: { title: `Withdrawing ${side} Bid`, body: `Cancelling bid at ${priceDisplay}...` },
                        submitted: { title: `Withdrawing ${side} Bid`, body: 'Waiting for confirmation...' },
                        success: { title: 'Bid Withdrawn', body: 'Your ETH has been returned' },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([loadUserPosition(), loadOrderbook()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Withdraw from bid pool error:', e);
                    showToast('Withdraw Failed', 'Could not withdraw from bid pool', 'error');
                }
            }
        }

        // ======================== PREVIEW FUNCTIONS ========================
        let tradeInputTimer = null;
        function handleTradeInput() {
            tradeMaxRaw = null; // Clear max when user manually edits input
            // Debounce expensive preview calculations
            clearTimeout(tradeInputTimer);
            tradeInputTimer = setTimeout(() => {
                if (currentTradeMode === 'trade') updateTradePreview();
            }, 80);
        }

        function updateTradePreview() {
            const amount = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const routeEl = document.getElementById('previewRoute');

            if (!currentTrade.marketId || amount <= 0 || currentTrade.rYes === 0n || currentTrade.rNo === 0n) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                document.getElementById('previewPayout').style.color = 'var(--text-muted)';
                routeEl.textContent = '--';
                return;
            }

            const amtWei = ethers.parseEther(amount.toString());
            const isBuy = currentTradeDirection === 'buy';

            // Calculate AMM execution price (with price impact) for routing
            const ammOutput = isBuy
                ? (currentTrade.isYes ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo))
                : (currentTrade.isYes ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo));
            const ammOutputNum = Number(ammOutput) / 1e18;
            const ammExecutionPrice = (ammOutputNum > 0 && amount > 0)
                ? (isBuy ? amount / ammOutputNum : ammOutputNum / amount)
                : null;

            // Check orderbook for better prices (use current side's book)
            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            if (!book) {
                document.getElementById('previewShares').textContent = ammOutputNum.toFixed(4);
                document.getElementById('previewPrice').textContent = ammExecutionPrice ? ammExecutionPrice.toFixed(4) : '--';
                document.getElementById('previewPayout').textContent = isBuy ? ammOutputNum.toFixed(4) + ' ETH' : '--';
                routeEl.textContent = 'AMM';
                return;
            }

            const { bids, asks } = book;
            const relevantLevels = isBuy ? asks : bids;

            // Simulate routing through orderbook depth levels then AMM
            let sharesFromPool = 0;
            let ethFromPool = 0;
            let remainingAmount = amount;
            let poolLevelsUsed = 0;

            if (relevantLevels && relevantLevels.length > 0 && ammExecutionPrice !== null) {
                for (const level of relevantLevels) {
                    if (remainingAmount <= 0) break;

                    // Check if level price is better than AMM
                    const isBetter = isBuy ? level.price <= ammExecutionPrice : level.price >= ammExecutionPrice;
                    if (!isBetter) continue;

                    const levelDepth = Number(level.depth) / 1e18;
                    poolLevelsUsed++;

                    if (isBuy) {
                        // Buy: spend ETH to get shares from asks
                        const levelCost = levelDepth * level.price;
                        if (remainingAmount >= levelCost) {
                            sharesFromPool += levelDepth;
                            remainingAmount -= levelCost;
                        } else {
                            const partialShares = remainingAmount / level.price;
                            sharesFromPool += partialShares;
                            remainingAmount = 0;
                        }
                    } else {
                        // Sell: sell shares to bids for ETH
                        if (remainingAmount >= levelDepth) {
                            ethFromPool += levelDepth * level.price;
                            remainingAmount -= levelDepth;
                        } else {
                            ethFromPool += remainingAmount * level.price;
                            remainingAmount = 0;
                        }
                    }
                }
            }

            // Calculate final output including both pool and AMM portions
            let totalShares, avgPrice, profit;

            if (isBuy) {
                let ammShares = 0n;
                if (remainingAmount > 0) {
                    const remainingWei = ethers.parseEther(remainingAmount.toFixed(18));
                    ammShares = currentTrade.isYes
                        ? quoteBuyYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                }
                totalShares = sharesFromPool + Number(ammShares) / 1e18;
                avgPrice = totalShares > 0 ? amount / totalShares : 0;
                profit = totalShares - amount;
            } else {
                let ammEth = 0n;
                if (remainingAmount > 0) {
                    const remainingWei = ethers.parseEther(remainingAmount.toFixed(18));
                    ammEth = currentTrade.isYes
                        ? quoteSellYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                }
                const totalEth = ethFromPool + Number(ammEth) / 1e18;
                totalShares = amount;
                avgPrice = totalEth / amount;
                profit = totalEth;
            }

            // Update route indicator
            if (poolLevelsUsed > 0) {
                const ammOnlyOutput = isBuy
                    ? (currentTrade.isYes ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo))
                    : (currentTrade.isYes ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo));
                const ammOnlyNum = Number(ammOnlyOutput) / 1e18;
                const savings = ammOnlyNum > 0
                    ? (isBuy ? ((totalShares / ammOnlyNum - 1) * 100).toFixed(1) : ((profit / ammOnlyNum - 1) * 100).toFixed(1))
                    : '0.0';
                const savingsStr = parseFloat(savings) > 0 ? ` (+${savings}%)` : '';
                const routeText = remainingAmount > 0 ? `Pool + AMM` : `Pool`;
                routeEl.innerHTML = `<span style="color:var(--green);">${routeText}</span><span style="color:var(--green);font-size:10px;">${savingsStr}</span>`;
            } else {
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--text-muted)';
            }

            if (isBuy) {
                document.getElementById('previewShares').textContent = totalShares.toFixed(4);
                document.getElementById('previewPrice').textContent = avgPrice.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').textContent = (profit > 0 ? '+' : '') + profit.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').style.color = 'var(--green)';
            } else {
                // For sells: profit = totalEth received
                document.getElementById('previewShares').textContent = profit.toFixed(4) + ' ETH';
                document.getElementById('previewPrice').textContent = avgPrice.toFixed(4) + ' ETH';
                const minReceived = profit * (100 - slippageTolerance) / 100;
                document.getElementById('previewPayout').textContent = minReceived.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').style.color = 'var(--text-muted)';
            }
        }

        function updateSwapPreview() {
            const amount = parseFloat(document.getElementById('swapAmount').value) || 0;

            if (!currentTrade.marketId || amount <= 0 || currentTrade.rYes === 0n || currentTrade.rNo === 0n) {
                document.getElementById('swapOutput').textContent = '--';
                document.getElementById('swapFee').textContent = '--';
                document.getElementById('swapMinOutput').textContent = '--';
                return;
            }

            const amtWei = ethers.parseEther(amount.toString());
            const output = currentSwapDirection
                ? getAmountOut(amtWei, currentTrade.rYes, currentTrade.rNo)
                : getAmountOut(amtWei, currentTrade.rNo, currentTrade.rYes);
            const outputNum = Number(output) / 1e18;
            const fee = amount * 0.003;
            const minOut = outputNum * (1 - swapSlippage / 100);
            const outputSide = currentSwapDirection ? 'NO' : 'YES';

            document.getElementById('swapOutput').textContent = outputNum.toFixed(4) + ' ' + outputSide;
            document.getElementById('swapFee').textContent = fee.toFixed(6) + ' (included)';
            document.getElementById('swapMinOutput').textContent = minOut.toFixed(4) + ' ' + outputSide;
        }

        function updateLpPreview() {
            const amount = parseFloat(document.getElementById('lpAmount').value) || 0;
            const rYes = currentTrade.rYes || 0n;
            const rNo = currentTrade.rNo || 0n;
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;

            // Get total LP supply and user LP balance
            const hasActualSupply = currentUserPosition.lpTotalSupply !== null && currentUserPosition.lpTotalSupply > 0n;
            const totalLpSupply = hasActualSupply
                ? Number(currentUserPosition.lpTotalSupply) / 1e18
                : Math.sqrt(rYesNum * rNoNum);
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;

            if (!currentTrade.marketId || amount <= 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                document.getElementById('lpShareChange').textContent = '';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP provider
                document.getElementById('lpPreview').textContent = '~' + amount.toFixed(4) + ' LP';
                document.getElementById('lpPoolShare').textContent = '100%';
                document.getElementById('lpShareChange').textContent = '(+100%)';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: estimate LP tokens
                // splitAndAddLiquidity adds equal YES+NO, so LP = min(amt/rYes, amt/rNo) * supply
                const maxReserve = Math.max(rYesNum, rNoNum);
                const estLp = maxReserve > 0 ? (amount / maxReserve) * totalLpSupply : amount;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = '~' + estLp.toFixed(4) + ' LP';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta > 0 ? `(+${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
            } else {
                // Removing liquidity: LP tokens -> ETH
                if (amount > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    document.getElementById('lpShareChange').textContent = '';
                    return;
                }

                // Calculate ETH out from burning LP
                const shareOfPool = totalLpSupply > 0 ? amount / totalLpSupply : 0;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;
                const ethOut = Math.min(yesOut, noOut);

                // Calculate new share after removal
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newUserLp = userLp - amount;
                const newTotalLp = totalLpSupply - amount;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = '~' + ethOut.toFixed(4) + ' ETH';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta !== 0 ? `(${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = shareDelta < 0 ? 'var(--red)' : 'var(--text-muted)';
            }
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const amount = parseFloat(document.getElementById('limitAmount').value) || 0;

            // Update odds display (price as percentage)
            const oddsDisplay = document.getElementById('limitOddsDisplay');
            if (price > 0 && price < 1) {
                oddsDisplay.textContent = (price * 100).toFixed(0) + '%';
            } else {
                oddsDisplay.textContent = '--';
            }

            // Calculate pool price
            let poolPrice = null;
            if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                const yesPrice = Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo);
                poolPrice = currentTrade.isYes ? yesPrice : (1 - yesPrice);
                document.getElementById('limitPoolPrice').textContent = (poolPrice * 100).toFixed(1) + '%';
            } else {
                document.getElementById('limitPoolPrice').textContent = '--';
            }

            if (price <= 0 || amount <= 0) {
                document.getElementById('limitResult').textContent = '--';
                document.getElementById('limitSavings').textContent = '--';
                return;
            }

            if (limitIsBuy) {
                // BUY: User spends ETH, receives shares
                // shares = ETH / price
                const shares = amount / price;
                document.getElementById('limitResult').textContent = shares.toFixed(4) + ' shares';

                // Compare to pool: how many shares would pool ACTUALLY give (with slippage)?
                if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                    const amtWei = ethers.parseEther(amount.toString());
                    const poolSharesWei = currentTrade.isYes
                        ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                    const poolShares = Number(poolSharesWei) / 1e18;
                    const extraShares = shares - poolShares;
                    if (extraShares > 0) {
                        document.getElementById('limitSavings').textContent = '+' + extraShares.toFixed(4) + ' shares';
                        document.getElementById('limitSavings').style.color = 'var(--green)';
                    } else {
                        document.getElementById('limitSavings').textContent = extraShares.toFixed(4) + ' shares';
                        document.getElementById('limitSavings').style.color = 'var(--red)';
                    }
                } else {
                    document.getElementById('limitSavings').textContent = '--';
                }
            } else {
                // SELL: User sells shares, receives ETH
                // ETH = shares * price
                const ethReceived = amount * price;
                document.getElementById('limitResult').textContent = ethReceived.toFixed(4) + ' ETH';

                // Compare to pool: how much ETH would pool ACTUALLY give (with slippage)?
                if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                    const amtWei = ethers.parseEther(amount.toString());
                    const poolEthWei = currentTrade.isYes
                        ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                    const poolEth = Number(poolEthWei) / 1e18;
                    const extraEth = ethReceived - poolEth;
                    if (extraEth > 0) {
                        document.getElementById('limitSavings').textContent = '+' + extraEth.toFixed(4) + ' ETH';
                        document.getElementById('limitSavings').style.color = 'var(--green)';
                    } else {
                        document.getElementById('limitSavings').textContent = extraEth.toFixed(4) + ' ETH';
                        document.getElementById('limitSavings').style.color = 'var(--red)';
                    }
                } else {
                    document.getElementById('limitSavings').textContent = '--';
                }
            }
        }

        // ======================== AMM MATH ========================
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            return collateralIn + yesFromSwap;
        }

        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            return collateralIn + noFromSwap;
        }

        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Binary search for optimal swap amount
            // Goal: find x where (yesIn - x) == getAmountOut(x, rYes, rNo)
            if (yesIn === 0n) return 0n;
            let lo = 0n, hi = yesIn;
            for (let i = 0; i < 64; i++) {
                const mid = (lo + hi) / 2n;
                const noFromSwap = getAmountOut(mid, rYes, rNo, feeBps);
                const yesRemaining = yesIn - mid;
                if (yesRemaining > noFromSwap) {
                    lo = mid + 1n;
                } else {
                    hi = mid;
                }
            }
            const noFromSwap = getAmountOut(lo, rYes, rNo, feeBps);
            const yesRemaining = yesIn - lo;
            return yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
        }

        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Binary search for optimal swap amount
            // Goal: find x where (noIn - x) == getAmountOut(x, rNo, rYes)
            if (noIn === 0n) return 0n;
            let lo = 0n, hi = noIn;
            for (let i = 0; i < 64; i++) {
                const mid = (lo + hi) / 2n;
                const yesFromSwap = getAmountOut(mid, rNo, rYes, feeBps);
                const noRemaining = noIn - mid;
                if (noRemaining > yesFromSwap) {
                    lo = mid + 1n;
                } else {
                    hi = mid;
                }
            }
            const yesFromSwap = getAmountOut(lo, rNo, rYes, feeBps);
            const noRemaining = noIn - lo;
            return noRemaining < yesFromSwap ? noRemaining : yesFromSwap;
        }

        // ======================== EXECUTE FUNCTIONS ========================
        // Uses MasterRouter.buyWithSweep/sellWithSweep for optimal routing
        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('tradeAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            const isBuy = currentTradeDirection === 'buy';
            const side = currentTrade.isYes ? 'YES' : 'NO';

            // For sells, validate balance first
            if (!isBuy) {
                const balance = currentTrade.isYes
                    ? currentUserPosition.yesBalance
                    : currentUserPosition.noBalance;
                const amtToSell = tradeMaxRaw || ethers.parseEther(amount.toString());
                if (!balance || amtToSell > balance) {
                    showToast('Insufficient Balance', `You don't have enough ${side} shares`, 'error');
                    return;
                }
            }

            // Refresh pool state before trade to ensure fresh prices
            await refreshPoolState();

            try {
                if (!isBuy) {
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, await getReadProvider());

                // Use exact raw value if max was clicked, otherwise parse input
                const amtWei = (!isBuy && tradeMaxRaw) ? tradeMaxRaw : ethers.parseEther(amount.toString());
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                // Get quote from quoter for expected output
                let expectedOutput;
                let txPromise;

                if (isBuy) {
                    // maxPriceBps: apply slippage as max price willing to pay (spot + slippage)
                    const spotPriceBps = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                        ? (currentTrade.isYes
                            ? Number(currentTrade.rNo * 10000n / (currentTrade.rYes + currentTrade.rNo))
                            : Number(currentTrade.rYes * 10000n / (currentTrade.rYes + currentTrade.rNo)))
                        : 5000;
                    const maxPriceBps = Math.min(9900, Math.floor(spotPriceBps * (1 + slippageTolerance / 100)));

                    // Quote the buy
                    const quote = await quoter.quoteBuyWithSweep(currentTrade.marketId, currentTrade.isYes, amtWei, maxPriceBps);
                    expectedOutput = quote.totalSharesOut;
                    const minOutput = expectedOutput * BigInt(100 - slippageTolerance) / 100n;

                    txPromise = masterRouter.buyWithSweep(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        amtWei,
                        minOutput,
                        maxPriceBps,
                        connectedAddress,
                        deadline,
                        { value: amtWei }
                    );
                } else {
                    // minPriceBps: apply slippage as min price willing to accept (spot - slippage)
                    const spotPriceBps = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                        ? (currentTrade.isYes
                            ? Number(currentTrade.rNo * 10000n / (currentTrade.rYes + currentTrade.rNo))
                            : Number(currentTrade.rYes * 10000n / (currentTrade.rYes + currentTrade.rNo)))
                        : 5000;
                    const minPriceBps = Math.max(100, Math.floor(spotPriceBps * (1 - slippageTolerance / 100)));

                    // Quote the sell
                    const quote = await quoter.quoteSellWithSweep(currentTrade.marketId, currentTrade.isYes, amtWei, minPriceBps);
                    expectedOutput = quote.totalCollateralOut;
                    const minOutput = expectedOutput * BigInt(100 - slippageTolerance) / 100n;

                    txPromise = masterRouter.sellWithSweep(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        amtWei,
                        minOutput,
                        minPriceBps,
                        connectedAddress,
                        deadline
                    );
                }

                const expectedOutputNum = Number(expectedOutput) / 1e18;
                await monitorTransaction(txPromise, {
                    pending: { title: `${isBuy ? 'Buying' : 'Selling'} ${side}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${isBuy ? 'Buying' : 'Selling'} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Complete!', body: isBuy ? `Bought ~${expectedOutputNum.toFixed(4)} ${side} shares for ${amount} ETH` : `Sold ${amount} ${side} shares for ~${expectedOutputNum.toFixed(4)} ETH` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        tradeMaxRaw = null; // Clear max flag
                        await Promise.all([refreshPoolState(), loadUserPosition(), loadOrderbook(), loadData()]);
                        loadBalance();
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) console.error('Trade error:', e);
            } finally {
                tradeMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function executeSwap() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('swapAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            // Check balance - use exact raw value if max was clicked, otherwise parse input
            const sourceBalance = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
            const amtWei = swapMaxRaw || ethers.parseEther(amount.toString());
            if (amtWei > sourceBalance) {
                showToast('Insufficient Balance', `You don't have enough ${currentSwapDirection ? 'YES' : 'NO'} shares`, 'error');
                return;
            }

            const fromLabel = currentSwapDirection ? 'YES' : 'NO';
            const toLabel = currentSwapDirection ? 'NO' : 'YES';

            // Refresh pool state before swap to ensure fresh prices
            await refreshPoolState();

            try {
                // Need ZAMM approved as operator on PAMM
                const approved = await checkAndRequestApprovals('swap');
                if (!approved) return;

                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const yesId = currentTrade.yesId;
                const noId = currentTrade.noId;
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;

                const poolKey = {
                    id0: id0,
                    id1: id1,
                    token0: PAMM_ADDRESS,
                    token1: PAMM_ADDRESS,
                    feeOrHook: FEE_TIER
                };

                const yesIsToken0 = yesId === id0;
                const zeroForOne = currentSwapDirection ? yesIsToken0 : !yesIsToken0;

                // Calculate min output with slippage
                const output = currentSwapDirection
                    ? getAmountOut(amtWei, currentTrade.rYes, currentTrade.rNo)
                    : getAmountOut(amtWei, currentTrade.rNo, currentTrade.rYes);
                const minOut = output * BigInt(Math.floor((1 - swapSlippage / 100) * 10000)) / 10000n;

                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                await monitorTransaction(
                    zamm.swapExactIn(poolKey, amtWei, minOut, zeroForOne, connectedAddress, deadline),
                    {
                        pending: { title: `Swap ${fromLabel} ‚Üí ${toLabel}`, body: 'Confirm in your wallet...' },
                        submitted: { title: `Swap ${fromLabel} ‚Üí ${toLabel}`, body: 'Waiting for confirmation...' },
                        success: { title: 'Swap Complete!', body: `Swapped ${amount} ${fromLabel} ‚Üí ${toLabel}` },
                        error: { title: 'Swap Failed', body: '' },
                        onSuccess: async () => {
                            swapMaxRaw = null; // Clear max flag
                            await Promise.all([refreshPoolState(), loadUserPosition(), loadData()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) console.error('Swap error:', e);
            } finally {
                swapMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('lpAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            // Use exact raw value if max was clicked, otherwise parse input
            const amtWei = lpMaxRaw || ethers.parseEther(amount.toString());

            // Validate balance for LP remove
            if (currentLpMode === 'remove') {
                const lpBal = currentUserPosition.lpBalance;
                if (!lpBal || amtWei > lpBal) {
                    showToast('Insufficient LP', 'You don\'t have enough LP tokens', 'error');
                    return;
                }
            }

            // Validate pool exists for adding liquidity
            if (currentLpMode === 'add' && (!currentTrade.rYes || currentTrade.rYes === 0n)) {
                showToast('Pool Not Seeded', 'This market has no liquidity pool yet', 'error');
                return;
            }

            // Refresh pool state before LP action to ensure fresh reserves
            await refreshPoolState();

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                // Calculate expected outputs for slippage protection
                const rYesNum = Number(currentTrade.rYes) / 1e18;
                const rNoNum = Number(currentTrade.rNo) / 1e18;
                // Use actual LP supply if available, otherwise estimate from reserves (only accurate for initial add)
                const hasActualSupply = currentUserPosition.lpTotalSupply !== null && currentUserPosition.lpTotalSupply > 0n;
                const totalLpSupply = hasActualSupply
                    ? Number(currentUserPosition.lpTotalSupply) / 1e18
                    : Math.sqrt(rYesNum * rNoNum);

                if (currentLpMode === 'add') {
                    // Use PMHookRouter.provideLiquidity for adding to vault + AMM
                    const pmHookRouter = new ethers.Contract(PMHOOKROUTER_ADDRESS, PMHOOKROUTER_ABI, signer);

                    // Split ETH between vault (for bootstrap) and AMM
                    // Default: 50% to vault (YES + NO), 50% to AMM
                    const vaultShare = amtWei / 4n; // 25% to YES vault, 25% to NO vault
                    const ammShare = amtWei / 2n;   // 50% to AMM

                    // Calculate minimum outputs with slippage
                    const maxReserve = Math.max(rYesNum, rNoNum);
                    const estLp = maxReserve > 0 && hasActualSupply
                        ? (amount / 2 / maxReserve) * totalLpSupply
                        : amount / 2;
                    const minAmmLiquidity = hasActualSupply && maxReserve > 0
                        ? ethers.parseEther((estLp * (100 - slippageTolerance) / 100).toFixed(18))
                        : 0n;

                    await monitorTransaction(
                        pmHookRouter.provideLiquidity(
                            currentTrade.marketId,
                            amtWei,         // Total collateral
                            vaultShare,     // vaultYesShares
                            vaultShare,     // vaultNoShares
                            ammShare,       // ammLPShares
                            0n,             // minAmount0
                            0n,             // minAmount1
                            connectedAddress,
                            deadline,
                            { value: amtWei }
                        ),
                        {
                            pending: { title: 'Adding Liquidity', body: 'Providing to vault + AMM...' },
                            submitted: { title: 'Adding Liquidity', body: 'Waiting for confirmation...' },
                            success: { title: 'Liquidity Added!', body: `Added ${amount} ETH to vault + AMM` },
                            error: { title: 'Add Liquidity Failed', body: '' },
                            onSuccess: async () => {
                                lpMaxRaw = null; // Clear max flag
                                await Promise.all([refreshPoolState(), loadUserPosition(), loadData()]);
                                loadBalance();
                            }
                        }
                    );
                } else {
                    // Need PAMM approved as operator on ZAMM for LP removal
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    // Calculate minimum collateral out with slippage protection
                    const shareOfPool = totalLpSupply > 0 ? amount / totalLpSupply : 0;
                    const yesOut = shareOfPool * rYesNum;
                    const noOut = shareOfPool * rNoNum;
                    const estEthOut = Math.min(yesOut, noOut);
                    const minCollateral = ethers.parseEther((estEthOut * (100 - slippageTolerance) / 100).toFixed(18));

                    // Check if market is resolved and user has direct winning tokens
                    const market = await pamm.getMarket(currentTrade.marketId);
                    const isResolved = market[2]; // resolved
                    const outcome = market[3]; // outcome (true = YES won)

                    // Check for direct winning token holdings (beyond LP)
                    let hasDirectWinnings = false;
                    if (isResolved) {
                        const winningBalance = outcome
                            ? currentUserPosition.yesBalance
                            : currentUserPosition.noBalance;
                        hasDirectWinnings = winningBalance > 0n;
                    }

                    let txPromise;
                    if (isResolved && hasDirectWinnings) {
                        // Use multicall to batch LP removal + claim
                        const pammInterface = new ethers.Interface(PAMM_ABI);
                        const calls = [
                            pammInterface.encodeFunctionData('removeLiquidityToCollateral', [
                                currentTrade.marketId,
                                FEE_TIER,
                                amtWei,
                                0n, 0n, minCollateral,
                                connectedAddress,
                                deadline
                            ]),
                            pammInterface.encodeFunctionData('claim', [
                                currentTrade.marketId,
                                connectedAddress
                            ])
                        ];
                        txPromise = pamm.multicall(calls);
                    } else {
                        txPromise = pamm.removeLiquidityToCollateral(
                            currentTrade.marketId,
                            FEE_TIER,
                            amtWei,
                            0n, 0n, minCollateral,
                            connectedAddress,
                            deadline
                        );
                    }

                    const actionTitle = hasDirectWinnings ? 'Withdrawing All' : 'Removing Liquidity';
                    const successBody = hasDirectWinnings
                        ? 'LP and winnings returned to your wallet'
                        : 'Withdrew liquidity from the pool';

                    await monitorTransaction(txPromise, {
                        pending: { title: actionTitle, body: 'Confirm in your wallet...' },
                        submitted: { title: actionTitle, body: 'Waiting for confirmation...' },
                        success: { title: 'Success!', body: successBody },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            lpMaxRaw = null; // Clear max flag
                            await Promise.all([refreshPoolState(), loadUserPosition(), loadData()]);
                            loadBalance();
                        }
                    });
                }
            } catch (e) {
                if (!isUserRejection(e)) console.error('LP error:', e);
            } finally {
                lpMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function claimWinnings(marketId) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const rpc = await getReadProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);

                // Check if user has any winning tokens to claim
                const market = await pamm.getMarket(marketId);
                const outcome = market[3]; // true = YES won
                const yesId = BigInt(marketId);
                const noId = await pamm.getNoId(marketId);
                const winningId = outcome ? yesId : noId;
                const balance = await pamm.balanceOf(connectedAddress, winningId);

                if (balance === 0n) {
                    showToast('Nothing to Claim', `You don't have any ${outcome ? 'YES' : 'NO'} shares to claim`, 'info');
                    return;
                }

                const pammSigner = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                await monitorTransaction(
                    pammSigner.claim(marketId, connectedAddress),
                    {
                        pending: { title: 'Claiming Winnings', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Claiming Winnings', body: 'Waiting for confirmation...' },
                        success: { title: 'Winnings Claimed!', body: 'Your winnings have been sent to your wallet' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) console.error('Claim failed:', e);
            }
        }

        // Uses MasterRouter.mintAndPool for buy orders, depositSharesToPool for sell orders
        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) return;

            const price = parseFloat(document.getElementById('limitPrice').value);
            const amount = parseFloat(document.getElementById('limitAmount').value);

            if (!price || price <= 0 || price >= 1) {
                showToast('Invalid Price', 'Enter price between 0.01 and 0.99', 'error');
                return;
            }
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Enter a valid amount', 'error');
                return;
            }

            // Convert price to BPS for MasterRouter
            const priceBps = Math.floor(price * 10000);

            // Calculate shares and collateral based on order type
            const WAD = 10n ** 18n;
            let sharesWei, collateralWei;

            if (limitIsBuy) {
                // BUY: user provides ETH (amount), mints shares and pools opposite side
                collateralWei = limitMaxRaw || ethers.parseEther(amount.toString());
                sharesWei = collateralWei * 10000n / BigInt(priceBps);
            } else {
                // SELL: user provides shares (amount), deposits to pool at price
                sharesWei = limitMaxRaw || ethers.parseEther(amount.toString());
                collateralWei = sharesWei * BigInt(priceBps) / 10000n;

                // Check balance
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                if (sharesWei > userShares) {
                    showToast('Insufficient Shares', `You don't have enough shares`, 'error');
                    return;
                }
            }

            // Calculate display values for toast message
            const shares = Number(sharesWei) / 1e18;
            const collateral = Number(collateralWei) / 1e18;

            try {
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('limit');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);

                const orderType = limitIsBuy ? 'Buy' : 'Sell';
                const displayPrice = (price * 100).toFixed(0) + '%';
                let txPromise;

                if (limitIsBuy) {
                    // mintAndPool: mints shares and pools the opposite side at the given price
                    // keepYes=true means we want YES shares, so we pool NO at (1-price)
                    // keepYes=false means we want NO shares, so we pool YES at price
                    // The priceInBps is for the side being pooled
                    const keepYes = currentTrade.isYes;
                    const poolPriceBps = keepYes ? (10000 - priceBps) : priceBps;

                    txPromise = masterRouter.mintAndPool(
                        currentTrade.marketId,
                        collateralWei,
                        keepYes,
                        poolPriceBps,
                        connectedAddress,
                        { value: collateralWei }
                    );
                } else {
                    // depositSharesToPool: deposits existing shares to pool at price
                    txPromise = masterRouter.depositSharesToPool(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        sharesWei,
                        priceBps,
                        connectedAddress
                    );
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `Placing ${orderType} Order`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Placing ${orderType} Order`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Placed!', body: `${orderType} ${shares.toFixed(2)} shares at ${displayPrice}` },
                    error: { title: 'Order Failed', body: '' },
                    onSuccess: async () => {
                        document.getElementById('limitAmount').value = '';
                        limitMaxRaw = null; // Clear max flag
                        setDefaultLimitPrice();
                        updateLimitPreview();
                        await Promise.all([loadUserPosition(), loadOrderbook()]);
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) console.error('Limit order error:', e);
            }
            limitMaxRaw = null; // Clear max flag regardless of outcome
        }

        // ======================== APPROVALS ========================
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                let success = false;
                await monitorTransaction(contract.setOperator(operatorAddress, true), {
                    pending: { title: `Approving ${operatorName}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Approving ${operatorName}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Approved!', body: `${operatorName} can now manage your shares` },
                    error: { title: 'Approval Failed', body: '' },
                    onSuccess: () => { success = true; }
                });

                return success;
            } catch (e) {
                if (!isUserRejection(e)) console.error('Approval error:', e);
                return false;
            }
        }

        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error');
                return false;
            }

            // MasterRouter needs operator on PAMM for: sell, limit orders (depositSharesToPool)
            if (operation === 'sell' || operation === 'limit') {
                return await ensureOperatorApproval('pamm', MASTERROUTER_ADDRESS, 'MasterRouter');
            }

            // PAMM needs operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                return await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
            }

            // ZAMM needs operator on PAMM for: swap
            if (operation === 'swap') {
                return await ensureOperatorApproval('pamm', ZAMM_ADDRESS, 'ZAMM');
            }

            // PMHookRouter needs operator on PAMM for: LP via vault
            if (operation === 'lp_vault') {
                return await ensureOperatorApproval('pamm', PMHOOKROUTER_ADDRESS, 'PMHookRouter');
            }

            return true;
        }

        // ======================== TX MONITORING ========================
        async function monitorTransaction(txPromise, options = {}) {
            const {
                pending = { title: 'Transaction Pending', body: 'Confirm in your wallet...' },
                submitted = { title: 'Transaction Submitted', body: 'Waiting for confirmation...' },
                success = { title: 'Transaction Confirmed', body: '' },
                error = { title: 'Transaction Failed', body: '' },
                onSuccess = null
            } = options;

            const toastId = showToast(pending.title, pending.body, 'pending');
            let txHash = null;

            try {
                const tx = await txPromise;
                txHash = tx.hash;
                const etherscanLink = `<a href="https://etherscan.io/tx/${txHash}" target="_blank" style="color:var(--blue);">View on Etherscan</a>`;
                updateToast(toastId, submitted.title, `${submitted.body}<br>${etherscanLink}`, 'pending');

                // Wait for confirmation using dedicated RPC
                const rpc = await getRpcProvider();
                const receipt = await Promise.race([
                    rpc.waitForTransaction(txHash, 1, 60000),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 65000))
                ]);

                if (receipt && Number(receipt.status) === 1) {
                    updateToast(toastId, success.title, `${success.body}${success.body ? '<br>' : ''}${etherscanLink}`, 'success', 5000);
                    invalidatePositionCache(); // Clear cached positions after successful tx
                    if (onSuccess) await onSuccess(receipt);
                    return receipt;
                } else if (receipt && Number(receipt.status) === 0) {
                    updateToast(toastId, error.title, `Transaction reverted<br>${etherscanLink}`, 'error', 8000);
                    throw new Error('Transaction reverted');
                } else {
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded<br>${etherscanLink}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                }
            } catch (e) {
                console.error('Transaction error:', e);
                if (isUserRejection(e)) {
                    updateToast(toastId, 'Transaction Cancelled', 'You rejected the transaction', 'error', 4000);
                } else if (e.message === 'timeout') {
                    const etherscanLink = txHash ? `<a href="https://etherscan.io/tx/${txHash}" target="_blank" style="color:var(--blue);">View on Etherscan</a>` : '';
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded${etherscanLink ? '<br>' + etherscanLink : ''}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                } else {
                    const errMsg = e.reason || e.message || 'Unknown error';
                    updateToast(toastId, error.title, errMsg.slice(0, 100), 'error', 8000);
                }
                throw e;
            }
        }

        // ======================== MARKET CREATION ========================
        // Helper to get end of current week (Sunday 23:59:59 UTC)
        function getEndOfWeekTimestamp() {
            const now = new Date();
            const dayOfWeek = now.getUTCDay(); // 0 = Sunday, 6 = Saturday
            const daysUntilSunday = dayOfWeek === 0 ? 0 : 7 - dayOfWeek;
            const endOfWeek = new Date(Date.UTC(
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate() + daysUntilSunday,
                23, 59, 59
            ));
            return Math.floor(endOfWeek.getTime() / 1000);
        }

        function formatDeadlineDate(timestamp) {
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                timeZone: 'UTC'
            }) + ' UTC';
        }

        function updateCreatePreview() {
            const threshold = document.getElementById('createThreshold').value || '40';
            const deadlineSelect = document.getElementById('createDeadline').value;
            const canClose = document.getElementById('createCanClose').value === 'true';

            document.getElementById('customDeadlineGroup').style.display = deadlineSelect === 'custom' ? 'block' : 'none';

            let deadlineStr;
            if (deadlineSelect === 'eow') {
                deadlineStr = formatDeadlineDate(getEndOfWeekTimestamp());
            } else if (deadlineSelect === 'eoy2025') {
                deadlineStr = 'Dec 31, 2025 23:59:59 UTC';
            } else {
                const customTs = document.getElementById('createCustomDeadline').value;
                if (customTs) {
                    deadlineStr = formatDeadlineDate(parseInt(customTs));
                } else {
                    deadlineStr = '--';
                }
            }

            document.getElementById('createPreview').innerHTML =
                `PNKSTR CryptoPunks >= ${threshold} by ${deadlineStr}` +
                (canClose ? ' <span style="color:var(--amber);">(may close early)</span>' : '');
        }

        async function createMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            const threshold = parseInt(document.getElementById('createThreshold').value);
            const deadlineSelect = document.getElementById('createDeadline').value;
            const canClose = document.getElementById('createCanClose').value === 'true';
            const seedEth = parseFloat(document.getElementById('createSeed').value);

            if (!threshold || threshold < 1) {
                showToast('Invalid Threshold', 'Please enter a valid threshold', 'error');
                return;
            }

            if (!seedEth || seedEth < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001 ETH', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eow') {
                close = getEndOfWeekTimestamp();
            } else if (deadlineSelect === 'eoy2025') {
                close = EOY_2025;
            } else {
                close = parseInt(document.getElementById('createCustomDeadline').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = document.querySelector('.create-btn');
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = ethers.parseEther(seedEth.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // callData for balanceOf(PNKSTR)
                const callData = PNKSTR_BALANCE_CALLDATA;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                // Observable string for on-chain description
                const deadlineLabel = deadlineSelect === 'eow' ? 'EOW' : (deadlineSelect === 'eoy2025' ? 'EOY25' : 'custom');
                const observable = `PNKSTR Punks >= ${threshold} (${deadlineLabel})`;

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    ethers.ZeroAddress, // ETH collateral
                    CRYPTOPUNKS_ADDRESS,
                    callData,
                    3, // Op.GE (greater than or equal) - index 3 in [LT, GT, LE, GE, EQ, NE]
                    BigInt(threshold),
                    BigInt(close),
                    canClose,
                    seedParams,
                    { value: seedWei }
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank">View on Etherscan</a>`, 'pending');

                const receipt = await tx.wait();

                // Clear discovered markets cache to force refresh
                discoveredPnkstrMarkets = [];
                lastMarketDiscoveryBlock = 0;

                showToast('Market Created', 'Your market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Creation Failed', error.reason || error.message || 'Transaction failed', 'error');
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Market';
            }
        }

        // ======================== RESOLUTION ========================
        async function resolveMarket(marketId) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);

                await monitorTransaction(
                    resolver.resolveMarket(marketId),
                    {
                        pending: { title: 'Resolving Market', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Resolving Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Resolved!', body: 'The market has been resolved' },
                        error: { title: 'Resolution Failed', body: '' },
                        onSuccess: () => loadData()
                    }
                );

            } catch (error) {
                console.error('Resolution failed:', error);
            }
        }

        // ======================== UTILITIES ========================
        function formatEth(wei) {
            if (typeof wei === 'bigint') {
                return (Number(wei) / 1e18).toFixed(4);
            }
            return '0.0000';
        }

        function formatCountdown(seconds) {
            if (seconds <= 0) return 'Ended';

            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            return `${mins}m`;
        }

        function formatDate(unixTimestamp) {
            const date = new Date(unixTimestamp * 1000);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function escapeHtml(str) {
            return str.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
        }

        function truncateId(id) {
            if (id.length <= 12) return id;
            return id.slice(0, 6) + '...' + id.slice(-4);
        }

        function showToast(title, message, type = 'info', duration = 5000) {
            const id = ++toastIdCounter;
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.dataset.toastId = id;

            const icons = { pending: '‚è≥', success: '‚úì', error: '‚úï', info: '‚Ñπ' };

            toast.innerHTML = `
                <div class="toast-header">
                    <span class="icon">${icons[type] || icons.info}</span>
                    <span class="toast-title">${title}</span>
                </div>
                <div class="toast-body">${message}</div>
            `;

            container.appendChild(toast);
            pendingToasts.set(id, toast);

            if (type !== 'pending') {
                setTimeout(() => {
                    toast.classList.add('hiding');
                    setTimeout(() => {
                        toast.remove();
                        pendingToasts.delete(id);
                    }, 300);
                }, duration);
            } else {
                // Auto-cleanup pending toasts after 70s (just after tx monitor's 60s timeout)
                setTimeout(() => {
                    if (pendingToasts.has(id)) {
                        updateToast(id, 'Timeout', 'Transaction may still be pending. Check Etherscan.', 'info', 8000);
                    }
                }, 70000);
            }

            return id;
        }

        function updateToast(toastId, title, message, type = 'info', duration = 5000) {
            const toast = pendingToasts.get(toastId);
            if (!toast) return;

            const icons = { pending: '‚è≥', success: '‚úì', error: '‚úï', info: '‚Ñπ' };
            toast.className = `toast ${type}`;

            const titleEl = toast.querySelector('.toast-title');
            const bodyEl = toast.querySelector('.toast-body');
            const iconEl = toast.querySelector('.icon');

            if (titleEl) titleEl.textContent = title;
            if (bodyEl) bodyEl.innerHTML = message;
            if (iconEl) iconEl.textContent = icons[type] || icons.info;

            if (type !== 'pending' && duration > 0) {
                setTimeout(() => {
                    toast.classList.add('hiding');
                    setTimeout(() => {
                        toast.remove();
                        pendingToasts.delete(toastId);
                    }, 300);
                }, duration);
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
