<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>gasPM - Gas Bets</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='600' fill='%2322c55e' text-anchor='middle'>Gas</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='600' fill='%233b82f6' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --amber: #f59e0b;
            --yellow: #eab308;
            --orange: #f97316;
            --gray: #27272a;
            --light-gray: #3f3f46;
            --black: #09090b;

            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--green); }

        .tagline {
            font-size: var(--font-xs);
            color: var(--text-dim);
            margin-left: 0.75rem;
        }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.green { color: var(--green); }
        .live-stat-value.cyan { color: var(--blue); }
        .live-stat-value.amber { color: var(--amber); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--green);
            color: var(--bg);
            border-color: var(--green);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* CHART SECTION */
        .chart-section {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            overflow: visible; /* Allow tooltips to extend beyond */
        }

        .chart-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius);
            height: 260px;
            position: relative;
            overflow: visible; /* Allow tooltips to extend beyond container */
        }

        .chart-canvas { width: 100%; height: 100%; }

        .chart-expand-btn {
            position: absolute;
            top: 6px;
            right: 6px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid transparent;
            border-radius: var(--radius);
            color: var(--text-dim);
            padding: 4px 6px;
            font-size: 12px;
            cursor: pointer;
            z-index: 50;
            opacity: 0.5;
            transition: all 0.15s;
        }
        .chart-expand-btn:hover {
            background: rgba(0, 0, 0, 0.7);
            color: var(--text);
            border-color: var(--border);
            opacity: 1;
        }

        /* Chart Modal */
        .chart-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(8px);
            z-index: 3000;
            flex-direction: column;
        }
        .chart-modal-overlay.active { display: flex; }

        .chart-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }
        .chart-modal-title {
            font-size: var(--font-lg);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .chart-modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.75rem;
            cursor: pointer;
            padding: 0.25rem;
        }
        .chart-modal-close:hover { color: var(--text); }

        .chart-modal-body {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .chart-modal-canvas-container {
            flex: 1;
            background: var(--surface);
            border-radius: var(--radius);
            position: relative;
            min-height: 300px;
        }
        .chart-modal-canvas {
            width: 100%;
            height: 100%;
        }

        .chart-modal-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            background: var(--surface);
            border-radius: var(--radius);
            margin-top: 1rem;
        }
        .chart-modal-stat {
            text-align: center;
        }
        .chart-modal-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .chart-modal-stat-value {
            font-size: var(--font-lg);
            font-weight: 600;
        }

        .chart-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
        }

        .chart-tooltip.visible { opacity: 1; }
        .chart-tooltip-time {
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .chart-tooltip-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .chart-tooltip-row:last-child { margin-bottom: 0; }
        .chart-tooltip-dot { width: 6px; height: 6px; border-radius: 50%; }
        .chart-tooltip-dot.spot { background: var(--green); }
        .chart-tooltip-dot.twap { background: var(--blue); }
        .chart-tooltip-key { color: var(--text-muted); flex: 1; }
        .chart-tooltip-val { font-weight: 600; font-variant-numeric: tabular-nums; }

        /* Prediction tooltip */
        .pred-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s, transform 0.15s;
            z-index: 110;
            min-width: 190px;
            transform: translateY(5px);
        }
        .pred-tooltip.visible { opacity: 1; transform: translateY(0); }
        .pred-tooltip-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .pred-tooltip-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 10px;
        }
        .pred-tooltip-title {
            font-weight: 500;
            color: var(--text);
        }
        .pred-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.35rem;
        }
        .pred-tooltip-row:last-child { margin-bottom: 0; }
        .pred-tooltip-label { color: var(--text-muted); }
        .pred-tooltip-value { font-weight: 600; font-variant-numeric: tabular-nums; }
        .pred-tooltip-direction {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 11px;
        }
        .pred-tooltip-direction.up { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
        .pred-tooltip-direction.down { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
        .pred-tooltip-direction.neutral { background: rgba(161, 161, 170, 0.15); color: #a1a1aa; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 1100px) { .bets-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .bets-grid { grid-template-columns: 1fr; } }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--green);
        }

        .bet-card.no-market { opacity: 0.5; }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
        }

        .bet-type.hourly { color: var(--amber); }
        .bet-type.daily { color: var(--green); }
        .bet-type.weekly { color: var(--blue); }
        .bet-type.extreme { color: var(--red); }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        /* Gas Comparison Display */
        .gas-compare {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .gas-compare-point { text-align: center; }

        .gas-compare-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .gas-compare-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .gas-compare-arrow { font-size: 1.25rem; }
        .gas-compare-arrow.up { color: var(--green); }
        .gas-compare-arrow.down { color: var(--red); }

        /* Progress Bar */
        .progress-container { margin-bottom: 1rem; }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .progress-bar {
            height: 8px;
            background: var(--surface-2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--amber), var(--red));
            border-radius: 4px;
            transition: width 0.5s;
        }

        .target-display {
            font-size: var(--font-2xl);
            font-weight: 700;
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--red);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.3); }

        .bet-btn.up { border-color: var(--green); background: var(--green-dim); }
        .bet-btn.up:hover { background: var(--green); }
        .bet-btn.up:hover .bet-btn-label,
        .bet-btn.up:hover .bet-btn-odds,
        .bet-btn.up:hover .bet-btn-price { color: var(--bg); }
        .bet-btn.down { border-color: var(--red); background: var(--red-dim); }
        .bet-btn.down:hover { background: var(--red); }
        .bet-btn.down:hover .bet-btn-label,
        .bet-btn.down:hover .bet-btn-odds,
        .bet-btn.down:hover .bet-btn-price { color: var(--bg); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.up .bet-btn-label { color: var(--green); }
        .bet-btn.down .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* Position Display */
        .position-display {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            font-size: var(--font-xs);
        }

        .position-row { display: flex; justify-content: space-between; }

        /* CARD CHART TOGGLE */
        .card-chart-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            margin-top: 0.5rem;
            padding: 0.6rem 0.75rem;
            background: var(--surface-2);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text-muted);
            font-size: var(--font-xs);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .card-chart-toggle:hover {
            background: var(--surface-3);
            color: var(--text);
            border-color: var(--text-dim);
        }

        .card-chart-toggle:active {
            transform: scale(0.98);
        }

        .card-chart-toggle.active {
            background: var(--surface-3);
            border-color: var(--green);
            color: var(--green);
        }

        .card-chart-toggle-icon {
            transition: transform 0.2s ease;
            font-size: 8px;
        }

        .card-chart-toggle.active .card-chart-toggle-icon {
            transform: rotate(180deg);
        }

        .card-chart-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.2s ease;
            opacity: 0;
            margin-top: 0;
            border-radius: var(--radius);
        }

        .card-chart-container.open {
            max-height: 340px;
            opacity: 1;
            margin-top: 0.5rem;
        }

        .card-chart-container iframe {
            display: block;
            width: 100%;
            height: 280px;
            border: none;
            border-radius: var(--radius);
            background: #0a0a0a;
        }

        .card-chart-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 280px;
            background: #0a0a0a;
            border-radius: var(--radius);
            color: var(--text-dim);
            font-size: var(--font-xs);
        }

        .card-chart-expand {
            position: absolute;
            top: 6px;
            right: 6px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            z-index: 5;
            opacity: 0;
        }

        .card-chart-wrapper {
            position: relative;
            border-radius: var(--radius);
            overflow: hidden;
        }

        .card-chart-wrapper iframe {
            display: block;
            width: 100%;
            height: 280px;
            border: none;
            background: #0a0a0a;
        }

        .card-chart-wrapper:hover .card-chart-expand,
        .card-chart-wrapper:focus-within .card-chart-expand {
            opacity: 1;
        }

        .card-chart-expand:hover {
            background: rgba(0,0,0,0.8);
            color: var(--text);
            border-color: rgba(255,255,255,0.2);
        }

        @media (hover: none) {
            .card-chart-expand {
                opacity: 1;
            }
        }

        /* Odds Chart Modal */
        .odds-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(8px);
            z-index: 3000;
            flex-direction: column;
        }
        .odds-modal-overlay.active { display: flex; }

        .odds-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            background: var(--bg);
        }
        .odds-modal-title {
            font-size: var(--font-lg);
            font-weight: 600;
        }
        .odds-modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.75rem;
            cursor: pointer;
            padding: 0.25rem;
        }
        .odds-modal-close:hover { color: var(--text); }

        .odds-modal-body {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .odds-modal-iframe-container {
            flex: 1;
            background: var(--surface);
            border-radius: var(--radius);
            overflow: hidden;
            min-height: 400px;
        }
        .odds-modal-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .odds-modal-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            background: var(--surface);
            border-radius: var(--radius);
            margin-top: 1rem;
        }
        .odds-modal-stat {
            text-align: center;
        }
        .odds-modal-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .odds-modal-stat-value {
            font-size: var(--font-lg);
            font-weight: 600;
        }

        /* Depth Modal */
        .depth-modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(4px);
            z-index: 2500;
            justify-content: center;
            align-items: center;
        }
        .depth-modal-overlay.active { display: flex; }
        .depth-modal {
            background: var(--surface);
            border-radius: var(--radius);
            width: 100%;
            max-width: 520px;
            max-height: 85vh;
            overflow: hidden;
        }
        .depth-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }
        .depth-modal-title {
            font-size: var(--font-md);
            font-weight: 600;
        }
        .depth-modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .depth-modal-close:hover { color: var(--text); }
        .depth-ladder-row {
            display: grid;
            grid-template-columns: 1fr 56px 1fr;
            gap: 0;
            align-items: center;
            height: 28px;
            border-bottom: 1px solid var(--border);
        }
        .depth-ladder-row:hover { background: var(--surface-2); }
        .depth-ladder-row.amm-row { background: var(--surface-2); }
        .depth-cell {
            position: relative;
            height: 100%;
            display: flex;
            align-items: center;
            overflow: hidden;
            padding: 0 8px;
        }
        .depth-cell.clickable { cursor: pointer; }
        .depth-cell.clickable:hover { background: rgba(255,255,255,0.05); }
        .depth-bar {
            position: absolute;
            top: 0;
            bottom: 0;
            opacity: 0.3;
        }
        .depth-bar.up { background: var(--green); right: 0; }
        .depth-bar.down { background: var(--red); left: 0; }
        .depth-bar.own { opacity: 0.4; background: var(--amber); }
        .depth-center {
            text-align: center;
            font-size: 11px;
            font-weight: 700;
            color: var(--text);
            background: var(--surface);
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-left: 1px solid var(--border);
            border-right: 1px solid var(--border);
        }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .create-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1.25rem;
        }

        @media (max-width: 1100px) { .create-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .create-grid { grid-template-columns: 1fr; } }

        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--green);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        /* Orderbook - CEX/Polymarket Style */
        .orderbook {
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            overflow: hidden;
            border: 1px solid var(--border);
        }
        .orderbook-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
        }
        .orderbook-title-text {
            font-size: var(--font-xs);
            font-weight: 600;
            color: var(--text);
        }
        .orderbook-depth-info {
            font-size: 9px;
            color: var(--text-muted);
        }
        .orderbook-body {
            max-height: 220px;
            overflow-y: auto;
        }
        .orderbook-side {
            display: flex;
            flex-direction: column;
        }
        .orderbook-side.asks {
            flex-direction: column-reverse;
        }
        .orderbook-header {
            display: grid;
            grid-template-columns: 2fr 1.2fr 1.2fr;
            padding: 0.4rem 0.75rem;
            background: var(--surface);
            font-size: 9px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .orderbook-header span:last-child { text-align: right; }
        .orderbook-row {
            display: grid;
            grid-template-columns: 2fr 1.2fr 1.2fr;
            padding: 0.35rem 0.75rem;
            font-size: 11px;
            font-variant-numeric: tabular-nums;
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
        }
        .orderbook-row::before {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: var(--depth, 0%);
            opacity: 0.15;
            pointer-events: none;
            transition: width 0.2s;
        }
        .orderbook-row.ask::before { background: var(--red); }
        .orderbook-row.bid::before { background: var(--green); }
        .orderbook-row:hover { background: var(--surface-2); }
        .orderbook-row:hover::before { opacity: 0.25; }
        .orderbook-row.ask { color: var(--red); }
        .orderbook-row.bid { color: var(--green); }
        .orderbook-row .price { font-weight: 600; z-index: 1; }
        .orderbook-row .size { color: var(--text); z-index: 1; }
        .orderbook-row .total { color: var(--text-muted); text-align: right; z-index: 1; }
        .orderbook-row.mine { background: rgba(59, 130, 246, 0.1); }
        .orderbook-row.mine::after {
            content: 'YOU';
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            background: var(--blue);
            color: white;
            padding: 1px 4px;
            border-radius: 2px;
            font-weight: 600;
        }
        .orderbook-empty {
            padding: 1.5rem 1rem;
            text-align: center;
            color: var(--text-dim);
            font-size: var(--font-xs);
        }
        .orderbook-spread {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 0.75rem;
            background: var(--surface-2);
            font-size: 11px;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        .orderbook-spread-left {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .orderbook-spread-price {
            font-weight: 700;
            font-size: 14px;
            color: var(--text);
        }
        .orderbook-spread-label {
            font-size: 9px;
            color: var(--text-dim);
        }
        .orderbook-spread-right {
            text-align: right;
            font-size: 10px;
        }
        .orderbook-spread-pct {
            color: var(--text-muted);
        }
        .orderbook-row.better-deal { background: rgba(34, 197, 94, 0.1); }
        .orderbook-row.better-deal:hover { background: rgba(34, 197, 94, 0.2); }
        .orderbook-row.better-deal .price { color: var(--green); }
        .orderbook-row.better-deal::before { background: var(--green); opacity: 0.2; }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-up { background: var(--green); color: var(--bg); }
        .trade-submit.buy-down { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* STATUS */
        .status-message {
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
            border-radius: var(--radius);
            display: none;
        }

        .status-message.show { display: block; }
        .status-message.pending { background: rgba(59, 130, 246, 0.15); color: var(--blue); }
        .status-message.success { background: var(--green-dim); color: var(--green); }
        .status-message.error { background: var(--red-dim); color: var(--red); }
        .status-message.info { background: rgba(255, 136, 0, 0.15); color: var(--orange); }

        /* Wallet Options */
        .wallet-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--gray);
            border: 1px solid var(--light-gray);
            border-radius: var(--radius);
            cursor: pointer;
            margin-bottom: var(--spacing-xs);
            transition: all 0.15s ease;
        }
        .wallet-option:hover { border-color: var(--green); }
        .wallet-option-icon { font-size: 1.5rem; }
        .wallet-option-name { font-weight: 600; }
        .wallet-option.disconnect {
            border-color: var(--red);
            color: var(--red);
            justify-content: center;
        }
        .wallet-option.disconnect:hover {
            background: var(--red);
            color: var(--black);
        }

        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 380px;
            pointer-events: none;
        }
        .toast {
            padding: 1rem 1.25rem;
            border-radius: var(--radius);
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: var(--font-sm);
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-in forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toast-out {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); }
        }
        .toast-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        .toast-header .icon {
            font-size: 1.1em;
        }
        .toast.pending .toast-header { color: var(--blue); }
        .toast.success .toast-header { color: var(--green); }
        .toast.error .toast-header { color: var(--red); }
        .toast.info .toast-header { color: var(--yellow); }
        .toast-body {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }
        .toast-body a {
            color: var(--blue);
            text-decoration: underline;
        }
        .toast-progress {
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.25rem;
        }
        .toast-progress-bar {
            height: 100%;
            background: var(--blue);
            animation: progress-shrink linear forwards;
        }
        @keyframes progress-shrink {
            from { width: 100%; }
            to { width: 0%; }
        }
        .toast.pending .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border);
            border-top-color: var(--blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; }
            .header-center { gap: 1rem; }
            .chart-container { height: 220px; }
            .card-chart-container.open { max-height: 320px; }
            .card-chart-container iframe { height: 260px; }
            .card-chart-loading { height: 260px; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .bet-card, .create-card { padding: 1rem; }
            .modal {
                margin: 0.5rem;
                padding: 1rem;
                max-width: calc(100vw - 1rem);
                max-height: calc(100vh - 1rem);
            }
            .orderbook-body { max-height: 140px; }
            .trade-submit, .create-btn { min-height: 44px; }
            .bet-btn { min-height: 56px; }
        }

        @media (max-width: 480px) {
            .header {
                flex-wrap: wrap;
                justify-content: space-between;
                gap: 0.5rem;
            }
            .header-center {
                order: 3;
                width: 100%;
                justify-content: space-between;
                gap: 0.25rem;
                padding: 0.5rem 0 0;
                border-top: 1px solid var(--border);
                margin-top: 0.25rem;
            }
            .live-stat {
                flex: 1;
                min-width: 0;
            }
            .live-stat-label {
                font-size: 9px;
            }
            .live-stat-value {
                font-size: 11px;
            }
            /* Hide outlook on very small screens, keep essentials */
            .live-stat:nth-child(4) {
                display: none;
            }
            .tagline { display: none; }
            .section-title { font-size: var(--font-base); }
            .logo { font-size: var(--font-base); }

            /* Chart mobile optimizations */
            .chart-section { padding: 0.75rem; }
            .chart-container { height: 200px; border-radius: 8px; }
            .chart-tooltip, .pred-tooltip {
                font-size: 10px;
                padding: 0.4rem;
            }
            .pred-tooltip {
                min-width: 150px;
                max-width: 170px;
                pointer-events: auto; /* Allow tapping on mobile */
            }
            .pred-tooltip-header { gap: 0.25rem; margin-bottom: 0.25rem; padding-bottom: 0.25rem; }
            .pred-tooltip-badge { padding: 0.1rem 0.35rem; font-size: 8px; }
            .pred-tooltip-title { font-size: 10px; }
            .pred-tooltip-direction { padding: 0.15rem 0.35rem; font-size: 9px; }
            .pred-tooltip-row { margin-bottom: 0.15rem; font-size: 9px; }
            .pred-tooltip-label { font-size: 9px; }
            .pred-tooltip-value { font-size: 9px; }
        }

        @media (max-width: 360px) {
            .header-center {
                flex-wrap: wrap;
                gap: 0.25rem 0.5rem;
            }
            .live-stat {
                flex: 0 0 auto;
            }
            .chart-container { height: 180px; }
        }

        /* Chart modal mobile styles */
        @media (max-width: 600px) {
            .chart-modal-header {
                padding: 0.75rem 1rem;
            }
            .chart-modal-title {
                font-size: var(--font-base);
                gap: 0.5rem;
            }
            .chart-modal-body {
                padding: 0.5rem;
            }
            .chart-modal-canvas-container {
                min-height: 250px;
            }
            .chart-modal-stats {
                flex-wrap: wrap;
                gap: 1rem;
                padding: 0.75rem;
                margin-top: 0.5rem;
            }
            .chart-modal-stat {
                flex: 1 1 40%;
                min-width: 80px;
            }
            .chart-modal-stat-label {
                font-size: 10px;
            }
            .chart-modal-stat-value {
                font-size: var(--font-base);
            }
            .chart-expand-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
        }
        @media (max-width: 400px) {
            .chart-modal-stats {
                gap: 0.75rem;
            }
            .chart-modal-stat {
                flex: 1 1 45%;
            }
        }

        /* Odds modal mobile styles */
        @media (max-width: 600px) {
            .odds-modal-header {
                padding: 0.75rem 1rem;
            }
            .odds-modal-title {
                font-size: var(--font-base);
            }
            .odds-modal-body {
                padding: 0.5rem;
            }
            .odds-modal-iframe-container {
                min-height: 300px;
            }
            .odds-modal-stats {
                flex-wrap: wrap;
                gap: 1rem;
                padding: 0.75rem;
                margin-top: 0.5rem;
            }
            .odds-modal-stat {
                flex: 1 1 40%;
                min-width: 70px;
            }
            .odds-modal-stat-label {
                font-size: 10px;
            }
            .odds-modal-stat-value {
                font-size: var(--font-base);
            }
            .card-chart-toggle {
                padding: 0.7rem 0.75rem;
            }
            .card-chart-container.open {
                max-height: 280px;
            }
            .card-chart-wrapper iframe,
            .card-chart-container iframe {
                height: 220px;
            }
            .card-chart-loading {
                height: 220px;
            }
            .card-chart-expand {
                opacity: 1;
                padding: 6px 12px;
                font-size: 12px;
            }
        }

        @media (max-width: 400px) {
            .card-chart-toggle {
                padding: 0.75rem 0.75rem;
                font-size: 11px;
            }
            .card-chart-container.open {
                max-height: 240px;
            }
            .card-chart-wrapper iframe,
            .card-chart-container iframe {
                height: 180px;
            }
            .card-chart-loading {
                height: 180px;
            }
        }

        @media (max-width: 768px) {
            .tagline { display: none; }
        }

        /* Stats summary responsive */
        .stats-summary { flex-wrap: wrap; }
        @media (max-width: 600px) {
            .stats-summary { gap: 0.75rem !important; }
            .stats-summary > div { flex: 1 1 40%; }
        }

        /* Touch-friendly interactions */
        @media (hover: none) {
            .bet-btn:active, .btn:active { transform: scale(0.98); }
            .orderbook-row:active { background: var(--surface-2); }
        }

        /* Modal mode toggle buttons */
        .mode-toggle {
            display: flex;
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            padding: 3px;
        }
        .mode-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            color: var(--text-muted);
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .mode-toggle-btn.active-buy {
            background: var(--green);
            color: var(--bg);
        }
        .mode-toggle-btn.active-sell {
            background: var(--red);
            color: var(--text);
        }
        .mode-toggle-btn.active-lp {
            background: var(--blue);
            color: var(--text);
        }
        .mode-toggle-btn.active-mint {
            background: var(--amber);
            color: var(--bg);
        }
        .mode-toggle-btn.active-limit {
            background: #8b5cf6;
            color: var(--text);
        }
        .mode-toggle-btn.active-swap {
            background: #06b6d4;
            color: var(--bg);
        }

        /* LP mode toggle */
        .lp-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .lp-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .lp-toggle-btn.active-add {
            background: var(--blue);
            color: var(--text);
            border-color: var(--blue);
        }
        .lp-toggle-btn.active-remove {
            background: var(--red);
            color: var(--text);
            border-color: var(--red);
        }
        .slip-btn {
            padding: 4px 8px;
            font-size: var(--font-xs);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.15s;
        }
        .slip-btn:hover {
            border-color: var(--blue);
            color: var(--text);
        }
        .slip-btn.slip-active {
            background: var(--blue);
            border-color: var(--blue);
            color: var(--text);
        }

        @media (max-width: 768px) {
            .mode-toggle-btn, .lp-toggle-btn { min-height: 40px; }
        }
    </style>
</head>
<body>
    <!-- Toast Notifications Container -->
    <div id="toastContainer" class="toast-container"></div>

    <header class="header">
        <div class="logo">gas<span>PM</span></div>
        <span class="tagline">Bet Gas on Gas Price</span>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">Live</div>
                <div class="live-stat-value green" id="liveGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">TWAP</div>
                <div class="live-stat-value cyan" id="twapGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Min</div>
                <div class="live-stat-value" id="minGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Outlook</div>
                <div class="live-stat-value" id="predictionArrows" style="display:flex;gap:0.5rem;font-size:var(--font-sm);">
                    <span id="pred1W" title="Weekly prediction">1W --</span>
                </div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Max</div>
                <div class="live-stat-value" id="maxGas">--</div>
            </div>
        </div>
        <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
    </header>

    <main class="main">
        <!-- Chart Section -->
        <section class="chart-section">
            <div class="chart-container">
                <button class="chart-expand-btn" onclick="openChartModal()" title="Expand chart"></button>
                <canvas id="gasChart" class="chart-canvas"></canvas>
                <div class="chart-tooltip" id="chartTooltip">
                    <div class="chart-tooltip-time" id="tooltipTime">--</div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot spot"></span>
                        <span class="chart-tooltip-key">Spot</span>
                        <span class="chart-tooltip-val" id="tooltipSpot">--</span>
                    </div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot twap"></span>
                        <span class="chart-tooltip-key">TWAP</span>
                        <span class="chart-tooltip-val" id="tooltipTwap">--</span>
                    </div>
                </div>
                <div class="pred-tooltip" id="predTooltip">
                    <div class="pred-tooltip-header">
                        <span class="pred-tooltip-badge" id="predBadge">1H</span>
                        <span class="pred-tooltip-title" id="predTitle">Hourly Market</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Odds</span>
                        <span class="pred-tooltip-direction up" id="predDirection">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Threshold</span>
                        <span class="pred-tooltip-value" id="predThreshold">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Predicted</span>
                        <span class="pred-tooltip-value" id="predTwap">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Closes in</span>
                        <span class="pred-tooltip-value" id="predCloses">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">TVL</span>
                        <span class="pred-tooltip-value" id="predTvl">--</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Bets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Bets</h2>
            <div class="stats-summary" style="display:flex;justify-content:center;gap:2rem;padding:0.875rem;margin-bottom:1rem;background:var(--surface);border-radius:var(--radius);">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">TVL</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--blue);" id="totalPoolTvl">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Orderbook</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="totalOrderbookLiq">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Markets</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeMarketsCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Resolved</div>
                    <a href="#" onclick="toggleResolved();return false;" id="resolvedMarketsCount" title="Click to view resolved markets" style="font-size:var(--font-lg);font-weight:600;color:var(--text-muted);text-decoration:none;cursor:pointer;transition:color 0.15s;" onmouseover="this.style.color='var(--green)'" onmouseout="this.style.color='var(--text-muted)'">0 </a>
                </div>
            </div>
            <div class="bets-grid">
                <!-- Weekly Card -->
                <div class="bet-card" id="weeklyCard">
                    <div class="bet-header">
                        <span class="bet-type weekly">Weekly</span>
                    </div>
                    <div class="bet-title">This Week's Gas</div>
                    <div class="bet-question">Will gas go up or down this week?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="weeklyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="weeklyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">TWAP</div>
                            <div class="gas-compare-value" id="weeklyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('weekly', true)">
                            <div class="bet-btn-label">Buy Up</div>
                            <div class="bet-btn-odds" id="weeklyUpOdds">--</div>
                            <div class="bet-btn-price" id="weeklyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('weekly', false)">
                            <div class="bet-btn-label">Buy Down</div>
                            <div class="bet-btn-odds" id="weeklyDownOdds">--</div>
                            <div class="bet-btn-price" id="weeklyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends Sunday UTC</span>
                        <span class="countdown-value" id="weeklyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="weeklyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="weeklyOrderbook" style="color:var(--amber);">--</span></span>
                        <a id="weeklyZammLink" href="#" target="_blank" title="View on ZAMM" style="display:none;align-items:center;gap:3px;color:var(--text-muted);text-decoration:none;font-size:10px;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"><img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:12px;height:12px;border-radius:2px;">ZAMM</a>
                    </div>
                    <div class="position-display" id="weeklyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="weeklyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="weeklyDownBal">0</span></div>
                    </div>
                    <button id="weeklyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('weekly')">Resolve Market</button>
                    <button class="card-chart-toggle" id="weeklyChartToggle" onclick="toggleChart('weekly')">
                        <span>Odds Chart</span>
                        <span class="card-chart-toggle-icon"></span>
                    </button>
                    <div class="card-chart-container" id="weeklyChartContainer"></div>
                </div>

                <!-- Extreme Card -->
                <div class="bet-card" id="extremeCard">
                    <div class="bet-header">
                        <span class="bet-type extreme">Extreme</span>
                    </div>
                    <div class="bet-title">100 Gwei Challenge</div>
                    <div class="bet-question">Will gas hit 100 gwei?</div>
                    <div class="target-display">100 gwei</div>
                    <div class="progress-container">
                        <div class="progress-labels">
                            <span>Max seen: <strong id="extremeMax">--</strong></span>
                            <span id="extremePercent">--%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="extremeProgress" style="width:0%"></div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('extreme', true)">
                            <div class="bet-btn-label">Yes</div>
                            <div class="bet-btn-odds" id="extremeYesOdds">--</div>
                            <div class="bet-btn-price" id="extremeYesPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('extreme', false)">
                            <div class="bet-btn-label">No</div>
                            <div class="bet-btn-odds" id="extremeNoOdds">--</div>
                            <div class="bet-btn-price" id="extremeNoPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Resolves early if touched!</span>
                        <span class="countdown-value" id="extremeCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="extremePoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="extremeOrderbook" style="color:var(--amber);">--</span></span>
                        <a id="extremeZammLink" href="#" target="_blank" title="View on ZAMM" style="display:none;align-items:center;gap:3px;color:var(--text-muted);text-decoration:none;font-size:10px;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"><img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:12px;height:12px;border-radius:2px;">ZAMM</a>
                    </div>
                    <div class="position-display" id="extremePosition" style="display:none;">
                        <div class="position-row"><span>Your YES</span><span id="extremeYesBal">0</span></div>
                        <div class="position-row"><span>Your NO</span><span id="extremeNoBal">0</span></div>
                    </div>
                    <button id="extremeResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('extreme')">Resolve Market</button>
                    <button class="card-chart-toggle" id="extremeChartToggle" onclick="toggleChart('extreme')">
                        <span>Odds Chart</span>
                        <span class="card-chart-toggle-icon"></span>
                    </button>
                    <div class="card-chart-container" id="extremeChartContainer"></div>
                </div>
            </div>
        </section>

        <!-- Create Section (Owner Only) -->
        <section class="create-section" id="createSection" style="display:none;">
            <h2 class="section-title">Create Markets</h2>
            <p style="color:var(--text-muted);font-size:var(--font-xs);margin-bottom:1rem;">
                Create new betting markets. Requires initial liquidity.
            </p>
            <div class="create-grid">
                <!-- Weekly -->
                <div class="create-card" id="createWeeklyCard" style="display:none;">
                    <div class="create-card-title">Weekly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this week? Resolves Sunday midnight.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="weeklySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createWeekly()">Create Weekly</button>
                </div>

                <!-- Extreme -->
                <div class="create-card" id="createExtremeCard" style="display:none;">
                    <div class="create-card-title">100 Gwei Challenge</div>
                    <div class="create-card-desc">Will gas hit 100 gwei before end of 2025? Resolves early if hit.</div>
                    <div class="create-input-group">
                        <label class="create-label">Deadline</label>
                        <div style="color:var(--green);font-weight:600;">Dec 31, 2025 23:59:59 UTC</div>
                    </div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="extremeSeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createExtreme()">Create Challenge</button>
                </div>
            </div>
            <p id="allMarketsActive" style="display:none;color:var(--green);text-align:center;margin-top:1.5rem;">
                 All market types are currently active
            </p>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>Weekly:</strong> Bet on whether the gas TWAP (time-weighted average) will be higher when the market closes compared to when it was created. UP wins if TWAP increased, DOWN wins if it stayed the same or decreased.<br><br>
                <strong>100 Gwei Challenge:</strong> Bet on whether gas will spike to 100 gwei before the deadline. If it touches 100 gwei at any point, YES wins and the market can resolve early. If the deadline passes without reaching 100 gwei, NO wins.<br><br>
                <strong>Trading:</strong> Price = Probability. If UP shows 30%, one share costs ~0.30 ETH and pays 1 ETH if UP wins (3.3x return). Losing shares pay nothing. Trade anytime or hold to resolution. Use limit orders to set your own odds.
            </div>
        </section>

        <!-- Resolved Markets (hidden by default) -->
        <section class="bets-section" id="resolvedSection" style="display:none;">
            <h2 class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
                Resolved Markets
                <a href="#" onclick="toggleResolved();return false;" style="font-size:var(--font-xs);color:var(--text-muted);text-decoration:none;">Hide</a>
            </h2>
            <div class="bets-grid" id="resolvedGrid"></div>
        </section>

        <!-- Footer -->
        <footer style="text-align:center;padding:2rem 0;margin-top:1rem;border-top:1px solid var(--border);color:var(--text-dim);font-size:var(--font-xs);">
            <div style="display:flex;justify-content:center;align-items:center;gap:1.5rem;">
                <a href="https://zamm.finance/" target="_blank" style="display:flex;align-items:center;gap:0.5rem;color:var(--text-muted);text-decoration:none;">
                    <img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:20px;height:20px;border-radius:4px;">
                    Built on zAMM
                </a>
                <a href="https://github.com/zammdefi/pm" target="_blank" style="color:var(--text-muted);text-decoration:none;">Code</a>
            </div>
        </footer>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
        <div class="modal" style="max-width:360px;">
            <div class="modal-header">
                <div class="modal-title">Connect Wallet</div>
                <button class="modal-close" onclick="closeWalletModal()">&times;</button>
            </div>
            <div class="modal-body" id="walletOptions"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal" onclick="if(event.target===this)closeModal()">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <!-- YES/NO Side Toggle -->
            <div style="display:flex;gap:4px;margin-bottom:0.75rem;">
                <button id="sideYesBtn" class="mode-toggle-btn" onclick="switchTradeSide(true)" style="flex:1;padding:0.5rem;">
                    <span id="sideYesLabel">YES</span>
                    <span id="sideYesOdds" style="opacity:0.7;margin-left:4px;font-size:11px;">--</span>
                </button>
                <button id="sideNoBtn" class="mode-toggle-btn" onclick="switchTradeSide(false)" style="flex:1;padding:0.5rem;">
                    <span id="sideNoLabel">NO</span>
                    <span id="sideNoOdds" style="opacity:0.7;margin-left:4px;font-size:11px;">--</span>
                </button>
            </div>
            <div class="status-message" id="tradeStatus"></div>
            <!-- Mode Toggle: Trade, Swap, Limit, LP -->
            <div class="mode-toggle">
                <button id="tradeModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('trade')">Trade</button>
                <button id="swapModeBtn" class="mode-toggle-btn" onclick="setTradeMode('swap')">Swap</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')">LP</button>
            </div>
            <!-- Trade Direction Toggle (Buy/Sell) - shown only in Trade mode -->
            <div id="tradeDirectionToggle" class="mode-toggle" style="margin-top:4px;">
                <button id="buyDirBtn" class="mode-toggle-btn active-buy" onclick="setTradeDirection('buy')" style="flex:1;">Buy with ETH</button>
                <button id="sellDirBtn" class="mode-toggle-btn" onclick="setTradeDirection('sell')" style="flex:1;">Sell for ETH</button>
            </div>
            <!-- Swap Direction Toggle (YESNO) - shown only in Swap mode -->
            <div id="swapDirectionToggle" class="mode-toggle" style="margin-top:4px;display:none;">
                <button id="yesToNoBtn" class="mode-toggle-btn active-buy" onclick="setSwapDirection(true)" style="flex:1;">YES  NO</button>
                <button id="noToYesBtn" class="mode-toggle-btn" onclick="setSwapDirection(false)" style="flex:1;">NO  YES</button>
            </div>
            <!-- Position Display -->
            <div id="tradePositionDisplay" style="background:var(--surface-2);padding:0.75rem;margin-bottom:1rem;font-size:var(--font-xs);border-radius:var(--radius);">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <span style="color:var(--text-dim);">Your Position</span>
                    <span id="positionValue" style="color:var(--text);font-weight:600;">--</span>
                </div>
                <div style="display:flex;gap:1.5rem;margin-bottom:6px;">
                    <span style="color:var(--green);"><span id="tradeModalYesLabel">YES</span>: <span id="tradeModalYes">0</span></span>
                    <span style="color:var(--red);"><span id="tradeModalNoLabel">NO</span>: <span id="tradeModalNo">0</span></span>
                    <span style="color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                </div>
                <div style="display:none;gap:1rem;margin-bottom:6px;font-size:11px;">
                    <span style="color:var(--amber);">Vault LP: <span id="tradeModalVault">--</span></span>
                </div>
                <div id="positionPnL" style="display:none;padding-top:6px;border-top:1px solid var(--border);">
                    <div style="display:flex;justify-content:space-between;">
                        <span style="color:var(--text-dim);">If <span id="positionOutcome">YES</span> wins</span>
                        <span id="positionPayout" style="color:var(--green);">+0 ETH</span>
                    </div>
                </div>
            </div>
            <!-- Orderbook -->
            <div class="orderbook" id="orderbookContainer">
                <div class="orderbook-title">
                    <span class="orderbook-title-text"><span id="orderbookShareType">YES</span> Pool</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <span class="orderbook-depth-info" style="display:none;">Depth: <span id="orderbookTotalDepth">--</span> ETH</span>
                        <button onclick="openDepthModal()" style="font-size:9px;padding:2px 6px;background:var(--surface-2);border:1px solid var(--border);border-radius:4px;color:var(--text-muted);cursor:pointer;">Full Depth </button>
                    </div>
                </div>
                <div class="orderbook-header" style="display:none;">
                    <span>Price <span style="font-weight:400;opacity:0.7">(= Odds)</span></span>
                    <span>Size</span>
                    <span>Total</span>
                </div>
                <div class="orderbook-body">
                    <div id="asksLabel" class="orderbook-section-label" style="display:none;justify-content:space-between;padding:2px 8px;background:rgba(239,68,68,0.1);font-size:9px;color:var(--red);">
                        <span>ASKS (Sellers)</span>
                        <span style="opacity:0.7;">Click to buy from</span>
                    </div>
                    <div class="orderbook-side asks" id="orderbookAsks">
                        <!-- Asks (sell orders) - sorted high to low, displayed reversed -->
                    </div>
                    <div class="orderbook-spread" id="orderbookSpread">
                        <div class="orderbook-spread-left">
                            <div class="orderbook-spread-price" id="spreadMidPrice">--</div>
                            <div class="orderbook-spread-label">Pool Price (<span id="spreadOddsPct">--%</span> <span id="spreadOutcome">YES</span>)</div>
                        </div>
                        <div class="orderbook-spread-right">
                            <div id="spreadBidAsk" style="color:var(--text);">-- / --</div>
                            <div class="orderbook-spread-pct">Spread: <span id="spreadPct">--%</span></div>
                        </div>
                    </div>
                    <div id="bidsLabel" class="orderbook-section-label" style="display:none;justify-content:space-between;padding:2px 8px;background:rgba(34,197,94,0.1);font-size:9px;color:var(--green);">
                        <span>BIDS (Buyers)</span>
                        <span style="opacity:0.7;">Click to sell to</span>
                    </div>
                    <div class="orderbook-side bids" id="orderbookBids">
                        <!-- Bids (buy orders) - sorted high to low -->
                    </div>
                </div>
                <div class="orderbook-empty" id="orderbookEmpty" style="display:none;">
                    <div style="margin-bottom:8px;">No limit orders yet</div>
                    <div style="font-size:10px;color:var(--text-muted);">Place a limit order or trade against the pool</div>
                </div>
                <!-- Liquidity Sources Panel -->
                <div id="liquiditySourcesPanel" style="margin-top:8px;padding:8px;background:var(--surface-2);border-radius:var(--radius);font-size:10px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                        <span style="font-weight:600;color:var(--text);">Liquidity Sources</span>
                        <span id="liquiditySourcesToggle" onclick="toggleLiquiditySources()" style="cursor:pointer;color:var(--text-muted);font-size:9px;"> Details</span>
                    </div>
                    <!-- Vault Info (PMHookRouter) -->
                    <div class="liquidity-source" style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid var(--border);">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="color:var(--amber);"></span>
                            <span>Bootstrap Vault</span>
                        </div>
                        <div style="text-align:right;">
                            <span id="vaultDepthYes" style="color:var(--green);">--</span>
                            <span style="color:var(--text-dim);">/</span>
                            <span id="vaultDepthNo" style="color:var(--red);">--</span>
                        </div>
                    </div>
                    <!-- AMM Info -->
                    <div class="liquidity-source" style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid var(--border);">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="color:var(--blue);"></span>
                            <span>AMM Pool</span>
                        </div>
                        <div style="text-align:right;">
                            <span id="ammDepth" style="color:var(--text);">--</span>
                        </div>
                    </div>
                    <!-- Pooled Orderbook Info (MasterRouter) -->
                    <div class="liquidity-source" id="pooledOrderbookSource" style="display:none;justify-content:space-between;align-items:center;padding:4px 0;">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="color:var(--green);"></span>
                            <span>Pooled Orders</span>
                        </div>
                        <div style="text-align:right;">
                            <span id="pooledAskDepth" style="color:var(--red);">--</span>
                            <span style="color:var(--text-dim);">ask /</span>
                            <span id="pooledBidDepth" style="color:var(--green);">--</span>
                            <span style="color:var(--text-dim);">bid</span>
                        </div>
                    </div>
                    <!-- Expanded Details -->
                    <div id="liquiditySourcesDetails" style="display:none;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
                        <!-- Vault Details -->
                        <div style="margin-bottom:8px;">
                            <div style="font-weight:500;color:var(--amber);margin-bottom:4px;">Bootstrap Vault (OTC Fills)</div>
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:9px;">
                                <div style="padding:4px;background:var(--bg);border-radius:4px;">
                                    <div style="color:var(--text-dim);">YES Inventory</div>
                                    <div id="vaultYesDetail" style="color:var(--green);font-weight:500;">--</div>
                                </div>
                                <div style="padding:4px;background:var(--bg);border-radius:4px;">
                                    <div style="color:var(--text-dim);">NO Inventory</div>
                                    <div id="vaultNoDetail" style="color:var(--red);font-weight:500;">--</div>
                                </div>
                                <div style="padding:4px;background:var(--bg);border-radius:4px;">
                                    <div style="color:var(--text-dim);">YES LP Shares</div>
                                    <div id="vaultYesLpShares" style="color:var(--text);">--</div>
                                </div>
                                <div style="padding:4px;background:var(--bg);border-radius:4px;">
                                    <div style="color:var(--text-dim);">NO LP Shares</div>
                                    <div id="vaultNoLpShares" style="color:var(--text);">--</div>
                                </div>
                            </div>
                            <div id="vaultUserPosition" style="display:none;margin-top:4px;padding:4px;background:rgba(245,158,11,0.1);border-radius:4px;font-size:9px;">
                                <div style="color:var(--amber);font-weight:500;">Your Vault LP</div>
                                <div id="vaultUserPositionDetail" style="color:var(--text);">--</div>
                            </div>
                        </div>
                        <!-- Bid Pool Details -->
                        <div id="bidPoolDetails" style="display:none;">
                            <div style="font-weight:500;color:var(--green);margin-bottom:4px;">Bid Pools (Limit Buy Orders)</div>
                            <div id="bidPoolLevels" style="font-size:9px;">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                        <!-- Ask Pool Details -->
                        <div id="askPoolDetails" style="display:none;">
                            <div style="font-weight:500;color:var(--red);margin-bottom:4px;">Ask Pools (Limit Sell Orders)</div>
                            <div id="askPoolLevels" style="font-size:9px;">
                                <!-- Populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="trade-input-group" id="tradeInputGroup">
                <div class="trade-label">
                    <span id="tradeInputLabel">Amount (ETH)</span>
                    <span>Balance: <span id="tradeBalance">--</span> <span id="tradeBalanceUnit">ETH</span></span>
                </div>
                <div style="display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                    <input type="number" class="trade-input" id="tradeAmount" value="0.01" step="0.001" min="0" oninput="handleTradeInput()" style="flex:1;background:transparent;border:none;border-radius:0;">
                    <button onclick="setMaxTrade()" style="padding:0.5rem 1rem;background:var(--surface-2);border:none;border-left:1px solid var(--border);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-xs);">MAX</button>
                </div>
            </div>
            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <div id="tradeExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Buy or sell shares for ETH. Orders route through the orderbook and AMM for the best price.
                </div>
                <!-- Slippage Settings -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button onclick="setSlippage(0.5)" id="slip05" class="slip-btn slip-active">0.5%</button>
                        <button onclick="setSlippage(1)" id="slip1" class="slip-btn">1%</button>
                        <button onclick="setSlippage(2)" id="slip2" class="slip-btn">2%</button>
                        <input type="number" id="slipCustom" placeholder="Custom" step="0.1" min="0.1" max="50" style="width:60px;padding:4px 6px;font-size:var(--font-xs);background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);" onchange="setSlippage(parseFloat(this.value))">
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Avg. price <span style="opacity:0.6">(= odds)</span></span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row" id="previewOddsRow" style="display:none;">
                        <span style="color:var(--text-dim);">Implied probability</span>
                        <span id="previewOdds" style="font-weight:600;">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">Potential payout</span>
                        <span id="previewPayout">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="color:var(--blue);">AMM</span>
                    </div>
                    <div id="previewBreakdown" class="trade-preview-row" style="display:none;flex-direction:column;align-items:flex-start;gap:2px;padding-top:0.5rem;border-top:1px solid var(--border);margin-top:0.5rem;">
                        <span style="font-size:var(--font-xs);color:var(--text-dim);width:100%;">Execution breakdown:</span>
                        <div id="breakdownDetails" style="font-size:var(--font-xs);color:var(--text-muted);width:100%;"></div>
                    </div>
                    <div id="previewSavings" class="trade-preview-row" style="display:none;">
                        <span style="color:var(--text-dim);">vs pure AMM</span>
                        <span id="savingsAmount" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="tradeSubmit" onclick="executeTrade()">Buy</button>
            </div>
            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div class="lp-toggle">
                    <button id="addLpBtn" class="lp-toggle-btn active-add" onclick="setLpMode('add')">Deposit</button>
                    <button id="removeLpBtn" class="lp-toggle-btn" onclick="setLpMode('remove')">Withdraw</button>
                </div>
                <div id="lpExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.
                </div>
                <!-- Slippage for LP -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button id="lpSlip05" class="slip-btn" onclick="setLpSlippage(0.5)">0.5%</button>
                        <button id="lpSlip1" class="slip-btn slip-active" onclick="setLpSlippage(1)">1%</button>
                        <button id="lpSlip2" class="slip-btn" onclick="setLpSlippage(2)">2%</button>
                        <input type="number" id="lpSlipCustom" placeholder="Custom" step="0.1" min="0.1" max="50" style="width:60px;padding:4px 6px;font-size:var(--font-xs);background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);" onchange="setLpSlippage(parseFloat(this.value))">
                    </div>
                </div>
                <!-- Your Position Summary -->
                <div id="lpPositionSummary" style="background:var(--surface-2);padding:0.75rem;margin-bottom:0.75rem;border-radius:var(--radius);font-size:var(--font-xs);">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span id="lpPositionValue" style="color:var(--text);">-- ETH</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;">
                        <span style="color:var(--text-dim);">Pool Share</span>
                        <span id="lpCurrentShare" style="color:var(--text-muted);">--%</span>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>Pool TVL</span>
                        <span id="lpPoolReserves">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="lpPoolPrice">-- (--% YES)</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">You receive</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Your share after</span>
                        <span><span id="lpPoolShare">--%</span> <span id="lpShareChange" style="font-size:10px;color:var(--text-muted);"></span></span>
                    </div>
                </div>
                <div id="lpWarning" style="display:none;font-size:var(--font-xs);color:var(--amber);padding:0.5rem;background:rgba(245,158,11,0.1);border-radius:var(--radius);margin-bottom:0.75rem;">
                </div>
                <button class="trade-submit" id="lpSubmit" style="background:var(--blue);" onclick="executeLp()">Deposit Liquidity</button>
            </div>
            <!-- Swap Section (YESNO) -->
            <div id="swapSection" style="display:none;">
                <div id="swapExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Swap shares directly via the pool. No ETH needed - trade one outcome for the other.
                </div>
                <!-- Slippage for Swap -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button id="swapSlip05" class="slip-btn slip-active" onclick="setSwapSlippage(0.5)">0.5%</button>
                        <button id="swapSlip1" class="slip-btn" onclick="setSwapSlippage(1)">1%</button>
                        <button id="swapSlip2" class="slip-btn" onclick="setSwapSlippage(2)">2%</button>
                        <input type="number" id="swapSlipCustom" placeholder="Custom" step="0.1" min="0.1" max="50" style="width:60px;padding:4px 6px;font-size:var(--font-xs);background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);" onchange="setSwapSlippage(parseFloat(this.value))">
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="swapGiveLabel">You give (YES)</span>
                        <span id="swapGive">-- shares</span>
                    </div>
                    <div class="trade-preview-row" style="border-bottom:1px solid var(--border);padding-bottom:8px;margin-bottom:4px;">
                        <span>Pool Rate</span>
                        <span id="swapPoolRate">1 YES = -- NO</span>
                    </div>
                    <div class="trade-preview-row" style="font-weight:600;font-size:1.05em;">
                        <span id="swapReceiveLabel">You receive (NO)</span>
                        <span id="swapReceive" style="color:var(--green);">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Swap Fee (0.3%)</span>
                        <span id="swapFee">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Price Impact</span>
                        <span id="swapImpact">--%</span>
                    </div>
                    <div class="trade-preview-row" style="border-top:1px solid var(--border);padding-top:8px;margin-top:4px;">
                        <span>Min. Receive (<span id="swapSlipDisplay">0.5%</span> slip)</span>
                        <span id="swapMinReceive">-- shares</span>
                    </div>
                </div>
                <button class="trade-submit buy-down" id="swapSubmit" onclick="executeSwap()">Swap YES  NO</button>
            </div>
            <!-- Mint & List Section -->
            <div id="mintSection" style="display:none;">
                <div id="mintExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Mint YES + NO shares from ETH, keep one side and list the other at your price. Useful for low liquidity markets.
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="keepYesBtn" class="lp-toggle-btn active-add" onclick="setMintKeep(true)">Keep YES</button>
                    <button id="keepNoBtn" class="lp-toggle-btn" onclick="setMintKeep(false)">Keep NO</button>
                </div>
                <div style="margin-bottom:1rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Sell price (ETH per share)</label>
                    <input type="number" id="mintLimitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateMintPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You deposit</span>
                        <span id="mintDeposit">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="mintReceive">-- YES + -- NO</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You keep</span>
                        <span id="mintKeep">-- YES</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You list for sale</span>
                        <span id="mintList">-- NO @ -- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>If order fills</span>
                        <span id="mintProfit" style="color:var(--green);">Net cost: -- ETH</span>
                    </div>
                </div>
                <button class="trade-submit" id="mintSubmit" style="background:var(--amber);color:var(--bg);" onclick="executeMintAndList()">Mint & List</button>
            </div>
            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <div id="limitExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    <span id="limitExplainerText"><strong>Buy Limit:</strong> Bid below pool price to get better odds. Your ETH is escrowed until filled or cancelled.</span>
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="limitBuyBtn" class="lp-toggle-btn active-add" onclick="setLimitSide('buy')">Buy Order</button>
                    <button id="limitSellBtn" class="lp-toggle-btn" onclick="setLimitSide('sell')">Sell Order</button>
                </div>
                <div style="margin-bottom:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <label style="font-size:var(--font-xs);color:var(--text-muted);">Limit Price (ETH = Odds %)</label>
                        <span style="font-size:var(--font-xs);color:var(--text-dim);">Pool: <span id="limitPoolPrice">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <div style="flex:1;display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                            <input type="number" id="limitPrice" placeholder="0.50" step="0.01" min="0.01" max="0.99"
                                style="flex:1;padding:0.75rem;background:transparent;border:none;color:var(--text);font-size:var(--font-base);"
                                oninput="updateLimitPreview()">
                        </div>
                        <button onclick="adjustLimitPrice(-0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--red);font-weight:600;cursor:pointer;font-size:var(--font-sm);">-1%</button>
                        <button onclick="adjustLimitPrice(0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-sm);">+1%</button>
                        <button onclick="setLimitPriceToPool()" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--blue);font-weight:600;cursor:pointer;font-size:10px;">POOL</button>
                    </div>
                    <div id="limitOddsHelper" style="margin-top:6px;font-size:var(--font-xs);padding:0.5rem;background:var(--surface);border-radius:var(--radius);display:none;">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <span style="color:var(--text);">= <strong id="limitOddsValue">50%</strong> implied odds</span>
                            <span id="limitOddsVsPool" style="color:var(--text-muted);">--</span>
                        </div>
                        <div id="limitReturnInfo" style="margin-top:4px;color:var(--green);"></div>
                    </div>
                </div>
                <div style="margin-bottom:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <label style="font-size:var(--font-xs);color:var(--text-muted);">Shares</label>
                        <span style="font-size:var(--font-xs);color:var(--text-muted);">Balance: <span id="limitBalance">--</span> <span id="limitBalanceUnit">ETH</span></span>
                    </div>
                    <div style="display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                        <input type="number" id="limitShares" placeholder="1.0" step="0.1" min="0.01"
                            style="flex:1;padding:0.75rem;background:transparent;border:none;color:var(--text);font-size:var(--font-base);"
                            oninput="updateLimitPreview()">
                        <button onclick="setMaxLimitShares()" style="padding:0.5rem 1rem;background:var(--surface-2);border:none;border-left:1px solid var(--border);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-xs);">MAX</button>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitCostLabel">You escrow</span>
                        <span id="limitCost">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="limitReceiveLabel">If filled, you get</span>
                        <span id="limitReceive">-- shares</span>
                    </div>
                    <div class="trade-preview-row" id="limitProfitRow">
                        <span id="limitProfitLabel">If you win</span>
                        <span id="limitProfit" style="color:var(--green);">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Expires</span>
                        <span id="limitExpires">Market close</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" style="background:#8b5cf6;" onclick="executeLimitOrder()">Place Buy Order</button>
            </div>
            <!-- Your Orders Section -->
            <div id="yourOrdersSection" style="margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border);display:none;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);font-weight:600;">YOUR OPEN ORDERS</span>
                    <button onclick="refreshUserOrders()" style="font-size:var(--font-xs);padding:2px 8px;background:transparent;border:1px solid var(--border);border-radius:var(--radius);color:var(--text-muted);cursor:pointer;"></button>
                </div>
                <div id="yourOrdersList" style="font-size:var(--font-xs);">
                    <!-- Orders populate here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Chart Modal (Full Screen) -->
    <div class="chart-modal-overlay" id="chartModal" onclick="if(event.target === this) closeChartModal()">
        <div class="chart-modal-header">
            <div class="chart-modal-title">
                <span style="color:var(--green);">Gas</span><span style="color:var(--blue);">PM</span>
                <span style="color:var(--text-muted);font-weight:400;font-size:var(--font-sm);">TWAP Chart</span>
            </div>
            <button class="chart-modal-close" onclick="closeChartModal()">&times;</button>
        </div>
        <div class="chart-modal-body">
            <div class="chart-modal-canvas-container">
                <canvas id="modalChart" class="chart-modal-canvas"></canvas>
            </div>
            <div class="chart-modal-stats">
                <div class="chart-modal-stat">
                    <div class="chart-modal-stat-label">Current Gas</div>
                    <div class="chart-modal-stat-value" style="color:var(--green);" id="modalCurrentGas">--</div>
                </div>
                <div class="chart-modal-stat">
                    <div class="chart-modal-stat-label">TWAP</div>
                    <div class="chart-modal-stat-value" style="color:var(--blue);" id="modalTwapGas">--</div>
                </div>
                <div class="chart-modal-stat">
                    <div class="chart-modal-stat-label">1H Odds</div>
                    <div class="chart-modal-stat-value" id="modalHourlyOdds">--</div>
                </div>
                <div class="chart-modal-stat">
                    <div class="chart-modal-stat-label">1D Odds</div>
                    <div class="chart-modal-stat-value" id="modalDailyOdds">--</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Depth Modal -->
    <div class="depth-modal-overlay" id="depthModal" onclick="if(event.target === this) closeDepthModal()">
        <div class="depth-modal">
            <div class="depth-modal-header">
                <div class="depth-modal-title"><span id="depthModalMarketType">Daily</span> Market Depth</div>
                <button class="depth-modal-close" onclick="closeDepthModal()">&times;</button>
            </div>
            <div style="padding:0.75rem;">
                <!-- Header with AMM prices -->
                <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;margin-bottom:0.25rem;padding-bottom:0.5rem;border-bottom:2px solid var(--border);">
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--green);font-size:13px;" id="depthUpLabel">UP</div>
                        <div id="depthUpAmm" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                    <div style="text-align:center;font-size:9px;color:var(--text-dim);display:flex;align-items:center;justify-content:center;">Odds</div>
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--red);font-size:13px;" id="depthDownLabel">DOWN</div>
                        <div id="depthDownAmm" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                </div>
                <!-- Depth Ladder -->
                <div id="depthLadder" style="background:var(--surface);border-radius:var(--radius);max-height:360px;overflow-y:auto;">
                    <div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading...</div>
                </div>
                <!-- Actions -->
                <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
                    <button id="depthTradeUpBtn" onclick="depthTradeUp()" style="flex:1;padding:0.5rem;background:var(--green);color:var(--bg);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade UP</button>
                    <button id="depthTradeDownBtn" onclick="depthTradeDown()" style="flex:1;padding:0.5rem;background:var(--red);color:white;border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade DOWN</button>
                </div>
                <!-- Legend -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);font-size:9px;color:var(--text-dim);">
                    <span><span style="color:var(--green);"></span> Bids (buy)</span>
                    <span>Depth in ETH | Click to fill</span>
                    <span><span style="color:var(--red);"></span> Asks (sell)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Odds Chart Modal (Full Screen) -->
    <div class="odds-modal-overlay" id="oddsModal" onclick="if(event.target === this) closeOddsModal()">
        <div class="odds-modal-header">
            <div class="odds-modal-title" id="oddsModalTitle">Odds Chart</div>
            <button class="odds-modal-close" onclick="closeOddsModal()">&times;</button>
        </div>
        <div class="odds-modal-body">
            <div class="odds-modal-iframe-container">
                <iframe id="oddsModalIframe" class="odds-modal-iframe" src="" title="Odds Chart"></iframe>
            </div>
            <div class="odds-modal-stats">
                <div class="odds-modal-stat">
                    <div class="odds-modal-stat-label">UP Price</div>
                    <div class="odds-modal-stat-value" style="color:var(--green);" id="oddsModalUpPrice">--</div>
                </div>
                <div class="odds-modal-stat">
                    <div class="odds-modal-stat-label">DOWN Price</div>
                    <div class="odds-modal-stat-value" style="color:var(--red);" id="oddsModalDownPrice">--</div>
                </div>
                <div class="odds-modal-stat">
                    <div class="odds-modal-stat-label">TVL</div>
                    <div class="odds-modal-stat-value" style="color:var(--blue);" id="oddsModalTvl">--</div>
                </div>
                <div class="odds-modal-stat">
                    <div class="odds-modal-stat-label">Closes</div>
                    <div class="odds-modal-stat-value" id="oddsModalCloses">--</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const GASPM_ADDRESS = '0x0000000000ee3d4294438093EaA34308f47Bc0b4';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const PMHOOKROUTER_ADDRESS = '0x0000000000BADa259Cb860c12ccD9500d9496B3e';
        const PMFEEHOOK_ADDRESS = '0x0000000000Cc736804447C7E1dC8d3683a37f1a9';
        const PMHOOKQUOTER_ADDRESS = '0x0000000000000000000000000000000000000000'; // TODO: Deploy and update
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        // Hook address with flags for pool creation
        const HOOK_FEE_OR_HOOK = BigInt(PMFEEHOOK_ADDRESS) | (1n << 255n) | (1n << 254n); // FLAG_BEFORE | FLAG_AFTER
        const FEE_BPS = 30n; // 30 bps = 0.30% base fee (for local quote calculations)

        // Public RPC fallbacks
        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc);
                    await p.getBlockNumber(); // test connection
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const RESOLVER_ABI = [
            'function resolveMarket(uint256 marketId) public'
        ];

        const GASPM_ABI = [
            'function baseFeeAverage() public view returns (uint256)',
            'function baseFeeMax() public view returns (uint256)',
            'function baseFeeMin() public view returns (uint256)',
            'function startTime() public view returns (uint64)',
            'function baseFeeMaxSince(uint256 marketId) public view returns (uint256)',
            'function comparisonStartValue(uint256 marketId) public view returns (uint256)',
            'function marketCount() public view returns (uint256)',
            'function getMarkets(uint256 start, uint256 count) public view returns (uint256[])',
            'function getMarketInfos(uint256 start, uint256 count) public view returns (tuple(uint256 marketId, uint64 close, bool resolved, bool outcome, uint256 currentValue, bool conditionMet, bool ready)[])',
            'function observationCount() public view returns (uint256)',
            'function getObservations(uint256 start, uint256 count) public view returns (tuple(uint64 timestamp, uint64 baseFee, uint128 cumulativeBaseFee)[])',
            'function createComparisonMarket(address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function createWindowPeakMarket(uint256 threshold, address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function owner() public view returns (address)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) public view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) public view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function poolKey(uint256 marketId, uint256 feeOrHook) public view returns (tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook))',
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function getNoId(uint256 marketId) public pure returns (uint256)',
            'function claim(uint256 marketId, address to) public returns (uint256 shares, uint256 payout)',
            'function claimMany(uint256[] marketIds, address to) public returns (uint256 totalPayout)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) public payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) public returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
            'function multicall(bytes[] data) public returns (bytes[])'
        ];

        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const ZAMM_ABI = [
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)',
            'function pools(uint256 poolId) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)',
            'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)'
        ];

        const PMHOOKROUTER_ABI = [
            // Trading
            'function buyWithBootstrap(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 sharesOut, bytes4 source, uint256 vaultSharesMinted)',
            'function sellWithBootstrap(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minOut, address to, uint256 deadline) returns (uint256 collateralOut, bytes4 source)',
            'function claim(uint256 marketId, address to) returns (uint256 payout)',
            // LP - Vault + AMM combined
            'function provideLiquidity(uint256 marketId, uint256 collateralAmount, uint256 vaultYesShares, uint256 vaultNoShares, uint256 ammLPShares, uint256 minAmount0, uint256 minAmount1, address receiver, uint256 deadline) payable returns (uint256 yesVaultSharesMinted, uint256 noVaultSharesMinted, uint256 ammLiquidity)',
            // Vault-only LP
            'function depositToVault(uint256 marketId, bool isYes, uint256 shares, address receiver, uint256 deadline) returns (uint256 vaultShares)',
            'function withdrawFromVault(uint256 marketId, bool isYes, uint256 vaultSharesToRedeem, address receiver, uint256 deadline) returns (uint256 sharesReturned, uint256 feesEarned)',
            'function harvestVaultFees(uint256 marketId, bool isYes) returns (uint256 feesEarned)',
            // View functions
            'function canonicalPoolId(uint256 marketId) view returns (uint256)',
            'function canonicalFeeOrHook(uint256 marketId) view returns (uint256)',
            'function totalYesVaultShares(uint256 marketId) view returns (uint256)',
            'function totalNoVaultShares(uint256 marketId) view returns (uint256)',
            'function bootstrapVaults(uint256 marketId) view returns (uint112 yesShares, uint112 noShares, uint32 lastActivity)',
            'function vaultPositions(uint256 marketId, address user) view returns (uint112 yesVaultShares, uint112 noVaultShares, uint256 yesDebt, uint256 noDebt, uint32 lastDepositTime)',
            'function accYesCollateralPerShare(uint256 marketId) view returns (uint256)',
            'function accNoCollateralPerShare(uint256 marketId) view returns (uint256)',
            'function multicall(bytes[] data) payable returns (bytes[])'
        ];

        const PMHOOKQUOTER_ABI = [
            // PMHookRouter quote functions
            'function quoteBootstrapBuy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut) view returns (uint256 totalSharesOut, bool usesVault, bytes4 source, uint256 vaultSharesMinted)',
            'function quoteSellWithBootstrap(uint256 marketId, bool sellYes, uint256 sharesIn) view returns (uint256 collateralOut, bytes4 source)',
            // MasterRouter sweep quote functions (pools + PMHookRouter fallback)
            'function quoteBuyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, uint256 pmSharesOut, bytes4 pmSource)',
            'function quoteSellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, uint256 pmCollateralOut, bytes4 pmSource)'
        ];

        // MasterRouter - Pooled orderbook + vault integration
        const MASTERROUTER_ADDRESS = '0x0000000000000000000000000000000000000000'; // TODO: Deploy and update
        const MASTERROUTER_ABI = [
            // Buy/sell with pool + PMHookRouter fallback
            'function buy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 poolPriceInBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, bytes4[] sources)',
            'function buyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, bytes4[] sources)',
            'function sell(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 bidPoolPriceInBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, bytes4[] sources)',
            'function sellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, bytes4[] sources)',
            // ASK pool functions (sell shares at price)
            'function mintAndPool(uint256 marketId, uint256 collateralIn, bool keepYes, uint256 priceInBps, address to) payable returns (bytes32 poolId)',
            'function depositSharesToPool(uint256 marketId, bool isYes, uint256 sharesIn, uint256 priceInBps, address to) returns (bytes32 poolId)',
            'function fillFromPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 sharesWanted, uint256 maxCollateral, address to, uint256 deadline) payable returns (uint256 sharesBought, uint256 collateralPaid)',
            'function withdrawFromPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 sharesToWithdraw, address to) returns (uint256 sharesWithdrawn, uint256 collateralClaimed)',
            'function claimProceeds(uint256 marketId, bool isYes, uint256 priceInBps, address to) returns (uint256 collateralClaimed)',
            'function exitDepletedAskPool(uint256 marketId, bool isYes, uint256 priceInBps, address to) returns (uint256 collateralClaimed)',
            // BID pool functions (buy shares at price)
            'function createBidPool(uint256 marketId, uint256 collateralIn, bool buyYes, uint256 priceInBps, address to) payable returns (bytes32 bidPoolId)',
            'function sellToPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 sharesWanted, uint256 minCollateral, address to, uint256 deadline) returns (uint256 sharesSold, uint256 collateralReceived)',
            'function withdrawFromBidPool(uint256 marketId, bool isYes, uint256 priceInBps, uint256 collateralToWithdraw, address to) returns (uint256 collateralWithdrawn, uint256 sharesClaimed)',
            'function claimBidShares(uint256 marketId, bool isYes, uint256 priceInBps, address to) returns (uint256 sharesClaimed)',
            'function exitDepletedBidPool(uint256 marketId, bool isYes, uint256 priceInBps, address to) returns (uint256 sharesClaimed)',
            // Vault functions
            'function mintAndVault(uint256 marketId, uint256 collateralIn, bool keepYes, address to) payable returns (uint256 sharesKept, uint256 vaultShares)',
            // View functions - orderbook
            'function getOrderbook(uint256 marketId, bool isYes, uint256[] pricesInBps) view returns (uint256[] askDepths, uint256[] bidDepths)',
            'function getBestAsk(uint256 marketId, bool isYes) view returns (uint256 price, uint256 depth)',
            'function getBestBid(uint256 marketId, bool buyYes) view returns (uint256 price, uint256 depth)',
            'function getPoolDepths(uint256 marketId, bool isYes, uint256[] pricesInBps) view returns (uint256[] depths)',
            'function getBidPoolDepths(uint256 marketId, bool buyYes, uint256[] pricesInBps) view returns (uint256[] depths)',
            'function getPoolInfo(uint256 marketId, bool isYes, uint256 priceInBps) view returns (uint256 totalShares, uint256 totalScaled, uint256 collateralEarned)',
            'function getBidPoolInfo(uint256 marketId, bool buyYes, uint256 priceInBps) view returns (uint256 totalCollateral, uint256 totalScaled, uint256 sharesAcquired)',
            // View functions - user positions
            'function getUserPosition(uint256 marketId, bool isYes, uint256 priceInBps, address user) view returns (uint256 userScaled, uint256 userWithdrawableShares, uint256 userPendingCollateral, uint256 userCollateralDebt)',
            'function getBidPosition(uint256 marketId, bool buyYes, uint256 priceInBps, address user) view returns (uint256 userScaled, uint256 userWithdrawableCollateral, uint256 userPendingShares, uint256 userSharesDebt)',
            'function getPoolId(uint256 marketId, bool isYes, uint256 priceInBps) pure returns (bytes32)',
            'function getBidPoolId(uint256 marketId, bool buyYes, uint256 priceInBps) pure returns (bytes32)',
            // Multicall
            'function multicall(bytes[] data) payable returns (bytes[])'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let isOwner = false;
        let connectedWalletProvider = null;
        let walletConnectProvider = null;
        let isConnecting = false;
        const eip6963Providers = new Map();

        let markets = { weekly: null, extreme: null };
        let resolvedMarkets = [];
        const chartPoolIds = new Map(); // type -> { poolId, yesIsToken0 } for ZAMM embed
        const marketMetaCache = new Map(); // marketId -> { noId, poolKey, poolId }
        const chartLoaded = new Set(); // track which chart iframes have been loaded
        let currentTrade = { type: null, isYes: true, marketId: null };
        let currentTradeMode = 'buy'; // 'buy' or 'sell'
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
        let slippageTolerance = 0.5; // 0.5% default slippage tolerance
        let lpSlippageTolerance = 1; // 1% default LP slippage (higher due to split/merge)

        // Chart data
        let chartDataPoints = [];   // Historical baseFee in gwei
        let chartTimestamps = [];   // Timestamps for each observation
        let chartCumulatives = [];  // Cumulative base fee for rolling TWAP
        let chartState = {};
        let cachedGasData = { twap: 0, current: 0, startTime: 0 };
        let lastLoadedObsCount = 0; // Track for incremental loading
        let lastCanvasSize = { width: 0, height: 0 }; // Track canvas size to avoid unnecessary resizes
        let predictionMarkerPositions = []; // Store prediction marker hit areas for hover detection
        let hoveredPrediction = null; // Currently hovered prediction market type
        let priceChangeBadgeArea = null; // Store price change badge hit area for hover

        // ======================== DOM CACHE ========================
        // Cache frequently accessed DOM elements to avoid repeated lookups
        const DOM = {};
        function initDOMCache() {
            DOM.liveGas = document.getElementById('liveGas');
            DOM.twapGas = document.getElementById('twapGas');
            DOM.minGas = document.getElementById('minGas');
            DOM.maxGas = document.getElementById('maxGas');
            DOM.extremeMax = document.getElementById('extremeMax');
            DOM.extremeProgress = document.getElementById('extremeProgress');
            DOM.extremePercent = document.getElementById('extremePercent');
            DOM.weeklyCountdown = document.getElementById('weeklyCountdown');
            DOM.extremeCountdown = document.getElementById('extremeCountdown');
            DOM.totalPoolTvl = document.getElementById('totalPoolTvl');
            DOM.totalOrderbookLiq = document.getElementById('totalOrderbookLiq');
            DOM.activeMarketsCount = document.getElementById('activeMarketsCount');
            DOM.gasChart = document.getElementById('gasChart');
            DOM.chartTooltip = document.getElementById('chartTooltip');
            DOM.predTooltip = document.getElementById('predTooltip');
            DOM.connectBtn = document.getElementById('connectBtn');
            DOM.createSection = document.getElementById('createSection');
        }

        // ======================== INIT ========================
        async function init() {
            initDOMCache();
            initEIP6963();

            // Auto-reconnect wallet if previously connected
            const savedWallet = localStorage.getItem('gaspm_wallet');
            if (savedWallet) {
                // Small delay to let EIP-6963 providers announce themselves
                setTimeout(async () => {
                    try {
                        await connectWithWallet(savedWallet);
                    } catch (e) {
                        console.warn('Auto-reconnect failed:', e);
                        localStorage.removeItem('gaspm_wallet');
                    }
                }, 100);
            }

            await loadData();
            updateCountdowns();
            setInterval(updateCountdowns, 1000);
            startSmartPolling();
            setupChart();
            startPulseAnimation();
        }

        // Smart polling - pauses when tab is hidden, refreshes on return
        let pollInterval = null;
        function startSmartPolling() {
            const ACTIVE_INTERVAL = 60000;   // 60s when active
            const HIDDEN_INTERVAL = 300000;  // 5 min when hidden

            function poll() {
                clearInterval(pollInterval);
                const interval = document.hidden ? HIDDEN_INTERVAL : ACTIVE_INTERVAL;
                pollInterval = setInterval(loadData, interval);
            }

            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    loadData(); // Refresh immediately when tab becomes visible
                }
                poll(); // Adjust polling interval
            });

            poll(); // Start polling
        }

        function startPulseAnimation() {
            // Only animate pulse for small datasets; skip for large ones (too expensive)
            let lastPulseTime = 0;
            const pulseInterval = 66; // ~15fps for pulse animation

            function animatePulse(timestamp) {
                if (timestamp - lastPulseTime >= pulseInterval) {
                    if (chartDataPoints.length > 0 && chartDataPoints.length <= 200 && cachedGasData.current && hoverIndex < 0) {
                        drawChart(cachedGasData);
                    }
                    lastPulseTime = timestamp;
                }
                requestAnimationFrame(animatePulse);
            }
            requestAnimationFrame(animatePulse);
        }

        // ======================== WALLET ========================
        const WALLET_CONFIG = {
            metamask: { name: 'MetaMask', icon: '', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
            coinbase: { name: 'Coinbase', icon: '', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
            rabby: { name: 'Rabby', icon: '', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
            rainbow: { name: 'Rainbow', icon: '', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
            walletconnect: { name: 'WalletConnect', icon: '' }
        };

        function initEIP6963() {
            if (typeof window === 'undefined') return;
            window.addEventListener('eip6963:announceProvider', (event) => {
                const { info, provider } = event.detail;
                eip6963Providers.set(info.uuid, { info, provider });
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

        function detectWallets() {
            const detected = [];
            const seenNames = new Set();

            for (const [key, config] of Object.entries(WALLET_CONFIG)) {
                if (key === 'walletconnect') continue;
                if (config.detect && config.detect()) {
                    detected.push({ key, ...config });
                    seenNames.add(config.name.toLowerCase());
                }
            }

            for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
                if (!seenNames.has(info.name.toLowerCase())) {
                    // Sanitize wallet name to prevent XSS
                    const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
                    // Only allow data: or https: URLs for icons
                    const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
                    // Escape URL to prevent XSS via attribute injection
                    const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
                    detected.push({
                        key: `eip6963_${uuid}`,
                        name: safeName,
                        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : '',
                        getProvider: () => provider
                    });
                    seenNames.add(info.name.toLowerCase());
                }
            }

            if (detected.length === 0 && window.ethereum) {
                detected.push({ key: 'injected', name: 'Browser Wallet', icon: '', getProvider: () => window.ethereum });
            }

            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            if (wcModule?.EthereumProvider) {
                detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: '', isWalletConnect: true });
            }

            return detected;
        }

        function showWalletModal() {
            const wallets = detectWallets();
            const container = document.getElementById('walletOptions');

            if (connectedAddress) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: var(--gray); border-radius: var(--radius); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Connected</div>
                        <div style="font-size: 0.9rem; word-break: break-all; color: var(--green);">${connectedAddress}</div>
                    </div>
                    <div class="wallet-option disconnect" onclick="disconnectWallet()">
                        <span class="wallet-option-name">Disconnect</span>
                    </div>
                `;
            } else {
                container.innerHTML = wallets.length > 0 ? wallets.map(w => `
                    <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
                        <span class="wallet-option-icon">${w.icon}</span>
                        <span class="wallet-option-name">${w.name}</span>
                    </div>
                `).join('') : '<div style="padding:1rem;text-align:center;color:var(--text-muted);">No wallets detected. Install MetaMask or use WalletConnect.</div>';
            }

            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        async function connectWallet() {
            showWalletModal();
        }

        async function connectWithWallet(walletKey) {
            if (isConnecting) return;
            isConnecting = true;

            try {
                closeWalletModal();
                let walletProvider;

                if (walletKey === 'walletconnect') {
                    const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
                    const WCProvider = wcModule?.EthereumProvider;

                    if (!WCProvider?.init) throw new Error('WalletConnect not available');

                    if (walletConnectProvider) {
                        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
                        walletConnectProvider = null;
                    }

                    walletConnectProvider = await WCProvider.init({
                        projectId: '1e8390ef1c1d8a185e035912a1409749',
                        chains: [1],
                        showQrModal: true,
                        rpcMap: { 1: 'https://1rpc.io/eth' },
                        metadata: {
                            name: 'GasPM',
                            description: 'Ethereum Gas Prediction Markets',
                            url: window.location.origin,
                            icons: []
                        }
                    });

                    await walletConnectProvider.enable();
                    walletProvider = walletConnectProvider;
                } else if (walletKey.startsWith('eip6963_')) {
                    const uuid = walletKey.replace('eip6963_', '');
                    walletProvider = eip6963Providers.get(uuid)?.provider;
                } else {
                    walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
                }

                if (!walletProvider) throw new Error('Wallet not found');

                if (walletKey !== 'walletconnect') {
                    await walletProvider.request({ method: 'eth_requestAccounts' });
                }

                provider = new ethers.BrowserProvider(walletProvider);
                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                connectedWalletProvider = walletProvider;

                DOM.connectBtn.textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                DOM.connectBtn.classList.add('connected');

                walletProvider.on('accountsChanged', () => window.location.reload());
                walletProvider.on('chainChanged', () => window.location.reload());

                // Check if owner (for reference, but creation is now public)
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, provider);
                const owner = await gasPm.owner();
                isOwner = owner.toLowerCase() === connectedAddress.toLowerCase();
                // Show create section to all connected users (creation is public)
                DOM.createSection.style.display = 'block';

                await loadPositions();

                // Save wallet preference for auto-reconnect on page refresh
                localStorage.setItem('gaspm_wallet', walletKey);

            } catch (error) {
                console.error('Connection failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Connection Failed', error.message || 'Could not connect wallet', 'error', 4000);
                }
            } finally {
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            if (walletConnectProvider) {
                try { walletConnectProvider.disconnect(); } catch (e) {}
                walletConnectProvider = null;
            }
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletProvider = null;
            isOwner = false;
            DOM.connectBtn.textContent = 'Connect';
            DOM.connectBtn.classList.remove('connected');
            DOM.createSection.style.display = 'none';
            hidePositions();
            closeWalletModal();

            // Clear saved wallet preference
            localStorage.removeItem('gaspm_wallet');
        }

        // Check if error is a user rejection (wallet popup cancelled)
        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== DATA LOADING ========================
        const MAX_MARKETS = 1000;

        async function loadData() {
            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const gasPmInterface = new ethers.Interface(GASPM_ABI);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Batch gas data + market infos with block fetch
                const [results, block] = await Promise.all([
                    multicall.aggregate3([
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeAverage') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMax') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMin') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('startTime') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('observationCount') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('getMarketInfos', [0, MAX_MARKETS]) }
                    ]),
                    rpc.getBlock('latest')
                ]);

                // Live gas from block (baseFeePerGas is in wei)
                const liveWei = block.baseFeePerGas || 0n;
                const liveGwei = Number(liveWei) / 1e9;
                DOM.liveGas.textContent = formatGwei(liveWei) + ' gwei';

                // Decode oracle data (returns wei, convert to gwei)
                let twapWei = 0n, maxWei = 0n, minWei = 0n, startTime = 0, obsCount = 0;

                if (results[0].success) {
                    twapWei = gasPmInterface.decodeFunctionResult('baseFeeAverage', results[0].returnData)[0];
                } else {
                    console.warn('baseFeeAverage call failed');
                }

                if (results[1].success) {
                    maxWei = gasPmInterface.decodeFunctionResult('baseFeeMax', results[1].returnData)[0];
                } else {
                    console.warn('baseFeeMax call failed');
                }

                if (results[2].success) {
                    minWei = gasPmInterface.decodeFunctionResult('baseFeeMin', results[2].returnData)[0];
                } else {
                    console.warn('baseFeeMin call failed');
                }

                if (results[3].success) {
                    startTime = Number(gasPmInterface.decodeFunctionResult('startTime', results[3].returnData)[0]);
                } else {
                    console.warn('startTime call failed');
                }

                if (results[4].success) {
                    obsCount = Number(gasPmInterface.decodeFunctionResult('observationCount', results[4].returnData)[0]);
                } else {
                    console.warn('observationCount call failed');
                }

                const twapGwei = Number(twapWei) / 1e9;
                const maxGwei = Number(maxWei) / 1e9;

                DOM.twapGas.textContent = formatGwei(twapWei) + ' gwei';
                DOM.minGas.textContent = formatGwei(minWei) + ' gwei';
                DOM.maxGas.textContent = formatGwei(maxWei) + ' gwei';

                // Update extreme progress
                DOM.extremeMax.textContent = formatGwei(maxWei) + ' gwei';
                const pct = Math.min(100, (maxGwei / 100) * 100);
                DOM.extremeProgress.style.width = pct + '%';
                DOM.extremePercent.textContent = pct.toFixed(0) + '%';

                // Note: Start/Now values are set in updateCard() when markets are loaded

                // Cache gas data for chart
                cachedGasData = { twap: twapGwei, current: liveGwei, startTime };

                // Fetch observations for chart (incremental loading for efficiency)
                if (obsCount > 0) {
                    const batchSize = 500;
                    let fetchStart = 0;
                    let newObservations = [];

                    if (lastLoadedObsCount === 0) {
                        // First load: only fetch last 500 observations (don't need ancient history)
                        fetchStart = Math.max(0, obsCount - batchSize);
                    } else if (obsCount > lastLoadedObsCount) {
                        // Incremental load: only fetch new observations
                        fetchStart = lastLoadedObsCount;
                    } else {
                        // No new observations, skip fetch
                        fetchStart = obsCount; // Will skip the loop
                    }

                    if (fetchStart < obsCount) {
                        const obsCalls = [];
                        for (let start = fetchStart; start < obsCount; start += batchSize) {
                            obsCalls.push({
                                target: GASPM_ADDRESS,
                                allowFailure: true,
                                callData: gasPmInterface.encodeFunctionData('getObservations', [start, Math.min(batchSize, obsCount - start)])
                            });
                        }
                        const obsResults = await multicall.aggregate3(obsCalls);
                        for (const res of obsResults) {
                            if (res.success) {
                                const batch = gasPmInterface.decodeFunctionResult('getObservations', res.returnData)[0];
                                newObservations.push(...batch);
                            }
                        }

                        // Append new observations to existing arrays (or replace on first load)
                        const newPoints = newObservations.map(o => Number(o.baseFee) / 1e9);
                        const newTimestamps = newObservations.map(o => Number(o.timestamp));
                        const newCumulatives = newObservations.map(o => Number(o.cumulativeBaseFee));

                        if (lastLoadedObsCount === 0) {
                            // First load - replace
                            chartDataPoints = newPoints;
                            chartTimestamps = newTimestamps;
                            chartCumulatives = newCumulatives;
                        } else {
                            // Incremental - append
                            chartDataPoints.push(...newPoints);
                            chartTimestamps.push(...newTimestamps);
                            chartCumulatives.push(...newCumulatives);
                        }
                        lastLoadedObsCount = obsCount;
                    }
                }

                // Decode market infos
                let marketInfos = [];
                if (results[5].success) {
                    try {
                        marketInfos = gasPmInterface.decodeFunctionResult('getMarketInfos', results[5].returnData)[0];
                    } catch (e) {
                        console.warn('No markets or failed to decode:', e);
                    }
                }

                // Load markets using marketInfos (this also calls updatePredictions)
                await loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei, liveGwei);

                // Draw chart AFTER markets loaded so predictions are available
                drawChart(cachedGasData);

            } catch (e) {
                console.error('Load failed:', e);
            }
        }

        async function loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei, liveGwei) {
            // Reset markets on each load to handle expiry
            markets = { weekly: null, extreme: null };
            resolvedMarkets = [];

            // Clear chart cache when markets reload (new period may have different poolIds)
            chartPoolIds.clear();
            chartLoaded.clear();
            // Reset chart UI
            ['weekly', 'extreme'].forEach(type => {
                const container = document.getElementById(`${type}ChartContainer`);
                const toggle = document.getElementById(`${type}ChartToggle`);
                if (container) { container.classList.remove('open'); container.innerHTML = ''; }
                if (toggle) toggle.classList.remove('active');
            });

            try {
                if (marketInfos.length === 0) return;

                const now = Math.floor(Date.now() / 1000);

                // Batch all PAMM.getMarket calls for descriptions
                const marketCalls = marketInfos.map(info => ({
                    target: PAMM_ADDRESS,
                    allowFailure: true,
                    callData: pammInterface.encodeFunctionData('getMarket', [info.marketId])
                }));
                const marketResults = await multicall.aggregate3(marketCalls);

                // Find comparison markets (including expired-but-unresolved) and batch their startValue calls
                const comparisonIds = [];
                const comparisonMarketIndices = []; // Maps back to marketInfos index
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    // Skip only resolved markets - include expired-but-unresolved
                    if (info.resolved) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const desc = data.description || data[10];
                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        comparisonIds.push(info.marketId);
                        comparisonMarketIndices.push(i);
                    }
                }

                // Batch comparisonStartValue calls AND getPoolState calls for unresolved markets
                let startValuesMap = new Map(); // marketId -> startValue
                let poolStateMap = new Map(); // marketId -> { rYes, rNo }

                // Collect all unresolved market IDs for pool state (including expired)
                const activeMarketIds = [];
                const activeMarketIndices = [];
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    // Include expired-but-unresolved markets
                    if (info.resolved) continue;
                    activeMarketIds.push(info.marketId);
                    activeMarketIndices.push(i);
                }

                if (activeMarketIds.length > 0) {
                    // Batch: startValue for comparison markets + poolState for all active markets
                    const batchCalls = [];

                    // Add startValue calls for comparison markets
                    for (const id of comparisonIds) {
                        batchCalls.push({
                            target: GASPM_ADDRESS,
                            allowFailure: true,
                            callData: gasPmInterface.encodeFunctionData('comparisonStartValue', [id])
                        });
                    }

                    // Add getPoolState calls for all active markets
                    for (const id of activeMarketIds) {
                        batchCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('getPoolState', [id, HOOK_FEE_OR_HOOK])
                        });
                    }

                    const batchResults = await multicall.aggregate3(batchCalls);

                    // Parse startValue results
                    for (let i = 0; i < comparisonIds.length; i++) {
                        const val = batchResults[i].success ? gasPmInterface.decodeFunctionResult('comparisonStartValue', batchResults[i].returnData)[0] : 0n;
                        startValuesMap.set(comparisonIds[i].toString(), val);
                    }

                    // Parse poolState results
                    const poolStateOffset = comparisonIds.length;
                    for (let i = 0; i < activeMarketIds.length; i++) {
                        const res = batchResults[poolStateOffset + i];
                        if (res.success) {
                            const [rYes, rNo] = pammInterface.decodeFunctionResult('getPoolState', res.returnData);
                            poolStateMap.set(activeMarketIds[i].toString(), { rYes, rNo });
                        }
                    }
                }

                // Process markets
                let collateralMap = new Map(); // marketId -> collateralLocked
                let pendingComparisons = []; // Collect comparison markets for sorted assignment
                for (let i = 0; i < marketInfos.length; i++) {
                    const info = marketInfos[i];
                    if (!marketResults[i].success) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const resolved = info.resolved;
                    const close = Number(info.close);
                    const desc = data.description || data[10];
                    const collateralLocked = data.collateralLocked || data[6] || 0n;

                    // Collect resolved markets for history display
                    if (resolved) {
                        const outcome = info.outcome; // 0 = no, 1 = yes
                        // Only distinguish extreme (spike) vs comparison (TWAP) markets
                        const isExtreme = desc.includes('spikes to') || desc.includes('Gas spikes');
                        resolvedMarkets.push({
                            id: info.marketId,
                            isExtreme,
                            close,
                            outcome,
                            desc,
                            collateralLocked
                        });
                        continue;
                    }

                    const isExpired = close <= now;
                    // info.ready accounts for canClose markets (true if condition met early OR expired)
                    const needsResolve = info.ready;

                    // Store collateralLocked for TVL display (total ETH backing all tokens)
                    collateralMap.set(info.marketId.toString(), collateralLocked);

                    // Use pool reserves for price (reflects AMM state, not just supply)
                    const poolState = poolStateMap.get(info.marketId.toString());
                    let yesPrice = 0.5, noPrice = 0.5;

                    if (poolState && poolState.rYes > 0n && poolState.rNo > 0n) {
                        // AMM price: yesPrice = rNo / (rYes + rNo)
                        const rYesNum = Number(poolState.rYes);
                        const rNoNum = Number(poolState.rNo);
                        const total = rYesNum + rNoNum;
                        yesPrice = rNoNum / total;
                        noPrice = rYesNum / total;
                    } else {
                        // Fallback to supply-based calculation if no pool
                        const yesSupply = data.yesSupply || data[8];
                        const noSupply = data.noSupply || data[9];
                        const total = Number(yesSupply) + Number(noSupply);
                        if (total > 0) {
                            yesPrice = Number(noSupply) / total;
                            noPrice = Number(yesSupply) / total;
                        }
                    }

                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        const startValue = startValuesMap.get(info.marketId.toString()) || 0n;
                        const startGwei = Number(startValue) / 1e9;
                        const timeToClose = close - now;
                        // Collect for later sorting and assignment
                        pendingComparisons.push({
                            id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve,
                            tvl: Number(collateralLocked) / 1e18, timeToClose
                        });
                    } else if (desc.includes('spikes to') || desc.includes('Gas spikes')) {
                        if (!markets.extreme) {
                            markets.extreme = { id: info.marketId, close, yesPrice, noPrice, needsResolve, conditionMet: info.conditionMet, tvl: Number(collateralLocked) / 1e18 };
                            document.getElementById('extremeYesOdds').textContent = formatOdds(yesPrice);
                            document.getElementById('extremeNoOdds').textContent = formatOdds(noPrice);
                            document.getElementById('extremeYesPrice').textContent = yesPrice.toFixed(2) + ' ';
                            document.getElementById('extremeNoPrice').textContent = noPrice.toFixed(2) + ' ';
                            // Show resolve button for extreme if ready (condition met OR expired)
                            const resolveBtn = document.getElementById('extremeResolveBtn');
                            if (resolveBtn) {
                                resolveBtn.style.display = needsResolve ? 'block' : 'none';
                                // Update button text if condition met early
                                if (info.conditionMet && !isExpired) {
                                    resolveBtn.textContent = '100 GWEI HIT! Resolve Now';
                                    resolveBtn.style.background = 'var(--green)';
                                }
                            }
                        }
                    }
                }

                // Sort comparison markets by timeToClose descending (longest remaining first)
                pendingComparisons.sort((a, b) => b.timeToClose - a.timeToClose);

                // Assign comparison markets to slots based on close time pattern (weekly only)
                for (const m of pendingComparisons) {
                    const closeDate = new Date(m.close * 1000);
                    const isMidnightUTC = closeDate.getUTCHours() === 0 && closeDate.getUTCMinutes() === 0;
                    const isSunday = closeDate.getUTCDay() === 0;

                    // Weekly: closes Sunday midnight UTC
                    if (isMidnightUTC && isSunday && m.timeToClose <= 604800 && m.timeToClose > -604800 && !markets.weekly) {
                        markets.weekly = { id: m.id, close: m.close, startGwei: m.startGwei, yesPrice: m.yesPrice, noPrice: m.noPrice, needsResolve: m.needsResolve, tvl: m.tvl };
                        updateCard('weekly', m.startGwei, twapGwei, m.yesPrice, m.noPrice, m.needsResolve);
                    }
                }

                // Update create cards visibility
                updateCreateCardsVisibility();
                // Load liquidity stats after markets are loaded (pass collateralMap for TVL)
                loadLiquidityStats(collateralMap);
                // Update predictions based on market odds
                updatePredictions();
                // Update resolved markets count and render if visible
                const isExpanded = document.getElementById('resolvedSection').style.display !== 'none';
                document.getElementById('resolvedMarketsCount').textContent = resolvedMarkets.length + (isExpanded ? ' ' : ' ');
                renderResolvedMarkets();
            } catch (e) {
                console.error('Load markets failed:', e);
            }
        }

        async function loadLiquidityStats(collateralMap = null) {
            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                let totalTvl = 0;
                let totalOrderbookLiq = 0;
                let activeCount = 0;

                // Collect active markets for batch poolKey fetch
                const marketTypes = ['weekly', 'extreme'];
                const activeMarkets = [];
                for (const type of marketTypes) {
                    const market = markets[type];
                    if (market && market.id) {
                        activeMarkets.push({ type, market });
                    }
                }

                // Batch fetch noIds for all active markets to compute poolIds
                let poolIdMap = new Map(); // type -> poolId
                if (activeMarkets.length > 0) {
                    try {
                        const noIdCalls = activeMarkets.map(({ market }) => ({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('getNoId', [market.id])
                        }));
                        const noIdResults = await multicall.aggregate3(noIdCalls);

                        for (let i = 0; i < activeMarkets.length; i++) {
                            if (noIdResults[i].success) {
                                const noId = pammInterface.decodeFunctionResult('getNoId', noIdResults[i].returnData)[0];
                                const yesId = activeMarkets[i].market.id;
                                // Compute poolId same as pnkPM.html
                                const id0 = yesId < noId ? yesId : noId;
                                const id1 = yesId < noId ? noId : yesId;
                                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                                    [id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, HOOK_FEE_OR_HOOK]
                                ));
                                poolIdMap.set(activeMarkets[i].type, poolId);
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to batch fetch noIds:', e);
                    }
                }

                // Load stats for each active market
                for (const type of marketTypes) {
                    const market = markets[type];
                    if (!market || !market.id) continue;

                    activeCount++;

                    try {
                        // Use collateralMap if available (from loadMarkets), otherwise fetch
                        let collateralLocked;
                        const cachedCollateral = collateralMap?.get(market.id.toString());
                        if (cachedCollateral !== undefined) {
                            collateralLocked = cachedCollateral;
                        } else {
                            const marketData = await pamm.getMarket(market.id);
                            collateralLocked = marketData.collateralLocked || marketData[6] || 0n;
                        }

                        // Market TVL = total collateral locked (ETH backing all tokens)
                        const marketTvl = Number(collateralLocked) / 1e18;
                        totalTvl += marketTvl;

                        // Update individual card
                        const poolEl = document.getElementById(`${type}PoolTvl`);
                        if (poolEl) poolEl.textContent = formatEth(marketTvl);

                        // Update ZAMM link
                        const zammLink = document.getElementById(`${type}ZammLink`);
                        const poolId = poolIdMap.get(type);
                        if (zammLink && poolId) {
                            const poolIdDecimal = BigInt(poolId).toString();
                            zammLink.href = `https://zamm.finance/p/${poolIdDecimal}`;
                            zammLink.style.display = 'flex';
                        }

                        // Orderbook no longer supported (using PMHookRouter vault system)
                        const orderbookEl = document.getElementById(`${type}Orderbook`);
                        if (orderbookEl) orderbookEl.textContent = 'N/A';

                    } catch (e) {
                        console.warn(`Failed to load liquidity for ${type}:`, e);
                    }
                }

                // Update global stats
                DOM.totalPoolTvl.textContent = formatEth(totalTvl);
                DOM.totalOrderbookLiq.textContent = totalOrderbookLiq > 0 ? formatEth(totalOrderbookLiq) : '--';
                DOM.activeMarketsCount.textContent = activeCount.toString();

            } catch (e) {
                console.error('Failed to load liquidity stats:', e);
            }
        }

        // Hide create cards for market types that already have active markets
        function updateCreateCardsVisibility() {
            const cards = {
                weekly: document.getElementById('createWeeklyCard'),
                extreme: document.getElementById('createExtremeCard')
            };

            let allActive = true;
            for (const [type, card] of Object.entries(cards)) {
                if (card) {
                    if (markets[type]) {
                        card.style.display = 'none';
                    } else {
                        card.style.display = '';
                        allActive = false;
                    }
                }
            }

            // Show message if all markets are active
            const allActiveMsg = document.getElementById('allMarketsActive');
            if (allActiveMsg) {
                allActiveMsg.style.display = allActive ? 'block' : 'none';
            }
        }

        // ======================== RESOLVED MARKETS ========================
        async function toggleResolved() {
            const section = document.getElementById('resolvedSection');
            const countEl = document.getElementById('resolvedMarketsCount');
            if (section) {
                const willShow = section.style.display === 'none';
                section.style.display = willShow ? 'block' : 'none';
                // Update arrow direction
                if (countEl) {
                    countEl.textContent = resolvedMarkets.length + (willShow ? ' ' : ' ');
                }
                // Re-render when opening to fetch fresh balances (e.g., if wallet connected after initial load)
                if (willShow) {
                    await renderResolvedMarkets();
                }
            }
        }

        async function renderResolvedMarkets() {
            const grid = document.getElementById('resolvedGrid');
            if (!grid) return;

            if (resolvedMarkets.length === 0) {
                grid.innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:2rem;">No resolved markets yet</div>';
                return;
            }

            // Sort by close time (most recent first)
            const sorted = [...resolvedMarkets].sort((a, b) => b.close - a.close);

            // Load user's winning shares AND LP balances if connected
            let userWinnings = new Map(); // marketId -> winning token balance
            let userLpBalances = new Map(); // marketId -> { lpBalance, poolId }
            if (connectedAddress) {
                try {
                    const rpc = provider || await getRpcProvider();
                    const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                    const pammInterface = new ethers.Interface(PAMM_ABI);
                    const zammInterface = new ethers.Interface(ZAMM_ABI);

                    // First batch: get poolKeys for all markets
                    const poolKeyCalls = sorted.map(m => ({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('poolKey', [m.id, HOOK_FEE_OR_HOOK])
                    }));
                    const poolKeyResults = await multicall.aggregate3(poolKeyCalls);

                    // Compute pool IDs and build balance calls
                    // Query BOTH YES and NO token balances for each market
                    const poolIds = new Map();
                    const balanceCalls = [];
                    for (let i = 0; i < sorted.length; i++) {
                        const m = sorted[i];
                        const noId = ethers.solidityPackedKeccak256(['string', 'uint256'], ['PMARKET:NO', m.id]);

                        // YES token balance (marketId)
                        balanceCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                        });
                        // NO token balance (derived)
                        balanceCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                        });

                        // LP token balance
                        if (poolKeyResults[i].success) {
                            const poolKey = pammInterface.decodeFunctionResult('poolKey', poolKeyResults[i].returnData)[0];
                            const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                                [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                            ));
                            poolIds.set(m.id.toString(), poolId);
                            balanceCalls.push({
                                target: ZAMM_ADDRESS,
                                allowFailure: true,
                                callData: zammInterface.encodeFunctionData('balanceOf', [connectedAddress, poolId])
                            });
                        } else {
                            // Placeholder for failed poolKey
                            balanceCalls.push({ target: ZAMM_ADDRESS, allowFailure: true, callData: '0x' });
                        }
                    }

                    if (balanceCalls.length > 0) {
                        const balanceResults = await multicall.aggregate3(balanceCalls);
                        for (let i = 0; i < sorted.length; i++) {
                            const m = sorted[i];
                            // Each market has 3 calls: YES, NO, LP
                            const yesRes = balanceResults[i * 3];
                            const noRes = balanceResults[i * 3 + 1];
                            const lpRes = balanceResults[i * 3 + 2];

                            const yesBal = yesRes.success ? BigInt(pammInterface.decodeFunctionResult('balanceOf', yesRes.returnData)[0]) : 0n;
                            const noBal = noRes.success ? BigInt(pammInterface.decodeFunctionResult('balanceOf', noRes.returnData)[0]) : 0n;

                            // Determine winning balance based on outcome
                            // outcome truthy = YES won, outcome falsy = NO won
                            const winBal = m.outcome ? yesBal : noBal;
                            const loseBal = m.outcome ? noBal : yesBal;
                            userWinnings.set(m.id.toString(), { winBal, loseBal, yesBal, noBal });

                            const poolId = poolIds.get(m.id.toString());
                            if (lpRes.success && poolId) {
                                const lpBal = BigInt(zammInterface.decodeFunctionResult('balanceOf', lpRes.returnData)[0]);
                                userLpBalances.set(m.id.toString(), { lpBalance: lpBal, poolId });
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load resolved market balances:', e);
                }
            }

            // Helper to truncate market ID
            const truncateId = (id) => {
                const s = id.toString();
                if (s.length <= 12) return s;
                return s.slice(0, 6) + '...' + s.slice(-4);
            };

            grid.innerHTML = sorted.map(m => {
                const typeLabel = m.isExtreme ? 'Challenge' : 'TWAP';
                const typeClass = m.isExtreme ? 'extreme' : 'weekly';
                const outcomeLabel = m.isExtreme ? (m.outcome ? 'YES' : 'NO') : (m.outcome ? 'UP' : 'DOWN');
                const outcomeColor = m.outcome ? 'var(--green)' : 'var(--red)';
                const closeDate = new Date(m.close * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                const tvl = Number(m.collateralLocked) / 1e18;

                // User positions
                const posData = userWinnings.get(m.id.toString()) || { winBal: 0n, loseBal: 0n };
                const winBal = posData.winBal || 0n;
                const loseBal = posData.loseBal || 0n;
                const winBalNum = Number(winBal) / 1e18;
                const loseBalNum = Number(loseBal) / 1e18;
                const hasWinnings = winBal > 0n;
                const hasLosing = loseBal > 0n;

                const lpData = userLpBalances.get(m.id.toString());
                const lpBal = lpData?.lpBalance || 0n;
                const lpBalNum = Number(lpBal) / 1e18;
                const hasLp = lpBal > 0n;

                const hasPosition = hasWinnings || hasLp || hasLosing;

                return `
                    <div class="bet-card resolved" style="opacity:0.9;">
                        <div class="bet-header">
                            <span class="bet-type ${typeClass}">${typeLabel}</span>
                            <span style="font-size:var(--font-xs);color:var(--text-dim);">${closeDate}</span>
                        </div>
                        <div class="bet-title" style="font-size:var(--font-sm);" title="Market #${m.id}">Market #${truncateId(m.id)}</div>
                        <div style="text-align:center;padding:0.75rem 0;">
                            <div style="font-size:var(--font-xs);color:var(--text-dim);">Outcome</div>
                            <div style="font-size:var(--font-lg);font-weight:700;color:${outcomeColor};">${outcomeLabel} Won</div>
                        </div>
                        ${hasPosition ? `
                            <div style="background:var(--gray);border-radius:var(--radius);padding:0.75rem;margin:0.5rem 0;">
                                ${hasWinnings ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);${hasLp || hasLosing ? 'margin-bottom:0.5rem;' : ''}">
                                        <span style="color:var(--text-muted);">Winnings</span>
                                        <span style="color:var(--green);font-weight:600;">${winBalNum.toFixed(4)} ETH</span>
                                    </div>
                                ` : ''}
                                ${hasLosing && !hasWinnings && !hasLp ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);">
                                        <span style="color:var(--text-muted);">Position</span>
                                        <span style="color:var(--text-dim);font-weight:600;">Claimed </span>
                                    </div>
                                ` : ''}
                                ${hasLp ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);">
                                        <span style="color:var(--text-muted);">LP Position</span>
                                        <span style="color:var(--blue);font-weight:600;">${lpBalNum.toFixed(4)}</span>
                                    </div>
                                ` : ''}
                            </div>
                            ${hasWinnings && !hasLp ? `
                                <button class="bet-btn up" style="width:100%;margin-top:0.5rem;" onclick="claimWinnings('${m.id}')">
                                    <div class="bet-btn-label">Claim ${winBalNum.toFixed(4)} ETH</div>
                                </button>
                            ` : ''}
                            ${hasLp ? `
                                <button class="bet-btn up" style="width:100%;margin-top:0.5rem;" onclick="withdrawLP('${m.id}', ${hasWinnings})">
                                    <div class="bet-btn-label">Withdraw All</div>
                                </button>
                            ` : ''}
                        ` : `
                            <div style="font-size:var(--font-xs);color:var(--text-dim);text-align:center;padding-top:0.5rem;">TVL: ${formatEth(tvl)}</div>
                        `}
                    </div>
                `;
            }).join('');
        }

        async function claimWinnings(marketId) {
            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                await monitorTransaction(
                    pamm.claim(marketId, connectedAddress),
                    {
                        pending: { title: 'Claiming Winnings', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Claiming Winnings', body: 'Waiting for confirmation...' },
                        success: { title: 'Winnings Claimed!', body: 'Your winnings have been sent to your wallet' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            renderResolvedMarkets();
                        }
                    }
                );
            } catch (e) {
                // monitorTransaction already shows toast for errors, so just log
                console.error('Claim failed:', e);
            }
        }

        async function withdrawLP(marketId, hasDirectWinnings = false) {
            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                // Get LP balance
                const poolKey = await pamm.poolKey(marketId, HOOK_FEE_OR_HOOK);
                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                    [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                ));
                const lpBalance = await zamm.balanceOf(connectedAddress, poolId);

                if (lpBalance === 0n) {
                    showToast('No LP', 'No LP position to withdraw', 'error', 3000);
                    return;
                }

                // Ensure PAMM is approved as operator for ZAMM
                const isApproved = await zamm.isOperator(connectedAddress, PAMM_ADDRESS);
                if (!isApproved) {
                    let approved = false;
                    await monitorTransaction(zamm.setOperator(PAMM_ADDRESS, true), {
                        pending: { title: 'Approval Required', body: 'Approve PAMM as operator...' },
                        submitted: { title: 'Approval Required', body: 'Waiting for confirmation...' },
                        success: { title: 'Approved!', body: 'PAMM can now manage your LP tokens' },
                        error: { title: 'Approval Failed', body: '' },
                        onSuccess: () => { approved = true; }
                    });
                    if (!approved) return;
                }

                const deadline = Math.floor(Date.now() / 1000) + 600;
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Build calls array - removeLiquidityToCollateral already handles winning tokens from LP
                // Only add claim if user has direct winning token holdings (from trades)
                const calls = [
                    pammInterface.encodeFunctionData('removeLiquidityToCollateral', [
                        marketId,
                        HOOK_FEE_OR_HOOK,
                        lpBalance,
                        0, // amount0Min
                        0, // amount1Min
                        0, // minCollateralOut
                        connectedAddress,
                        deadline
                    ])
                ];

                // Only claim if user has direct winning tokens (not from LP)
                if (hasDirectWinnings) {
                    calls.push(pammInterface.encodeFunctionData('claim', [marketId, connectedAddress]));
                }

                await monitorTransaction(
                    pamm.multicall(calls),
                    {
                        pending: { title: 'Withdrawing All', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Withdrawing All', body: 'Waiting for confirmation...' },
                        success: { title: 'Withdrawn!', body: 'LP and winnings returned to your wallet' },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            renderResolvedMarkets();
                        }
                    }
                );
            } catch (e) {
                console.error('Withdraw LP failed:', e);
            }
        }

        function updateCard(type, startGwei, nowGwei, yesPrice, noPrice, needsResolve = false) {
            // Format gwei values with appropriate precision
            const formatGweiValue = (gwei) => {
                if (gwei >= 10) return gwei.toFixed(1);
                if (gwei >= 1) return gwei.toFixed(2);
                return gwei.toFixed(3);
            };

            document.getElementById(`${type}Start`).textContent = formatGweiValue(startGwei);
            document.getElementById(`${type}Now`).textContent = formatGweiValue(nowGwei);

            const arrow = document.getElementById(`${type}Arrow`);
            const diff = nowGwei - startGwei;
            const pctChange = startGwei > 0 ? (diff / startGwei * 100) : 0;

            if (nowGwei > startGwei * 1.001) { // > 0.1% higher
                arrow.textContent = '';
                arrow.className = 'gas-compare-arrow up';
                arrow.title = `+${pctChange.toFixed(1)}% from start`;
            } else if (nowGwei < startGwei * 0.999) { // > 0.1% lower
                arrow.textContent = '';
                arrow.className = 'gas-compare-arrow down';
                arrow.title = `${pctChange.toFixed(1)}% from start`;
            } else {
                arrow.textContent = '=';
                arrow.className = 'gas-compare-arrow';
                arrow.title = 'No significant change';
            }

            document.getElementById(`${type}UpOdds`).textContent = formatOdds(yesPrice);
            document.getElementById(`${type}DownOdds`).textContent = formatOdds(noPrice);
            document.getElementById(`${type}UpPrice`).textContent = yesPrice.toFixed(2) + ' ';
            document.getElementById(`${type}DownPrice`).textContent = noPrice.toFixed(2) + ' ';

            // Show/hide resolve button and update card state for expired markets
            const resolveBtn = document.getElementById(`${type}ResolveBtn`);
            const buttonsDiv = document.querySelector(`#${type}Card .bet-buttons`);
            const countdownEl = document.getElementById(`${type}Countdown`);

            if (needsResolve) {
                // Market expired - show resolve button, hide trade buttons
                if (resolveBtn) resolveBtn.style.display = 'block';
                if (buttonsDiv) buttonsDiv.style.opacity = '0.5';
                if (countdownEl) {
                    countdownEl.textContent = 'Ready to resolve';
                    countdownEl.style.color = 'var(--amber)';
                }
            } else {
                if (resolveBtn) resolveBtn.style.display = 'none';
                if (buttonsDiv) buttonsDiv.style.opacity = '1';
            }
        }

        async function loadPositions() {
            if (!connectedAddress) return;

            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                const marketList = [];
                const types = [];
                if (markets.weekly) { marketList.push(markets.weekly); types.push('weekly'); }
                if (markets.extreme) { marketList.push(markets.extreme); types.push('extreme'); }

                if (marketList.length === 0) return;

                // Build multicall for YES and NO balances
                const calls = [];
                for (const m of marketList) {
                    // YES balance (marketId is the YES token id)
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                    });
                    // NO balance (need to compute noId = keccak256(abi.encodePacked("PMARKET:NO", marketId)))
                    const noId = ethers.solidityPackedKeccak256(
                        ['string', 'uint256'],
                        ['PMARKET:NO', m.id]
                    );
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                    });
                }

                const results = await multicall.aggregate3(calls);

                for (let i = 0; i < types.length; i++) {
                    const t = types[i];
                    const yesResult = results[i * 2];
                    const noResult = results[i * 2 + 1];

                    const yes = yesResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', yesResult.returnData)[0]) / 1e18 : 0;
                    const no = noResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', noResult.returnData)[0]) / 1e18 : 0;

                    if (yes > 0 || no > 0) {
                        document.getElementById(`${t}Position`).style.display = 'block';
                        document.getElementById(`${t}${t === 'extreme' ? 'Yes' : 'Up'}Bal`).textContent = yes.toFixed(4);
                        document.getElementById(`${t}${t === 'extreme' ? 'No' : 'Down'}Bal`).textContent = no.toFixed(4);
                    } else {
                        document.getElementById(`${t}Position`).style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Load positions failed:', e);
            }
        }

        function hidePositions() {
            ['weekly', 'extreme'].forEach(t => {
                const el = document.getElementById(`${t}Position`);
                if (el) el.style.display = 'none';
            });
        }

        // ======================== CHART MODAL ========================
        let isChartModalOpen = false;
        let modalChartCtx = null;

        function openChartModal() {
            const modal = document.getElementById('chartModal');
            modal.classList.add('active');
            isChartModalOpen = true;

            // Update stats
            updateModalStats();

            // Draw chart in modal after a small delay for DOM to settle
            setTimeout(() => {
                drawModalChart();
            }, 50);

            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        function closeChartModal() {
            const modal = document.getElementById('chartModal');
            modal.classList.remove('active');
            isChartModalOpen = false;
            document.body.style.overflow = '';
        }

        // Handle ESC key and resize for modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isChartModalOpen) {
                closeChartModal();
            }
        });

        // Resize handler for modal chart
        let modalResizeTimer = null;
        window.addEventListener('resize', () => {
            if (isChartModalOpen) {
                clearTimeout(modalResizeTimer);
                modalResizeTimer = setTimeout(drawModalChart, 100);
            }
        });

        // ======================== ODDS CHART MODAL ========================
        let isOddsModalOpen = false;
        let currentOddsMarketType = null;

        function openOddsModal(type) {
            const market = markets[type];
            if (!market) return;

            const modal = document.getElementById('oddsModal');
            const iframe = document.getElementById('oddsModalIframe');
            const title = document.getElementById('oddsModalTitle');

            // Get market label
            const typeLabels = {
                weekly: 'Weekly',
                extreme: '100 Gwei Challenge'
            };
            title.textContent = `${typeLabels[type] || type} Odds Chart`;

            // Get the chart URL - ZAMM handles Y/N orientation
            const chartData = chartPoolIds.get(type);
            if (chartData) {
                const poolIdDecimal = BigInt(chartData.poolId).toString();
                iframe.src = `https://www.zamm.finance/embed/pool/${poolIdDecimal}?theme=dark`;
            }

            // Update stats
            updateOddsModalStats(type);

            modal.classList.add('active');
            isOddsModalOpen = true;
            currentOddsMarketType = type;
            document.body.style.overflow = 'hidden';
        }

        function closeOddsModal() {
            const modal = document.getElementById('oddsModal');
            const iframe = document.getElementById('oddsModalIframe');
            modal.classList.remove('active');
            isOddsModalOpen = false;
            currentOddsMarketType = null;
            document.body.style.overflow = '';
            // Clear iframe to stop loading
            iframe.src = '';
        }

        function updateOddsModalStats(type) {
            const market = markets[type];
            if (!market) return;

            const upPrice = document.getElementById('oddsModalUpPrice');
            const downPrice = document.getElementById('oddsModalDownPrice');
            const tvl = document.getElementById('oddsModalTvl');
            const closes = document.getElementById('oddsModalCloses');

            // Use YES/NO labels for extreme, UP/DOWN for others
            const upLabel = document.querySelector('#oddsModalUpPrice').parentElement.querySelector('.odds-modal-stat-label');
            const downLabel = document.querySelector('#oddsModalDownPrice').parentElement.querySelector('.odds-modal-stat-label');
            if (type === 'extreme') {
                upLabel.textContent = 'YES Price';
                downLabel.textContent = 'NO Price';
            } else {
                upLabel.textContent = 'UP Price';
                downLabel.textContent = 'DOWN Price';
            }

            // Prices
            if (market.yesPrice !== undefined) {
                upPrice.textContent = market.yesPrice.toFixed(2) + ' ';
            }
            if (market.noPrice !== undefined) {
                downPrice.textContent = market.noPrice.toFixed(2) + ' ';
            }

            // TVL
            if (market.tvl) {
                tvl.textContent = formatEth(market.tvl);
            }

            // Time to close
            if (market.closeTime) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = market.closeTime - now;
                closes.textContent = formatTime(remaining);
            }
        }

        // Handle ESC key for odds modal
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isOddsModalOpen) {
                closeOddsModal();
            }
        });

        function updateModalStats() {
            const modalCurrentGas = document.getElementById('modalCurrentGas');
            const modalTwapGas = document.getElementById('modalTwapGas');

            if (cachedGasData.current) {
                modalCurrentGas.textContent = cachedGasData.current.toFixed(2) + ' gwei';
            }
            if (cachedGasData.twap) {
                modalTwapGas.textContent = cachedGasData.twap.toFixed(2) + ' gwei';
            }
        }

        function drawModalChart() {
            if (!isChartModalOpen) return;
            if (!cachedGasData || !cachedGasData.current) return;

            const canvas = document.getElementById('modalChart');
            const container = canvas.parentElement;

            // Size canvas to container
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            if (!modalChartCtx) modalChartCtx = canvas.getContext('2d');
            const ctx = modalChartCtx;

            const { twap, current, startTime } = cachedGasData;
            const width = canvas.width;
            const height = canvas.height;

            // Generous padding for modal view
            const isMobile = width < 500;
            const padding = isMobile ? 35 : 50;
            const paddingRight = isMobile ? 80 : 120;
            const chartWidth = width - padding - paddingRight;

            // Clear
            ctx.fillStyle = '#18181b';
            ctx.fillRect(0, 0, width, height);

            // Use actual data points
            let data = chartDataPoints.length > 0 ? [...chartDataPoints] : [current];
            let timestamps = [...chartTimestamps];

            // Ensure current is last point
            if (data.length === 0 || data[data.length - 1] !== current) {
                data.push(current);
                timestamps.push(Math.floor(Date.now() / 1000));
            }

            // Downsample for large datasets
            const maxDisplayPoints = 400;
            if (data.length > maxDisplayPoints) {
                const factor = Math.ceil(data.length / maxDisplayPoints);
                const sampledData = [];
                const sampledTimestamps = [];
                for (let i = 0; i < data.length; i += factor) {
                    sampledData.push(data[i]);
                    if (timestamps[i] !== undefined) sampledTimestamps.push(timestamps[i]);
                }
                if (sampledData[sampledData.length - 1] !== data[data.length - 1]) {
                    sampledData.push(data[data.length - 1]);
                    if (timestamps.length > 0) sampledTimestamps.push(timestamps[timestamps.length - 1]);
                }
                data = sampledData;
                timestamps = sampledTimestamps;
            }

            // Calculate Y range
            const allValues = [...data, twap];
            let max = Math.max(...allValues) * 1.1;
            let min = Math.min(...allValues) * 0.9;
            const range = Math.max(max - min, 0.001);
            const gweiToY = (gwei) => padding + (height - padding * 2) * (1 - (gwei - min) / range);

            const getDecimals = (r) => {
                if (r >= 10) return 0;
                if (r >= 1) return 1;
                if (r >= 0.1) return 2;
                return 3;
            };
            const decimals = getDecimals(range);

            // Draw grid
            const axisFontSize = isMobile ? 10 : 12;
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (height - padding * 2) * i / 5;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'right';
                ctx.fillText((max - range * i / 5).toFixed(decimals), padding - 8, y + 4);
            }

            // Draw time axis labels
            if (timestamps.length > 1) {
                const firstTime = timestamps[0];
                const lastTime = timestamps[timestamps.length - 1];
                const timeSpan = lastTime - firstTime;

                const formatTime = (ts) => {
                    const d = new Date(ts * 1000);
                    if (timeSpan < 86400) {
                        return d.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                    } else if (timeSpan < 604800) {
                        return d.toLocaleDateString(undefined, { weekday: 'short', hour: '2-digit' });
                    } else {
                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    }
                };

                const numLabels = isMobile ? 4 : 6;
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'center';
                for (let i = 0; i < numLabels; i++) {
                    const idx = Math.floor(i * (timestamps.length - 1) / (numLabels - 1));
                    const x = padding + chartWidth * idx / Math.max(1, data.length - 1);
                    ctx.fillText(formatTime(timestamps[idx]), x, height - padding + 20);
                }
            }

            // Draw TWAP reference line
            const twapY = gweiToY(twap);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([8, 6]);
            ctx.beginPath();
            ctx.moveTo(padding, twapY);
            ctx.lineTo(padding + chartWidth, twapY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#3b82f6';
            ctx.font = `bold ${axisFontSize}px Helvetica`;
            ctx.textAlign = 'right';
            ctx.fillText('TWAP ' + twap.toFixed(decimals), padding + chartWidth - 8, twapY - 8);

            // Draw line chart with directional coloring
            if (data.length > 0) {
                ctx.lineWidth = 2.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                for (let i = 1; i < data.length; i++) {
                    const x1 = padding + chartWidth * (i - 1) / Math.max(1, data.length - 1);
                    const y1 = gweiToY(data[i - 1]);
                    const x2 = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y2 = gweiToY(data[i]);

                    const isUp = data[i] >= data[i - 1];
                    ctx.strokeStyle = isUp ? '#22c55e' : '#ef4444';

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Gradient fill
                const firstVal = data[0];
                const lastVal = data[data.length - 1];
                const overallUp = lastVal >= firstVal;
                const trendColor = overallUp ? '34, 197, 94' : '239, 68, 68';

                const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
                gradient.addColorStop(0, `rgba(${trendColor}, 0.2)`);
                gradient.addColorStop(1, `rgba(${trendColor}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                for (let i = 0; i < data.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(padding + chartWidth, height - padding);
                ctx.closePath();
                ctx.fill();

                // Current point with pulse effect
                const lastX = padding + chartWidth;
                const lastY = gweiToY(data[data.length - 1]);
                const pulseTime = Date.now() / 1000;
                const pulseScale = 1 + 0.3 * Math.sin(pulseTime * 3);
                const pulseColor = overallUp ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)';

                ctx.fillStyle = pulseColor;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 15 * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = overallUp ? '#22c55e' : '#ef4444';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 6, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 2, 0, Math.PI * 2);
                ctx.fill();

                // Current value label
                ctx.font = `bold 14px Helvetica`;
                ctx.textAlign = 'left';
                ctx.fillStyle = overallUp ? '#22c55e' : '#ef4444';
                ctx.fillText(data[data.length - 1].toFixed(decimals) + ' gwei', lastX + 12, lastY + 5);
            }

            // Legend
            ctx.font = `${isMobile ? 10 : 11}px Helvetica`;
            ctx.textAlign = 'left';
            const legendY = 20;
            ctx.fillStyle = '#22c55e';
            ctx.fillText(' UP', padding, legendY);
            ctx.fillStyle = '#ef4444';
            ctx.fillText(' DOWN', padding + 50, legendY);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText(' TWAP', padding + 120, legendY);

            // Observation count
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.textAlign = 'left';
            ctx.fillText(`${chartDataPoints.length || 1} observations`, padding, height - 8);
        }

        // ======================== CHART ========================
        let hoverIndex = -1; // Track hovered data point for crosshair
        let resizeTimer = null; // For debouncing resize
        let tooltipSpotEl, tooltipTwapEl, tooltipTimeEl; // Cache tooltip elements

        function setupChart() {
            const canvas = DOM.gasChart;
            const tooltip = DOM.chartTooltip;
            const predTooltip = DOM.predTooltip;

            if (!canvas || !tooltip) {
                console.error('Chart elements not found');
                return;
            }

            // Cache tooltip sub-elements
            tooltipSpotEl = document.getElementById('tooltipSpot');
            tooltipTwapEl = document.getElementById('tooltipTwap');
            tooltipTimeEl = document.getElementById('tooltipTime');

            // Cache prediction tooltip elements
            const predBadge = document.getElementById('predBadge');
            const predTitle = document.getElementById('predTitle');
            const predTwap = document.getElementById('predTwap');
            const predDirection = document.getElementById('predDirection');
            const predThreshold = document.getElementById('predThreshold');
            const predTvl = document.getElementById('predTvl');
            const predCloses = document.getElementById('predCloses');

            canvas.addEventListener('mousemove', (e) => {
                if (!chartState.data || !chartState.data.length) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const { data, rollingTwap, padding, chartWidth, width, height } = chartState;

                // Check if hovering over price change badge first
                if (priceChangeBadgeArea) {
                    const b = priceChangeBadgeArea;
                    if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                        // Show price change tooltip using the chart tooltip
                        tooltip.classList.remove('visible');
                        if (predTooltip) predTooltip.classList.remove('visible');
                        hoverIndex = -1;
                        hoveredPrediction = null;

                        // Format time span for display
                        let timeDesc = '';
                        if (b.timeSpan < 3600) {
                            timeDesc = 'Last ' + Math.round(b.timeSpan / 60) + ' minutes';
                        } else if (b.timeSpan < 86400) {
                            const hrs = Math.round(b.timeSpan / 3600);
                            timeDesc = 'Last ' + hrs + ' hour' + (hrs > 1 ? 's' : '');
                        } else {
                            const days = Math.round(b.timeSpan / 86400);
                            timeDesc = 'Last ' + days + ' day' + (days > 1 ? 's' : '');
                        }

                        // Update tooltip content for price change
                        tooltipTimeEl.textContent = timeDesc;
                        tooltipSpotEl.textContent = b.firstVal.toFixed(2) + '  ' + b.lastVal.toFixed(2) + ' gwei';
                        const changeSign = b.change >= 0 ? '+' : '';
                        tooltipTwapEl.textContent = changeSign + b.change.toFixed(2) + '% change';

                        // Position tooltip near badge
                        tooltip.style.left = (b.x + b.width + 10) + 'px';
                        tooltip.style.top = (b.y) + 'px';
                        tooltip.classList.add('visible');

                        canvas.style.cursor = 'help';
                        return;
                    }
                }

                // Check if hovering over a prediction marker
                let foundPrediction = null;
                for (const marker of predictionMarkerPositions) {
                    const dx = x - marker.x;
                    const dy = y - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        foundPrediction = marker;
                        break;
                    }
                }

                if (foundPrediction && predTooltip) {
                    // Hide chart tooltip, show prediction tooltip
                    tooltip.classList.remove('visible');
                    hoverIndex = -1;

                    // Update prediction tooltip content
                    const marketNames = { weekly: 'Weekly' };
                    const isUp = foundPrediction.yesPrice > 0.5;
                    const prob = Math.round(foundPrediction.yesPrice * 100);

                    if (predBadge) {
                        predBadge.textContent = foundPrediction.label;
                        predBadge.style.background = foundPrediction.color;
                        predBadge.style.color = '#18181b';
                    }
                    if (predTitle) predTitle.textContent = marketNames[foundPrediction.type] + ' Prediction';
                    predTooltip.style.borderColor = foundPrediction.color;

                    // Get market data for threshold
                    const marketData = markets[foundPrediction.type];
                    const threshold = marketData?.startGwei || 0;
                    const predicted = foundPrediction.predicted;
                    const aboveThreshold = predicted > threshold;

                    // Direction/Odds indicator - shows market sentiment
                    const isNeutral = prob >= 45 && prob <= 55;
                    if (predDirection) {
                        if (isNeutral) {
                            predDirection.className = 'pred-tooltip-direction neutral';
                            predDirection.innerHTML = `~50% EVEN`;
                        } else {
                            predDirection.className = 'pred-tooltip-direction ' + (isUp ? 'up' : 'down');
                            predDirection.innerHTML = `${isUp ? prob : 100 - prob}% ${isUp ? 'UP' : 'DOWN'}`;
                        }
                    }

                    // Threshold - what the market is betting against
                    if (predThreshold) {
                        predThreshold.textContent = threshold.toFixed(3) + ' gwei';
                    }

                    // Predicted value with above/below indicator
                    if (predTwap) {
                        const arrow = aboveThreshold ? '' : '';
                        const color = aboveThreshold ? '#22c55e' : '#ef4444';
                        predTwap.innerHTML = `<span style="color:${color}">${arrow}</span> ${predicted.toFixed(3)} gwei`;
                    }

                    // Time to close
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = foundPrediction.closeTime - now;
                    if (predCloses) predCloses.textContent = formatTime(remaining);

                    // TVL
                    if (predTvl) predTvl.textContent = marketData?.tvl ? formatEth(marketData.tvl) : '--';

                    // Position prediction tooltip - responsive
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    const isMobileTooltip = canvasWidth < 400;
                    const predTooltipWidth = isMobileTooltip ? 150 : 180;
                    const predTooltipHeight = isMobileTooltip ? 130 : 150;
                    let tooltipX, tooltipY;

                    if (isMobileTooltip) {
                        // On mobile, position to left of marker (prediction zone is on right)
                        tooltipX = Math.max(5, x - predTooltipWidth - 10);
                        // Center vertically on marker, but clamp to canvas
                        tooltipY = Math.max(5, Math.min(y - predTooltipHeight / 2, canvasHeight - predTooltipHeight - 5));
                    } else {
                        // Desktop: position to left of marker to avoid going off right edge
                        tooltipX = x - predTooltipWidth - 15;
                        tooltipY = y - predTooltipHeight / 2;

                        // If not enough room on left, try right
                        if (tooltipX < 10) {
                            tooltipX = x + 15;
                        }
                        // Clamp to canvas edges
                        if (tooltipY + predTooltipHeight > canvasHeight) {
                            tooltipY = canvasHeight - predTooltipHeight - 5;
                        }
                        if (tooltipY < 5) {
                            tooltipY = 5;
                        }
                    }

                    predTooltip.style.left = tooltipX + 'px';
                    predTooltip.style.top = tooltipY + 'px';
                    predTooltip.classList.add('visible');

                    // Update hovered prediction state
                    if (hoveredPrediction !== foundPrediction.type) {
                        hoveredPrediction = foundPrediction.type;
                        drawChart(cachedGasData); // Redraw with highlight
                    }

                    canvas.style.cursor = 'pointer';
                    return;
                }

                // Not hovering over prediction - hide prediction tooltip
                if (hoveredPrediction) {
                    hoveredPrediction = null;
                    drawChart(cachedGasData);
                }
                if (predTooltip) predTooltip.classList.remove('visible');
                canvas.style.cursor = 'crosshair';

                // Regular chart hover logic
                const idx = Math.round((x - padding) / chartWidth * (data.length - 1));
                const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                // Update hover index and redraw for crosshair
                if (hoverIndex !== clampedIdx) {
                    hoverIndex = clampedIdx;
                    drawChart(cachedGasData);
                }

                if (clampedIdx >= 0 && clampedIdx < data.length) {
                    const spotVal = data[clampedIdx];
                    const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                    // Update tooltip content
                    tooltipSpotEl.textContent = spotVal.toFixed(2) + ' gwei';
                    tooltipTwapEl.textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                    // Time display
                    let timeText = '';
                    if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                        const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                        timeText = date.toLocaleString();
                    } else if (clampedIdx === data.length - 1) {
                        timeText = 'Now';
                    }
                    tooltipTimeEl.textContent = timeText;

                    // Position tooltip with edge clamping
                    const tooltipWidth = 160;
                    const tooltipHeight = 80;
                    let tooltipX = e.clientX - rect.left + 15;
                    let tooltipY = e.clientY - rect.top - 10;

                    // Clamp to right edge
                    if (tooltipX + tooltipWidth > width) {
                        tooltipX = e.clientX - rect.left - tooltipWidth - 15;
                    }
                    // Clamp to bottom edge
                    if (tooltipY + tooltipHeight > height) {
                        tooltipY = height - tooltipHeight - 10;
                    }
                    // Clamp to top edge
                    if (tooltipY < 10) {
                        tooltipY = 10;
                    }

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.classList.add('visible');
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
                if (predTooltip) predTooltip.classList.remove('visible');
                hoverIndex = -1;
                hoveredPrediction = null;
                canvas.style.cursor = 'default';
                drawChart(cachedGasData); // Clear crosshair
            });

            // Click handler for prediction markers - opens trade modal
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if clicking on a prediction marker
                for (const marker of predictionMarkerPositions) {
                    const dx = x - marker.x;
                    const dy = y - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        // Open trade for this market (default to UP/YES)
                        const isUp = marker.yesPrice > 0.5;
                        openTrade(marker.type, isUp);
                        return;
                    }
                }
            });

            // Touch support for mobile - full chart interaction
            let touchTimeout = null;
            let isTouchingChart = false;

            function handleChartTouch(touchX, touchY, clientX, clientY) {
                if (!chartState.data || !chartState.data.length) return false;

                const { data, rollingTwap, padding, chartWidth, width, height } = chartState;

                // Check if touching a prediction marker first
                for (const marker of predictionMarkerPositions) {
                    const dx = touchX - marker.x;
                    const dy = touchY - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        hoveredPrediction = marker.type;
                        if (cachedGasData) drawChart(cachedGasData);
                        // Trigger mousemove to show prediction tooltip
                        canvas.dispatchEvent(new MouseEvent('mousemove', { clientX, clientY }));
                        return true;
                    }
                }

                // Check if touching within chart area (not prediction zone)
                if (touchX >= padding && touchX <= padding + chartWidth) {
                    // Calculate data index from touch position
                    const idx = Math.round((touchX - padding) / chartWidth * (data.length - 1));
                    const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                    if (clampedIdx >= 0 && clampedIdx < data.length) {
                        hoverIndex = clampedIdx;
                        if (cachedGasData) drawChart(cachedGasData);

                        const spotVal = data[clampedIdx];
                        const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                        // Update tooltip content
                        tooltipSpotEl.textContent = spotVal.toFixed(2) + ' gwei';
                        tooltipTwapEl.textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                        // Time display
                        let timeText = '';
                        if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                            const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                            timeText = date.toLocaleString();
                        } else if (clampedIdx === data.length - 1) {
                            timeText = 'Now';
                        }
                        tooltipTimeEl.textContent = timeText;

                        // Position tooltip - centered above touch point on mobile
                        const tooltipWidth = 140;
                        let tooltipX = Math.max(5, Math.min(touchX - tooltipWidth / 2, width - tooltipWidth - 5));
                        let tooltipY = Math.max(5, touchY - 70);

                        tooltip.style.left = tooltipX + 'px';
                        tooltip.style.top = tooltipY + 'px';
                        tooltip.classList.add('visible');
                        return true;
                    }
                }

                return false;
            }

            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Clear any pending timeout
                if (touchTimeout) clearTimeout(touchTimeout);

                isTouchingChart = handleChartTouch(x, y, touch.clientX, touch.clientY);

                if (isTouchingChart) {
                    e.preventDefault(); // Prevent scroll while interacting
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (!isTouchingChart) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                handleChartTouch(x, y, touch.clientX, touch.clientY);
                e.preventDefault();
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                // Clear tooltip after a delay on touch release
                if (touchTimeout) clearTimeout(touchTimeout);
                touchTimeout = setTimeout(() => {
                    tooltip.classList.remove('visible');
                    if (predTooltip) predTooltip.classList.remove('visible');
                    hoverIndex = -1;
                    hoveredPrediction = null;
                    isTouchingChart = false;
                    if (cachedGasData) drawChart(cachedGasData);
                }, 2500); // Keep tooltip visible for 2.5s after touch ends
            });

            // Debounced resize handler
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (chartDataPoints.length) drawChart(cachedGasData);
                }, 150);
            });
        }

        // Cache canvas context
        let chartCtx = null;

        function drawChart(gasData) {
            const { twap, current, startTime } = gasData;

            const canvas = DOM.gasChart;
            if (!chartCtx) chartCtx = canvas.getContext('2d');
            const ctx = chartCtx;
            const container = canvas.parentElement;

            // Only resize canvas if dimensions actually changed (avoids clearing on every frame)
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            if (lastCanvasSize.width !== newWidth || lastCanvasSize.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                lastCanvasSize.width = newWidth;
                lastCanvasSize.height = newHeight;
            }

            const width = canvas.width;
            const height = canvas.height;

            // Responsive padding based on screen width
            const isMobile = width < 400;
            const isSmall = width < 600;
            const padding = isMobile ? 25 : (isSmall ? 32 : 40);
            const paddingRight = isMobile ? 60 : (isSmall ? 80 : 100); // Extra space for prediction zone
            const chartWidth = width - padding - paddingRight; // Chart area width

            // Clear
            ctx.fillStyle = '#18181b';
            ctx.fillRect(0, 0, width, height);

            // Use actual data points, or just current if no history
            // Note: We reference arrays directly for pulse animation, only copy when data changes
            let data = chartDataPoints.length > 0 ? chartDataPoints : [current];
            let timestamps = chartTimestamps;
            let cumulatives = chartCumulatives;

            // Ensure current is last point (only modify if needed)
            if (data.length === 0 || data[data.length - 1] !== current) {
                data = [...data, current];
                timestamps = [...timestamps, Math.floor(Date.now() / 1000)];
            }

            // Downsample for large datasets (keep max ~300 points for smooth rendering)
            const maxDisplayPoints = 300;
            let downsampleFactor = 1;
            if (data.length > maxDisplayPoints) {
                downsampleFactor = Math.ceil(data.length / maxDisplayPoints);
                const sampledData = [];
                const sampledTimestamps = [];
                const sampledCumulatives = [];
                for (let i = 0; i < data.length; i += downsampleFactor) {
                    sampledData.push(data[i]);
                    if (timestamps[i] !== undefined) sampledTimestamps.push(timestamps[i]);
                    if (cumulatives[i] !== undefined) sampledCumulatives.push(cumulatives[i]);
                }
                // Always include the last point
                if (sampledData[sampledData.length - 1] !== data[data.length - 1]) {
                    sampledData.push(data[data.length - 1]);
                    if (timestamps.length > 0) sampledTimestamps.push(timestamps[timestamps.length - 1]);
                    if (cumulatives.length > 0) sampledCumulatives.push(cumulatives[cumulatives.length - 1]);
                }
                data = sampledData;
                timestamps = sampledTimestamps;
                cumulatives = sampledCumulatives;
            }

            // Compute rolling TWAP from cumulative observations
            let rollingTwap = [];
            if (cumulatives.length >= 2 && startTime) {
                for (let i = 0; i < cumulatives.length; i++) {
                    const elapsed = timestamps[i] - startTime;
                    if (elapsed > 0) {
                        rollingTwap.push(cumulatives[i] / elapsed / 1e9);
                    } else {
                        rollingTwap.push(data[i]);
                    }
                }
            }
            // Add current TWAP as final point if needed
            if (rollingTwap.length > 0 && rollingTwap.length < data.length) {
                rollingTwap.push(twap);
            }

            // Calculate Y range (include rolling TWAP but only reasonable predictions)
            const allValues = [...data, twap];
            if (rollingTwap.length > 0) allValues.push(...rollingTwap);

            // Calculate base range from actual data first
            const dataMin = Math.min(...data);
            const dataMax = Math.max(...data);
            const dataRange = dataMax - dataMin;

            // Only include predictions if they're within 3x of the data range
            // This prevents extreme outliers from distorting the chart
            const addPredictionIfReasonable = (pred) => {
                if (!pred || pred <= 0) return;
                // Check if prediction is within reasonable bounds (within 3x range of data)
                const upperBound = dataMax + dataRange * 2;
                const lowerBound = Math.max(0, dataMin - dataRange * 2);
                if (pred >= lowerBound && pred <= upperBound) {
                    allValues.push(pred);
                }
            };
            addPredictionIfReasonable(markets.weekly?.predictedTwap);

            let max = Math.max(...allValues) * 1.1;
            let min = Math.min(...allValues) * 0.9;

            // Ensure non-zero range to prevent division by zero
            const range = Math.max(max - min, 0.001);
            const gweiToY = (gwei) => padding + (height - padding * 2) * (1 - (gwei - min) / range);

            // Determine decimal places based on range
            const getDecimals = (r) => {
                if (r >= 10) return 0;
                if (r >= 1) return 1;
                if (r >= 0.1) return 2;
                if (r >= 0.01) return 3;
                return 4;
            };
            const decimals = getDecimals(range);

            // Draw grid - responsive Y-axis labels
            const axisFontSize = isMobile ? 8 : (isSmall ? 9 : 10);
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (height - padding * 2) * i / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'right';
                ctx.fillText((max - range * i / 4).toFixed(decimals), padding - (isMobile ? 3 : 5), y + 4);
            }

            // Draw time axis labels (X-axis)
            if (timestamps.length > 1) {
                const firstTime = timestamps[0];
                const lastTime = timestamps[timestamps.length - 1];
                const timeSpan = lastTime - firstTime;

                // Determine time format based on span
                const formatTime = (ts) => {
                    const d = new Date(ts * 1000);
                    if (timeSpan < 86400) { // < 1 day: show hours
                        return d.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                    } else if (timeSpan < 604800) { // < 1 week: show day + hour
                        return d.toLocaleDateString(undefined, { weekday: 'short', hour: '2-digit' });
                    } else { // >= 1 week: show date
                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    }
                };

                // Draw 3-5 time labels evenly spaced - responsive
                const numLabels = isMobile ? Math.min(3, data.length) : Math.min(5, data.length);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'center';
                for (let i = 0; i < numLabels; i++) {
                    const idx = Math.floor(i * (timestamps.length - 1) / (numLabels - 1));
                    const x = padding + chartWidth * idx / Math.max(1, data.length - 1);
                    const label = formatTime(timestamps[idx]);
                    ctx.fillText(label, x, height - padding + (isMobile ? 18 : 28));
                }
            }

            // Draw rolling TWAP line (cyan, behind spot line)
            if (rollingTwap.length > 1) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                for (let i = 0; i < rollingTwap.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(rollingTwap[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw current TWAP reference (final value as horizontal dashed line) - responsive
            const twapY = gweiToY(twap);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, twapY);
            ctx.lineTo(padding + chartWidth, twapY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#3b82f6';
            ctx.font = `${axisFontSize}px Helvetica`;
            ctx.textAlign = 'right';
            // Position TWAP label BEFORE prediction zone to avoid overlap with diamonds
            const twapLabel = isMobile ? twap.toFixed(decimals) : ('TWAP ' + twap.toFixed(decimals));
            ctx.fillText(twapLabel, padding + chartWidth - (isMobile ? 3 : 5), twapY + 4);

            // Draw line chart connecting data points (spot prices) with directional coloring
            // Green = price going UP (bullish for YES/UP), Red = price going DOWN (bearish/NO)
            if (data.length > 0) {
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw each segment with direction-based color
                for (let i = 1; i < data.length; i++) {
                    const x1 = padding + chartWidth * (i - 1) / Math.max(1, data.length - 1);
                    const y1 = gweiToY(data[i - 1]);
                    const x2 = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y2 = gweiToY(data[i]);

                    // Color based on direction: green if going up, red if going down
                    const isUp = data[i] >= data[i - 1];
                    ctx.strokeStyle = isUp ? '#22c55e' : '#ef4444';

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Draw gradient fill under spot line - use overall trend color
                const firstVal = data[0];
                const lastVal = data[data.length - 1];
                const overallUp = lastVal >= firstVal;
                const trendColor = overallUp ? '34, 197, 94' : '239, 68, 68'; // green or red RGB

                const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
                gradient.addColorStop(0, `rgba(${trendColor}, 0.15)`);
                gradient.addColorStop(1, `rgba(${trendColor}, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                for (let i = 0; i < data.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(padding + chartWidth, height - padding);
                ctx.closePath();
                ctx.fill();

                // Find min/max values and indices
                let minVal = Infinity, maxVal = -Infinity, minIdx = 0, maxIdx = 0;
                for (let i = 0; i < data.length; i++) {
                    if (data[i] < minVal) { minVal = data[i]; minIdx = i; }
                    if (data[i] > maxVal) { maxVal = data[i]; maxIdx = i; }
                }

                // Draw data points (skip for large datasets - line is enough)
                if (data.length <= 100) {
                    const pointSize = data.length > 50 ? 2 : (data.length > 20 ? 3 : 4);
                    for (let i = 0; i < data.length; i++) {
                        const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                        const y = gweiToY(data[i]);
                        // Color based on direction from previous point
                        const isUp = i === 0 ? true : data[i] >= data[i - 1];
                        ctx.fillStyle = isUp ? '#22c55e' : '#ef4444';
                        ctx.beginPath();
                        ctx.arc(x, y, i === data.length - 1 ? 6 : pointSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw min/max markers (subtle, just small indicators)
                if (data.length > 3) {
                    // Max marker - small diamond
                    const maxX = padding + chartWidth * maxIdx / Math.max(1, data.length - 1);
                    const maxY = gweiToY(maxVal);
                    if (maxIdx !== data.length - 1) { // Don't mark if it's the current point
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(maxX, maxY - 6);
                        ctx.lineTo(maxX + 4, maxY);
                        ctx.lineTo(maxX, maxY + 6);
                        ctx.lineTo(maxX - 4, maxY);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Min marker - small diamond (only if significantly different position)
                    if (Math.abs(minIdx - maxIdx) > 2 && minIdx !== data.length - 1) {
                        const minX = padding + chartWidth * minIdx / Math.max(1, data.length - 1);
                        const minY = gweiToY(minVal);
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(minX, minY - 5);
                        ctx.lineTo(minX + 3, minY);
                        ctx.lineTo(minX, minY + 5);
                        ctx.lineTo(minX - 3, minY);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw crosshair on hover
                if (hoverIndex >= 0 && hoverIndex < data.length) {
                    const hoverX = padding + chartWidth * hoverIndex / Math.max(1, data.length - 1);
                    const hoverY = gweiToY(data[hoverIndex]);

                    // Vertical line
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(hoverX, padding);
                    ctx.lineTo(hoverX, height - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Highlight circle on spot line - color based on direction
                    const hoverUp = hoverIndex === 0 ? true : data[hoverIndex] >= data[hoverIndex - 1];
                    ctx.strokeStyle = hoverUp ? '#22c55e' : '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hoverX, hoverY, 8, 0, Math.PI * 2);
                    ctx.stroke();

                    // Also highlight TWAP point if available
                    if (rollingTwap && rollingTwap[hoverIndex]) {
                        const twapHoverY = gweiToY(rollingTwap[hoverIndex]);
                        ctx.strokeStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(hoverX, twapHoverY, 6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Pulsing live point (outer glow) - responsive, color based on trend
                const lastX = padding + chartWidth;
                const lastY = gweiToY(data[data.length - 1]);
                const pulseTime = Date.now() / 1000;
                const pulseScale = 1 + 0.3 * Math.sin(pulseTime * 3);
                const pulseRadius = isMobile ? 8 : 12;
                // Use overall trend color for pulse
                const pulseColor = overallUp ? 'rgba(34, 197, 94, 0.25)' : 'rgba(239, 68, 68, 0.25)';
                ctx.fillStyle = pulseColor;
                ctx.beginPath();
                ctx.arc(lastX, lastY, pulseRadius * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                // White center on current point
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(lastX, lastY, isMobile ? 1.5 : 2, 0, Math.PI * 2);
                ctx.fill();

                // Current value label (next to live point) - responsive, color based on trend
                const currentLabel = data[data.length - 1].toFixed(decimals);
                ctx.font = `bold ${axisFontSize}px Helvetica`;
                ctx.textAlign = 'left';
                ctx.fillStyle = overallUp ? '#22c55e' : '#ef4444';
                const labelOffset = isMobile ? 12 : 18;
                const labelY = lastY < padding + 30 ? lastY + labelOffset : lastY - (isMobile ? 8 : 12);
                ctx.fillText(currentLabel, lastX + (isMobile ? 6 : 10), labelY);
            }

            // Price change badge (top-left, inside chart with subtle background)
            if (data.length > 1 && timestamps.length > 1) {
                const firstVal = data[0];
                const lastVal = data[data.length - 1];
                const change = firstVal > 0 ? ((lastVal - firstVal) / firstVal) * 100 : 0;
                const changeColor = change >= 0 ? '#22c55e' : '#ef4444';
                const changeSign = change >= 0 ? '+' : '';
                const changeText = changeSign + change.toFixed(1) + '%';

                // Calculate time period for context
                const timeSpan = timestamps[timestamps.length - 1] - timestamps[0];
                let periodLabel = '';
                if (timeSpan < 3600) {
                    periodLabel = Math.round(timeSpan / 60) + 'm';
                } else if (timeSpan < 86400) {
                    periodLabel = Math.round(timeSpan / 3600) + 'h';
                } else {
                    periodLabel = Math.round(timeSpan / 86400) + 'd';
                }

                // Responsive badge sizing
                const badgeFontBold = isMobile ? 8 : (isSmall ? 9 : 10);
                const badgeFontSmall = isMobile ? 7 : (isSmall ? 8 : 9);
                ctx.font = `bold ${badgeFontBold}px Helvetica`;
                const changeWidth = ctx.measureText(changeText).width;
                ctx.font = `${badgeFontSmall}px Helvetica`;
                const periodWidth = ctx.measureText(periodLabel).width;
                const totalWidth = changeWidth + periodWidth + (isMobile ? 4 : 6);

                // Draw subtle pill background - top left, above chart area - responsive
                const pillX = isMobile ? 4 : 8;
                const pillY = isMobile ? 10 : 12;
                const pillPadX = isMobile ? 4 : 6;
                const pillPadY = isMobile ? 3 : 4;
                const pillHeight = isMobile ? 13 : 16;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.roundRect(pillX - pillPadX, pillY - pillPadY - (isMobile ? 6 : 8), totalWidth + pillPadX * 2, pillHeight, 4);
                ctx.fill();

                // Draw change percentage
                ctx.textAlign = 'left';
                ctx.font = `bold ${badgeFontBold}px Helvetica`;
                ctx.fillStyle = changeColor;
                ctx.fillText(changeText, pillX, pillY);

                // Draw period label
                ctx.font = `${badgeFontSmall}px Helvetica`;
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText(periodLabel, pillX + changeWidth + (isMobile ? 3 : 4), pillY);

                // Store hit area for hover detection
                priceChangeBadgeArea = {
                    x: pillX - pillPadX,
                    y: pillY - pillPadY - (isMobile ? 6 : 8),
                    width: totalWidth + pillPadX * 2,
                    height: pillHeight,
                    change,
                    firstVal,
                    lastVal,
                    timeSpan,
                    periodLabel
                };
            } else {
                priceChangeBadgeArea = null;
            }

            // Legend - top-right corner, above chart area - responsive
            const legendFontSize = isMobile ? 7 : (isSmall ? 8 : 9);
            ctx.font = `${legendFontSize}px Helvetica`;
            ctx.textAlign = 'right';
            const legendY = isMobile ? 10 : 12;
            const legendSpacing = isMobile ? 35 : 48;
            // Show UP (green) and DOWN (red) indicators
            ctx.fillStyle = '#22c55e';
            ctx.fillText(' UP', width - legendSpacing * 3 - 5, legendY);
            ctx.fillStyle = '#ef4444';
            ctx.fillText(' DOWN', width - legendSpacing * 2 - 5, legendY);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
            ctx.fillText(' TWAP', width - legendSpacing - 5, legendY);
            ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';
            ctx.fillText(' Pred', width - 5, legendY);

            // Draw prediction markers for each market
            drawPredictionMarkers(ctx, width, height, padding, chartWidth, gweiToY, timestamps, decimals);

            // Observation count (bottom-left) - show original count, not downsampled - responsive
            const originalCount = chartDataPoints.length || 1;
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = `${legendFontSize}px Helvetica`;
            ctx.fillText(`${originalCount} obs`, padding, height - padding + (isMobile ? 8 : 12));

            // Store state for tooltips (include rolling TWAP for tooltip display)
            chartState = { data, rollingTwap, padding, chartWidth, min, max, width, height, twap, current, timestamps, downsampleFactor };
        }

        /**
         * Draw prediction markers on the chart for each market's close time
         */
        function drawPredictionMarkers(ctx, width, height, padding, chartWidth, gweiToY, timestamps, decimals) {
            // Clear previous marker positions for hover detection
            predictionMarkerPositions = [];

            if (!timestamps || timestamps.length < 2) return;

            const firstTime = timestamps[0];
            const lastTime = timestamps[timestamps.length - 1];
            const timeRange = lastTime - firstTime;
            if (timeRange <= 0) return;

            // Responsive sizing based on canvas width
            const isMobile = width < 400;
            const isSmall = width < 600;

            const chartRightEdge = padding + chartWidth;

            // Draw "NOW" separator line - vertical dashed line at chart edge
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(chartRightEdge, padding);
            ctx.lineTo(chartRightEdge, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);

            // "NOW" label at top
            ctx.font = isMobile ? 'bold 7px Helvetica' : 'bold 9px Helvetica';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.textAlign = 'center';
            ctx.fillText('NOW', chartRightEdge, padding - (isMobile ? 4 : 6));

            // Subtle gradient overlay for prediction zone
            const predZoneGradient = ctx.createLinearGradient(chartRightEdge, 0, width, 0);
            predZoneGradient.addColorStop(0, 'rgba(255, 255, 255, 0.02)');
            predZoneGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
            ctx.fillStyle = predZoneGradient;
            ctx.fillRect(chartRightEdge, padding, width - chartRightEdge - 5, height - padding * 2);

            // Colors for each market type
            const marketColors = {
                weekly: '#06b6d4'   // cyan
            };

            const marketLabels = {
                weekly: '1W'
            };

            // Animation time for pulse effect
            const pulseTime = Date.now() / 1000;

            // Draw predictions for weekly market
            ['weekly'].forEach(type => {
                const market = markets[type];
                if (!market || !market.predictedTwap || !market.close) return;

                const closeTime = market.close;
                const predicted = market.predictedTwap;
                const yesPrice = market.yesPrice;

                // Calculate X position: extend chart to show future predictions
                const timeOffset = closeTime - lastTime;
                const futureExtend = Math.min(timeOffset / timeRange, 0.35);

                // Position: right edge + proportional future offset
                const xPos = padding + chartWidth + futureExtend * chartWidth;

                // Only draw if within canvas bounds (allow close to edge for predictions)
                if (xPos > width - 5) return;

                // Calculate Y position - use raw position for accurate placement
                const rawYPos = gweiToY(predicted);
                // Only clamp to prevent going off canvas, not for label fitting
                const minY = padding + 5;
                const maxY = height - padding - 5;
                const markerYPos = Math.max(minY, Math.min(rawYPos, maxY));

                const color = marketColors[type];
                const label = marketLabels[type];

                // Draw connecting line from current TWAP to ACTUAL prediction position (not clamped)
                // Gradient line that fades toward prediction
                const lineGradient = ctx.createLinearGradient(chartRightEdge, 0, xPos, 0);
                lineGradient.addColorStop(0, color);
                lineGradient.addColorStop(1, color + '80'); // 50% opacity at end
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = 1;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(chartRightEdge, gweiToY(cachedGasData.twap));
                ctx.lineTo(xPos, rawYPos); // Use raw position for accurate line direction
                ctx.stroke();
                ctx.setLineDash([]);

                // Marker size - larger on mobile for visibility, smaller on desktop for precision
                const markerSize = isMobile ? 7 : (isSmall ? 5 : 5);

                // Draw glow effect for markers - more prominent on mobile
                const glowSize = isMobile ? (markerSize + 6) : (markerSize + 3);
                const glowGradient = ctx.createRadialGradient(xPos, markerYPos, 0, xPos, markerYPos, glowSize);
                glowGradient.addColorStop(0, color + '40');
                glowGradient.addColorStop(1, color + '00');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(xPos, markerYPos, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Draw prediction diamond marker
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(xPos, markerYPos - markerSize);
                ctx.lineTo(xPos + markerSize * 0.7, markerYPos);
                ctx.lineTo(xPos, markerYPos + markerSize);
                ctx.lineTo(xPos - markerSize * 0.7, markerYPos);
                ctx.closePath();
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#18181b';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Inner highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(xPos, markerYPos - markerSize + 2);
                ctx.lineTo(xPos + markerSize * 0.5, markerYPos);
                ctx.stroke();

                // Hover highlight ring
                if (hoveredPrediction === type) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(xPos, markerYPos, markerSize + 6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Extra glow on hover
                    const hoverGlow = ctx.createRadialGradient(xPos, markerYPos, markerSize, xPos, markerYPos, markerSize + 20);
                    hoverGlow.addColorStop(0, color + '60');
                    hoverGlow.addColorStop(1, color + '00');
                    ctx.fillStyle = hoverGlow;
                    ctx.beginPath();
                    ctx.arc(xPos, markerYPos, markerSize + 20, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw pill-style label badge - only on desktop to reduce mobile clutter
                const valueDecimals = predicted < 1 ? Math.max(2, decimals) : (decimals > 1 ? 1 : decimals);
                const valueText = predicted.toFixed(valueDecimals);
                const timeText = formatCloseTime(closeTime);

                if (!isMobile) {
                    const pillFontSize = isSmall ? 9 : 10;
                    ctx.font = `bold ${pillFontSize}px Helvetica`;
                    const labelWidth = ctx.measureText(label).width;
                    const pillWidth = Math.max(labelWidth + 12, 28);
                    const pillHeight = isSmall ? 16 : 18;
                    const pillX = xPos - pillWidth / 2;
                    const pillY = markerYPos - markerSize - pillHeight - 6;

                    // Pill background
                    ctx.fillStyle = color + 'E0';
                    ctx.beginPath();
                    ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 4);
                    ctx.fill();

                    // Pill border
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Label text
                    ctx.fillStyle = '#18181b';
                    ctx.font = `bold ${pillFontSize}px Helvetica`;
                    ctx.textAlign = 'center';
                    ctx.fillText(label, xPos, pillY + 13);

                    // Close time label (below pill)
                    ctx.font = isSmall ? '8px Helvetica' : '9px Helvetica';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(timeText, xPos, pillY + pillHeight + 10);
                }

                // Predicted value (below marker) - skip on mobile since value is in pill
                if (!isMobile) {
                    const valueFontSize = isSmall ? 9 : 10;
                    ctx.font = `${valueFontSize}px Helvetica`;
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.fillText(valueText + ' gwei', xPos, markerYPos + markerSize + 16);
                }

                // Draw odds indicator bar
                if (!isMobile) {
                    const barWidth = isSmall ? 20 : 24;
                    const barHeight = 4;
                    const barX = xPos - barWidth / 2;
                    const barY = markerYPos + markerSize + 22;

                    // Bar background with rounded ends
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth, barHeight, 2);
                    ctx.fill();

                    // Fill based on YES odds - neutral gray if near 50/50
                    const yesPct = Math.round(yesPrice * 100);
                    const isNeutralOdds = yesPct >= 45 && yesPct <= 55;
                    const oddsColor = isNeutralOdds ? '#71717a' : (yesPrice > 0.5 ? '#22c55e' : '#ef4444');
                    ctx.fillStyle = oddsColor;
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth * yesPrice, barHeight, 2);
                    ctx.fill();
                }

                // Store marker position for hover detection
                // Larger hit radius on mobile for easier touch targets
                const hitRadius = isMobile ? 30 : 18;
                predictionMarkerPositions.push({
                    type,
                    x: xPos,
                    y: markerYPos,
                    radius: hitRadius,
                    predicted,
                    yesPrice,
                    noPrice: market.noPrice,
                    closeTime,
                    color,
                    label
                });
            });
        }

        // Format close time for display
        function formatCloseTime(timestamp) {
            const date = new Date(timestamp * 1000);
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const h = hours % 12 || 12;
            const m = minutes.toString().padStart(2, '0');
            return h + ':' + m + ' ' + ampm;
        }

        // ======================== COUNTDOWNS ========================
        // Cache next period timestamps to avoid creating Date objects every second
        let cachedPeriods = { nextWeek: 0 };

        function updateCountdowns() {
            const now = Math.floor(Date.now() / 1000);

            // Weekly
            if (markets.weekly) {
                DOM.weeklyCountdown.textContent = formatTime(markets.weekly.close - now);
            } else {
                if (cachedPeriods.nextWeek <= now) {
                    const sun = new Date();
                    sun.setUTCDate(sun.getUTCDate() + (7 - sun.getUTCDay()));
                    sun.setUTCHours(0, 0, 0, 0);
                    cachedPeriods.nextWeek = Math.floor(sun.getTime() / 1000);
                }
                DOM.weeklyCountdown.textContent = formatTime(cachedPeriods.nextWeek - now);
            }

            // Extreme
            if (markets.extreme) {
                const remaining = markets.extreme.close - now;
                if (remaining <= 0) {
                    DOM.extremeCountdown.textContent = 'Ended';
                } else {
                    const days = Math.floor(remaining / 86400);
                    DOM.extremeCountdown.textContent = days + ' days';
                }
            }
        }

        function formatTime(s) {
            if (s <= 0) return 'Ended';
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h >= 24) return Math.floor(h / 24) + 'd ' + (h % 24) + 'h';
            if (h > 0) return h + 'h ' + m + 'm';
            if (m > 0) return m + 'm ' + sec + 's';
            return sec + 's';
        }

        // ======================== TRADING ========================
        async function openTrade(type, isYes) {
            const market = markets[type];
            if (!market) { showStatus('No active market', 'error'); return; }
            if (!connectedAddress) { showStatus('Connect wallet first', 'error'); return; }

            currentTrade = { type, isYes, marketId: market.id, tvl: market.tvl || 0 };
            currentTradeMode = 'trade';
            currentTradeDirection = 'buy';

            // Update side toggle labels based on market type
            const yesLabel = type === 'extreme' ? 'YES' : 'UP';
            const noLabel = type === 'extreme' ? 'NO' : 'DOWN';
            document.getElementById('sideYesLabel').textContent = yesLabel;
            document.getElementById('sideNoLabel').textContent = noLabel;
            document.getElementById('tradeModalYesLabel').textContent = yesLabel;
            document.getElementById('tradeModalNoLabel').textContent = noLabel;

            // Update odds on both buttons
            updateSideOdds(market);

            // Update active side button
            updateSideButtons(isYes);

            document.getElementById('tradeTitle').textContent = market.name || type;

            // Reset to trade mode with buy direction
            setTradeMode('trade');

            // Show modal immediately with loading state
            document.getElementById('tradeAmount').value = '0.01';
            document.getElementById('tradeModalYes').textContent = '...';
            document.getElementById('tradeModalNo').textContent = '...';
            document.getElementById('tradeModalLP').textContent = '...';
            document.getElementById('previewShares').textContent = '--';
            document.getElementById('previewPrice').textContent = '--';
            document.getElementById('previewPayout').textContent = 'Loading...';
            document.getElementById('tradeModal').classList.add('active');

            // Load data in background (non-blocking)
            Promise.all([
                loadUserPosition(market.id),
                loadOrderbook(market.id, isYes)
            ]).then(() => {
                updatePreview();
            }).catch(e => {
                console.error('Failed to load trade data:', e);
                document.getElementById('previewPayout').textContent = 'Load failed';
            });
        }

        function updateSideOdds(market) {
            // Show both YES and NO odds on the side buttons
            const yesOdds = market.yesPrice ? (market.yesPrice * 100).toFixed(0) + '%' : '--';
            const noOdds = market.noPrice ? (market.noPrice * 100).toFixed(0) + '%' : '--';
            document.getElementById('sideYesOdds').textContent = yesOdds;
            document.getElementById('sideNoOdds').textContent = noOdds;
        }

        function updateSideButtons(isYes) {
            const yesBtn = document.getElementById('sideYesBtn');
            const noBtn = document.getElementById('sideNoBtn');

            if (isYes) {
                yesBtn.className = 'mode-toggle-btn active-buy';
                noBtn.className = 'mode-toggle-btn';
            } else {
                yesBtn.className = 'mode-toggle-btn';
                noBtn.className = 'mode-toggle-btn active-sell';
            }
        }

        async function switchTradeSide(isYes) {
            if (currentTrade.isYes === isYes) return; // Already on this side

            currentTrade.isYes = isYes;
            updateSideButtons(isYes);

            // Update position value display immediately
            const yesShares = parseFloat(ethers.formatEther(currentUserPosition.yesBalance || 0n));
            const noShares = parseFloat(ethers.formatEther(currentUserPosition.noBalance || 0n));
            updatePositionValue(yesShares, noShares);

            // Update trade mode labels
            setTradeMode(currentTradeMode);

            // Update limit balance if in limit mode
            if (currentTradeMode === 'limit') {
                updateLimitBalance();
            }

            // Reload orderbook in background, then update preview
            loadOrderbook(currentTrade.marketId, isYes).then(() => {
                updatePreview();
            }).catch(e => {
                console.error('Failed to load orderbook:', e);
            });
        }

        async function loadUserPosition(marketId) {
            if (!connectedAddress) {
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n, vaultYes: 0n, vaultNo: 0n };
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, rpc);

                // Use cached metadata or fetch if not available
                const marketIdStr = marketId.toString();
                let meta = marketMetaCache.get(marketIdStr);
                if (!meta) {
                    const [noId, poolKey] = await Promise.all([
                        pamm.getNoId(marketId),
                        pamm.poolKey(marketId, HOOK_FEE_OR_HOOK)
                    ]);
                    const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                        ['uint256', 'uint256', 'address', 'address', 'uint256'],
                        [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                    ));
                    meta = { noId, poolKey, poolId };
                    marketMetaCache.set(marketIdStr, meta);
                }

                // Store yesId and noId in currentTrade for swap functionality
                currentTrade.yesId = marketId;
                currentTrade.noId = meta.noId;

                // Fetch share balances and AMM LP
                const [yesBal, noBal, lpBal, poolData] = await Promise.all([
                    pamm.balanceOf(connectedAddress, marketId),
                    pamm.balanceOf(connectedAddress, meta.noId),
                    zamm.balanceOf(connectedAddress, meta.poolId),
                    zamm.pools(meta.poolId)
                ]);

                // Fetch vault positions from PMHookRouter
                let vaultYes = 0n, vaultNo = 0n;
                try {
                    const pmRouter = new ethers.Contract(PMHOOKROUTER_ADDRESS, PMHOOKROUTER_ABI, rpc);
                    const vaultPos = await pmRouter.vaultPositions(marketId, connectedAddress);
                    vaultYes = BigInt(vaultPos[0]); // yesVaultShares
                    vaultNo = BigInt(vaultPos[1]);  // noVaultShares
                } catch (e) {
                    // Vault might not exist for this market
                }

                // poolData: [reserve0, reserve1, blockTimestampLast, price0CumulativeLast, price1CumulativeLast, kLast, supply]
                currentUserPosition = {
                    yesBalance: yesBal,
                    noBalance: noBal,
                    lpBalance: lpBal,
                    poolId: meta.poolId,
                    lpTotalSupply: poolData[6],
                    vaultYes,
                    vaultNo
                };
            } catch (e) {
                console.error('Failed to load position:', e);
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n, vaultYes: 0n, vaultNo: 0n };
            }

            // Update modal display
            const yesShares = parseFloat(ethers.formatEther(currentUserPosition.yesBalance));
            const noShares = parseFloat(ethers.formatEther(currentUserPosition.noBalance));
            const vaultYesShares = parseFloat(ethers.formatEther(currentUserPosition.vaultYes || 0n));
            const vaultNoShares = parseFloat(ethers.formatEther(currentUserPosition.vaultNo || 0n));

            document.getElementById('tradeModalYes').textContent = yesShares.toFixed(4);
            document.getElementById('tradeModalNo').textContent = noShares.toFixed(4);
            document.getElementById('tradeModalLP').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);

            // Show vault positions if user has any
            const vaultEl = document.getElementById('tradeModalVault');
            if (vaultEl) {
                if (vaultYesShares > 0 || vaultNoShares > 0) {
                    vaultEl.parentElement.style.display = 'flex';
                    const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                    const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                    vaultEl.innerHTML = `${vaultYesShares.toFixed(2)} ${yesLabel} / ${vaultNoShares.toFixed(2)} ${noLabel}`;
                } else {
                    vaultEl.parentElement.style.display = 'none';
                }
            }

            // Update position value and P&L display
            updatePositionValue(yesShares, noShares);
        }

        function updatePositionValue(yesShares, noShares) {
            const positionValueEl = document.getElementById('positionValue');
            const positionPnLEl = document.getElementById('positionPnL');
            const positionOutcomeEl = document.getElementById('positionOutcome');
            const positionPayoutEl = document.getElementById('positionPayout');

            // Get pool price from orderbook state
            const ammPrice = currentOrderbook.ammPrice || 0;

            if (yesShares === 0 && noShares === 0) {
                positionValueEl.textContent = 'No position';
                positionPnLEl.style.display = 'none';
                return;
            }

            // Current value based on pool price
            // For the side we're trading (currentTrade.isYes), ammPrice is the price
            // YES value = yesShares * yesPrice, NO value = noShares * (1 - yesPrice)
            const yesPrice = currentTrade.isYes ? ammPrice : (1 - ammPrice);
            const noPrice = currentTrade.isYes ? (1 - ammPrice) : ammPrice;
            const currentValue = (yesShares * yesPrice) + (noShares * noPrice);

            if (ammPrice > 0 && currentValue > 0) {
                positionValueEl.textContent = ` ${currentValue.toFixed(4)} ETH`;
            } else {
                positionValueEl.textContent = '--';
            }

            // Show P&L section
            if (yesShares > 0 || noShares > 0) {
                positionPnLEl.style.display = 'block';

                // Use market-specific labels
                const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';

                // Determine the larger position
                if (yesShares >= noShares) {
                    positionOutcomeEl.textContent = yesLabel;
                    positionOutcomeEl.style.color = 'var(--green)';
                    const payout = yesShares;
                    const profit = payout - currentValue;
                    positionPayoutEl.textContent = `${payout.toFixed(4)} ETH`;
                    positionPayoutEl.style.color = profit >= 0 ? 'var(--green)' : 'var(--red)';
                } else {
                    positionOutcomeEl.textContent = noLabel;
                    positionOutcomeEl.style.color = 'var(--red)';
                    const payout = noShares;
                    const profit = payout - currentValue;
                    positionPayoutEl.textContent = `${payout.toFixed(4)} ETH`;
                    positionPayoutEl.style.color = profit >= 0 ? 'var(--green)' : 'var(--red)';
                }
            } else {
                positionPnLEl.style.display = 'none';
            }
        }

        let currentOrderbook = { bids: [], asks: [], ammPrice: 0, rYes: 0n, rNo: 0n };
        let currentLiquiditySources = { vault: null, amm: null, pools: null };
        let liquidityDetailsExpanded = false;

        function toggleLiquiditySources() {
            liquidityDetailsExpanded = !liquidityDetailsExpanded;
            const details = document.getElementById('liquiditySourcesDetails');
            const toggle = document.getElementById('liquiditySourcesToggle');
            if (liquidityDetailsExpanded) {
                details.style.display = 'block';
                toggle.textContent = ' Hide';
            } else {
                details.style.display = 'none';
                toggle.textContent = ' Details';
            }
        }

        // Load and display liquidity sources (vault, AMM, pools)
        async function loadLiquiditySources(marketId, isYes) {
            const rpc = provider || await getRpcProvider();

            // Reset display
            document.getElementById('vaultDepthYes').textContent = '--';
            document.getElementById('vaultDepthNo').textContent = '--';
            document.getElementById('ammDepth').textContent = '--';

            try {
                // Use Multicall3 to batch vault info requests
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pmRouterIface = new ethers.Interface(PMHOOKROUTER_ABI);

                const vaultCalls = [
                    { target: PMHOOKROUTER_ADDRESS, allowFailure: true, callData: pmRouterIface.encodeFunctionData('bootstrapVaults', [marketId]) },
                    { target: PMHOOKROUTER_ADDRESS, allowFailure: true, callData: pmRouterIface.encodeFunctionData('totalYesVaultShares', [marketId]) },
                    { target: PMHOOKROUTER_ADDRESS, allowFailure: true, callData: pmRouterIface.encodeFunctionData('totalNoVaultShares', [marketId]) }
                ];

                const vaultResults = await multicall.aggregate3(vaultCalls);

                // Decode results
                let vaultData = null, totalYesVaultShares = 0n, totalNoVaultShares = 0n;
                if (vaultResults[0].success) {
                    vaultData = pmRouterIface.decodeFunctionResult('bootstrapVaults', vaultResults[0].returnData);
                }
                if (vaultResults[1].success) {
                    totalYesVaultShares = pmRouterIface.decodeFunctionResult('totalYesVaultShares', vaultResults[1].returnData)[0];
                }
                if (vaultResults[2].success) {
                    totalNoVaultShares = pmRouterIface.decodeFunctionResult('totalNoVaultShares', vaultResults[2].returnData)[0];
                }

                if (vaultData) {
                    const yesShares = Number(vaultData[0]) / 1e18;
                    const noShares = Number(vaultData[1]) / 1e18;
                    const totalYesLP = Number(totalYesVaultShares) / 1e18;
                    const totalNoLP = Number(totalNoVaultShares) / 1e18;

                    currentLiquiditySources.vault = { yesShares, noShares, totalYesLP, totalNoLP };

                    // Update summary display
                    document.getElementById('vaultDepthYes').textContent = formatCompact(yesShares);
                    document.getElementById('vaultDepthNo').textContent = formatCompact(noShares);

                    // Update detailed display
                    document.getElementById('vaultYesDetail').textContent = yesShares.toFixed(2) + ' shares';
                    document.getElementById('vaultNoDetail').textContent = noShares.toFixed(2) + ' shares';
                    document.getElementById('vaultYesLpShares').textContent = totalYesLP.toFixed(2);
                    document.getElementById('vaultNoLpShares').textContent = totalNoLP.toFixed(2);

                    // Show user vault position if they have one
                    const userVaultYes = currentUserPosition.vaultYes ? Number(currentUserPosition.vaultYes) / 1e18 : 0;
                    const userVaultNo = currentUserPosition.vaultNo ? Number(currentUserPosition.vaultNo) / 1e18 : 0;
                    if (userVaultYes > 0 || userVaultNo > 0) {
                        const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                        const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                        document.getElementById('vaultUserPosition').style.display = 'block';
                        document.getElementById('vaultUserPositionDetail').textContent =
                            `${userVaultYes.toFixed(2)} ${yesLabel} LP / ${userVaultNo.toFixed(2)} ${noLabel} LP`;
                    } else {
                        document.getElementById('vaultUserPosition').style.display = 'none';
                    }
                }

                // AMM depth is already loaded in currentOrderbook
                if (currentOrderbook.rYes && currentOrderbook.rNo) {
                    const ammYes = Number(currentOrderbook.rYes) / 1e18;
                    const ammNo = Number(currentOrderbook.rNo) / 1e18;
                    const ammValue = Math.min(ammYes, ammNo); // Effective liquidity
                    document.getElementById('ammDepth').textContent = formatCompact(ammValue) + ' ETH';
                    currentLiquiditySources.amm = { rYes: ammYes, rNo: ammNo, effectiveDepth: ammValue };
                }

                // Fetch pooled orderbook info from MasterRouter
                const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
                if (masterRouterDeployed) {
                    const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, rpc);

                    // Get best bid/ask for quick display
                    const [bestAsk, bestBid] = await Promise.all([
                        masterRouter.getBestAsk(marketId, isYes).catch(() => [0n, 0n]),
                        masterRouter.getBestBid(marketId, isYes).catch(() => [0n, 0n])
                    ]);

                    const askPrice = Number(bestAsk[0]) / 10000;
                    const askDepth = Number(bestAsk[1]) / 1e18;
                    const bidPrice = Number(bestBid[0]) / 10000;
                    const bidDepth = Number(bestBid[1]) / 1e18;

                    if (askDepth > 0 || bidDepth > 0) {
                        document.getElementById('pooledOrderbookSource').style.display = 'flex';
                        document.getElementById('pooledAskDepth').textContent = askDepth > 0 ? formatCompact(askDepth) : '0';
                        document.getElementById('pooledBidDepth').textContent = bidDepth > 0 ? formatCompact(bidDepth) : '0';

                        currentLiquiditySources.pools = {
                            bestAskPrice: askPrice,
                            bestAskDepth: askDepth,
                            bestBidPrice: bidPrice,
                            bestBidDepth: bidDepth
                        };

                        // Update detailed pool displays
                        updatePoolDetailsDisplay(marketId, isYes);
                    } else {
                        document.getElementById('pooledOrderbookSource').style.display = 'none';
                    }
                } else {
                    document.getElementById('pooledOrderbookSource').style.display = 'none';
                }

            } catch (e) {
                console.warn('Failed to load liquidity sources:', e);
            }
        }

        // Update the detailed pool levels display
        async function updatePoolDetailsDisplay(marketId, isYes) {
            const askPoolDetails = document.getElementById('askPoolDetails');
            const bidPoolDetails = document.getElementById('bidPoolDetails');
            const askPoolLevels = document.getElementById('askPoolLevels');
            const bidPoolLevels = document.getElementById('bidPoolLevels');

            if (!currentOrderbook.asks.length && !currentOrderbook.bids.length) {
                askPoolDetails.style.display = 'none';
                bidPoolDetails.style.display = 'none';
                return;
            }

            // Show ask pools (from currentOrderbook)
            if (currentOrderbook.asks.length > 0) {
                askPoolDetails.style.display = 'block';
                const topAsks = currentOrderbook.asks.slice(0, 5); // Top 5 ask levels
                askPoolLevels.innerHTML = topAsks.map(ask => `
                    <div style="display:flex;justify-content:space-between;padding:2px 4px;background:rgba(239,68,68,0.05);border-radius:2px;margin-bottom:2px;">
                        <span>${(ask.price * 100).toFixed(0)}</span>
                        <span style="color:var(--red);">${formatCompact(ask.size)} shares</span>
                    </div>
                `).join('');
            } else {
                askPoolDetails.style.display = 'none';
            }

            // Show bid pools (from currentOrderbook)
            if (currentOrderbook.bids.length > 0) {
                bidPoolDetails.style.display = 'block';
                const topBids = currentOrderbook.bids.slice(0, 5); // Top 5 bid levels
                bidPoolLevels.innerHTML = topBids.map(bid => `
                    <div style="display:flex;justify-content:space-between;padding:2px 4px;background:rgba(34,197,94,0.05);border-radius:2px;margin-bottom:2px;">
                        <span>${(bid.price * 100).toFixed(0)}</span>
                        <span style="color:var(--green);">${formatCompact(bid.size)} shares</span>
                    </div>
                `).join('');
            } else {
                bidPoolDetails.style.display = 'none';
            }
        }

        // Compact number formatting for liquidity displays
        function formatCompact(num) {
            if (num === 0) return '0';
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            if (num >= 100) return num.toFixed(0);
            if (num >= 10) return num.toFixed(1);
            if (num >= 1) return num.toFixed(2);
            if (num >= 0.01) return num.toFixed(3);
            return num.toFixed(4);
        }

        async function loadOrderbook(marketId, isYes) {
            const asksContainer = document.getElementById('orderbookAsks');
            const bidsContainer = document.getElementById('orderbookBids');
            const spreadEl = document.getElementById('orderbookSpread');
            const emptyEl = document.getElementById('orderbookEmpty');
            const bodyEl = document.querySelector('.orderbook-body');

            // Clear and show loading state
            asksContainer.innerHTML = '<div class="orderbook-empty">Loading...</div>';
            bidsContainer.innerHTML = '';
            document.getElementById('spreadMidPrice').textContent = '--';
            document.getElementById('spreadOddsPct').textContent = '--';
            document.getElementById('spreadBidAsk').textContent = '-- / --';
            document.getElementById('spreadPct').textContent = '--%';
            // Use UP/DOWN for comparison markets, YES/NO for extreme
            const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            document.getElementById('orderbookShareType').textContent = isYes ? yesLabel : noLabel;
            document.getElementById('spreadOutcome').textContent = isYes ? yesLabel : noLabel;
            document.getElementById('orderbookTotalDepth').textContent = '--';

            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);

                // Fetch pool state for AMM pricing
                const poolStateResult = await pamm.getPoolState(marketId, HOOK_FEE_OR_HOOK).catch(e => {
                    console.warn('Could not get AMM price:', e);
                    return null;
                });

                // Process pool state
                let ammPrice = 0;
                let rYesBigInt = 0n, rNoBigInt = 0n;
                if (poolStateResult) {
                    const [rYes, rNo, pYesNum, pYesDen] = poolStateResult;
                    rYesBigInt = rYes;
                    rNoBigInt = rNo;
                    ammPrice = isYes ?
                        Number(pYesNum) / Number(pYesDen) :
                        (Number(pYesDen) - Number(pYesNum)) / Number(pYesDen);
                }

                // Fetch pooled orderbook from MasterRouter when deployed
                let pooledAsks = [], pooledBids = [];
                const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';

                if (masterRouterDeployed) {
                    const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, rpc);
                    const priceLevels = [];
                    for (let i = 100; i <= 9900; i += 100) priceLevels.push(i);

                    try {
                        const orderbook = await masterRouter.getOrderbook(marketId, isYes, priceLevels);
                        const askDepths = orderbook[0] || [];
                        const bidDepths = orderbook[1] || [];

                        for (let i = 0; i < priceLevels.length; i++) {
                            const price = priceLevels[i] / 10000;
                            const askShares = askDepths[i] ? Number(askDepths[i]) / 1e18 : 0;
                            const bidCollateral = bidDepths[i] ? Number(bidDepths[i]) / 1e18 : 0;
                            if (askShares > 0) {
                                pooledAsks.push({ price, size: askShares, pooled: true, priceBps: priceLevels[i] });
                            }
                            if (bidCollateral > 0) {
                                const bidShares = bidCollateral / price;
                                pooledBids.push({ price, size: bidShares, pooled: true, priceBps: priceLevels[i] });
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to load pooled orderbook:', e);
                    }
                }

                currentOrderbook = {
                    bids: pooledBids,
                    asks: pooledAsks,
                    ammPrice,
                    rYes: rYesBigInt,
                    rNo: rNoBigInt
                };

                // Format pooled entries for display
                const formatOrder = (order) => {
                    if (!order || order.size <= 0) return null;
                    return { price: order.price, size: order.size, pooled: order.pooled, priceBps: order.priceBps };
                };

                // Smart decimal formatting for small values
                const formatSize = (size) => {
                    if (size >= 1) return size.toFixed(2);
                    if (size >= 0.01) return size.toFixed(4);
                    if (size >= 0.0001) return size.toFixed(6);
                    return size.toExponential(2);
                };

                // Filter out invalid orders (null) before sorting
                const bids = currentOrderbook.bids.map(o => formatOrder(o)).filter(o => o !== null).sort((a, b) => b.price - a.price);
                const asks = currentOrderbook.asks.map(o => formatOrder(o)).filter(o => o !== null).sort((a, b) => a.price - b.price);

                // Clear containers
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';

                bodyEl.style.display = 'block';
                emptyEl.style.display = 'none';

                // Get section labels for showing/hiding
                const asksLabel = document.getElementById('asksLabel');
                const bidsLabel = document.getElementById('bidsLabel');
                const orderbookHeader = document.querySelector('.orderbook-header');
                const hasOrders = bids.length > 0 || asks.length > 0;

                // Show/hide orderbook structure based on whether orders exist
                if (hasOrders) {
                    asksLabel.style.display = 'flex';
                    bidsLabel.style.display = 'flex';
                    orderbookHeader.style.display = 'grid';
                } else {
                    // No orders - hide the asks/bids structure, show clean pool-only view
                    asksLabel.style.display = 'none';
                    bidsLabel.style.display = 'none';
                    orderbookHeader.style.display = 'none';
                }

                // Calculate max cumulative for depth bar scaling
                const totalAskDepth = asks.reduce((sum, a) => sum + a.size, 0);
                const totalBidDepth = bids.reduce((sum, b) => sum + b.size, 0);
                const maxDepth = Math.max(totalAskDepth, totalBidDepth, 0.01);

                // Update total depth display and title based on order availability
                const totalDepthEth = (totalAskDepth * ammPrice) + (totalBidDepth * ammPrice);
                const depthInfo = document.querySelector('.orderbook-depth-info');
                const titleText = document.querySelector('.orderbook-title-text');

                if (hasOrders) {
                    document.getElementById('orderbookTotalDepth').textContent = totalDepthEth > 0 ? formatSize(totalDepthEth) : '--';
                    depthInfo.style.display = 'block';
                    titleText.innerHTML = `<span id="orderbookShareType">${isYes ? yesLabel : noLabel}</span> Order Book`;
                } else {
                    // No orders - show simpler title
                    depthInfo.style.display = 'none';
                    titleText.innerHTML = `<span id="orderbookShareType">${isYes ? yesLabel : noLabel}</span> Pool`;
                }

                // Get user's address for highlighting their orders
                const userAddr = connectedAddress ? connectedAddress.toLowerCase() : '';

                // Calculate cumulative depth for asks (from lowest price up)
                let askCumulative = 0;
                const asksWithCumulative = asks.map(a => {
                    askCumulative += a.size;
                    return { ...a, cumulative: askCumulative };
                });

                // Render asks (sell orders) - displayed in reverse order (lowest at bottom near spread)
                asksWithCumulative.forEach((a, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && a.price < ammPrice;
                    row.className = 'orderbook-row ask' + (isBetterDeal ? ' better-deal' : '');

                    // Depth bar width based on cumulative size
                    const depthPct = Math.min((a.cumulative / maxDepth) * 100, 100);
                    row.style.setProperty('--depth-width', depthPct + '%');
                    row.style.cssText += `; --depth-width: ${depthPct}%`;

                    const oddsStr = (a.price * 100).toFixed(0) + '%';
                    const priceStr = a.price.toFixed(3);
                    row.innerHTML = `
                        <span class="price">${priceStr} <span style="opacity:0.6">(${oddsStr})</span>${isBetterDeal ? ' <span style="color:var(--green)"></span>' : ''}</span>
                        <span class="size">${formatSize(a.size)}</span>
                        <span class="total">${formatSize(a.cumulative)}</span>
                    `;
                    row.title = `${oddsStr} implied odds | ${formatSize(a.size)} shares @ ${priceStr} ETH${isBetterDeal ? ' | Better than AMM!' : ''}`;
                    // Pooled order: click to fill from pool (buy shares)
                    if (a.pooled && a.priceBps) {
                        row.onclick = () => fillPoolFromOrderbook(a.priceBps, false);
                    }

                    // Set depth bar width via inline style on pseudo-element
                    row.style.setProperty('--depth', depthPct + '%');
                    asksContainer.appendChild(row);
                });

                // Calculate cumulative depth for bids (from highest price down)
                let bidCumulative = 0;
                const bidsWithCumulative = bids.map(b => {
                    bidCumulative += b.size;
                    return { ...b, cumulative: bidCumulative };
                });

                // Render bids (buy orders)
                bidsWithCumulative.forEach((b, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && b.price > ammPrice;
                    row.className = 'orderbook-row bid' + (isBetterDeal ? ' better-deal' : '');

                    // Depth bar width
                    const depthPct = Math.min((b.cumulative / maxDepth) * 100, 100);

                    const oddsStr = (b.price * 100).toFixed(0) + '%';
                    const priceStr = b.price.toFixed(3);
                    row.innerHTML = `
                        <span class="price">${priceStr} <span style="opacity:0.6">(${oddsStr})</span>${isBetterDeal ? ' <span style="color:var(--green)"></span>' : ''}</span>
                        <span class="size">${formatSize(b.size)}</span>
                        <span class="total">${formatSize(b.cumulative)}</span>
                    `;
                    row.title = `${oddsStr} implied odds | ${formatSize(b.size)} shares @ ${priceStr} ETH${isBetterDeal ? ' | Better than AMM!' : ''}`;
                    // Pooled order: click to fill to pool (sell shares)
                    if (b.pooled && b.priceBps) {
                        row.onclick = () => fillPoolFromOrderbook(b.priceBps, true);
                    }

                    // Set depth bar width
                    row.style.setProperty('--depth', depthPct + '%');
                    bidsContainer.appendChild(row);
                });

                // Update spread area with new element structure
                const spreadMidPrice = document.getElementById('spreadMidPrice');
                const spreadOddsPct = document.getElementById('spreadOddsPct');
                const spreadOutcome = document.getElementById('spreadOutcome');
                const spreadBidAsk = document.getElementById('spreadBidAsk');
                const spreadPct = document.getElementById('spreadPct');

                // Calculate best bid/ask
                const bestAsk = asks.length > 0 ? asks[0].price : null;
                const bestBid = bids.length > 0 ? bids[0].price : null;

                // Update pool price display (mid-market or AMM price)
                if (ammPrice > 0) {
                    spreadMidPrice.textContent = ammPrice.toFixed(3) + ' ETH';
                    spreadOddsPct.textContent = (ammPrice * 100).toFixed(0) + '%';
                    spreadOutcome.textContent = isYes ? yesLabel : noLabel;
                    spreadOutcome.style.color = isYes ? 'var(--green)' : 'var(--red)';
                } else if (bestAsk && bestBid) {
                    const midPrice = (bestAsk + bestBid) / 2;
                    spreadMidPrice.textContent = midPrice.toFixed(3) + ' ETH';
                    spreadOddsPct.textContent = (midPrice * 100).toFixed(0) + '%';
                } else {
                    spreadMidPrice.textContent = '--';
                    spreadOddsPct.textContent = '--';
                }

                // Update bid/ask display
                if (bestBid && bestAsk) {
                    spreadBidAsk.innerHTML = `<span style="color:var(--green)">${bestBid.toFixed(3)}</span> / <span style="color:var(--red)">${bestAsk.toFixed(3)}</span>`;
                    const spread = ((bestAsk - bestBid) / bestAsk * 100).toFixed(1);
                    spreadPct.textContent = spread + '%';
                } else if (bestBid) {
                    spreadBidAsk.innerHTML = `<span style="color:var(--green)">${bestBid.toFixed(3)}</span> / --`;
                    spreadPct.textContent = '--';
                } else if (bestAsk) {
                    spreadBidAsk.innerHTML = `-- / <span style="color:var(--red)">${bestAsk.toFixed(3)}</span>`;
                    spreadPct.textContent = '--';
                } else if (ammPrice > 0) {
                    // No orders, just pool
                    spreadBidAsk.textContent = 'Pool only';
                    spreadPct.textContent = '0%';
                } else {
                    bodyEl.style.display = 'none';
                    emptyEl.style.display = 'block';
                    return;
                }

                // Load liquidity sources display (vault, AMM, pools) after orderbook is ready
                loadLiquiditySources(marketId, isYes);

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';
                bodyEl.style.display = 'none';
                emptyEl.style.display = 'block';
                emptyEl.innerHTML = '<div>Failed to load orderbook</div><div style="font-size:10px;color:var(--text-muted);margin-top:4px;">Check console for details</div>';
            }
        }

        // ======================== DEPTH MODAL ========================
        let depthModalData = { upBook: null, downBook: null, marketId: null, type: null };

        async function openDepthModal() {
            if (!currentTrade.marketId) return;

            const type = currentTrade.type;
            const marketId = currentTrade.marketId;
            const isExtreme = type === 'extreme';
            const upLabel = isExtreme ? 'YES' : 'UP';
            const downLabel = isExtreme ? 'NO' : 'DOWN';

            // Update labels
            document.getElementById('depthUpLabel').textContent = upLabel;
            document.getElementById('depthDownLabel').textContent = downLabel;
            document.getElementById('depthTradeUpBtn').textContent = `Trade ${upLabel}`;
            document.getElementById('depthTradeDownBtn').textContent = `Trade ${downLabel}`;
            document.getElementById('depthModalMarketType').textContent = { weekly: 'Weekly', extreme: 'Extreme' }[type] || type;

            document.getElementById('depthModal').classList.add('active');
            document.getElementById('depthLadder').innerHTML = '<div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading...</div>';

            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);

                // Generate price levels for pooled orderbook (100 bps = 1 cent increments)
                const priceLevels = [];
                for (let i = 100; i <= 9900; i += 100) {
                    priceLevels.push(i);
                }

                // Calculate AMM prices first
                const poolState = await pamm.getPoolState(marketId, HOOK_FEE_OR_HOOK).catch(() => null);
                let upAmmPrice = 0.5, downAmmPrice = 0.5;
                if (poolState) {
                    const [rYes, rNo, pYesNum, pYesDen] = poolState;
                    upAmmPrice = Number(pYesNum) / Number(pYesDen);
                    downAmmPrice = 1 - upAmmPrice;
                }

                // Fetch pooled orderbook from MasterRouter if deployed
                let upAskDepths = [], upBidDepths = [], downAskDepths = [], downBidDepths = [];
                const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';

                if (masterRouterDeployed) {
                    const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, rpc);
                    const [upOrderbook, downOrderbook] = await Promise.all([
                        masterRouter.getOrderbook(marketId, true, priceLevels).catch(() => [[], []]),
                        masterRouter.getOrderbook(marketId, false, priceLevels).catch(() => [[], []])
                    ]);
                    upAskDepths = upOrderbook[0] || [];
                    upBidDepths = upOrderbook[1] || [];
                    downAskDepths = downOrderbook[0] || [];
                    downBidDepths = downOrderbook[1] || [];
                }

                // Convert pooled depths to orderbook format
                const buildBookFromPools = (askDepths, bidDepths, priceLevels) => {
                    const asks = [], bids = [];
                    for (let i = 0; i < priceLevels.length; i++) {
                        const price = priceLevels[i] / 10000; // Convert bps to decimal
                        const askShares = askDepths[i] ? Number(askDepths[i]) / 1e18 : 0;
                        const bidCollateral = bidDepths[i] ? Number(bidDepths[i]) / 1e18 : 0;
                        if (askShares > 0) {
                            asks.push({ price, shares: askShares, collateral: askShares * price, pooled: true, priceBps: priceLevels[i] });
                        }
                        if (bidCollateral > 0) {
                            const bidShares = bidCollateral / price;
                            bids.push({ price, shares: bidShares, collateral: bidCollateral, pooled: true, priceBps: priceLevels[i] });
                        }
                    }
                    // Sort asks low to high, bids high to low
                    asks.sort((a, b) => a.price - b.price);
                    bids.sort((a, b) => b.price - a.price);
                    return { asks, bids };
                };

                const upBook = buildBookFromPools(upAskDepths, upBidDepths, priceLevels);
                const downBook = buildBookFromPools(downAskDepths, downBidDepths, priceLevels);

                depthModalData = {
                    upBook: { ...upBook, ammPrice: upAmmPrice },
                    downBook: { ...downBook, ammPrice: downAmmPrice },
                    marketId,
                    type
                };

                // Update AMM price displays
                document.getElementById('depthUpAmm').textContent = `AMM ${(upAmmPrice * 100).toFixed(1)}%`;
                document.getElementById('depthDownAmm').textContent = `AMM ${(downAmmPrice * 100).toFixed(1)}%`;

                renderDepthLadder();
            } catch (e) {
                console.error('Failed to load depth:', e);
                document.getElementById('depthLadder').innerHTML = '<div style="text-align:center;color:var(--red);padding:2rem;font-size:11px;">Failed to load depth data</div>';
            }
        }

        function closeDepthModal() {
            document.getElementById('depthModal').classList.remove('active');
        }

        function renderDepthLadder() {
            const ladder = document.getElementById('depthLadder');
            const { upBook, downBook, type } = depthModalData;
            if (!upBook || !downBook) return;

            const upAmm = upBook.ammPrice || 0.5;
            const downAmm = downBook.ammPrice || 0.5;
            const isExtreme = type === 'extreme';
            const upLabel = isExtreme ? 'YES' : 'UP';
            const downLabel = isExtreme ? 'NO' : 'DOWN';
            const userAddr = connectedAddress ? connectedAddress.toLowerCase() : '';

            // Collect pooled depth at each price level
            const levels = new Map();

            // Add pooled depths (asks = shares for sale, bids = collateral to buy)
            const addPoolDepth = (asks, bids, isUp, ammPrice) => {
                asks.forEach(a => {
                    const price = a.price;
                    // Only show resting orders (asks above AMM for selling)
                    if (price <= ammPrice) return;
                    const eth = a.shares * price;
                    if (!levels.has(price)) levels.set(price, { upAsks: 0, upBids: 0, downAsks: 0, downBids: 0, pools: [] });
                    const key = isUp ? 'upAsks' : 'downAsks';
                    levels.get(price)[key] += eth;
                    levels.get(price).pools.push({ ...a, type: 'ask', isUp, eth });
                });
                bids.forEach(b => {
                    const price = b.price;
                    // Only show resting bids (below AMM for buying)
                    if (price >= ammPrice) return;
                    const eth = b.collateral;
                    if (!levels.has(price)) levels.set(price, { upAsks: 0, upBids: 0, downAsks: 0, downBids: 0, pools: [] });
                    const key = isUp ? 'upBids' : 'downBids';
                    levels.get(price)[key] += eth;
                    levels.get(price).pools.push({ ...b, type: 'bid', isUp, eth });
                });
            };

            addPoolDepth(upBook.asks, upBook.bids, true, upAmm);
            addPoolDepth(downBook.asks, downBook.bids, false, downAmm);

            // Add AMM price rows
            const upAmmRounded = Math.round(upAmm * 1000) / 1000;
            const downAmmRounded = Math.round(downAmm * 1000) / 1000;
            if (!levels.has(upAmmRounded)) levels.set(upAmmRounded, { upBids: 0, upAsks: 0, downBids: 0, downAsks: 0, pools: [], isUpAmm: true });
            else levels.get(upAmmRounded).isUpAmm = true;
            if (!levels.has(downAmmRounded)) levels.set(downAmmRounded, { upBids: 0, upAsks: 0, downBids: 0, downAsks: 0, pools: [], isDownAmm: true });
            else levels.get(downAmmRounded).isDownAmm = true;

            // Sort by price descending
            const sortedLevels = [...levels.entries()].sort((a, b) => b[0] - a[0]);
            const hasDepth = sortedLevels.some(([, d]) => d.pools.length > 0);

            if (!hasDepth) {
                ladder.innerHTML = `
                    <div style="text-align:center;padding:1.5rem;color:var(--text-dim);">
                        <div style="font-size:12px;margin-bottom:1rem;">No pool liquidity</div>
                        <div style="display:flex;justify-content:center;gap:2rem;font-size:11px;">
                            <span><span style="color:var(--green);">${upLabel}</span> AMM: ${(upAmm * 100).toFixed(1)}%</span>
                            <span><span style="color:var(--red);">${downLabel}</span> AMM: ${(downAmm * 100).toFixed(1)}%</span>
                        </div>
                    </div>`;
                return;
            }

            // Find max depth for bar scaling
            let maxDepth = 0.001;
            sortedLevels.forEach(([, d]) => maxDepth = Math.max(maxDepth, d.upBids, d.upAsks, d.downBids, d.downAsks));

            ladder.innerHTML = sortedLevels.map(([price, data]) => {
                const pct = (price * 100).toFixed(1);
                const priceBps = Math.round(price * 10000);
                const upDepth = data.upAsks > 0 ? data.upAsks : data.upBids;
                const downDepth = data.downAsks > 0 ? data.downAsks : data.downBids;
                const upBarWidth = (upDepth / maxDepth * 100).toFixed(1);
                const downBarWidth = (downDepth / maxDepth * 100).toFixed(1);
                const upIsAsk = data.upAsks > 0;
                const downIsAsk = data.downAsks > 0;
                const isAmmRow = data.isUpAmm || data.isDownAmm;

                // Get pool info for clicks
                const upPool = data.pools.find(p => p.isUp && ((upIsAsk && p.type === 'ask') || (!upIsAsk && p.type === 'bid')));
                const downPool = data.pools.find(p => !p.isUp && ((downIsAsk && p.type === 'ask') || (!downIsAsk && p.type === 'bid')));

                // Click handlers - for pooled system, use price in bps
                // User buying from ASK pool or selling to BID pool
                const upClick = upPool ? `onclick="fillPoolFromDepth(${priceBps}, ${upPool.type === 'bid'}, true)"` : '';
                const downClick = downPool ? `onclick="fillPoolFromDepth(${priceBps}, ${downPool.type === 'bid'}, false)"` : '';

                // Format depth
                const formatDepth = d => d > 0 ? (d >= 1 ? d.toFixed(2) : d.toFixed(3)) + '' : '';

                return `
                    <div class="depth-ladder-row${isAmmRow ? ' amm-row' : ''}">
                        <div class="depth-cell${upPool ? ' clickable' : ''}" style="justify-content:flex-end;" ${upClick}>
                            ${upDepth > 0 ? `<div class="depth-bar up" style="width:${upBarWidth}%;${upIsAsk ? 'background:var(--red);' : ''}"></div>` : ''}
                            ${data.isUpAmm ? '<span style="font-size:8px;color:var(--blue);margin-right:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                            <span style="font-size:10px;color:${upIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:600;">${formatDepth(upDepth)}</span>
                        </div>
                        <div class="depth-center${isAmmRow ? '" style="background:var(--surface-2);' : ''}">${pct}%</div>
                        <div class="depth-cell${downPool ? ' clickable' : ''}" ${downClick}>
                            ${downDepth > 0 ? `<div class="depth-bar down" style="width:${downBarWidth}%;${downIsAsk ? 'background:var(--red);' : ''}"></div>` : ''}
                            <span style="font-size:10px;color:${downIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:600;">${formatDepth(downDepth)}</span>
                            ${data.isDownAmm ? '<span style="font-size:8px;color:var(--blue);margin-left:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                        </div>
                    </div>`;
            }).join('');
        }

        function depthTradeUp() {
            closeDepthModal();
            if (depthModalData.marketId && depthModalData.type) {
                openTrade(depthModalData.type, true);
            }
        }

        function depthTradeDown() {
            closeDepthModal();
            if (depthModalData.marketId && depthModalData.type) {
                openTrade(depthModalData.type, false);
            }
        }

        // Open depth modal from card (without requiring trade modal to be open first)
        async function openDepthModalForType(type) {
            const market = markets[type];
            if (!market || !market.id) return;

            // Set up currentTrade context for the depth modal
            currentTrade.marketId = market.id;
            currentTrade.type = type;
            currentTrade.isYes = true;

            await openDepthModal();
        }

        // Fill from pool in depth modal - prompts for amount then executes
        async function fillPoolFromDepth(priceBps, isBidPool, isUp) {
            if (!signer) {
                closeDepthModal();
                showWalletModal();
                return;
            }

            const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
            if (!masterRouterDeployed) {
                showToast('Not Available', 'MasterRouter not yet deployed', 'error', 4000);
                return;
            }

            const price = priceBps / 10000;
            const isExtreme = depthModalData.type === 'extreme';
            const upLabel = isExtreme ? 'YES' : 'UP';
            const downLabel = isExtreme ? 'NO' : 'DOWN';
            const side = isUp ? upLabel : downLabel;
            const marketId = depthModalData.marketId;
            // User buying from ASK pool, or selling to BID pool
            const userIsBuying = !isBidPool;

            // Prompt for amount
            const promptText = userIsBuying ?
                `Buy ${side} at ${(price * 100).toFixed(0)}%\n\nEnter ETH amount:` :
                `Sell ${side} at ${(price * 100).toFixed(0)}%\n\nEnter shares amount:`;
            const input = prompt(promptText);
            if (!input) return;

            const amount = parseFloat(input);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error', 4000);
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);

                // Validate user has sufficient balance
                if (userIsBuying) {
                    const ethBal = await rpc.getBalance(connectedAddress);
                    const collateralWei = ethers.parseEther(amount.toString());
                    if (collateralWei > ethBal) {
                        showToast('Insufficient ETH', `Need ${amount.toFixed(4)} ETH`, 'error', 4000);
                        return;
                    }
                } else {
                    const tokenId = isUp ? marketId : await pamm.getNoId(marketId);
                    const userShares = await pamm.balanceOf(connectedAddress, tokenId);
                    const sharesWei = ethers.parseEther(amount.toString());
                    if (sharesWei > userShares) {
                        const have = parseFloat(ethers.formatEther(userShares)).toFixed(4);
                        showToast('Insufficient Shares', `Have ${have} ${side}`, 'error', 4000);
                        return;
                    }
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                let txPromise;

                if (userIsBuying) {
                    // Buy shares from ASK pool: collateral in, shares out
                    const collateralWei = ethers.parseEther(amount.toString());
                    const sharesWei = ethers.parseEther((amount / price).toString());
                    // fillFromPool(marketId, isYes, priceInBps, sharesWanted, maxCollateral, to, deadline)
                    txPromise = masterRouter.fillFromPool(marketId, isUp, priceBps, sharesWei, collateralWei, connectedAddress, 0, { value: collateralWei });
                } else {
                    // Sell shares to BID pool: shares in, collateral out
                    const sharesWei = ethers.parseEther(amount.toString());
                    const minCollateralWei = ethers.parseEther((amount * price * 0.99).toString()); // 1% slippage tolerance
                    // sellToPool(marketId, isYes, priceInBps, sharesWanted, minCollateral, to, deadline)
                    txPromise = masterRouter.sellToPool(marketId, isUp, priceBps, sharesWei, minCollateralWei, connectedAddress, 0);
                }

                closeDepthModal();
                await monitorTransaction(txPromise, {
                    pending: { title: `${userIsBuying ? 'Buying' : 'Selling'} ${side}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${userIsBuying ? 'Buying' : 'Selling'} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Complete!', body: `${userIsBuying ? 'Bought' : 'Sold'} ${amount.toFixed(4)} ${userIsBuying ? 'ETH worth of' : ''} ${side}` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        await Promise.all([
                            loadUserPosition(marketId),
                            loadOrderbook(marketId, currentTrade.isYes)
                        ]);
                        loadBalance();
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Pool fill failed:', e);
                    showToast('Fill Failed', 'Check console for details', 'error', 4000);
                }
            }
        }

        // Fill from pool via orderbook display - prompts for amount
        async function fillPoolFromOrderbook(priceBps, isBidPool) {
            if (!signer) {
                showStatus('Connect wallet first', 'error');
                return;
            }

            const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
            if (!masterRouterDeployed) {
                showStatus('MasterRouter not deployed', 'error');
                return;
            }

            const price = priceBps / 10000;
            const isExtreme = currentTrade.type === 'extreme';
            const yesLabel = isExtreme ? 'YES' : 'UP';
            const noLabel = isExtreme ? 'NO' : 'DOWN';
            const side = currentTrade.isYes ? yesLabel : noLabel;
            const userIsBuying = !isBidPool;

            // Prompt for amount
            const promptText = userIsBuying ?
                `Buy ${side} at ${(price * 100).toFixed(0)}%\nEnter ETH amount:` :
                `Sell ${side} at ${(price * 100).toFixed(0)}%\nEnter shares amount:`;
            const input = prompt(promptText);
            if (!input) return;

            const amount = parseFloat(input);
            if (!amount || amount <= 0) {
                showStatus('Invalid amount', 'error');
                return;
            }

            try {
                // Validate balance
                if (userIsBuying) {
                    const ethBal = await provider.getBalance(connectedAddress);
                    if (ethers.parseEther(amount.toString()) > ethBal) {
                        showStatus('Insufficient ETH', 'error');
                        return;
                    }
                } else {
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                let txPromise;

                if (userIsBuying) {
                    const collateralWei = ethers.parseEther(amount.toString());
                    const sharesWei = ethers.parseEther((amount / price).toString());
                    // fillFromPool(marketId, isYes, priceInBps, sharesWanted, maxCollateral, to, deadline)
                    txPromise = masterRouter.fillFromPool(currentTrade.marketId, currentTrade.isYes, priceBps, sharesWei, collateralWei, connectedAddress, 0, { value: collateralWei });
                } else {
                    const sharesWei = ethers.parseEther(amount.toString());
                    const minCollateralWei = ethers.parseEther((amount * price * 0.99).toString()); // 1% slippage
                    // sellToPool(marketId, isYes, priceInBps, sharesWanted, minCollateral, to, deadline)
                    txPromise = masterRouter.sellToPool(currentTrade.marketId, currentTrade.isYes, priceBps, sharesWei, minCollateralWei, connectedAddress, 0);
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `${userIsBuying ? 'Buying' : 'Selling'} ${side}`, body: 'Confirm in wallet...' },
                    submitted: { title: `${userIsBuying ? 'Buying' : 'Selling'} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Complete!', body: `${userIsBuying ? 'Bought' : 'Sold'} ${amount.toFixed(4)}` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        await Promise.all([
                            loadOrderbook(currentTrade.marketId, currentTrade.isYes),
                            loadUserPosition(currentTrade.marketId)
                        ]);
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Pool fill failed:', e);
                }
            }
        }

        let currentLpMode = 'add'; // 'add' or 'remove'
        let mintKeepYes = true; // true = keep YES, false = keep NO
        let limitIsBuy = true; // true = buy order, false = sell order
        let userOrders = []; // User's active orders for this market

        function setSlippage(pct) {
            if (!pct || pct <= 0) pct = 0.5;
            if (pct > 50) pct = 50; // Cap at 50% for safety
            slippageTolerance = pct;

            // Update button states
            document.getElementById('slip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';

            // Clear custom if using preset
            if (pct === 0.5 || pct === 1 || pct === 2) {
                document.getElementById('slipCustom').value = '';
            }

            updatePreview();
        }

        function setSwapSlippage(pct) {
            if (!pct || pct <= 0) pct = 0.5;
            if (pct > 50) pct = 50; // Cap at 50% for safety
            slippageTolerance = pct;

            // Update swap slippage button states
            document.getElementById('swapSlip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('swapSlip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('swapSlip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';
            // Clear custom input if preset was clicked
            const customInput = document.getElementById('swapSlipCustom');
            if ([0.5, 1, 2].includes(pct)) {
                customInput.value = '';
            }

            // Update display
            document.getElementById('swapSlipDisplay').textContent = pct + '%';

            updateSwapPreview();
        }

        function setLpSlippage(pct) {
            if (!pct || pct <= 0) pct = 1;
            if (pct > 50) pct = 50; // Cap at 50% for safety
            lpSlippageTolerance = pct;

            // Update LP slippage button states
            document.getElementById('lpSlip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('lpSlip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('lpSlip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';
            // Clear custom input if preset was clicked
            const customInput = document.getElementById('lpSlipCustom');
            if ([0.5, 1, 2].includes(pct)) {
                customInput.value = '';
            }

            updateLpPreview();
        }

        // Track current trade direction (buy/sell) and swap direction (yesToNo)
        let currentTradeDirection = 'buy';
        let currentSwapDirection = true; // true = YESNO, false = NOYES

        // Store raw BigInt values for exact max operations (avoid rounding errors)
        let tradeMaxRaw = null;
        let swapMaxRaw = null;
        let lpMaxRaw = null;

        function setTradeMode(mode) {
            currentTradeMode = mode;

            const tradeBtn = document.getElementById('tradeModeBtn');
            const swapBtn = document.getElementById('swapModeBtn');
            const limitBtn = document.getElementById('limitModeBtn');
            const lpBtn = document.getElementById('lpModeBtn');
            const submitBtn = document.getElementById('tradeSubmit');
            const tradeSection = document.getElementById('tradeSection');
            const lpSection = document.getElementById('lpSection');
            const swapSection = document.getElementById('swapSection');
            const limitSection = document.getElementById('limitSection');
            const yourOrdersSection = document.getElementById('yourOrdersSection');
            const orderbookContainer = document.getElementById('orderbookContainer');
            const tradeDirectionToggle = document.getElementById('tradeDirectionToggle');
            const swapDirectionToggle = document.getElementById('swapDirectionToggle');
            const tradeInputGroup = document.getElementById('tradeInputGroup');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            // Reset all mode buttons
            tradeBtn.className = 'mode-toggle-btn';
            swapBtn.className = 'mode-toggle-btn';
            limitBtn.className = 'mode-toggle-btn';
            lpBtn.className = 'mode-toggle-btn';

            // Hide direction toggles by default
            tradeDirectionToggle.style.display = 'none';
            swapDirectionToggle.style.display = 'none';

            // Hide your orders section by default
            yourOrdersSection.style.display = 'none';

            if (mode === 'trade') {
                tradeBtn.className = 'mode-toggle-btn ' + (currentTradeDirection === 'buy' ? 'active-buy' : 'active-sell');
                tradeDirectionToggle.style.display = 'flex';
                tradeSection.style.display = 'block';
                lpSection.style.display = 'none';
                if (swapSection) swapSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'block';
                tradeInputGroup.style.display = 'block';
                // Apply direction-specific settings
                setTradeDirection(currentTradeDirection, true);
            } else if (mode === 'swap') {
                swapBtn.className = 'mode-toggle-btn active-swap';
                swapDirectionToggle.style.display = 'flex';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                if (swapSection) swapSection.style.display = 'block';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                tradeInputGroup.style.display = 'block';
                // Sync swap slippage buttons with current slippage
                document.getElementById('swapSlip05').className = slippageTolerance === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
                document.getElementById('swapSlip1').className = slippageTolerance === 1 ? 'slip-btn slip-active' : 'slip-btn';
                document.getElementById('swapSlip2').className = slippageTolerance === 2 ? 'slip-btn slip-active' : 'slip-btn';
                document.getElementById('swapSlipDisplay').textContent = slippageTolerance + '%';
                // Apply swap direction settings
                setSwapDirection(currentSwapDirection, true);
            } else if (mode === 'limit') {
                limitBtn.className = 'mode-toggle-btn active-limit';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                if (swapSection) swapSection.style.display = 'none';
                limitSection.style.display = 'block';
                orderbookContainer.style.display = 'block';
                yourOrdersSection.style.display = 'block';
                tradeInputGroup.style.display = 'none';
                // Set smart default price and shares
                setSmartDefaultPrice();
                if (!document.getElementById('limitShares').value) {
                    document.getElementById('limitShares').value = '1.0';
                }
                updateLimitBalance();
                updateLimitPreview();
                refreshUserOrders();
            } else if (mode === 'lp') {
                lpBtn.className = 'mode-toggle-btn active-lp';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'block';
                if (swapSection) swapSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                tradeInputGroup.style.display = 'block';
                document.getElementById('tradeInputLabel').textContent = currentLpMode === 'add' ? 'ETH to deposit' : 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = currentLpMode === 'add' ? 'ETH' : 'LP';
                updateLpPreview();
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '0.01';
            if (mode === 'trade') updatePreview();
            if (mode === 'swap') updateSwapPreview();
        }

        function setTradeDirection(direction, skipModeUpdate = false) {
            currentTradeDirection = direction;
            const buyDirBtn = document.getElementById('buyDirBtn');
            const sellDirBtn = document.getElementById('sellDirBtn');
            const tradeBtn = document.getElementById('tradeModeBtn');
            const submitBtn = document.getElementById('tradeSubmit');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            buyDirBtn.className = 'mode-toggle-btn' + (direction === 'buy' ? ' active-buy' : '');
            sellDirBtn.className = 'mode-toggle-btn' + (direction === 'sell' ? ' active-sell' : '');
            tradeBtn.className = 'mode-toggle-btn ' + (direction === 'buy' ? 'active-buy' : 'active-sell');

            if (direction === 'buy') {
                document.getElementById('tradeInputLabel').textContent = 'Amount (ETH)';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Payout if win';
                submitBtn.textContent = 'Buy ' + label;
                submitBtn.className = 'trade-submit ' + (currentTrade.isYes ? 'buy-up' : 'buy-down');
            } else {
                document.getElementById('tradeInputLabel').textContent = 'Shares to sell';
                document.getElementById('tradeBalanceUnit').textContent = 'shares';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Min receive';
                submitBtn.textContent = 'Sell ' + label;
                submitBtn.className = 'trade-submit buy-down';
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '0.01';
            updatePreview();
        }

        function setSwapDirection(yesToNo, skipUpdate = false) {
            currentSwapDirection = yesToNo;
            const yesToNoBtn = document.getElementById('yesToNoBtn');
            const noToYesBtn = document.getElementById('noToYesBtn');

            // Use market-appropriate labels (YES/NO for extreme, UP/DOWN for weekly)
            const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const fromShare = yesToNo ? yesLabel : noLabel;
            const toShare = yesToNo ? noLabel : yesLabel;

            yesToNoBtn.className = 'mode-toggle-btn' + (yesToNo ? ' active-buy' : '');
            noToYesBtn.className = 'mode-toggle-btn' + (!yesToNo ? ' active-sell' : '');
            yesToNoBtn.textContent = yesLabel + '  ' + noLabel;
            noToYesBtn.textContent = noLabel + '  ' + yesLabel;

            // Update input labels
            document.getElementById('tradeInputLabel').textContent = fromShare + ' shares to swap';
            document.getElementById('tradeBalanceUnit').textContent = fromShare;

            // Update swap preview labels
            const swapGiveLabel = document.getElementById('swapGiveLabel');
            const swapReceiveLabel = document.getElementById('swapReceiveLabel');
            const swapSubmit = document.getElementById('swapSubmit');
            const swapPoolRate = document.getElementById('swapPoolRate');
            if (swapGiveLabel) swapGiveLabel.textContent = 'You give (' + fromShare + ')';
            if (swapReceiveLabel) swapReceiveLabel.textContent = 'You receive (' + toShare + ')';
            if (swapPoolRate) swapPoolRate.textContent = '1 ' + fromShare + ' = -- ' + toShare;
            if (swapSubmit) {
                swapSubmit.textContent = 'Swap ' + fromShare + '  ' + toShare;
                swapSubmit.className = 'trade-submit ' + (yesToNo ? 'buy-down' : 'buy-up');
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '0.01';
            if (!skipUpdate) updateSwapPreview();
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            const addBtn = document.getElementById('addLpBtn');
            const removeBtn = document.getElementById('removeLpBtn');
            const lpSubmit = document.getElementById('lpSubmit');
            const explainer = document.getElementById('lpExplainer');

            if (mode === 'add') {
                addBtn.className = 'lp-toggle-btn active-add';
                removeBtn.className = 'lp-toggle-btn';
                document.getElementById('tradeInputLabel').textContent = 'ETH to deposit';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.';
                lpSubmit.textContent = 'Deposit Liquidity';
                lpSubmit.style.background = 'var(--blue)';
            } else {
                addBtn.className = 'lp-toggle-btn';
                removeBtn.className = 'lp-toggle-btn active-remove';
                document.getElementById('tradeInputLabel').textContent = 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = 'LP';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Withdraw your liquidity. Your LP tokens are burned and you receive ETH back.';
                lpSubmit.textContent = 'Withdraw Liquidity';
                lpSubmit.style.background = 'var(--red)';
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '0.01';
            updateLpPreview();
        }

        function updateLpPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;
            const warningEl = document.getElementById('lpWarning');

            // Calculate pool metrics
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;
            // Use actual TVL from market data if available, otherwise approximate
            const poolTvl = currentTrade.tvl > 0 ? currentTrade.tvl : (rYesNum + rNoNum) / 2;
            // Use actual LP supply from ZAMM pools() if available, otherwise estimate
            const totalLpSupply = currentUserPosition.lpTotalSupply
                ? Number(currentUserPosition.lpTotalSupply) / 1e18
                : Math.sqrt(rYesNum * rNoNum);

            // Pool price (YES probability)
            const yesPrice = rYesNum > 0 && rNoNum > 0 ? rNoNum / (rYesNum + rNoNum) : 0.5;

            // Display pool TVL and price with market-specific label
            const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
            if (rYes > 0n && rNo > 0n) {
                document.getElementById('lpPoolReserves').textContent = formatEth(poolTvl);
                document.getElementById('lpPoolPrice').textContent = yesPrice.toFixed(3) + ' (' + formatOdds(yesPrice) + ' ' + yesLabel + ')';
            } else {
                document.getElementById('lpPoolReserves').textContent = '--';
                document.getElementById('lpPoolPrice').textContent = '-- (--% ' + yesLabel + ')';
            }

            // Current user position value and share
            if (userLp > 0 && totalLpSupply > 0) {
                const userShare = userLp / totalLpSupply;
                const positionValue = userShare * poolTvl; // Value in ETH terms (collateral backing their LP)
                document.getElementById('lpPositionValue').textContent = formatEth(positionValue);
                document.getElementById('lpCurrentShare').textContent = (userShare * 100).toFixed(2) + '%';
            } else {
                document.getElementById('lpPositionValue').textContent = userLp > 0 ? formatEth(userLp, ' LP') : '0 ETH';
                document.getElementById('lpCurrentShare').textContent = '0%';
            }

            // Hide warning by default
            warningEl.style.display = 'none';

            if (amt === 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                document.getElementById('lpShareChange').textContent = '';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP
                document.getElementById('lpPreview').textContent = amt.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = '100%';
                document.getElementById('lpShareChange').textContent = '(+100%)';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: ETH -> split -> add to pool
                // User gets LP tokens proportional to their contribution
                // New LP = (amt / poolTvl) * totalLpSupply (simplified)
                const estLp = (amt / poolTvl) * totalLpSupply;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newShare = (newUserLp / newTotalLp) * 100;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = estLp.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta > 0 ? `(+${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = 'var(--green)';

                // Show IL warning for imbalanced pools
                if (yesPrice < 0.2 || yesPrice > 0.8) {
                    warningEl.textContent = ' Pool is imbalanced (' + formatOdds(yesPrice) + ' YES). Higher impermanent loss risk if price moves toward 50%.';
                    warningEl.style.display = 'block';
                }
            } else {
                // Removing liquidity: LP tokens -> YES + NO -> merge -> ETH
                if (amt > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    document.getElementById('lpShareChange').textContent = '';
                    return;
                }

                // Calculate how much YES + NO user gets from burning LP
                const shareOfPool = amt / totalLpSupply;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;

                // Merge gives min(yesOut, noOut) ETH back, leftover shares remain
                const ethOut = Math.min(yesOut, noOut);
                const leftoverYes = yesOut - ethOut;
                const leftoverNo = noOut - ethOut;

                // Display estimated ETH back
                document.getElementById('lpPreview').textContent = ethOut.toFixed(4) + ' ETH';

                // Calculate new share
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newUserLp = userLp - amt;
                const newTotalLp = totalLpSupply - amt;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta !== 0 ? `(${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = shareDelta < 0 ? 'var(--red)' : 'var(--text-muted)';

                // Show leftover warning if pool is imbalanced
                if (leftoverYes > 0.0001 || leftoverNo > 0.0001) {
                    const leftover = leftoverYes > leftoverNo ?
                        leftoverYes.toFixed(4) + ' YES' :
                        leftoverNo.toFixed(4) + ' NO';
                    warningEl.textContent = ' Pool imbalanced. You\'ll also receive ~' + leftover + ' shares (can\'t merge).';
                    warningEl.style.display = 'block';
                }
            }
        }

        // ======================== SWAP (YES  NO) ========================
        function updateSwapPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            // Use market-appropriate labels for defaults (default to YES/NO if type unknown)
            const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const fromLabel = currentSwapDirection ? yesLabel : noLabel;
            const toLabel = currentSwapDirection ? noLabel : yesLabel;

            // Update labels
            document.getElementById('swapGiveLabel').textContent = `You give (${fromLabel})`;
            document.getElementById('swapReceiveLabel').textContent = `You receive (${toLabel})`;

            if (rYes === 0n || rNo === 0n || amt === 0) {
                document.getElementById('swapGive').textContent = amt > 0 ? `${amt.toFixed(4)} shares` : '-- shares';
                document.getElementById('swapPoolRate').textContent = `1 ${fromLabel} = -- ${toLabel}`;
                document.getElementById('swapReceive').textContent = '-- shares';
                document.getElementById('swapFee').textContent = '-- shares';
                document.getElementById('swapImpact').textContent = '--%';
                document.getElementById('swapMinReceive').textContent = '-- shares';
                return;
            }

            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;

            // Current rate from pool (constant product)
            // YES  NO: rate = rNo / rYes
            // NO  YES: rate = rYes / rNo
            const spotRate = currentSwapDirection ? (rNoNum / rYesNum) : (rYesNum / rNoNum);

            // Calculate swap output using constant product formula
            // ZAMM applies fee BEFORE swap: amtInAfterFee = amtIn * (1 - fee)
            // Then: amtOut = (amtInAfterFee * reserveOut) / (reserveIn + amtInAfterFee)
            const fee = 0.003; // 0.3% fee (30 bps)
            const amtIn = amt;
            const feeAmount = amtIn * fee;
            let reserveIn, reserveOut;

            if (currentSwapDirection) {
                // YES  NO
                reserveIn = rYesNum;
                reserveOut = rNoNum;
            } else {
                // NO  YES
                reserveIn = rNoNum;
                reserveOut = rYesNum;
            }

            const amtInWithFee = amtIn * (1 - fee);
            const amtOut = (amtInWithFee * reserveOut) / (reserveIn + amtInWithFee);

            // Price impact (difference between spot rate and effective rate)
            const effectiveRate = amtOut / amtIn;
            const priceImpact = ((spotRate - effectiveRate) / spotRate) * 100;

            // Min receive with slippage
            const slippage = slippageTolerance / 100;
            const minReceive = amtOut * (1 - slippage);

            // Update all display elements
            document.getElementById('swapGive').textContent = `${amtIn.toFixed(4)} shares`;
            document.getElementById('swapPoolRate').textContent = `1 ${fromLabel} = ${spotRate.toFixed(4)} ${toLabel}`;
            document.getElementById('swapReceive').textContent = `${amtOut.toFixed(4)} ${toLabel}`;
            document.getElementById('swapFee').textContent = `${feeAmount.toFixed(4)} ${fromLabel}`;
            document.getElementById('swapImpact').textContent = priceImpact.toFixed(2) + '%';
            document.getElementById('swapMinReceive').textContent = `${minReceive.toFixed(4)} ${toLabel}`;

            // Color impact based on severity
            const impactEl = document.getElementById('swapImpact');
            if (priceImpact > 5) {
                impactEl.style.color = 'var(--red)';
            } else if (priceImpact > 1) {
                impactEl.style.color = 'var(--amber)';
            } else {
                impactEl.style.color = 'var(--text)';
            }
        }

        async function executeSwap() {
            if (!signer || !connectedAddress) {
                await connectWallet();
                if (!signer || !connectedAddress) return;
            }

            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            if (amt <= 0) {
                showStatus('Enter amount to swap', 'error');
                return;
            }

            // Validate market is selected
            if (!currentTrade.marketId || !currentTrade.yesId || !currentTrade.noId) {
                showStatus('Please select a market first', 'error');
                return;
            }

            // Validate pool has liquidity
            if (!currentOrderbook.rYes || !currentOrderbook.rNo ||
                currentOrderbook.rYes === 0n || currentOrderbook.rNo === 0n) {
                showStatus('Pool has no liquidity', 'error');
                return;
            }

            // Validate user has enough shares to swap
            // Use raw max value if available (from Max button), otherwise parse input
            const amtWei = swapMaxRaw || ethers.parseEther(amt.toString());
            const sourceBalance = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
            if (!sourceBalance || amtWei > sourceBalance) {
                const available = sourceBalance ? parseFloat(ethers.formatEther(sourceBalance)).toFixed(4) : '0';
                const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
                const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                const fromLabel = currentSwapDirection ? yesLabel : noLabel;
                showStatus(`Insufficient ${fromLabel}. You have ${available}`, 'error');
                return;
            }

            const submitBtn = document.getElementById('swapSubmit');
            const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const fromLabel = currentSwapDirection ? yesLabel : noLabel;
            const toLabel = currentSwapDirection ? noLabel : yesLabel;

            try {
                submitBtn.disabled = true;

                // Check approval using proper system
                const approved = await checkAndRequestApprovals('swap');
                if (!approved) {
                    submitBtn.disabled = false;
                    return;
                }

                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);
                // amtWei already declared above for balance validation

                // Get market IDs from current trade
                const yesId = BigInt(currentTrade.yesId);
                const noId = BigInt(currentTrade.noId);

                // Build pool key - YES/NO shares both use PAMM as token address
                // Pool is ordered with smaller ID first
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;
                const poolKey = {
                    id0: id0,
                    id1: id1,
                    token0: PAMM_ADDRESS,
                    token1: PAMM_ADDRESS,
                    feeOrHook: HOOK_FEE_OR_HOOK  // 30 bps = 0.3% fee tier
                };

                // zeroForOne: true if swapping token0 for token1
                // If YES is token0 (id0) and we're swapping YESNO, then zeroForOne = true
                // If NO is token0 (id0) and we're swapping NOYES, then zeroForOne = true
                const yesIsToken0 = yesId === id0;
                const zeroForOne = currentSwapDirection ? yesIsToken0 : !yesIsToken0;

                // Calculate minimum output with slippage
                const slippage = slippageTolerance / 100;
                const rYesNum = Number(currentOrderbook.rYes) / 1e18;
                const rNoNum = Number(currentOrderbook.rNo) / 1e18;
                const reserveIn = currentSwapDirection ? rYesNum : rNoNum;
                const reserveOut = currentSwapDirection ? rNoNum : rYesNum;
                const amtInWithFee = amt * 0.997;
                const expectedOut = (reserveIn + amtInWithFee) > 0
                    ? (amtInWithFee * reserveOut) / (reserveIn + amtInWithFee)
                    : 0;
                const minOut = Math.max(0, expectedOut * (1 - slippage));
                const minOutWei = ethers.parseEther(minOut.toFixed(18));

                // Deadline: 20 minutes from now
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                await monitorTransaction(
                    zamm.swapExactIn(poolKey, amtWei, minOutWei, zeroForOne, connectedAddress, deadline),
                    {
                        pending: { title: `Swap ${fromLabel}  ${toLabel}`, body: 'Confirm in your wallet...' },
                        submitted: { title: `Swap ${fromLabel}  ${toLabel}`, body: 'Waiting for confirmation...' },
                        success: { title: 'Swap Complete!', body: `Swapped ${amt.toFixed(4)} ${fromLabel}  ${expectedOut.toFixed(4)} ${toLabel}` },
                        error: { title: 'Swap Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('tradeAmount').value = '0.01';
                            updateSwapPreview();
                            await loadUserPosition(currentTrade.marketId);
                            await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                        }
                    }
                );

            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Swap failed:', err);
                }
            } finally {
                submitBtn.disabled = false;
                swapMaxRaw = null; // Clear max flag
            }
        }

        // ======================== MINT & LIST ========================
        function setMintKeep(keepYes) {
            mintKeepYes = keepYes;
            const keepYesBtn = document.getElementById('keepYesBtn');
            const keepNoBtn = document.getElementById('keepNoBtn');

            // Use market-specific labels
            const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            keepYesBtn.textContent = 'Keep ' + yesLabel;
            keepNoBtn.textContent = 'Keep ' + noLabel;

            if (keepYes) {
                keepYesBtn.className = 'lp-toggle-btn active-add';
                keepNoBtn.className = 'lp-toggle-btn';
            } else {
                keepYesBtn.className = 'lp-toggle-btn';
                keepNoBtn.className = 'lp-toggle-btn active-remove';
            }
            updateMintPreview();
        }

        function updateMintPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value) || 0;

            // Use market-specific labels
            const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const keepLabel = mintKeepYes ? yesLabel : noLabel;
            const sellLabel = mintKeepYes ? noLabel : yesLabel;

            document.getElementById('mintDeposit').textContent = amt > 0 ? amt.toFixed(4) + ' ETH' : '-- ETH';
            document.getElementById('mintReceive').textContent = amt > 0 ? amt.toFixed(4) + ' ' + yesLabel + ' + ' + amt.toFixed(4) + ' ' + noLabel : '-- ' + yesLabel + ' + -- ' + noLabel;
            document.getElementById('mintKeep').textContent = amt > 0 ? amt.toFixed(4) + ' ' + keepLabel : '-- ' + keepLabel;

            if (amt > 0 && limitPrice > 0) {
                const sellShares = amt;
                const expectedReturn = sellShares * limitPrice;
                const netCost = amt - expectedReturn;

                document.getElementById('mintList').textContent = sellShares.toFixed(4) + ' ' + sellLabel + ' @ ' + limitPrice.toFixed(2) + ' ETH';

                if (netCost > 0) {
                    document.getElementById('mintProfit').textContent = 'Net cost: ' + netCost.toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--text-muted)';
                } else {
                    document.getElementById('mintProfit').textContent = 'Net profit: ' + Math.abs(netCost).toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--green)';
                }
            } else {
                document.getElementById('mintList').textContent = '-- ' + sellLabel + ' @ -- ETH';
                document.getElementById('mintProfit').textContent = 'Net cost: -- ETH';
                document.getElementById('mintProfit').style.color = 'var(--text-muted)';
            }
        }

        async function executeMintAndList() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value);

            if (!amt || amt <= 0) {
                showStatus('Please enter an amount', 'error');
                return;
            }
            if (!limitPrice || limitPrice <= 0 || limitPrice >= 1) {
                showStatus('Please enter a valid limit price (0.01 - 0.99)', 'error');
                return;
            }

            try {
                const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
                if (!masterRouterDeployed) {
                    showStatus('MasterRouter not yet deployed', 'error');
                    return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                const marketId = currentTrade.marketId;
                const amountWei = ethers.parseEther(amt.toString());
                const priceBps = Math.round(limitPrice * 10000);

                // MasterRouter.mintAndPool: splits ETH -> YES + NO, keeps one side, pools the other at specified price
                // mintAndPool(marketId, collateralIn, keepYes, priceInBps, to)
                const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                const keepSide = mintKeepYes ? yesLabel : noLabel;
                const sellSide = mintKeepYes ? noLabel : yesLabel;

                await monitorTransaction(
                    masterRouter.mintAndPool(marketId, amountWei, mintKeepYes, priceBps, connectedAddress, { value: amountWei }),
                    {
                        pending: { title: 'Mint & Pool', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Mint & Pool', body: 'Minting shares and creating pool...' },
                        success: { title: 'Mint & Pool Success!', body: `Keeping ${amt} ${keepSide} shares, pooled ${amt} ${sellSide} at ${limitPrice.toFixed(2)}` },
                        error: { title: 'Mint & Pool Failed', body: '' },
                        onSuccess: async () => {
                            await loadUserPosition(currentTrade.marketId);
                            await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                            document.getElementById('tradeAmount').value = '0.01';
                            document.getElementById('mintLimitPrice').value = '';
                            updateMintPreview();
                        }
                    }
                );
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Mint & Pool error:', err);
                }
            }
        }

        // ======================== LIMIT ORDERS ========================

        async function updateLimitBalance() {
            const balEl = document.getElementById('limitBalance');
            const unitEl = document.getElementById('limitBalanceUnit');

            if (!provider || !connectedAddress) {
                balEl.textContent = '--';
                return;
            }

            try {
                if (limitIsBuy) {
                    // Buy order: need ETH
                    const bal = await provider.getBalance(connectedAddress);
                    balEl.textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    unitEl.textContent = 'ETH';
                } else {
                    // Sell order: need shares
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    balEl.textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                    const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                    const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                    unitEl.textContent = currentTrade.isYes ? yesLabel : noLabel;
                }
            } catch (e) {
                balEl.textContent = '--';
            }
        }

        function adjustLimitPrice(delta) {
            const input = document.getElementById('limitPrice');
            const current = parseFloat(input.value) || currentOrderbook.ammPrice || 0.5;
            const newPrice = Math.max(0.01, Math.min(0.99, current + delta));
            input.value = newPrice.toFixed(2);
            updateLimitPreview();
        }

        function setLimitPriceToPool() {
            const ammPrice = currentOrderbook.ammPrice;
            if (ammPrice > 0) {
                document.getElementById('limitPrice').value = ammPrice.toFixed(2);
                updateLimitPreview();
            }
        }

        function setSmartDefaultPrice() {
            const ammPrice = currentOrderbook.ammPrice;
            if (ammPrice > 0) {
                // Buy: bid 2% below pool, Sell: ask 2% above pool
                const spread = 0.02;
                const defaultPrice = limitIsBuy
                    ? Math.max(0.01, ammPrice - spread)
                    : Math.min(0.99, ammPrice + spread);
                document.getElementById('limitPrice').value = defaultPrice.toFixed(2);

                // Update pool price display
                document.getElementById('limitPoolPrice').textContent = ammPrice.toFixed(2) + ' (' + (ammPrice * 100).toFixed(0) + '%)';
            }
        }

        function setMaxLimitShares() {
            if (limitIsBuy) {
                // For buy orders, max is based on ETH balance and price
                const price = parseFloat(document.getElementById('limitPrice').value) || 0;
                if (price > 0 && provider && connectedAddress) {
                    provider.getBalance(connectedAddress).then(bal => {
                        const ethBal = parseFloat(ethers.formatEther(bal));
                        const maxShares = ethBal / price;
                        document.getElementById('limitShares').value = Math.floor(maxShares * 100) / 100;
                        updateLimitPreview();
                    });
                }
            } else {
                // For sell orders, max is share balance
                const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                const shares = parseFloat(ethers.formatEther(sharesBal || 0n));
                document.getElementById('limitShares').value = Math.floor(shares * 10000) / 10000;
                updateLimitPreview();
            }
        }

        function setLimitSide(side) {
            limitIsBuy = (side === 'buy');
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const submitBtn = document.getElementById('limitSubmit');
            const costLabel = document.getElementById('limitCostLabel');
            const receiveLabel = document.getElementById('limitReceiveLabel');
            const profitLabel = document.getElementById('limitProfitLabel');
            const explainerText = document.getElementById('limitExplainerText');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            if (limitIsBuy) {
                buyBtn.className = 'lp-toggle-btn active-add';
                sellBtn.className = 'lp-toggle-btn';
                costLabel.textContent = 'You escrow';
                receiveLabel.textContent = 'If filled, you get';
                profitLabel.textContent = 'If you win';
                submitBtn.textContent = 'Place Buy Order';
                submitBtn.style.background = 'var(--green)';
                explainerText.innerHTML = `<strong>Buy Limit:</strong> Bid below pool to get better odds. Your ETH is escrowed until filled.`;
            } else {
                buyBtn.className = 'lp-toggle-btn';
                sellBtn.className = 'lp-toggle-btn active-remove';
                costLabel.textContent = 'You escrow';
                receiveLabel.textContent = 'If filled, you get';
                profitLabel.textContent = 'Guaranteed receive';
                submitBtn.textContent = 'Place Sell Order';
                submitBtn.style.background = 'var(--red)';
                explainerText.innerHTML = `<strong>Sell Limit:</strong> Ask above pool to get a better price. Your ${label} shares are escrowed until filled.`;
            }

            // Set smart default price
            setSmartDefaultPrice();

            updateLimitBalance();
            updateLimitPreview();
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const shares = parseFloat(document.getElementById('limitShares').value) || 0;
            const ammPrice = currentOrderbook.ammPrice || 0;

            const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const label = currentTrade.isYes ? yesLabel : noLabel;
            const oddsHelper = document.getElementById('limitOddsHelper');
            const oddsValue = document.getElementById('limitOddsValue');
            const oddsVsPool = document.getElementById('limitOddsVsPool');
            const returnInfo = document.getElementById('limitReturnInfo');

            // Update pool price display
            if (ammPrice > 0) {
                document.getElementById('limitPoolPrice').textContent = ammPrice.toFixed(2) + ' (' + (ammPrice * 100).toFixed(0) + '%)';
            }

            // Show/update odds helper when price is entered
            if (price > 0 && price < 1) {
                oddsHelper.style.display = 'block';
                const oddsPct = (price * 100).toFixed(0);
                oddsValue.textContent = oddsPct + '%';

                // Calculate potential return
                const returnMultiple = (1 / price).toFixed(2);
                const returnPct = ((1 / price - 1) * 100).toFixed(0);
                returnInfo.textContent = limitIsBuy
                    ? `If you win: ${returnMultiple}x return (+${returnPct}%)`
                    : '';

                // Compare to pool odds
                if (ammPrice > 0) {
                    const poolOddsPct = (ammPrice * 100).toFixed(0);
                    const diff = ((price - ammPrice) / ammPrice * 100).toFixed(0);
                    const isBetter = limitIsBuy ? price < ammPrice : price > ammPrice;
                    const sign = diff > 0 ? '+' : '';
                    oddsVsPool.innerHTML = isBetter
                        ? `<span style="color:var(--green)">${sign}${diff}% vs pool</span>`
                        : `<span style="color:var(--text-muted)">${sign}${diff}% vs pool</span>`;
                } else {
                    oddsVsPool.textContent = '';
                }
            } else {
                oddsHelper.style.display = 'none';
            }

            if (price <= 0 || shares <= 0) {
                document.getElementById('limitCost').textContent = '-- ETH';
                document.getElementById('limitReceive').textContent = '-- ' + label;
                document.getElementById('limitProfit').textContent = '--';
                return;
            }

            const totalCost = price * shares;

            if (limitIsBuy) {
                // Buy order: escrow ETH, receive shares when filled
                document.getElementById('limitCost').textContent = totalCost.toFixed(4) + ' ETH';
                document.getElementById('limitReceive').textContent = shares.toFixed(4) + ' ' + label;

                // If you win, shares pay 1 ETH each
                const payout = shares;
                const profit = payout - totalCost;
                const roi = (profit / totalCost * 100).toFixed(0);
                document.getElementById('limitProfit').textContent = `${payout.toFixed(4)} ETH (+${roi}%)`;
                document.getElementById('limitProfit').style.color = 'var(--green)';
            } else {
                // Sell order: escrow shares, receive ETH when filled
                document.getElementById('limitCost').textContent = shares.toFixed(4) + ' ' + label;
                document.getElementById('limitReceive').textContent = totalCost.toFixed(4) + ' ETH';

                // Guaranteed ETH from sale
                document.getElementById('limitProfit').textContent = totalCost.toFixed(4) + ' ETH';
                document.getElementById('limitProfit').style.color = 'var(--text)';
            }
        }

        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const price = parseFloat(document.getElementById('limitPrice').value);
            const shares = parseFloat(document.getElementById('limitShares').value);

            if (!price || price <= 0 || price >= 1) {
                showStatus('Enter valid price (0.01 - 0.99)', 'error');
                return;
            }
            if (!shares || shares <= 0) {
                showStatus('Enter valid shares amount', 'error');
                return;
            }

            // For sell orders, validate user has enough shares
            if (!limitIsBuy) {
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                const sharesNeeded = ethers.parseEther(shares.toString());
                if (sharesNeeded > userShares) {
                    const available = parseFloat(ethers.formatEther(userShares)).toFixed(4);
                    showStatus(`Insufficient shares. You have ${available}`, 'error');
                    return;
                }
            }

            try {
                const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
                if (!masterRouterDeployed) {
                    showStatus('MasterRouter not yet deployed', 'error');
                    return;
                }

                // For sell orders (ASK pools), need MasterRouter approved as operator on PAMM
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                const marketId = currentTrade.marketId;
                const sharesWei = ethers.parseEther(shares.toString());
                const collateralWei = ethers.parseEther((price * shares).toString());
                const priceBps = Math.round(price * 10000);

                let txPromise;
                if (limitIsBuy) {
                    // BID pool: deposit collateral to buy shares at price
                    // createBidPool(marketId, collateralIn, buyYes, priceInBps, to)
                    txPromise = masterRouter.createBidPool(
                        marketId,
                        collateralWei,
                        currentTrade.isYes,
                        priceBps,
                        connectedAddress,
                        { value: collateralWei }
                    );
                } else {
                    // ASK pool: deposit shares to sell at price
                    // depositSharesToPool(marketId, isYes, sharesIn, priceInBps, to)
                    txPromise = masterRouter.depositSharesToPool(
                        marketId,
                        currentTrade.isYes,
                        sharesWei,
                        priceBps,
                        connectedAddress
                    );
                }

                const orderType = limitIsBuy ? 'Bid Pool' : 'Ask Pool';
                await monitorTransaction(txPromise, {
                    pending: { title: `Creating ${orderType}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Creating ${orderType}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Pool Created!', body: `${limitIsBuy ? 'Bid' : 'Ask'} ${shares} shares at ${price.toFixed(2)}` },
                    error: { title: 'Pool Creation Failed', body: '' },
                    onSuccess: async () => {
                        document.getElementById('limitPrice').value = '';
                        document.getElementById('limitShares').value = '';
                        updateLimitPreview();
                        await loadOrderbook(marketId, currentTrade.isYes);
                        await refreshUserOrders();
                    }
                });
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Pool creation error:', err);
                }
            }
        }

        async function refreshUserOrders() {
            const listEl = document.getElementById('yourOrdersList');

            if (!connectedAddress || !currentTrade.marketId) {
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Connect wallet to see pool positions</div>';
                return;
            }

            const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
            if (!masterRouterDeployed) {
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">MasterRouter not deployed</div>';
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, rpc);
                const marketId = currentTrade.marketId;

                // Scan common price levels for user positions
                const priceLevels = [];
                for (let i = 500; i <= 9500; i += 500) {
                    priceLevels.push(i);
                }

                const positions = [];
                const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';

                // Check ASK pool positions (selling shares) for both YES and NO
                for (const isYes of [true, false]) {
                    for (const priceBps of priceLevels) {
                        try {
                            const pos = await masterRouter.getUserPosition(marketId, isYes, priceBps, connectedAddress);
                            const [userScaled, userWithdrawableShares, userPendingCollateral] = pos;
                            if (userScaled > 0n) {
                                positions.push({
                                    type: 'ASK',
                                    isYes,
                                    priceBps,
                                    shares: userWithdrawableShares,
                                    pendingCollateral: userPendingCollateral,
                                    label: isYes ? yesLabel : noLabel
                                });
                            }
                        } catch {}
                    }
                }

                // Check BID pool positions (buying shares) for both YES and NO
                for (const buyYes of [true, false]) {
                    for (const priceBps of priceLevels) {
                        try {
                            const pos = await masterRouter.getBidPosition(marketId, buyYes, priceBps, connectedAddress);
                            const [userScaled, userWithdrawableCollateral, userPendingShares] = pos;
                            if (userScaled > 0n) {
                                positions.push({
                                    type: 'BID',
                                    isYes: buyYes,
                                    priceBps,
                                    collateral: userWithdrawableCollateral,
                                    pendingShares: userPendingShares,
                                    label: buyYes ? yesLabel : noLabel
                                });
                            }
                        } catch {}
                    }
                }

                userOrders = positions;

                if (positions.length === 0) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No pool positions</div>';
                    return;
                }

                // Render positions
                listEl.innerHTML = positions.map(p => {
                    const price = p.priceBps / 10000;
                    const oddsStr = (price * 100).toFixed(0) + '%';
                    const isCurrentSide = p.isYes === currentTrade.isYes;

                    if (p.type === 'ASK') {
                        const shares = Number(p.shares) / 1e18;
                        const pending = Number(p.pendingCollateral) / 1e18;
                        const sharesStr = shares >= 1 ? shares.toFixed(2) : shares.toFixed(4);
                        return `
                            <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-bottom:1px solid var(--border);${!isCurrentSide ? 'opacity:0.6;' : ''}">
                                <div>
                                    <span style="color:var(--red);font-weight:600;">SELL</span>
                                    <span style="color:var(--text);">${sharesStr} ${p.label}</span>
                                    <span style="color:var(--text-muted);">@ ${price.toFixed(2)} (${oddsStr})</span>
                                    ${pending > 0 ? `<span style="color:var(--green);font-size:10px;margin-left:4px;">+${pending.toFixed(4)} ETH earned</span>` : ''}
                                </div>
                                <button onclick="withdrawFromAskPool(${p.priceBps}, ${p.isYes})"
                                    style="padding:2px 8px;font-size:var(--font-xs);background:transparent;border:1px solid var(--amber);color:var(--amber);border-radius:var(--radius);cursor:pointer;">
                                    Withdraw
                                </button>
                            </div>
                        `;
                    } else {
                        const collateral = Number(p.collateral) / 1e18;
                        const pending = Number(p.pendingShares) / 1e18;
                        const collateralStr = collateral >= 1 ? collateral.toFixed(2) : collateral.toFixed(4);
                        return `
                            <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-bottom:1px solid var(--border);${!isCurrentSide ? 'opacity:0.6;' : ''}">
                                <div>
                                    <span style="color:var(--green);font-weight:600;">BUY</span>
                                    <span style="color:var(--text);">${collateralStr} ETH</span>
                                    <span style="color:var(--text-muted);">@ ${price.toFixed(2)} (${oddsStr}) for ${p.label}</span>
                                    ${pending > 0 ? `<span style="color:var(--green);font-size:10px;margin-left:4px;">+${pending.toFixed(4)} shares filled</span>` : ''}
                                </div>
                                <button onclick="withdrawFromBidPool(${p.priceBps}, ${p.isYes})"
                                    style="padding:2px 8px;font-size:var(--font-xs);background:transparent;border:1px solid var(--amber);color:var(--amber);border-radius:var(--radius);cursor:pointer;">
                                    Withdraw
                                </button>
                            </div>
                        `;
                    }
                }).join('');

            } catch (e) {
                console.error('Failed to load pool positions:', e);
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Failed to load positions</div>';
            }
        }

        // Withdraw from ASK pool (get back unfilled shares + claim earned collateral)
        async function withdrawFromAskPool(priceBps, isYes) {
            if (!signer) {
                showStatus('Connect wallet first', 'error');
                return;
            }

            if (!confirm('Withdraw from this pool? This will return unfilled shares and claim any earned ETH.')) return;

            try {
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                // withdrawFromPool(marketId, isYes, priceInBps, sharesToWithdraw, to)
                // 0 shares = withdraw all
                await monitorTransaction(
                    masterRouter.withdrawFromPool(currentTrade.marketId, isYes, priceBps, 0, connectedAddress),
                    {
                        pending: { title: 'Withdrawing', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Withdrawing', body: 'Waiting for confirmation...' },
                        success: { title: 'Withdrawn!', body: 'Shares and ETH proceeds returned' },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                            await refreshUserOrders();
                            await loadUserPosition(currentTrade.marketId);
                        }
                    }
                );
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Withdraw from ASK pool error:', err);
                }
            }
        }

        // Withdraw from BID pool (get back unfilled collateral + claim earned shares)
        async function withdrawFromBidPool(priceBps, buyYes) {
            if (!signer) {
                showStatus('Connect wallet first', 'error');
                return;
            }

            if (!confirm('Withdraw from this pool? This will return unfilled ETH and claim any earned shares.')) return;

            try {
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                // withdrawFromBidPool(marketId, isYes, priceInBps, collateralToWithdraw, to)
                // 0 collateral = withdraw all
                await monitorTransaction(
                    masterRouter.withdrawFromBidPool(currentTrade.marketId, buyYes, priceBps, 0, connectedAddress),
                    {
                        pending: { title: 'Withdrawing', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Withdrawing', body: 'Waiting for confirmation...' },
                        success: { title: 'Withdrawn!', body: 'ETH and shares returned' },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                            await refreshUserOrders();
                            await loadUserPosition(currentTrade.marketId);
                        }
                    }
                );
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Withdraw from BID pool error:', err);
                }
            }
        }

        async function setMaxTrade() {
            if (currentTradeMode === 'lp') {
                if (currentLpMode === 'add') {
                    // Set max ETH for adding LP
                    if (provider && connectedAddress) {
                        try {
                            const bal = await provider.getBalance(connectedAddress);
                            const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                            lpMaxRaw = maxBal; // Store exact value
                            document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                            updateLpPreview();
                        } catch (e) {
                            console.warn('Failed to fetch balance for max:', e.message);
                        }
                    }
                } else {
                    // Set max LP tokens for removing
                    const lpBal = currentUserPosition.lpBalance || 0n;
                    lpMaxRaw = lpBal; // Store exact value
                    document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(lpBal)).toFixed(4);
                    updateLpPreview();
                }
            } else if (currentTradeMode === 'swap') {
                // Set max shares for swap (YES if YESNO, NO if NOYES)
                const sharesBal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                swapMaxRaw = sharesBal || 0n; // Store exact value
                document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                updateSwapPreview();
            } else if (currentTradeMode === 'trade') {
                if (currentTradeDirection === 'buy') {
                    // Set max ETH balance (leave some for gas)
                    if (provider && connectedAddress) {
                        try {
                            const bal = await provider.getBalance(connectedAddress);
                            const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                            tradeMaxRaw = maxBal; // Store exact value
                            document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                            updatePreview();
                        } catch (e) {
                            console.warn('Failed to fetch balance for max:', e.message);
                        }
                    }
                } else {
                    // Set max shares for sell
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    tradeMaxRaw = sharesBal || 0n; // Store exact value
                    document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                    updatePreview();
                }
            } else if (currentTradeMode === 'mint') {
                // Set max ETH balance (leave some for gas)
                if (provider && connectedAddress) {
                    try {
                        const bal = await provider.getBalance(connectedAddress);
                        const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                        tradeMaxRaw = maxBal; // Store exact value
                        document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                        updateMintPreview();
                    } catch (e) {
                        console.warn('Failed to fetch balance for max:', e.message);
                    }
                }
            } else {
                // Legacy fallback
                const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                tradeMaxRaw = sharesBal || 0n; // Store exact value
                document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                updatePreview();
            }
        }

        function closeModal() {
            document.getElementById('tradeModal').classList.remove('active');
            document.getElementById('tradeStatus').className = 'status-message';
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                // Use raw max value if available (from Max button), otherwise parse input
                const amtWei = lpMaxRaw || ethers.parseEther(amt.toString());

                // Use configurable LP slippage tolerance
                const slippage = lpSlippageTolerance / 100;
                // Deadline: 20 minutes from now
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                // Get pool state for calculations
                const rYes = currentOrderbook.rYes || 0n;
                const rNo = currentOrderbook.rNo || 0n;
                const rYesNum = Number(rYes) / 1e18;
                const rNoNum = Number(rNo) / 1e18;
                const poolTvl = currentTrade.tvl > 0 ? currentTrade.tvl : (rYesNum + rNoNum) / 2;
                const totalLpSupply = currentUserPosition.lpTotalSupply
                    ? Number(currentUserPosition.lpTotalSupply) / 1e18
                    : Math.sqrt(rYesNum * rNoNum);

                let txPromise;
                if (currentLpMode === 'add') {
                    // Calculate expected LP tokens: estLp = (amt / poolTvl) * totalLpSupply
                    const estLp = poolTvl > 0 && totalLpSupply > 0
                        ? (amt / poolTvl) * totalLpSupply
                        : amt; // For new pool, 1:1
                    const minLiquidity = ethers.parseEther(Math.max(0, estLp * (1 - slippage)).toFixed(18));

                    // Add liquidity: splitAndAddLiquidity
                    txPromise = pamm.splitAndAddLiquidity(
                        currentTrade.marketId,
                        amtWei,
                        HOOK_FEE_OR_HOOK,
                        0, // amount0Min - tokens go to pool atomically, less MEV risk
                        0, // amount1Min
                        minLiquidity, // minLiquidity - protect against sandwich
                        connectedAddress,
                        deadline,
                        { value: amtWei }
                    );

                    await monitorTransaction(txPromise, {
                        pending: { title: 'Adding Liquidity', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Adding Liquidity', body: 'Waiting for confirmation...' },
                        success: { title: 'Liquidity Added!', body: `Added ${amt} ETH to the pool` },
                        error: { title: 'Add Liquidity Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([
                                loadUserPosition(currentTrade.marketId),
                                loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                            ]);
                            loadBalance();
                            updateLpPreview();
                        }
                    });
                } else {
                    // Remove liquidity: need PAMM approved as operator on ZAMM
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    // Calculate expected ETH out: ethOut = min(yesOut, noOut)
                    // where yesOut = shareOfPool * rYesNum, noOut = shareOfPool * rNoNum
                    const shareOfPool = totalLpSupply > 0 ? amt / totalLpSupply : 0;
                    const yesOut = shareOfPool * rYesNum;
                    const noOut = shareOfPool * rNoNum;
                    const expectedEthOut = Math.min(yesOut, noOut);
                    const minCollateralOut = ethers.parseEther(Math.max(0, expectedEthOut * (1 - slippage)).toFixed(18));

                    txPromise = pamm.removeLiquidityToCollateral(
                        currentTrade.marketId,
                        HOOK_FEE_OR_HOOK,
                        amtWei,
                        0, // amount0Min - handled by minCollateralOut
                        0, // amount1Min
                        minCollateralOut, // minCollateralOut - protect against sandwich
                        connectedAddress,
                        deadline
                    );

                    await monitorTransaction(txPromise, {
                        pending: { title: 'Removing Liquidity', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Removing Liquidity', body: 'Waiting for confirmation...' },
                        success: { title: 'Liquidity Removed!', body: `Withdrew liquidity from the pool` },
                        error: { title: 'Remove Liquidity Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([
                                loadUserPosition(currentTrade.marketId),
                                loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                            ]);
                            loadBalance();
                            updateLpPreview();
                        }
                    });
                }

            } catch (e) {
                // monitorTransaction handles errors, but catch user rejection before tx submission
                if (isUserRejection(e)) {
                    showStatus('', ''); // Clear status on user rejection
                } else {
                    console.error('LP operation failed:', e);
                    showStatus('LP operation failed', 'error');
                }
            } finally {
                lpMaxRaw = null; // Clear max flag
            }
        }

        let tradeInputTimer = null;
        function handleTradeInput() {
            // Clear raw max values when user manually edits input
            tradeMaxRaw = null;
            swapMaxRaw = null;
            lpMaxRaw = null;

            // Debounce expensive preview calculations
            clearTimeout(tradeInputTimer);
            tradeInputTimer = setTimeout(() => {
                if (currentTradeMode === 'lp') {
                    updateLpPreview();
                } else if (currentTradeMode === 'swap') {
                    updateSwapPreview();
                } else if (currentTradeMode === 'mint') {
                    updateMintPreview();
                } else {
                    updatePreview();
                }
            }, 80);
        }

        async function loadBalance() {
            if (!provider || !connectedAddress) return;
            try {
                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        const bal = await provider.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    } else {
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    }
                } else if (currentTradeMode === 'swap') {
                    // For swap, show balance of the share being swapped (YES if YESNO, NO if NOYES)
                    const sharesBal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                } else if (currentTradeMode === 'trade') {
                    if (currentTradeDirection === 'buy') {
                        const bal = await provider.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    } else {
                        const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                    }
                } else if (currentTradeMode === 'mint') {
                    const bal = await provider.getBalance(connectedAddress);
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                } else {
                    // Legacy fallback for buy/sell modes
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                }
            } catch (e) {
                document.getElementById('tradeBalance').textContent = '--';
            }
        }

        function updatePreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const m = markets[currentTrade.type];
            const routeEl = document.getElementById('previewRoute');
            const breakdownEl = document.getElementById('previewBreakdown');
            const savingsEl = document.getElementById('previewSavings');
            const breakdownDetails = document.getElementById('breakdownDetails');

            // Determine if buying based on currentTradeDirection (for 'trade' mode) or legacy mode
            const isBuy = currentTradeMode === 'trade' ? currentTradeDirection === 'buy' : currentTradeMode === 'buy';

            if (!m || amt === 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                document.getElementById('previewOddsRow').style.display = 'none';
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--blue)';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            const price = currentTrade.isYes ? m.yesPrice : m.noPrice;
            const ammPrice = currentOrderbook.ammPrice || price;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            // Simulate mixed fill execution
            const execution = simulateMixedFill(amt, isBuy, rYes, rNo, ammPrice);

            // Update route indicator
            if (execution.orderbookFills.length > 0) {
                routeEl.innerHTML = `Orderbook + AMM <span style="color:var(--green);"></span>`;
                routeEl.style.color = 'var(--green)';
            } else {
                routeEl.textContent = 'AMM only';
                routeEl.style.color = 'var(--blue)';
            }

            // Update main preview
            if (execution.totalOutput <= 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = 'No liquidity';
                document.getElementById('previewOddsRow').style.display = 'none';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            if (isBuy) {
                // Buy: spend ETH, receive shares (1 share = 1 ETH if win)
                const effectivePrice = amt / execution.totalOutput;
                const payout = execution.totalOutput; // Shares redeem at 1 ETH each
                const profit = payout - amt;
                const roi = (profit / amt) * 100;
                const impliedOdds = effectivePrice * 100;

                document.getElementById('previewShares').textContent = formatEth(execution.totalOutput, ' shares');
                document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH');
                document.getElementById('previewPayout').textContent = `${formatEth(payout, '')} ETH (+${roi.toFixed(0)}%)`;

                // Show implied odds
                document.getElementById('previewOddsRow').style.display = 'flex';
                const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                document.getElementById('previewOdds').textContent = impliedOdds.toFixed(1) + '% ' + (currentTrade.isYes ? yesLabel : noLabel);
            } else {
                // Sell: spend shares, receive ETH
                const effectivePrice = execution.totalOutput / amt;
                const minReceive = execution.totalOutput * (1 - slippageTolerance / 100);
                const impliedOdds = effectivePrice * 100;

                document.getElementById('previewShares').textContent = formatEth(execution.totalOutput);
                document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH');
                document.getElementById('previewPayout').textContent = formatEth(minReceive);

                // Show implied odds
                document.getElementById('previewOddsRow').style.display = 'flex';
                document.getElementById('previewOdds').textContent = impliedOdds.toFixed(1) + '%';
            }

            // Show execution breakdown if using orderbook
            if (execution.orderbookFills.length > 0) {
                breakdownEl.style.display = 'flex';
                let breakdownHtml = '';
                execution.orderbookFills.forEach(fill => {
                    if (isBuy) {
                        breakdownHtml += `<div> ${formatEth(fill.sharesOut, '')} @ ${formatEth(fill.price, '')} (OB)</div>`;
                    } else {
                        breakdownHtml += `<div> ${formatEth(fill.sharesIn, '')} @ ${formatEth(fill.price, '')} (OB)</div>`;
                    }
                });
                if (execution.ammOutput > 0) {
                    if (isBuy) {
                        breakdownHtml += `<div> ${formatEth(execution.ammOutput, '')} @ ~${formatEth(execution.ammEffectivePrice, '')} (AMM)</div>`;
                    } else {
                        breakdownHtml += `<div> ${formatEth(execution.ammSharesIn, '')}  ${formatEth(execution.ammOutput)} (AMM)</div>`;
                    }
                }
                breakdownDetails.innerHTML = breakdownHtml;
            } else {
                breakdownEl.style.display = 'none';
            }

            // Show savings vs pure AMM
            if (execution.savings > 0.0001 && execution.pureAmmOutput > 0) {
                savingsEl.style.display = 'flex';
                const savingsPct = (execution.savings / execution.pureAmmOutput * 100).toFixed(1);
                document.getElementById('savingsAmount').textContent = `+${execution.savings.toFixed(4)} (+${savingsPct}%)`;
                document.getElementById('savingsAmount').style.color = 'var(--green)';
            } else {
                savingsEl.style.display = 'none';
            }

            // Trigger async quote update for more accurate PMHookRouter quotes
            // This will update the preview with vault OTC/mint routing info when quoter is available
            if (PMHOOKQUOTER_ADDRESS !== '0x0000000000000000000000000000000000000000') {
                updatePreviewAsync();
            }
        }

        // Simulate execution with slippage-aware routing
        // Compares limit orders against AMM effective price (with slippage), not just spot
        function simulateMixedFill(inputAmt, isBuy, rYes, rNo, ammPrice) {
            const result = {
                orderbookFills: [],
                ammInput: 0,
                ammOutput: 0,
                ammSharesIn: 0,
                ammEffectivePrice: 0,
                totalOutput: 0,
                pureAmmOutput: 0,
                savings: 0
            };

            let remaining = inputAmt;
            const amtWei = BigInt(Math.floor(inputAmt * 1e18));

            // Calculate pure AMM output for comparison
            if (rYes > 0n && rNo > 0n) {
                if (isBuy) {
                    const pureAmm = currentTrade.isYes ?
                        quoteBuyYes(amtWei, rYes, rNo, FEE_BPS) :
                        quoteBuyNo(amtWei, rYes, rNo, FEE_BPS);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                } else {
                    const pureAmm = currentTrade.isYes ?
                        quoteSellYes(amtWei, rYes, rNo, FEE_BPS) :
                        quoteSellNo(amtWei, rYes, rNo, FEE_BPS);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                }
            }

            // Get ALL limit orders (we'll compare against AMM with slippage)
            let allOrders = [];
            if (isBuy) {
                // For buying: we look at asks (sell orders), sorted by price ascending (cheapest first)
                allOrders = (currentOrderbook.asks || [])
                    .map(o => {
                        // Use BigInt arithmetic with 1e18 scaling for precision
                        const priceScaled = o.shares > 0n ? (o.collateral * BigInt(1e18)) / o.shares : 0n;
                        return {
                            price: Number(priceScaled) / 1e18,
                            shares: Number(o.shares) / 1e18,
                            collateral: Number(o.collateral) / 1e18,
                            hash: o.hash,
                            remaining: Number(o.collateral) / 1e18 // ETH needed to fill
                        };
                    })
                    .filter(o => o.price > 0 && o.shares > 0)
                    .sort((a, b) => a.price - b.price);
            } else {
                // For selling: we look at bids (buy orders), sorted by price descending (best first)
                allOrders = (currentOrderbook.bids || [])
                    .map(o => {
                        // Use BigInt arithmetic with 1e18 scaling for precision
                        const priceScaled = o.shares > 0n ? (o.collateral * BigInt(1e18)) / o.shares : 0n;
                        return {
                            price: Number(priceScaled) / 1e18,
                            shares: Number(o.shares) / 1e18,
                            collateral: Number(o.collateral) / 1e18,
                            hash: o.hash,
                            remaining: Number(o.shares) / 1e18 // Shares they want to buy
                        };
                    })
                    .filter(o => o.price > 0 && o.shares > 0)
                    .sort((a, b) => b.price - a.price);
            }

            // Track AMM state as we simulate fills
            let simRYes = rYes;
            let simRNo = rNo;
            let orderIdx = 0;

            // Slippage-aware routing: compare each order against AMM marginal price
            while (remaining > 0.000001 && (orderIdx < allOrders.length || (simRYes > 0n && simRNo > 0n))) {
                const currentOrder = orderIdx < allOrders.length ? allOrders[orderIdx] : null;

                // Calculate AMM marginal price for a small test amount
                let ammMarginalPrice = ammPrice;
                if (simRYes > 0n && simRNo > 0n) {
                    const testAmt = BigInt(Math.floor(Math.min(remaining, 0.001) * 1e18));
                    if (testAmt > 0n) {
                        if (isBuy) {
                            const testOut = currentTrade.isYes ?
                                quoteBuyYes(testAmt, simRYes, simRNo, FEE_BPS) :
                                quoteBuyNo(testAmt, simRYes, simRNo, FEE_BPS);
                            ammMarginalPrice = Number(testAmt) / Number(testOut);
                        } else {
                            const testOut = currentTrade.isYes ?
                                quoteSellYes(testAmt, simRYes, simRNo, FEE_BPS) :
                                quoteSellNo(testAmt, simRYes, simRNo, FEE_BPS);
                            ammMarginalPrice = Number(testOut) / Number(testAmt);
                        }
                    }
                }

                // Decide: fill order or use AMM?
                let useOrder = false;
                if (currentOrder && currentOrder.remaining > 0) {
                    if (isBuy) {
                        // Buying: order is better if its price < AMM marginal price
                        useOrder = currentOrder.price < ammMarginalPrice;
                    } else {
                        // Selling: order is better if its price > AMM marginal price
                        useOrder = currentOrder.price > ammMarginalPrice;
                    }
                }

                if (useOrder && currentOrder) {
                    // Fill limit order
                    if (isBuy) {
                        const maxEthForOrder = currentOrder.remaining;
                        const ethToSpend = Math.min(remaining, maxEthForOrder);
                        const sharesOut = ethToSpend / currentOrder.price;

                        result.orderbookFills.push({
                            price: currentOrder.price,
                            ethSpent: ethToSpend,
                            sharesOut: sharesOut,
                            hash: currentOrder.hash
                        });
                        result.totalOutput += sharesOut;
                        remaining -= ethToSpend;
                        currentOrder.remaining -= ethToSpend;
                    } else {
                        const maxSharesForOrder = currentOrder.remaining;
                        const sharesToSell = Math.min(remaining, maxSharesForOrder);
                        const ethOut = sharesToSell * currentOrder.price;

                        result.orderbookFills.push({
                            price: currentOrder.price,
                            sharesIn: sharesToSell,
                            ethOut: ethOut,
                            hash: currentOrder.hash
                        });
                        result.totalOutput += ethOut;
                        remaining -= sharesToSell;
                        currentOrder.remaining -= sharesToSell;
                    }

                    // Move to next order if this one is exhausted
                    if (currentOrder.remaining <= 0.000001) {
                        orderIdx++;
                    }
                } else if (simRYes > 0n && simRNo > 0n) {
                    // Route to AMM - use chunk or all remaining
                    // If there are more orders, route just enough to make next order competitive
                    let amtToAmm = remaining;

                    // Check if routing partial to AMM would make next order better
                    if (currentOrder && currentOrder.remaining > 0) {
                        // Route smaller chunks to check when order becomes competitive
                        amtToAmm = Math.min(remaining, remaining * 0.1 + 0.0001);
                    }

                    const ammAmtWei = BigInt(Math.floor(amtToAmm * 1e18));
                    if (ammAmtWei > 0n) {
                        if (isBuy) {
                            const ammOut = currentTrade.isYes ?
                                quoteBuyYes(ammAmtWei, simRYes, simRNo, FEE_BPS) :
                                quoteBuyNo(ammAmtWei, simRYes, simRNo, FEE_BPS);
                            const sharesOut = Number(ammOut) / 1e18;
                            result.ammOutput += sharesOut;
                            result.ammInput += amtToAmm;
                            result.totalOutput += sharesOut;
                            remaining -= amtToAmm;

                            // Update simulated reserves (approximate)
                            if (currentTrade.isYes) {
                                simRNo += ammAmtWei;
                                simRYes -= ammOut > simRYes ? simRYes : ammOut;
                            } else {
                                simRYes += ammAmtWei;
                                simRNo -= ammOut > simRNo ? simRNo : ammOut;
                            }
                        } else {
                            const ammOut = currentTrade.isYes ?
                                quoteSellYes(ammAmtWei, simRYes, simRNo, FEE_BPS) :
                                quoteSellNo(ammAmtWei, simRYes, simRNo, FEE_BPS);
                            const ethOut = Number(ammOut) / 1e18;
                            result.ammOutput += ethOut;
                            result.ammSharesIn += amtToAmm;
                            result.totalOutput += ethOut;
                            remaining -= amtToAmm;

                            // Update simulated reserves (approximate)
                            if (currentTrade.isYes) {
                                simRYes += ammAmtWei;
                                simRNo -= ammOut > simRNo ? simRNo : ammOut;
                            } else {
                                simRNo += ammAmtWei;
                                simRYes -= ammOut > simRYes ? simRYes : ammOut;
                            }
                        }
                    } else {
                        break; // Can't route anymore
                    }
                } else {
                    // No AMM and no competitive orders
                    if (currentOrder) {
                        orderIdx++; // Skip to next order
                    } else {
                        break; // Nothing left to route
                    }
                }
            }

            // Calculate effective AMM price
            if (result.ammInput > 0 && result.ammOutput > 0) {
                result.ammEffectivePrice = result.ammInput / result.ammOutput;
            }

            // Calculate savings vs pure AMM
            if (result.pureAmmOutput > 0) {
                result.savings = result.totalOutput - result.pureAmmOutput;
            }

            return result;
        }

        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            // Determine if buying based on currentTradeDirection (for 'trade' mode) or legacy mode
            const isBuy = currentTradeMode === 'trade' ? currentTradeDirection === 'buy' : currentTradeMode === 'buy';

            try {
                showStatus('Preparing...', 'pending');

                const routerInfo = getTradeRouter();
                const router = new ethers.Contract(routerInfo.address, routerInfo.abi, signer);
                // Use raw max value if available (from Max button), otherwise parse input
                const amtWei = tradeMaxRaw || ethers.parseEther(amt.toString());

                // Get quote for expected output using fetchRouterQuote (handles quoter + fallback)
                let expectedOutput = 0;
                try {
                    // Clear cache to get fresh quote for execution
                    lastQuoteParams = null;
                    lastQuoteResult = null;

                    const quote = await fetchRouterQuote(currentTrade.marketId, currentTrade.isYes, amtWei, isBuy);
                    expectedOutput = Number(quote.totalOutput) / 1e18;
                } catch (e) {
                    console.warn('Quote failed:', e);
                }

                if (expectedOutput <= 0) {
                    showStatus('No liquidity available', 'error');
                    return;
                }

                // Calculate minOutput with slippage tolerance
                const minOutput = Math.max(0, expectedOutput * (1 - slippageTolerance / 100));
                const minOutputWei = ethers.parseEther(minOutput.toFixed(18));

                const tradeLabel = isBuy ? 'Buying' : 'Selling';
                const side = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

                let txPromise;
                if (isBuy) {
                    if (routerInfo.useMasterRouter) {
                        // Use MasterRouter.buyWithSweep - sweeps pooled orderbook then falls back to AMM
                        // maxPriceBps: sweep pools up to 95 cents (9500 bps) before AMM fallback
                        txPromise = router.buyWithSweep(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei,
                            9500, // maxPriceBps - willing to pay up to 95c from pools
                            connectedAddress,
                            0, // deadline (0 = no deadline)
                            { value: amtWei }
                        );
                    } else {
                        // Fallback to PMHookRouter.buyWithBootstrap
                        txPromise = router.buyWithBootstrap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei,
                            connectedAddress,
                            0,
                            { value: amtWei }
                        );
                    }
                } else {
                    // Sell - need router approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    if (routerInfo.useMasterRouter) {
                        // Use MasterRouter.sellWithSweep - sweeps bid pools then falls back to AMM
                        // minPriceBps: accept bids down to 5 cents (500 bps) before AMM fallback
                        txPromise = router.sellWithSweep(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei,
                            500, // minPriceBps - accept bids down to 5c from pools
                            connectedAddress,
                            0 // deadline
                        );
                    } else {
                        // Fallback to PMHookRouter.sellWithBootstrap
                        txPromise = router.sellWithBootstrap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei,
                            connectedAddress,
                            0
                        );
                    }
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `${tradeLabel} ${side}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${tradeLabel} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Successful!', body: `${tradeLabel} ${amt} ${isBuy ? 'ETH worth of' : ''} ${side} shares` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        await loadData();
                        await loadPositions();
                        setTimeout(closeModal, 1500);
                    }
                });

            } catch (e) {
                // monitorTransaction handles errors, but catch user rejection before tx submission
                if (isUserRejection(e)) {
                    showStatus('', ''); // Clear status on user rejection
                } else {
                    console.error('Trade failed:', e);
                    showStatus('Transaction failed', 'error');
                }
            } finally {
                tradeMaxRaw = null; // Clear max flag
            }
        }

        function showStatus(msg, type, isHtml = false) {
            const el = document.getElementById('tradeStatus');
            if (isHtml) {
                el.innerHTML = msg;
            } else {
                el.textContent = msg;
            }
            el.className = 'status-message show ' + type;
        }

        function txLink(hash, text = 'View tx') {
            return `<a href="https://etherscan.io/tx/${hash}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: underline;">${text}</a>`;
        }

        // ======================== TOAST NOTIFICATIONS ========================

        let activeToasts = new Map(); // Track active toasts by ID

        /**
         * Show a toast notification
         * @param {string} title - Toast title
         * @param {string} body - Toast body text (can include HTML)
         * @param {string} type - 'pending', 'success', or 'error'
         * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
         * @param {string} id - Optional unique ID for updating existing toast
         * @returns {string} - Toast ID
         */
        function showToast(title, body = '', type = 'pending', duration = 0, id = null) {
            const container = document.getElementById('toastContainer');
            const toastId = id || `toast-${Date.now()}`;

            // If updating existing toast, remove old one first
            if (id && activeToasts.has(id)) {
                const existing = activeToasts.get(id);
                existing.element.remove();
                if (existing.timeout) clearTimeout(existing.timeout);
            }

            const icons = {
                pending: '<div class="spinner"></div>',
                success: '<span class="icon"></span>',
                error: '<span class="icon"></span>',
                info: '<span class="icon"></span>'
            };

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-header">
                    ${icons[type] || ''}
                    <span>${title}</span>
                </div>
                ${body ? `<div class="toast-body">${body}</div>` : ''}
                ${duration > 0 ? `<div class="toast-progress"><div class="toast-progress-bar" style="animation-duration: ${duration}ms;"></div></div>` : ''}
            `;

            container.appendChild(toast);

            let timeout = null;
            if (duration > 0) {
                timeout = setTimeout(() => {
                    dismissToast(toastId);
                }, duration);
            } else if (type === 'pending') {
                // Auto-cleanup pending toasts after 70s (just after tx monitor's 60s timeout)
                timeout = setTimeout(() => {
                    if (activeToasts.has(toastId)) {
                        updateToast(toastId, 'Timeout', 'Transaction may still be pending. Check Etherscan.', 'info', 8000);
                    }
                }, 70000);
            }

            activeToasts.set(toastId, { element: toast, timeout });
            return toastId;
        }

        function dismissToast(toastId) {
            if (!activeToasts.has(toastId)) return;

            const { element, timeout } = activeToasts.get(toastId);
            if (timeout) clearTimeout(timeout);

            element.classList.add('hiding');
            setTimeout(() => {
                element.remove();
                activeToasts.delete(toastId);
            }, 300);
        }

        function updateToast(toastId, title, body, type, duration = 0) {
            return showToast(title, body, type, duration, toastId);
        }

        /**
         * Helper for transaction monitoring with toast updates
         * @param {Promise} txPromise - The transaction promise
         * @param {object} options - { pending, success, error } message configs
         * @returns {Promise} - The transaction receipt
         */
        async function monitorTransaction(txPromise, options = {}) {
            const {
                pending = { title: 'Transaction Pending', body: 'Confirm in your wallet...' },
                submitted = { title: 'Transaction Submitted', body: 'Waiting for confirmation...' },
                success = { title: 'Transaction Confirmed', body: '' },
                error = { title: 'Transaction Failed', body: '' },
                onSuccess = null
            } = options;

            const toastId = showToast(pending.title, pending.body, 'pending');
            let txHash = null;

            try {
                const tx = await txPromise;

                // Transaction submitted to network
                txHash = tx.hash;
                const etherscanLink = `<a href="https://etherscan.io/tx/${txHash}" target="_blank">View on Etherscan</a>`;
                updateToast(toastId, submitted.title, `${submitted.body}<br>${etherscanLink}`, 'pending');

                // Wait for confirmation using dedicated RPC provider (more reliable than wallet's provider)
                const rpc = await getRpcProvider();
                const receipt = await Promise.race([
                    rpc.waitForTransaction(txHash, 1, 60000), // 1 confirmation, 60s timeout
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 65000))
                ]);

                // Use Number() to handle BigInt or string status values
                if (receipt && Number(receipt.status) === 1) {
                    updateToast(toastId, success.title, `${success.body}${success.body ? '<br>' : ''}${etherscanLink}`, 'success', 5000);
                    if (onSuccess) await onSuccess(receipt);
                    return receipt;
                } else if (receipt && Number(receipt.status) === 0) {
                    updateToast(toastId, error.title, `Transaction reverted<br>${etherscanLink}`, 'error', 8000);
                    throw new Error('Transaction reverted');
                } else {
                    // Timeout or null receipt - tx may still be pending or succeeded
                    console.warn('Unexpected receipt state:', receipt);
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded<br>${etherscanLink}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                }
            } catch (e) {
                console.error('Transaction error:', e);
                if (isUserRejection(e)) {
                    updateToast(toastId, 'Transaction Cancelled', 'You rejected the transaction', 'error', 4000);
                } else if (e.message === 'timeout') {
                    const etherscanLink = txHash ? `<a href="https://etherscan.io/tx/${txHash}" target="_blank">View on Etherscan</a>` : '';
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded${etherscanLink ? '<br>' + etherscanLink : ''}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                } else {
                    const errMsg = e.reason || e.message || 'Unknown error';
                    updateToast(toastId, error.title, errMsg, 'error', 8000);
                }
                throw e;
            }
        }

        // ======================== APPROVALS ========================

        /**
         * Ensure operator approval for a contract.
         * @param {string} tokenContract - 'pamm' or 'zamm'
         * @param {string} operatorAddress - Address to approve as operator
         * @param {string} operatorName - Human-readable name for status messages
         * @returns {Promise<boolean>} - true if approved (or already approved), false if rejected
         */
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                let success = false;
                await monitorTransaction(contract.setOperator(operatorAddress, true), {
                    pending: { title: 'Approval Required', body: `Approve ${operatorName} as operator...` },
                    submitted: { title: 'Approval Required', body: 'Waiting for confirmation...' },
                    success: { title: 'Approved!', body: `${operatorName} can now manage your tokens` },
                    error: { title: 'Approval Failed', body: '' },
                    onSuccess: () => { success = true; }
                });
                return success;
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Approval error:', err);
                }
                return false;
            }
        }

        /**
         * Check all required approvals for the current operation
         * @param {string} operation - 'sell', 'lp', 'mint', 'limit'
         * @returns {Promise<boolean>} - true if all approvals granted
         */
        // Helper to determine which router to use (MasterRouter preferred when deployed)
        function getTradeRouter() {
            const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
            return {
                address: masterRouterDeployed ? MASTERROUTER_ADDRESS : PMHOOKROUTER_ADDRESS,
                abi: masterRouterDeployed ? MASTERROUTER_ABI : PMHOOKROUTER_ABI,
                name: masterRouterDeployed ? 'MasterRouter' : 'PMHookRouter',
                useMasterRouter: masterRouterDeployed
            };
        }

        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showStatus('Please connect wallet first', 'error');
                return false;
            }

            // Router needs to be operator on PAMM for: sell
            if (operation === 'sell') {
                const router = getTradeRouter();
                const approved = await ensureOperatorApproval('pamm', router.address, router.name);
                if (!approved) return false;
            }

            // PAMM needs to be operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                const approved = await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
                if (!approved) return false;
            }

            // ZAMM needs to be operator on PAMM for: swap (YESNO)
            if (operation === 'swap') {
                const approved = await ensureOperatorApproval('pamm', ZAMM_ADDRESS, 'ZAMM');
                if (!approved) return false;
            }

            return true;
        }

        // ======================== HELPERS ========================

        // AMM constant product formula (matches ZAMM._getAmountOut)
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        // Quote buying YES shares with collateral
        // PAMM buyYes: split collateral  YES + NO, then swap NO  YES
        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn  collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn NO  yesFromSwap YES (pool: NO in, YES out)
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            // Total YES = from split + from swap
            return collateralIn + yesFromSwap;
        }

        // Quote buying NO shares with collateral
        // PAMM buyNo: split collateral  YES + NO, then swap YES  NO
        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn  collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn YES  noFromSwap NO (pool: YES in, NO out)
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            // Total NO = from split + from swap
            return collateralIn + noFromSwap;
        }

        // Quote selling YES shares for collateral
        // PAMM sellYes: swap some YES  NO, then merge YES + NO  collateral
        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of YES  NO, then merge
            // Actual: swap yesIn/2  NO, merge min(yesIn/2, noFromSwap)
            const yesToSwap = yesIn / 2n;
            const noFromSwap = getAmountOut(yesToSwap, rYes, rNo, feeBps);
            const yesRemaining = yesIn - yesToSwap;
            // Merge: min(yesRemaining, noFromSwap)  collateral
            const merged = yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
            return merged;
        }

        // Quote selling NO shares for collateral
        // PAMM sellNo: swap some NO  YES, then merge YES + NO  collateral
        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of NO  YES, then merge
            const noToSwap = noIn / 2n;
            const yesFromSwap = getAmountOut(noToSwap, rNo, rYes, feeBps);
            const noRemaining = noIn - noToSwap;
            // Merge: min(yesFromSwap, noRemaining)  collateral
            const merged = yesFromSwap < noRemaining ? yesFromSwap : noRemaining;
            return merged;
        }

        // ============ ROUTER QUOTE HELPERS ============

        // Cache for quote results to avoid duplicate RPC calls
        let lastQuoteParams = null;
        let lastQuoteResult = null;
        let quoteDebounceTimer = null;

        // Decode bytes4 source tag to human-readable string
        function decodeSource(sourceBytes4) {
            if (!sourceBytes4 || sourceBytes4 === '0x00000000' || sourceBytes4 === 0n) return 'amm';

            // Handle both hex strings (0x...) and BigInt values
            let hex;
            if (typeof sourceBytes4 === 'string') {
                hex = sourceBytes4.toLowerCase().replace('0x', '');
            } else {
                hex = sourceBytes4.toString(16).padStart(8, '0');
            }

            // Source tags: otc=0x6f746300, amm=0x616d6d00, mint=0x6d696e74, mult=0x6d756c74
            if (hex.startsWith('6f7463')) return 'otc';   // "otc"
            if (hex.startsWith('616d6d')) return 'amm';   // "amm"
            if (hex.startsWith('6d696e74')) return 'mint'; // "mint"
            if (hex.startsWith('6d756c74')) return 'mult'; // "mult"
            return 'amm';
        }

        // Get quote from PMHookQuoter (async) with fallback to local calculation
        async function fetchRouterQuote(marketId, isYes, amountWei, isBuy) {
            // Check cache first
            const cacheKey = `${marketId}-${isYes}-${amountWei}-${isBuy}`;
            if (lastQuoteParams === cacheKey && lastQuoteResult) {
                return lastQuoteResult;
            }

            const quoterDeployed = PMHOOKQUOTER_ADDRESS !== '0x0000000000000000000000000000000000000000';
            const masterRouterDeployed = MASTERROUTER_ADDRESS !== '0x0000000000000000000000000000000000000000';

            try {
                if (quoterDeployed) {
                    const rpc = provider || await getRpcProvider();
                    const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, rpc);

                    // Use sweep quotes when MasterRouter is deployed (includes pool fills)
                    if (masterRouterDeployed) {
                        if (isBuy) {
                            // quoteBuyWithSweep: sweep pools up to 95c, then PMHookRouter
                            const quote = await quoter.quoteBuyWithSweep(marketId, isYes, amountWei, 9500);
                            const result = {
                                totalOutput: quote.totalSharesOut,
                                poolSharesOut: quote.poolSharesOut,
                                poolLevelsFilled: Number(quote.poolLevelsFilled),
                                pmSharesOut: quote.pmSharesOut,
                                source: quote.poolSharesOut > 0n ? 'pools+pm' : decodeSource(quote.pmSource),
                                fromQuoter: true
                            };
                            lastQuoteParams = cacheKey;
                            lastQuoteResult = result;
                            return result;
                        } else {
                            // quoteSellWithSweep: sweep bid pools down to 5c, then PMHookRouter
                            const quote = await quoter.quoteSellWithSweep(marketId, isYes, amountWei, 500);
                            const result = {
                                totalOutput: quote.totalCollateralOut,
                                poolCollateralOut: quote.poolCollateralOut,
                                poolLevelsFilled: Number(quote.poolLevelsFilled),
                                pmCollateralOut: quote.pmCollateralOut,
                                source: quote.poolCollateralOut > 0n ? 'pools+pm' : decodeSource(quote.pmSource),
                                fromQuoter: true
                            };
                            lastQuoteParams = cacheKey;
                            lastQuoteResult = result;
                            return result;
                        }
                    }

                    // PMHookRouter-only quotes (MasterRouter not deployed)
                    if (isBuy) {
                        const quote = await quoter.quoteBootstrapBuy(marketId, isYes, amountWei, 0);
                        const result = {
                            totalOutput: quote.totalSharesOut,
                            usesVault: quote.usesVault,
                            source: decodeSource(quote.source),
                            vaultSharesMinted: quote.vaultSharesMinted,
                            fromQuoter: true
                        };
                        lastQuoteParams = cacheKey;
                        lastQuoteResult = result;
                        return result;
                    } else {
                        const quote = await quoter.quoteSellWithBootstrap(marketId, isYes, amountWei);
                        const result = {
                            totalOutput: quote.collateralOut,
                            source: decodeSource(quote.source),
                            fromQuoter: true
                        };
                        lastQuoteParams = cacheKey;
                        lastQuoteResult = result;
                        return result;
                    }
                }
            } catch (e) {
                console.warn('PMHookQuoter call failed, using local calculation:', e.message);
            }

            // Fallback to local calculation
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            if (rYes === 0n || rNo === 0n) {
                return { totalOutput: 0n, source: 'none', fromQuoter: false };
            }

            if (isBuy) {
                const output = isYes ? quoteBuyYes(amountWei, rYes, rNo, FEE_BPS) : quoteBuyNo(amountWei, rYes, rNo, FEE_BPS);
                return { totalOutput: output, source: 'amm', fromQuoter: false };
            } else {
                const output = isYes ? quoteSellYes(amountWei, rYes, rNo, FEE_BPS) : quoteSellNo(amountWei, rYes, rNo, FEE_BPS);
                return { totalOutput: output, source: 'amm', fromQuoter: false };
            }
        }

        // Debounced async preview update using router quote
        function updatePreviewAsync() {
            if (quoteDebounceTimer) clearTimeout(quoteDebounceTimer);
            quoteDebounceTimer = setTimeout(async () => {
                await doAsyncPreviewUpdate();
            }, 150); // 150ms debounce
        }

        async function doAsyncPreviewUpdate() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const m = markets[currentTrade.type];
            if (!m || amt === 0 || !currentTrade.marketId) return;

            const isBuy = currentTradeMode === 'trade' ? currentTradeDirection === 'buy' : currentTradeMode === 'buy';
            const amtWei = ethers.parseEther(amt.toString());

            try {
                const quote = await fetchRouterQuote(currentTrade.marketId, currentTrade.isYes, amtWei, isBuy);
                if (quote.totalOutput === 0n) return;

                const totalOutput = Number(quote.totalOutput) / 1e18;
                const routeEl = document.getElementById('previewRoute');

                // Update route indicator based on source
                const sourceLabels = {
                    'otc': 'Vault OTC',
                    'amm': 'AMM',
                    'mint': 'Vault Mint',
                    'mult': 'Multi-venue',
                    'pools+pm': 'Pools + Router'
                };
                const sourceLabel = sourceLabels[quote.source] || 'AMM';

                if (quote.source === 'mult' || quote.source === 'pools+pm') {
                    routeEl.innerHTML = `${sourceLabel} <span style="color:var(--green);"></span>`;
                    routeEl.style.color = 'var(--green)';
                } else if (quote.source === 'otc' || quote.source === 'mint') {
                    routeEl.innerHTML = `${sourceLabel} <span style="color:var(--amber);"></span>`;
                    routeEl.style.color = 'var(--amber)';
                } else {
                    routeEl.textContent = sourceLabel;
                    routeEl.style.color = 'var(--blue)';
                }

                // Update output display
                if (isBuy) {
                    const effectivePrice = amt / totalOutput;
                    const payout = totalOutput;
                    const profit = payout - amt;
                    const roi = (profit / amt) * 100;
                    const impliedOdds = effectivePrice * 100;

                    document.getElementById('previewShares').textContent = formatEth(totalOutput, ' shares');
                    document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH');
                    document.getElementById('previewPayout').textContent = `${formatEth(payout, '')} ETH (+${roi.toFixed(0)}%)`;

                    document.getElementById('previewOddsRow').style.display = 'flex';
                    const yesLabel = currentTrade.type === 'extreme' ? 'YES' : 'UP';
                    const noLabel = currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                    document.getElementById('previewOdds').textContent = impliedOdds.toFixed(1) + '% ' + (currentTrade.isYes ? yesLabel : noLabel);
                } else {
                    const effectivePrice = totalOutput / amt;
                    const minReceive = totalOutput * (1 - slippageTolerance / 100);
                    const impliedOdds = effectivePrice * 100;

                    document.getElementById('previewShares').textContent = formatEth(totalOutput);
                    document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH');
                    document.getElementById('previewPayout').textContent = formatEth(minReceive);

                    document.getElementById('previewOddsRow').style.display = 'flex';
                    document.getElementById('previewOdds').textContent = impliedOdds.toFixed(1) + '%';
                }

                // Show breakdown for multi-venue fills
                const breakdownEl = document.getElementById('previewBreakdown');
                const breakdownDetails = document.getElementById('breakdownDetails');

                if (quote.source === 'pools+pm' && (quote.poolSharesOut || quote.poolCollateralOut)) {
                    breakdownEl.style.display = 'flex';
                    let html = '';
                    if (isBuy && quote.poolSharesOut) {
                        const poolShares = Number(quote.poolSharesOut) / 1e18;
                        const pmShares = quote.pmSharesOut ? Number(quote.pmSharesOut) / 1e18 : 0;
                        html += `<div> Pool fills: ${formatEth(poolShares, ' shares')} (${quote.poolLevelsFilled} levels)</div>`;
                        if (pmShares > 0) html += `<div> Router: ${formatEth(pmShares, ' shares')}</div>`;
                    } else if (!isBuy && quote.poolCollateralOut) {
                        const poolColl = Number(quote.poolCollateralOut) / 1e18;
                        const pmColl = quote.pmCollateralOut ? Number(quote.pmCollateralOut) / 1e18 : 0;
                        html += `<div> Pool fills: ${formatEth(poolColl)} (${quote.poolLevelsFilled} levels)</div>`;
                        if (pmColl > 0) html += `<div> Router: ${formatEth(pmColl)}</div>`;
                    }
                    breakdownDetails.innerHTML = html;
                } else if (quote.usesVault || quote.source === 'otc' || quote.source === 'mint') {
                    breakdownEl.style.display = 'flex';
                    if (quote.vaultSharesMinted && quote.vaultSharesMinted > 0n) {
                        const minted = Number(quote.vaultSharesMinted) / 1e18;
                        breakdownDetails.innerHTML = `<div> Vault LP: ${formatEth(minted, ' shares')}</div>`;
                    } else if (quote.source === 'otc') {
                        breakdownDetails.innerHTML = `<div> OTC fill from vault liquidity</div>`;
                    } else {
                        breakdownDetails.innerHTML = '';
                        breakdownEl.style.display = 'none';
                    }
                } else {
                    breakdownEl.style.display = 'none';
                }
            } catch (e) {
                console.warn('Async preview update failed:', e);
            }
        }

        function formatGwei(wei) {
            const gwei = Number(wei) / 1e9;
            if (gwei >= 100) return Math.round(gwei).toString();
            if (gwei >= 10) return gwei.toFixed(1);
            return gwei.toFixed(2);
        }

        // Smart ETH formatting - shows appropriate precision for amount size
        function formatEth(eth, suffix = ' ETH') {
            if (eth === 0) return '0' + suffix;
            if (eth >= 100) return eth.toFixed(1) + suffix;
            if (eth >= 10) return eth.toFixed(2) + suffix;
            if (eth >= 1) return eth.toFixed(3) + suffix;
            if (eth >= 0.1) return eth.toFixed(4) + suffix;
            if (eth >= 0.01) return eth.toFixed(4) + suffix;
            if (eth >= 0.001) return eth.toFixed(5) + suffix;
            return eth.toFixed(6) + suffix; // For very small amounts
        }

        // Format odds/probability with appropriate precision
        function formatOdds(price, asPercent = true) {
            if (asPercent) {
                const pct = price * 100;
                if (pct >= 99 || pct <= 1) return pct.toFixed(1) + '%';
                if (pct >= 90 || pct <= 10) return pct.toFixed(1) + '%';
                return pct.toFixed(1) + '%';
            }
            return price.toFixed(4);
        }

        // Toggle chart visibility in market cards
        async function toggleChart(type) {
            const toggle = document.getElementById(`${type}ChartToggle`);
            const container = document.getElementById(`${type}ChartContainer`);
            if (!toggle || !container) return;

            const isOpen = container.classList.contains('open');

            if (isOpen) {
                // Close chart
                container.classList.remove('open');
                toggle.classList.remove('active');
            } else {
                // Open chart
                toggle.classList.add('active');
                container.classList.add('open');

                // Load chart if not already loaded
                if (!chartLoaded.has(type)) {
                    container.innerHTML = '<div class="card-chart-loading">Loading chart...</div>';

                    try {
                        const market = markets[type];
                        if (!market || !market.id) {
                            container.innerHTML = '<div class="card-chart-loading" style="color:var(--text-dim);">No active market</div>';
                            return;
                        }

                        // Get poolId from cache or compute it
                        let chartData = chartPoolIds.get(type);
                        if (!chartData) {
                            const rpc = provider || await getRpcProvider();
                            const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                            const poolKey = await pamm.poolKey(market.id, HOOK_FEE_OR_HOOK);
                            const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                                [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                            ));
                            chartData = { poolId };
                            chartPoolIds.set(type, chartData);
                        }

                        // ZAMM embed handles Y/N orientation automatically
                        const poolIdDecimal = BigInt(chartData.poolId).toString();

                        const typeLabels = {
                            weekly: 'Weekly',
                            extreme: 'Extreme'
                        };

                        container.innerHTML = `
                            <div class="card-chart-wrapper">
                                <button class="card-chart-expand" onclick="openOddsModal('${type}')"></button>
                                <iframe
                                    src="https://www.zamm.finance/embed/pool/${poolIdDecimal}?theme=dark"
                                    title="${typeLabels[type] || type} Odds"
                                    loading="lazy"
                                ></iframe>
                            </div>`;
                        chartLoaded.add(type);
                    } catch (e) {
                        console.error('Failed to load chart:', e);
                        container.innerHTML = '<div class="card-chart-loading" style="color:var(--red);">Failed to load chart</div>';
                    }
                }
            }
        }

        /**
         * Calculate predicted TWAP at market close based on:
         * - Current TWAP (partially locked in based on elapsed time)
         * - Market odds indicating expected direction for remaining time
         * - Time remaining until market close
         */
        function calculatePredictedTwap(currentTwap, startTwap, yesPrice, marketClose, marketStart) {
            // Safety check - if no valid TWAP data, return 0 (will skip drawing)
            if (!currentTwap || currentTwap <= 0) return 0;

            const now = Math.floor(Date.now() / 1000);
            const totalDuration = marketClose - marketStart;
            if (totalDuration <= 0) return currentTwap; // Invalid duration, use current

            const elapsed = Math.max(0, now - marketStart);
            const remaining = Math.max(0, totalDuration - elapsed);

            // If market closed or about to close, return current TWAP
            if (remaining < 60) return currentTwap;

            // TWAP formula: finalTwap = (accumulatedGweiSeconds) / totalDuration
            // accumulatedGweiSeconds = currentTwap * elapsed + futureAvg * remaining

            // What future average would result in finalTwap = startTwap (the threshold)?
            // startTwap * totalDuration = currentTwap * elapsed + neutralFuture * remaining
            // neutralFuture = (startTwap * totalDuration - currentTwap * elapsed) / remaining
            const neutralFutureAvg = (startTwap * totalDuration - currentTwap * elapsed) / remaining;

            // Market odds indicate how much above/below threshold we expect
            // yesPrice = 0.5  expect exactly startTwap (threshold)
            // yesPrice > 0.5  expect above startTwap
            // yesPrice < 0.5  expect below startTwap
            const rawDeviation = yesPrice - 0.5; // -0.5 to +0.5

            // Use power curve: small deviations (near 50%) have reduced effect,
            // larger deviations (toward extremes) have proportionally more effect
            // This reflects that 55% is slightly bullish but 80% is very bullish
            const sign = rawDeviation >= 0 ? 1 : -1;
            const magnitude = Math.abs(rawDeviation) * 2; // 0 to 1
            const scaledMagnitude = Math.pow(magnitude, 1.5); // Power curve reduces small values
            const oddsDeviation = sign * scaledMagnitude * 0.5; // Back to -0.5 to +0.5 range

            // Scale factor: how much to shift future avg per odds deviation
            const shiftFactor = 0.7;

            // Calculate expected future average
            // Use blend of neutral (threshold-hitting) and current TWAP, weighted by odds
            let expectedFutureAvg;
            if (neutralFutureAvg > 0) {
                // Shift from neutral based on odds direction
                expectedFutureAvg = neutralFutureAvg * (1 + oddsDeviation * shiftFactor * 2);
            } else {
                // If neutral would be negative (current already way above threshold),
                // use current TWAP with odds-based adjustment
                expectedFutureAvg = currentTwap * (1 + oddsDeviation * 0.3);
            }

            // Clamp to reasonable range (avoid negative or extreme values)
            // Use relative bounds based on current TWAP, not absolute values
            expectedFutureAvg = Math.max(currentTwap * 0.2, Math.min(expectedFutureAvg, currentTwap * 3));

            // Calculate predicted final TWAP
            const predicted = (currentTwap * elapsed + expectedFutureAvg * remaining) / totalDuration;

            return predicted;
        }

        /**
         * Update market predictions and the header stats
         */
        function updatePredictions() {
            const predictions = [];
            const now = Math.floor(Date.now() / 1000);

            // Helper to estimate market start time (close minus typical duration)
            const estimateStart = (close, type) => {
                if (type === 'weekly') return close - 604800;
                return close - 604800; // default to weekly
            };

            // Weekly market prediction
            if (markets.weekly && markets.weekly.yesPrice !== undefined) {
                const m = markets.weekly;
                const start = estimateStart(m.close, 'weekly');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.weekly.predictedTwap = predicted;
                predictions.push({ type: 'weekly', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Update prediction arrow for weekly
            const updateArrow = (elId, market, label) => {
                const el = document.getElementById(elId);
                if (!el) return;

                if (market && market.yesPrice !== undefined) {
                    const yesOdds = market.yesPrice;
                    const arrow = yesOdds > 0.5 ? '' : yesOdds < 0.5 ? '' : '';
                    const color = yesOdds > 0.5 ? 'var(--green)' : yesOdds < 0.5 ? 'var(--red)' : 'var(--text-muted)';
                    const pct = Math.round(Math.max(yesOdds, 1 - yesOdds) * 100);
                    const direction = yesOdds > 0.5 ? 'UP' : 'DOWN';
                    el.innerHTML = `${label}<span style="color:${color};font-weight:700;">${arrow}</span>`;
                    el.title = `${pct}% ${direction} (from ${market.startGwei?.toFixed(2) || '--'} gwei)`;
                } else {
                    el.innerHTML = `${label}<span style="color:var(--text-dim);">--</span>`;
                    el.title = 'No active market';
                }
            };

            updateArrow('pred1W', markets.weekly, '1W ');

            return predictions;
        }

        // ======================== MARKET RESOLUTION ========================
        async function resolveMarket(type) {
            const market = markets[type];
            if (!market || !market.id) {
                showToast('No Market', 'No market to resolve', 'error', 3000);
                return;
            }

            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);

                await monitorTransaction(
                    resolver.resolveMarket(market.id),
                    {
                        pending: { title: 'Resolving Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Resolving Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Resolved!', body: `${type.charAt(0).toUpperCase() + type.slice(1)} market has been resolved` },
                        error: { title: 'Resolution Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            await loadPositions();
                        }
                    }
                );
            } catch (e) {
                // monitorTransaction already shows toast for errors, so just log
                console.error('Resolve failed:', e);
            }
        }

        // ======================== MARKET CREATION ========================
        async function createWeekly() {
            if (!signer) return;

            const seed = parseFloat(document.getElementById('weeklySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close next Sunday midnight UTC
                const close = new Date();
                close.setUTCDate(close.getUTCDate() + (7 - close.getUTCDay()));
                close.setUTCHours(0, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000',
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        HOOK_FEE_OR_HOOK,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Weekly Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Weekly Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Weekly market seeded with ${seed} ETH (Hook-based)` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('weeklySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createExtreme() {
            if (!signer) return;

            const seed = parseFloat(document.getElementById('extremeSeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Fixed deadline: Dec 31, 2025 23:59:59 UTC
                const closeTs = 1767225599;
                const threshold = ethers.parseUnits('100', 'gwei'); // 100 gwei

                await monitorTransaction(
                    gasPm.createWindowPeakMarket(
                        threshold,
                        '0x0000000000000000000000000000000000000000',
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        HOOK_FEE_OR_HOOK,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating 100 Gwei Challenge', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating 100 Gwei Challenge', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: '100 Gwei Challenge (Hook-based) - Deadline: Dec 31, 2025' },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('extremeSeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
