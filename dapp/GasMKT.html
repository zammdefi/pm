<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GasMKT</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='60' font-family='system-ui,sans-serif' font-size='20' font-weight='600' fill='%2322c55e' text-anchor='middle'>GAS</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --amber: #f59e0b;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--green); }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.green { color: var(--green); }
        .live-stat-value.cyan { color: var(--blue); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--green);
            color: var(--bg);
            border-color: var(--green);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* CHART SECTION */
        .chart-section {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
        }

        .chart-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius);
            height: 220px;
            position: relative;
            overflow: hidden;
        }

        .chart-canvas { width: 100%; height: 100%; }

        .chart-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
        }

        .chart-tooltip.visible { opacity: 1; }
        .chart-tooltip-time {
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .chart-tooltip-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .chart-tooltip-row:last-child { margin-bottom: 0; }
        .chart-tooltip-dot { width: 6px; height: 6px; border-radius: 50%; }
        .chart-tooltip-dot.spot { background: var(--green); }
        .chart-tooltip-dot.twap { background: var(--blue); }
        .chart-tooltip-key { color: var(--text-muted); flex: 1; }
        .chart-tooltip-val { font-weight: 600; font-variant-numeric: tabular-nums; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 1100px) { .bets-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .bets-grid { grid-template-columns: 1fr; } }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--green);
        }

        .bet-card.no-market { opacity: 0.5; }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
        }

        .bet-type.hourly { color: var(--amber); }
        .bet-type.daily { color: var(--green); }
        .bet-type.weekly { color: var(--blue); }
        .bet-type.extreme { color: var(--red); }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        /* Gas Comparison Display */
        .gas-compare {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .gas-compare-point { text-align: center; }

        .gas-compare-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .gas-compare-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .gas-compare-arrow { font-size: 1.25rem; }
        .gas-compare-arrow.up { color: var(--green); }
        .gas-compare-arrow.down { color: var(--red); }

        /* Progress Bar */
        .progress-container { margin-bottom: 1rem; }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .progress-bar {
            height: 8px;
            background: var(--surface-2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--amber), var(--red));
            border-radius: 4px;
            transition: width 0.5s;
        }

        .target-display {
            font-size: var(--font-2xl);
            font-weight: 700;
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--red);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { background: var(--surface-2); }

        .bet-btn.up { border-color: var(--green); }
        .bet-btn.up:hover { background: var(--green-dim); }
        .bet-btn.down { border-color: var(--red); }
        .bet-btn.down:hover { background: var(--red-dim); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.up .bet-btn-label { color: var(--green); }
        .bet-btn.down .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* Position Display */
        .position-display {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            font-size: var(--font-xs);
        }

        .position-row { display: flex; justify-content: space-between; }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .create-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1.25rem;
        }

        @media (max-width: 1100px) { .create-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .create-grid { grid-template-columns: 1fr; } }

        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--green);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        /* Orderbook */
        .orderbook {
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            overflow: hidden;
        }
        .orderbook-body {
            max-height: 180px;
            overflow-y: auto;
        }
        .orderbook-side {
            display: flex;
            flex-direction: column;
        }
        .orderbook-side.asks {
            flex-direction: column-reverse;
            border-bottom: 1px solid var(--border);
        }
        .orderbook-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 0.375rem 0.75rem;
            font-size: var(--font-xs);
            font-variant-numeric: tabular-nums;
            cursor: pointer;
            transition: background 0.1s;
        }
        .orderbook-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 0.5rem 0.75rem;
            background: var(--surface-2);
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .orderbook-row:hover { background: var(--surface-2); }
        .orderbook-row.ask { color: var(--red); }
        .orderbook-row.bid { color: var(--green); }
        .orderbook-row .price { font-weight: 600; }
        .orderbook-row .size { color: var(--text-muted); }
        .orderbook-row .total { color: var(--text-dim); text-align: right; }
        .orderbook-empty {
            padding: 1rem;
            text-align: center;
            color: var(--text-dim);
            font-size: var(--font-xs);
        }
        .orderbook-spread {
            display: flex;
            justify-content: center;
            padding: 0.375rem;
            background: var(--surface);
            font-size: 10px;
            color: var(--text-dim);
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        .orderbook-row.better-deal { background: var(--green-dim); }
        .orderbook-row.better-deal:hover { background: rgba(34, 197, 94, 0.25); }
        .orderbook-row.better-deal .price { color: var(--blue); }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-up { background: var(--green); color: var(--bg); }
        .trade-submit.buy-down { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* STATUS */
        .status-message {
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
            border-radius: var(--radius);
            display: none;
        }

        .status-message.show { display: block; }
        .status-message.pending { background: rgba(59, 130, 246, 0.15); color: var(--blue); }
        .status-message.success { background: var(--green-dim); color: var(--green); }
        .status-message.error { background: var(--red-dim); color: var(--red); }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; }
            .header-center { gap: 1rem; }
            .chart-container { height: 180px; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .bet-card, .create-card { padding: 1rem; }
            .modal {
                margin: 0.5rem;
                padding: 1rem;
                max-width: calc(100vw - 1rem);
                max-height: calc(100vh - 1rem);
            }
            .orderbook-body { max-height: 140px; }
            .trade-submit, .create-btn { min-height: 44px; }
            .bet-btn { min-height: 56px; }
        }

        @media (max-width: 480px) {
            .header-center { display: none; }
            .section-title { font-size: var(--font-base); }
        }

        /* Stats summary responsive */
        .stats-summary { flex-wrap: wrap; }
        @media (max-width: 600px) {
            .stats-summary { gap: 0.75rem !important; }
            .stats-summary > div { flex: 1 1 40%; }
        }

        /* Touch-friendly interactions */
        @media (hover: none) {
            .bet-btn:active, .btn:active { transform: scale(0.98); }
            .orderbook-row:active { background: var(--surface-2); }
        }

        /* Modal mode toggle buttons */
        .mode-toggle {
            display: flex;
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            padding: 3px;
        }
        .mode-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            color: var(--text-muted);
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .mode-toggle-btn.active-buy {
            background: var(--green);
            color: var(--bg);
        }
        .mode-toggle-btn.active-sell {
            background: var(--red);
            color: var(--text);
        }
        .mode-toggle-btn.active-lp {
            background: var(--blue);
            color: var(--text);
        }
        .mode-toggle-btn.active-mint {
            background: var(--amber);
            color: var(--bg);
        }
        .mode-toggle-btn.active-limit {
            background: #8b5cf6;
            color: var(--text);
        }

        /* LP mode toggle */
        .lp-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .lp-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .lp-toggle-btn.active-add {
            background: var(--blue);
            color: var(--text);
            border-color: var(--blue);
        }
        .lp-toggle-btn.active-remove {
            background: var(--red);
            color: var(--text);
            border-color: var(--red);
        }
        .slip-btn {
            padding: 4px 8px;
            font-size: var(--font-xs);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.15s;
        }
        .slip-btn:hover {
            border-color: var(--blue);
            color: var(--text);
        }
        .slip-btn.slip-active {
            background: var(--blue);
            border-color: var(--blue);
            color: var(--text);
        }

        @media (max-width: 768px) {
            .mode-toggle-btn, .lp-toggle-btn { min-height: 40px; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">Gas<span>MKT</span></div>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">Live</div>
                <div class="live-stat-value green" id="liveGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">TWAP</div>
                <div class="live-stat-value cyan" id="twapGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Max</div>
                <div class="live-stat-value" id="maxGas">--</div>
            </div>
        </div>
        <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
    </header>

    <main class="main">
        <!-- Chart Section -->
        <section class="chart-section">
            <div class="chart-container">
                <canvas id="gasChart" class="chart-canvas"></canvas>
                <div class="chart-tooltip" id="chartTooltip">
                    <div class="chart-tooltip-time" id="tooltipTime">--</div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot spot"></span>
                        <span class="chart-tooltip-key">Spot</span>
                        <span class="chart-tooltip-val" id="tooltipSpot">--</span>
                    </div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot twap"></span>
                        <span class="chart-tooltip-key">TWAP</span>
                        <span class="chart-tooltip-val" id="tooltipTwap">--</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Bets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Bets</h2>
            <div class="stats-summary" style="display:flex;justify-content:center;gap:2rem;padding:0.875rem;margin-bottom:1rem;background:var(--surface);border-radius:var(--radius);">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Pool TVL</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--blue);" id="totalPoolTvl">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Orderbook</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="totalOrderbookLiq">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Markets</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeMarketsCount">0</div>
                </div>
            </div>
            <div class="bets-grid">
                <!-- Hourly Card -->
                <div class="bet-card" id="hourlyCard">
                    <div class="bet-header">
                        <span class="bet-type hourly">Hourly</span>
                    </div>
                    <div class="bet-title">This Hour's Gas</div>
                    <div class="bet-question">Will gas go up or down this hour?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="hourlyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="hourlyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Now</div>
                            <div class="gas-compare-value" id="hourlyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('hourly', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="hourlyUpOdds">--</div>
                            <div class="bet-btn-price" id="hourlyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('hourly', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="hourlyDownOdds">--</div>
                            <div class="bet-btn-price" id="hourlyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends top of hour UTC</span>
                        <span class="countdown-value" id="hourlyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>Pool: <span id="hourlyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="hourlyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="hourlyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="hourlyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="hourlyDownBal">0</span></div>
                    </div>
                </div>

                <!-- Daily Card -->
                <div class="bet-card" id="dailyCard">
                    <div class="bet-header">
                        <span class="bet-type daily">Daily</span>
                    </div>
                    <div class="bet-title">Today's Gas</div>
                    <div class="bet-question">Will gas go up or down today?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="dailyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="dailyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Now</div>
                            <div class="gas-compare-value" id="dailyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('daily', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="dailyUpOdds">--</div>
                            <div class="bet-btn-price" id="dailyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('daily', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="dailyDownOdds">--</div>
                            <div class="bet-btn-price" id="dailyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends midnight UTC</span>
                        <span class="countdown-value" id="dailyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>Pool: <span id="dailyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="dailyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="dailyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="dailyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="dailyDownBal">0</span></div>
                    </div>
                </div>

                <!-- Weekly Card -->
                <div class="bet-card" id="weeklyCard">
                    <div class="bet-header">
                        <span class="bet-type weekly">Weekly</span>
                    </div>
                    <div class="bet-title">This Week's Gas</div>
                    <div class="bet-question">Will gas go up or down this week?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="weeklyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="weeklyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Now</div>
                            <div class="gas-compare-value" id="weeklyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('weekly', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="weeklyUpOdds">--</div>
                            <div class="bet-btn-price" id="weeklyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('weekly', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="weeklyDownOdds">--</div>
                            <div class="bet-btn-price" id="weeklyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends Sunday UTC</span>
                        <span class="countdown-value" id="weeklyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>Pool: <span id="weeklyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="weeklyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="weeklyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="weeklyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="weeklyDownBal">0</span></div>
                    </div>
                </div>

                <!-- Extreme Card -->
                <div class="bet-card" id="extremeCard">
                    <div class="bet-header">
                        <span class="bet-type extreme">Extreme</span>
                    </div>
                    <div class="bet-title">100 Gwei Challenge</div>
                    <div class="bet-question">Will gas hit 100 gwei?</div>
                    <div class="target-display">100 gwei</div>
                    <div class="progress-container">
                        <div class="progress-labels">
                            <span>Max seen: <strong id="extremeMax">--</strong></span>
                            <span id="extremePercent">--%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="extremeProgress" style="width:0%"></div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('extreme', true)">
                            <div class="bet-btn-label">Yes</div>
                            <div class="bet-btn-odds" id="extremeYesOdds">--</div>
                            <div class="bet-btn-price" id="extremeYesPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('extreme', false)">
                            <div class="bet-btn-label">No</div>
                            <div class="bet-btn-odds" id="extremeNoOdds">--</div>
                            <div class="bet-btn-price" id="extremeNoPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Resolves early if touched!</span>
                        <span class="countdown-value" id="extremeCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>Pool: <span id="extremePoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="extremeOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="extremePosition" style="display:none;">
                        <div class="position-row"><span>Your YES</span><span id="extremeYesBal">0</span></div>
                        <div class="position-row"><span>Your NO</span><span id="extremeNoBal">0</span></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Create Section (Owner Only) -->
        <section class="create-section" id="createSection" style="display:none;">
            <h2 class="section-title">Create Markets</h2>
            <p style="color:var(--text-muted);font-size:var(--font-xs);margin-bottom:1rem;">
                Create new betting markets. Requires initial liquidity.
            </p>
            <div class="create-grid">
                <!-- Hourly -->
                <div class="create-card" id="createHourlyCard">
                    <div class="create-card-title">Hourly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this hour? Resolves at top of hour UTC.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="hourlySeed" value="0.01" step="0.001" min="0.001">
                    </div>
                    <button class="create-btn" onclick="createHourly()">Create Hourly</button>
                </div>

                <!-- Daily -->
                <div class="create-card" id="createDailyCard">
                    <div class="create-card-title">Daily Comparison</div>
                    <div class="create-card-desc">Will gas go up or down today? Resolves at midnight UTC.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="dailySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createDaily()">Create Daily</button>
                </div>

                <!-- Weekly -->
                <div class="create-card" id="createWeeklyCard">
                    <div class="create-card-title">Weekly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this week? Resolves Sunday midnight.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="weeklySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createWeekly()">Create Weekly</button>
                </div>

                <!-- Extreme -->
                <div class="create-card" id="createExtremeCard">
                    <div class="create-card-title">100 Gwei Challenge</div>
                    <div class="create-card-desc">Will gas hit 100 gwei before end of 2025? Resolves early if hit.</div>
                    <div class="create-input-group">
                        <label class="create-label">Deadline</label>
                        <div style="color:var(--green);font-weight:600;">Dec 31, 2025 23:59:59 UTC</div>
                    </div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="extremeSeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createExtreme()">Create Challenge</button>
                </div>
            </div>
            <p id="allMarketsActive" style="display:none;color:var(--green);text-align:center;margin-top:1.5rem;">
                âœ“ All market types are currently active
            </p>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>Hourly, Daily &amp; Weekly:</strong> Bet on whether the gas TWAP (time-weighted average) will be higher when the market closes compared to when it was created. UP wins if TWAP increased, DOWN wins if it stayed the same or decreased.<br><br>
                <strong>100 Gwei Challenge:</strong> Bet on whether gas will spike to 100 gwei before the deadline. If it touches 100 gwei at any point, YES wins and the market can resolve early. If the deadline passes without reaching 100 gwei, NO wins.<br><br>
                <strong>Trading:</strong> Prices reflect implied probability. If UP shows 30%, it costs ~0.30 ETH to win 1 ETH if UP wins. Losing shares pay nothing. Trade anytime or hold to resolution.
            </div>
        </section>
    </main>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="status-message" id="tradeStatus"></div>
            <!-- Buy/Sell/LP Toggle -->
            <div class="mode-toggle">
                <button id="buyModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('buy')">Buy</button>
                <button id="sellModeBtn" class="mode-toggle-btn" onclick="setTradeMode('sell')">Sell</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')">LP</button>
                <button id="mintModeBtn" class="mode-toggle-btn" onclick="setTradeMode('mint')">Mint</button>
            </div>
            <!-- Position Display -->
            <div id="tradePositionDisplay" style="background:var(--surface-2);padding:0.75rem;margin-bottom:1rem;font-size:var(--font-xs);border-radius:var(--radius);">
                <div style="color:var(--text-dim);margin-bottom:4px;">Your Position</div>
                <div style="display:flex;gap:1.5rem;">
                    <span style="color:var(--green);">YES: <span id="tradeModalYes">0</span></span>
                    <span style="color:var(--red);">NO: <span id="tradeModalNo">0</span></span>
                    <span style="color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                </div>
            </div>
            <!-- Orderbook -->
            <div class="orderbook" id="orderbookContainer">
                <div class="orderbook-header">
                    <span>Price</span>
                    <span>Size</span>
                    <span>Total</span>
                </div>
                <div class="orderbook-body">
                    <div class="orderbook-side asks" id="orderbookAsks">
                        <!-- Asks (sell orders) populate here -->
                    </div>
                    <div class="orderbook-spread" id="orderbookSpread">
                        Spread: --
                    </div>
                    <div class="orderbook-side bids" id="orderbookBids">
                        <!-- Bids (buy orders) populate here -->
                    </div>
                </div>
                <div class="orderbook-empty" id="orderbookEmpty" style="display:none;">
                    No limit orders yet
                </div>
            </div>
            <div class="trade-input-group">
                <div class="trade-label">
                    <span id="tradeInputLabel">Amount (ETH)</span>
                    <span>Balance: <span id="tradeBalance">--</span> <span id="tradeBalanceUnit">ETH</span></span>
                </div>
                <div style="display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                    <input type="number" class="trade-input" id="tradeAmount" placeholder="0.01" step="0.001" min="0" oninput="currentTradeMode === 'lp' ? updateLpPreview() : (currentTradeMode === 'mint' ? updateMintPreview() : updatePreview())" style="flex:1;background:transparent;border:none;border-radius:0;">
                    <button onclick="setMaxTrade()" style="padding:0.5rem 1rem;background:var(--surface-2);border:none;border-left:1px solid var(--border);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-xs);">MAX</button>
                </div>
            </div>
            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <!-- Slippage Settings -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button onclick="setSlippage(0.5)" id="slip05" class="slip-btn slip-active">0.5%</button>
                        <button onclick="setSlippage(1)" id="slip1" class="slip-btn">1%</button>
                        <button onclick="setSlippage(2)" id="slip2" class="slip-btn">2%</button>
                        <input type="number" id="slipCustom" placeholder="Custom" step="0.1" min="0.1" max="50" style="width:60px;padding:4px 6px;font-size:var(--font-xs);background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);" onchange="setSlippage(parseFloat(this.value))">
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Price per share</span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">Potential payout</span>
                        <span id="previewPayout">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="color:var(--blue);">AMM</span>
                    </div>
                    <div id="previewBreakdown" class="trade-preview-row" style="display:none;flex-direction:column;align-items:flex-start;gap:2px;padding-top:0.5rem;border-top:1px solid var(--border);margin-top:0.5rem;">
                        <span style="font-size:var(--font-xs);color:var(--text-dim);width:100%;">Execution breakdown:</span>
                        <div id="breakdownDetails" style="font-size:var(--font-xs);color:var(--text-muted);width:100%;"></div>
                    </div>
                    <div id="previewSavings" class="trade-preview-row" style="display:none;">
                        <span style="color:var(--text-dim);">vs pure AMM</span>
                        <span id="savingsAmount" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="tradeSubmit" onclick="executeTrade()">Buy</button>
            </div>
            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div class="lp-toggle">
                    <button id="addLpBtn" class="lp-toggle-btn active-add" onclick="setLpMode('add')">Deposit</button>
                    <button id="removeLpBtn" class="lp-toggle-btn" onclick="setLpMode('remove')">Withdraw</button>
                </div>
                <div id="lpExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.
                </div>
                <!-- Your Position Summary -->
                <div id="lpPositionSummary" style="background:var(--surface-2);padding:0.75rem;margin-bottom:0.75rem;border-radius:var(--radius);font-size:var(--font-xs);">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span id="lpPositionValue" style="color:var(--text);">-- ETH</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;">
                        <span style="color:var(--text-dim);">Pool Share</span>
                        <span id="lpCurrentShare" style="color:var(--text-muted);">--%</span>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>Pool TVL</span>
                        <span id="lpPoolReserves">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="lpPoolPrice">-- (--% YES)</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">You receive</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>New pool share</span>
                        <span id="lpPoolShare">--%</span>
                    </div>
                </div>
                <div id="lpWarning" style="display:none;font-size:var(--font-xs);color:var(--amber);padding:0.5rem;background:rgba(245,158,11,0.1);border-radius:var(--radius);margin-bottom:0.75rem;">
                </div>
                <button class="trade-submit" id="lpSubmit" style="background:var(--blue);" onclick="executeLp()">Deposit Liquidity</button>
            </div>
            <!-- Mint & List Section -->
            <div id="mintSection" style="display:none;">
                <div id="mintExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Mint YES + NO shares from ETH, keep one side and list the other at your price. Useful for low liquidity markets.
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="keepYesBtn" class="lp-toggle-btn active-add" onclick="setMintKeep(true)">Keep YES</button>
                    <button id="keepNoBtn" class="lp-toggle-btn" onclick="setMintKeep(false)">Keep NO</button>
                </div>
                <div style="margin-bottom:1rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Sell price (ETH per share)</label>
                    <input type="number" id="mintLimitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateMintPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You deposit</span>
                        <span id="mintDeposit">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="mintReceive">-- YES + -- NO</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You keep</span>
                        <span id="mintKeep">-- YES</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You list for sale</span>
                        <span id="mintList">-- NO @ -- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>If order fills</span>
                        <span id="mintProfit" style="color:var(--green);">Net cost: -- ETH</span>
                    </div>
                </div>
                <button class="trade-submit" id="mintSubmit" style="background:var(--amber);color:var(--bg);" onclick="executeMintAndList()">Mint & List</button>
            </div>
            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <div id="limitExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Place a limit order at your price. Order stays open until filled or market closes.
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="limitBuyBtn" class="lp-toggle-btn active-add" onclick="setLimitSide('buy')">Buy Order</button>
                    <button id="limitSellBtn" class="lp-toggle-btn" onclick="setLimitSide('sell')">Sell Order</button>
                </div>
                <div style="margin-bottom:0.75rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Limit Price (ETH per share)</label>
                    <input type="number" id="limitPrice" placeholder="0.50" step="0.01" min="0.01" max="0.99"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateLimitPreview()">
                </div>
                <div style="margin-bottom:0.75rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Shares</label>
                    <input type="number" id="limitShares" placeholder="1.0" step="0.1" min="0.01"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateLimitPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitCostLabel">You escrow</span>
                        <span id="limitCost">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>If filled, you get</span>
                        <span id="limitReceive">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>vs AMM price</span>
                        <span id="limitVsAmm">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Expires</span>
                        <span id="limitExpires">Market close</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" style="background:#8b5cf6;" onclick="executeLimitOrder()">Place Buy Order</button>
            </div>
            <!-- Your Orders Section -->
            <div id="yourOrdersSection" style="margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border);display:none;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);font-weight:600;">YOUR OPEN ORDERS</span>
                    <button onclick="refreshUserOrders()" style="font-size:var(--font-xs);padding:2px 8px;background:transparent;border:1px solid var(--border);border-radius:var(--radius);color:var(--text-muted);cursor:pointer;">â†»</button>
                </div>
                <div id="yourOrdersList" style="font-size:var(--font-xs);">
                    <!-- Orders populate here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const GASPM_ADDRESS = '0x0000000000ee3d4294438093EaA34308f47Bc0b4';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const PMROUTER_ADDRESS = '0x0000000000000000000000000000000000000000'; // TODO
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        const FEE_TIER = 30n; // 30 bps = 0.30% fee

        // Public RPC fallbacks
        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc);
                    await p.getBlockNumber(); // test connection
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const GASPM_ABI = [
            'function baseFeeAverage() public view returns (uint256)',
            'function baseFeeMax() public view returns (uint256)',
            'function baseFeeMin() public view returns (uint256)',
            'function startTime() public view returns (uint64)',
            'function baseFeeMaxSince(uint256 marketId) public view returns (uint256)',
            'function comparisonStartValue(uint256 marketId) public view returns (uint256)',
            'function marketCount() public view returns (uint256)',
            'function getMarkets(uint256 start, uint256 count) public view returns (uint256[])',
            'function getMarketInfos(uint256 start, uint256 count) public view returns (tuple(uint256 marketId, uint64 close, bool resolved, bool outcome, uint256 currentValue, bool conditionMet, bool ready)[])',
            'function observationCount() public view returns (uint256)',
            'function getObservations(uint256 start, uint256 count) public view returns (tuple(uint64 timestamp, uint64 baseFee, uint128 cumulativeBaseFee)[])',
            'function createComparisonMarket(address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function createWindowPeakMarket(uint256 threshold, address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function owner() public view returns (address)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) public view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) public view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function poolKey(uint256 marketId, uint256 feeOrHook) public view returns (tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook))',
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function getNoId(uint256 marketId) public pure returns (uint256)',
            'function claim(uint256 marketId, address to) public returns (uint256 shares, uint256 payout)',
            'function claimMany(uint256[] marketIds, address to) public returns (uint256 totalPayout)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) public payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) public returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)'
        ];

        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const ZAMM_ABI = [
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)'
        ];

        const PMROUTER_ABI = [
            'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
            'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)',
            'function claim(uint256 marketId, address to) returns (uint256 payout)',
            'function getOrderbook(uint256 marketId, bool isYes, uint256 depth) view returns (bytes32[] bidHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] bidOrders, bytes32[] askHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] askOrders)',
            'function fillOrder(bytes32 orderHash, uint96 sharesToFill, address to) payable returns (uint96 sharesFilled, uint96 collateralFilled)',
            'function fillOrdersThenSwap(uint256 marketId, bool isYes, bool isBuy, uint256 totalAmount, uint256 minOutput, bytes32[] orderHashes, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256 totalOutput)',
            'function split(uint256 marketId, uint256 amount, address to) payable',
            'function placeOrder(uint256 marketId, bool isYes, bool isBuy, uint96 shares, uint96 collateral, uint56 deadline, bool partialFill) payable returns (bytes32)',
            'function multicall(bytes[] data) payable returns (bytes[])',
            'function cancelOrder(bytes32 orderHash)',
            'function getUserOrderCount(address user) view returns (uint256)',
            'function getUserOrderHashes(address user, uint256 offset, uint256 limit) view returns (bytes32[])',
            'function orders(bytes32 orderHash) view returns (address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let isOwner = false;

        let markets = { hourly: null, daily: null, weekly: null, extreme: null };
        let currentTrade = { type: null, isYes: true, marketId: null };
        let currentTradeMode = 'buy'; // 'buy' or 'sell'
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
        let slippageTolerance = 0.5; // 0.5% default slippage tolerance

        // Chart data (like GasPM.html)
        let chartDataPoints = [];   // Historical baseFee in gwei
        let chartTimestamps = [];   // Timestamps for each observation
        let chartCumulatives = [];  // Cumulative base fee for rolling TWAP
        let chartState = {};
        let cachedGasData = { twap: 0, current: 0, startTime: 0 };
        let lastLoadedObsCount = 0; // Track for incremental loading

        // ======================== INIT ========================
        async function init() {
            await loadData();
            updateCountdowns();
            setInterval(updateCountdowns, 1000);
            setInterval(loadData, 60000);
            setupChart();
            startPulseAnimation();
        }

        function startPulseAnimation() {
            // Only animate pulse for small datasets; skip for large ones (too expensive)
            setInterval(() => {
                if (chartDataPoints.length > 0 && chartDataPoints.length <= 200 && cachedGasData.current && hoverIndex < 0) {
                    drawChart(cachedGasData);
                }
            }, 66);
        }

        // ======================== WALLET ========================
        async function connectWallet() {
            if (connectedAddress) {
                provider = null; signer = null; connectedAddress = null; isOwner = false;
                document.getElementById('connectBtn').textContent = 'Connect';
                document.getElementById('connectBtn').classList.remove('connected');
                document.getElementById('createSection').style.display = 'none';
                hidePositions();
                return;
            }

            if (!window.ethereum) { alert('Please install MetaMask'); return; }

            try {
                provider = new ethers.BrowserProvider(window.ethereum);
                const accounts = await provider.send('eth_requestAccounts', []);
                signer = await provider.getSigner();
                connectedAddress = accounts[0];

                document.getElementById('connectBtn').textContent = connectedAddress.slice(0,6) + '...' + connectedAddress.slice(-4);
                document.getElementById('connectBtn').classList.add('connected');

                // Listen for account/chain changes
                window.ethereum.on('accountsChanged', () => window.location.reload());
                window.ethereum.on('chainChanged', () => window.location.reload());

                // Check if owner
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, provider);
                const owner = await gasPm.owner();
                isOwner = owner.toLowerCase() === connectedAddress.toLowerCase();
                if (isOwner) document.getElementById('createSection').style.display = 'block';

                await loadPositions();
            } catch (e) {
                console.error('Connection failed:', e);
            }
        }

        // Check if error is a user rejection (wallet popup cancelled)
        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== DATA LOADING ========================
        const MAX_MARKETS = 1000;

        async function loadData() {
            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const gasPmInterface = new ethers.Interface(GASPM_ABI);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Batch gas data + market infos with block fetch (like GasPM.html)
                const [results, block] = await Promise.all([
                    multicall.aggregate3([
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeAverage') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMax') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMin') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('startTime') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('observationCount') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('getMarketInfos', [0, MAX_MARKETS]) }
                    ]),
                    rpc.getBlock('latest')
                ]);

                // Live gas from block (baseFeePerGas is in wei)
                const liveWei = block.baseFeePerGas || 0n;
                const liveGwei = Number(liveWei) / 1e9;
                document.getElementById('liveGas').textContent = formatGwei(liveWei) + ' gwei';

                // Decode oracle data (returns wei, convert to gwei)
                let twapWei = 0n, maxWei = 0n, minWei = 0n, startTime = 0, obsCount = 0;

                if (results[0].success) {
                    twapWei = gasPmInterface.decodeFunctionResult('baseFeeAverage', results[0].returnData)[0];
                } else {
                    console.warn('baseFeeAverage call failed');
                }

                if (results[1].success) {
                    maxWei = gasPmInterface.decodeFunctionResult('baseFeeMax', results[1].returnData)[0];
                } else {
                    console.warn('baseFeeMax call failed');
                }

                if (results[2].success) {
                    minWei = gasPmInterface.decodeFunctionResult('baseFeeMin', results[2].returnData)[0];
                } else {
                    console.warn('baseFeeMin call failed');
                }

                if (results[3].success) {
                    startTime = Number(gasPmInterface.decodeFunctionResult('startTime', results[3].returnData)[0]);
                } else {
                    console.warn('startTime call failed');
                }

                if (results[4].success) {
                    obsCount = Number(gasPmInterface.decodeFunctionResult('observationCount', results[4].returnData)[0]);
                } else {
                    console.warn('observationCount call failed');
                }

                const twapGwei = Number(twapWei) / 1e9;
                const maxGwei = Number(maxWei) / 1e9;

                console.log('Gas data:', { liveWei: liveWei.toString(), twapWei: twapWei.toString(), maxWei: maxWei.toString(), obsCount });

                document.getElementById('twapGas').textContent = formatGwei(twapWei) + ' gwei';
                document.getElementById('maxGas').textContent = formatGwei(maxWei) + ' gwei';

                // Update extreme progress
                document.getElementById('extremeMax').textContent = formatGwei(maxWei) + ' gwei';
                const pct = Math.min(100, (maxGwei / 100) * 100);
                document.getElementById('extremeProgress').style.width = pct + '%';
                document.getElementById('extremePercent').textContent = pct.toFixed(0) + '%';

                // Update current values (show TWAP)
                document.getElementById('hourlyNow').textContent = formatGwei(twapWei);
                document.getElementById('dailyNow').textContent = formatGwei(twapWei);
                document.getElementById('weeklyNow').textContent = formatGwei(twapWei);

                // Cache gas data for chart
                cachedGasData = { twap: twapGwei, current: liveGwei, startTime };

                // Fetch observations for chart (incremental loading for efficiency)
                if (obsCount > 0) {
                    const batchSize = 500;
                    let fetchStart = 0;
                    let newObservations = [];

                    if (lastLoadedObsCount === 0) {
                        // First load: only fetch last 500 observations (don't need ancient history)
                        fetchStart = Math.max(0, obsCount - batchSize);
                        console.log(`Initial load: fetching observations ${fetchStart} to ${obsCount}`);
                    } else if (obsCount > lastLoadedObsCount) {
                        // Incremental load: only fetch new observations
                        fetchStart = lastLoadedObsCount;
                        console.log(`Incremental load: fetching ${obsCount - lastLoadedObsCount} new observations`);
                    } else {
                        // No new observations, skip fetch
                        fetchStart = obsCount; // Will skip the loop
                    }

                    if (fetchStart < obsCount) {
                        const obsCalls = [];
                        for (let start = fetchStart; start < obsCount; start += batchSize) {
                            obsCalls.push({
                                target: GASPM_ADDRESS,
                                allowFailure: true,
                                callData: gasPmInterface.encodeFunctionData('getObservations', [start, Math.min(batchSize, obsCount - start)])
                            });
                        }
                        const obsResults = await multicall.aggregate3(obsCalls);
                        for (const res of obsResults) {
                            if (res.success) {
                                const batch = gasPmInterface.decodeFunctionResult('getObservations', res.returnData)[0];
                                newObservations.push(...batch);
                            }
                        }

                        // Append new observations to existing arrays (or replace on first load)
                        const newPoints = newObservations.map(o => Number(o.baseFee) / 1e9);
                        const newTimestamps = newObservations.map(o => Number(o.timestamp));
                        const newCumulatives = newObservations.map(o => Number(o.cumulativeBaseFee));

                        if (lastLoadedObsCount === 0) {
                            // First load - replace
                            chartDataPoints = newPoints;
                            chartTimestamps = newTimestamps;
                            chartCumulatives = newCumulatives;
                        } else {
                            // Incremental - append
                            chartDataPoints.push(...newPoints);
                            chartTimestamps.push(...newTimestamps);
                            chartCumulatives.push(...newCumulatives);
                        }
                        lastLoadedObsCount = obsCount;
                        console.log(`Chart now has ${chartDataPoints.length} observations`);
                    }
                }

                // Draw chart with actual on-chain data
                drawChart(cachedGasData);

                // Decode market infos
                let marketInfos = [];
                if (results[5].success) {
                    try {
                        marketInfos = gasPmInterface.decodeFunctionResult('getMarketInfos', results[5].returnData)[0];
                    } catch (e) {
                        console.warn('No markets or failed to decode:', e);
                    }
                }

                // Load markets using marketInfos
                await loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei);

            } catch (e) {
                console.error('Load failed:', e);
            }
        }

        async function loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei) {
            // Reset markets on each load to handle expiry
            markets = { hourly: null, daily: null, weekly: null, extreme: null };

            try {
                if (marketInfos.length === 0) return;

                const now = Math.floor(Date.now() / 1000);

                // Batch all PAMM.getMarket calls for descriptions
                const marketCalls = marketInfos.map(info => ({
                    target: PAMM_ADDRESS,
                    allowFailure: true,
                    callData: pammInterface.encodeFunctionData('getMarket', [info.marketId])
                }));
                const marketResults = await multicall.aggregate3(marketCalls);

                // Find ACTIVE comparison markets and batch their startValue calls
                // Important: Only collect IDs for markets we'll actually use (not resolved/expired)
                const comparisonIds = [];
                const comparisonMarketIndices = []; // Maps back to marketInfos index
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    const resolved = info.resolved;
                    const close = Number(info.close);
                    // Skip resolved or expired markets
                    if (resolved || close <= now) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const desc = data.description || data[10];
                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        comparisonIds.push(info.marketId);
                        comparisonMarketIndices.push(i);
                    }
                }

                // Batch comparisonStartValue calls for active markets only
                let startValuesMap = new Map(); // marketId -> startValue
                if (comparisonIds.length > 0) {
                    const startCalls = comparisonIds.map(id => ({
                        target: GASPM_ADDRESS,
                        allowFailure: true,
                        callData: gasPmInterface.encodeFunctionData('comparisonStartValue', [id])
                    }));
                    const startResults = await multicall.aggregate3(startCalls);
                    for (let i = 0; i < comparisonIds.length; i++) {
                        const val = startResults[i].success ? gasPmInterface.decodeFunctionResult('comparisonStartValue', startResults[i].returnData)[0] : 0n;
                        startValuesMap.set(comparisonIds[i].toString(), val);
                    }
                }

                // Process markets
                for (let i = 0; i < marketInfos.length; i++) {
                    const info = marketInfos[i];
                    if (!marketResults[i].success) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const resolved = info.resolved;
                    const close = Number(info.close);
                    const desc = data.description || data[10];

                    if (resolved || close <= now) continue;

                    const yesSupply = data.yesSupply || data[8];
                    const noSupply = data.noSupply || data[9];
                    const total = Number(yesSupply) + Number(noSupply);
                    if (total === 0) continue;

                    const yesPrice = Number(noSupply) / total;
                    const noPrice = Number(yesSupply) / total;

                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        const startValue = startValuesMap.get(info.marketId.toString()) || 0n;
                        const startGwei = Number(startValue) / 1e9;
                        const timeToClose = close - now;

                        if (timeToClose <= 3600 && !markets.hourly) {
                            markets.hourly = { id: info.marketId, close, startGwei, yesPrice, noPrice };
                            updateCard('hourly', startGwei, twapGwei, yesPrice, noPrice);
                        } else if (timeToClose <= 86400 && !markets.daily) {
                            markets.daily = { id: info.marketId, close, startGwei, yesPrice, noPrice };
                            updateCard('daily', startGwei, twapGwei, yesPrice, noPrice);
                        } else if (timeToClose <= 604800 && !markets.weekly) {
                            markets.weekly = { id: info.marketId, close, startGwei, yesPrice, noPrice };
                            updateCard('weekly', startGwei, twapGwei, yesPrice, noPrice);
                        }
                    } else if (desc.includes('spikes to') || desc.includes('Gas spikes')) {
                        if (!markets.extreme) {
                            markets.extreme = { id: info.marketId, close, yesPrice, noPrice };
                            document.getElementById('extremeYesOdds').textContent = (yesPrice * 100).toFixed(0) + '%';
                            document.getElementById('extremeNoOdds').textContent = (noPrice * 100).toFixed(0) + '%';
                            document.getElementById('extremeYesPrice').textContent = yesPrice.toFixed(3) + ' ETH';
                            document.getElementById('extremeNoPrice').textContent = noPrice.toFixed(3) + ' ETH';
                        }
                    }
                }

                // Update create cards visibility
                updateCreateCardsVisibility();
                // Load liquidity stats after markets are loaded
                loadLiquidityStats();
            } catch (e) {
                console.error('Load markets failed:', e);
            }
        }

        async function loadLiquidityStats() {
            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                let totalPoolTvl = 0;
                let totalOrderbookLiq = 0;
                let activeCount = 0;

                // Load stats for each active market
                const marketTypes = ['hourly', 'daily', 'weekly', 'extreme'];
                for (const type of marketTypes) {
                    const market = markets[type];
                    if (!market || !market.id) continue;

                    activeCount++;

                    try {
                        // Get pool state for TVL
                        const [rYes, rNo] = await pamm.getPoolState(market.id, FEE_TIER);
                        // Pool TVL â‰ˆ collateral in pool. For balanced pool, ~= (rYes + rNo) / 2
                        const poolTvl = Number(rYes + rNo) / 1e18 / 2;
                        totalPoolTvl += poolTvl;

                        // Update individual card
                        const poolEl = document.getElementById(`${type}PoolTvl`);
                        if (poolEl) poolEl.textContent = poolTvl.toFixed(2) + ' ETH';

                        // Get orderbook depth
                        try {
                            const [bidHashes, bidOrders, askHashes, askOrders] = await pmRouter.getOrderbook(market.id, true, 20);
                            const orderCount = bidHashes.length + askHashes.length;

                            // Sum orderbook liquidity (collateral in orders)
                            let orderbookLiq = 0;
                            for (const o of bidOrders) orderbookLiq += Number(o.collateral) / 1e18;
                            for (const o of askOrders) orderbookLiq += Number(o.collateral) / 1e18;
                            totalOrderbookLiq += orderbookLiq;

                            const orderbookEl = document.getElementById(`${type}Orderbook`);
                            if (orderbookEl) {
                                if (orderCount > 0) {
                                    orderbookEl.textContent = orderbookLiq.toFixed(2) + ' ETH';
                                } else {
                                    orderbookEl.textContent = 'none';
                                }
                            }
                        } catch (e) {
                            // PMRouter may not be deployed yet
                            const orderbookEl = document.getElementById(`${type}Orderbook`);
                            if (orderbookEl) orderbookEl.textContent = '--';
                        }

                    } catch (e) {
                        console.warn(`Failed to load liquidity for ${type}:`, e);
                    }
                }

                // Update global stats
                document.getElementById('totalPoolTvl').textContent = totalPoolTvl.toFixed(2) + ' ETH';
                document.getElementById('totalOrderbookLiq').textContent = totalOrderbookLiq > 0 ? totalOrderbookLiq.toFixed(2) + ' ETH' : '--';
                document.getElementById('activeMarketsCount').textContent = activeCount.toString();

            } catch (e) {
                console.error('Failed to load liquidity stats:', e);
            }
        }

        // Hide create cards for market types that already have active markets
        function updateCreateCardsVisibility() {
            const cards = {
                hourly: document.getElementById('createHourlyCard'),
                daily: document.getElementById('createDailyCard'),
                weekly: document.getElementById('createWeeklyCard'),
                extreme: document.getElementById('createExtremeCard')
            };

            let allActive = true;
            for (const [type, card] of Object.entries(cards)) {
                if (card) {
                    if (markets[type]) {
                        card.style.display = 'none';
                    } else {
                        card.style.display = '';
                        allActive = false;
                    }
                }
            }

            // Show message if all markets are active
            const allActiveMsg = document.getElementById('allMarketsActive');
            if (allActiveMsg) {
                allActiveMsg.style.display = allActive ? 'block' : 'none';
            }
        }

        function updateCard(type, startGwei, nowGwei, yesPrice, noPrice) {
            document.getElementById(`${type}Start`).textContent = startGwei.toFixed(1);
            document.getElementById(`${type}Now`).textContent = nowGwei.toFixed(1);

            const arrow = document.getElementById(`${type}Arrow`);
            if (nowGwei > startGwei) {
                arrow.textContent = 'â–²';
                arrow.className = 'gas-compare-arrow up';
            } else if (nowGwei < startGwei) {
                arrow.textContent = 'â–¼';
                arrow.className = 'gas-compare-arrow down';
            } else {
                arrow.textContent = '=';
                arrow.className = 'gas-compare-arrow';
            }

            document.getElementById(`${type}UpOdds`).textContent = (yesPrice * 100).toFixed(0) + '%';
            document.getElementById(`${type}DownOdds`).textContent = (noPrice * 100).toFixed(0) + '%';
            document.getElementById(`${type}UpPrice`).textContent = yesPrice.toFixed(3) + ' ETH';
            document.getElementById(`${type}DownPrice`).textContent = noPrice.toFixed(3) + ' ETH';
        }

        async function loadPositions() {
            if (!connectedAddress) return;

            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                const marketList = [];
                const types = [];
                if (markets.hourly) { marketList.push(markets.hourly); types.push('hourly'); }
                if (markets.daily) { marketList.push(markets.daily); types.push('daily'); }
                if (markets.weekly) { marketList.push(markets.weekly); types.push('weekly'); }
                if (markets.extreme) { marketList.push(markets.extreme); types.push('extreme'); }

                if (marketList.length === 0) return;

                // Build multicall for YES and NO balances
                const calls = [];
                for (const m of marketList) {
                    // YES balance (marketId is the YES token id)
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                    });
                    // NO balance (need to compute noId = keccak256(abi.encodePacked("PMARKET:NO", marketId)))
                    const noId = ethers.solidityPackedKeccak256(
                        ['string', 'uint256'],
                        ['PMARKET:NO', m.id]
                    );
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                    });
                }

                const results = await multicall.aggregate3(calls);

                for (let i = 0; i < types.length; i++) {
                    const t = types[i];
                    const yesResult = results[i * 2];
                    const noResult = results[i * 2 + 1];

                    const yes = yesResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', yesResult.returnData)[0]) / 1e18 : 0;
                    const no = noResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', noResult.returnData)[0]) / 1e18 : 0;

                    if (yes > 0 || no > 0) {
                        document.getElementById(`${t}Position`).style.display = 'block';
                        document.getElementById(`${t}${t === 'extreme' ? 'Yes' : 'Up'}Bal`).textContent = yes.toFixed(4);
                        document.getElementById(`${t}${t === 'extreme' ? 'No' : 'Down'}Bal`).textContent = no.toFixed(4);
                    } else {
                        document.getElementById(`${t}Position`).style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Load positions failed:', e);
            }
        }

        function hidePositions() {
            ['hourly', 'daily', 'weekly', 'extreme'].forEach(t => {
                document.getElementById(`${t}Position`).style.display = 'none';
            });
        }

        // ======================== CHART ========================
        let hoverIndex = -1; // Track hovered data point for crosshair

        function setupChart() {
            const canvas = document.getElementById('gasChart');
            const tooltip = document.getElementById('chartTooltip');

            canvas.addEventListener('mousemove', (e) => {
                if (!chartState.data || !chartState.data.length) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const { data, rollingTwap, padding, width, height } = chartState;

                const idx = Math.round((x - padding) / (width - padding * 2) * (data.length - 1));
                const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                // Update hover index and redraw for crosshair
                if (hoverIndex !== clampedIdx) {
                    hoverIndex = clampedIdx;
                    drawChart(cachedGasData);
                }

                if (clampedIdx >= 0 && clampedIdx < data.length) {
                    const spotVal = data[clampedIdx];
                    const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                    // Update tooltip content
                    document.getElementById('tooltipSpot').textContent = spotVal.toFixed(2) + ' gwei';
                    document.getElementById('tooltipTwap').textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                    // Time display
                    let timeText = '';
                    if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                        const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                        timeText = date.toLocaleString();
                    } else if (clampedIdx === data.length - 1) {
                        timeText = 'Now';
                    }
                    document.getElementById('tooltipTime').textContent = timeText;

                    // Position tooltip with edge clamping
                    const tooltipWidth = 160;
                    const tooltipHeight = 80;
                    let tooltipX = e.clientX - rect.left + 15;
                    let tooltipY = e.clientY - rect.top - 10;

                    // Clamp to right edge
                    if (tooltipX + tooltipWidth > width) {
                        tooltipX = e.clientX - rect.left - tooltipWidth - 15;
                    }
                    // Clamp to bottom edge
                    if (tooltipY + tooltipHeight > height) {
                        tooltipY = height - tooltipHeight - 10;
                    }
                    // Clamp to top edge
                    if (tooltipY < 10) {
                        tooltipY = 10;
                    }

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.classList.add('visible');
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
                hoverIndex = -1;
                drawChart(cachedGasData); // Clear crosshair
            });

            window.addEventListener('resize', () => { if (chartDataPoints.length) drawChart(cachedGasData); });
        }

        function drawChart(gasData) {
            const { twap, current, startTime } = gasData;

            const canvas = document.getElementById('gasChart');
            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;

            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;

            // Clear
            ctx.fillStyle = '#18181b';
            ctx.fillRect(0, 0, width, height);

            // Use actual data points, or just current if no history
            let data = chartDataPoints.length > 0 ? [...chartDataPoints] : [current];
            let timestamps = chartTimestamps.length > 0 ? [...chartTimestamps] : [];
            let cumulatives = chartCumulatives.length > 0 ? [...chartCumulatives] : [];

            // Ensure current is last point
            if (data.length === 0 || data[data.length - 1] !== current) {
                data.push(current);
                timestamps.push(Math.floor(Date.now() / 1000));
            }

            // Downsample for large datasets (keep max ~300 points for smooth rendering)
            const maxDisplayPoints = 300;
            let downsampleFactor = 1;
            if (data.length > maxDisplayPoints) {
                downsampleFactor = Math.ceil(data.length / maxDisplayPoints);
                const sampledData = [];
                const sampledTimestamps = [];
                const sampledCumulatives = [];
                for (let i = 0; i < data.length; i += downsampleFactor) {
                    sampledData.push(data[i]);
                    if (timestamps[i] !== undefined) sampledTimestamps.push(timestamps[i]);
                    if (cumulatives[i] !== undefined) sampledCumulatives.push(cumulatives[i]);
                }
                // Always include the last point
                if (sampledData[sampledData.length - 1] !== data[data.length - 1]) {
                    sampledData.push(data[data.length - 1]);
                    if (timestamps.length > 0) sampledTimestamps.push(timestamps[timestamps.length - 1]);
                    if (cumulatives.length > 0) sampledCumulatives.push(cumulatives[cumulatives.length - 1]);
                }
                data = sampledData;
                timestamps = sampledTimestamps;
                cumulatives = sampledCumulatives;
            }

            // Compute rolling TWAP from cumulative observations
            let rollingTwap = [];
            if (cumulatives.length >= 2 && startTime) {
                for (let i = 0; i < cumulatives.length; i++) {
                    const elapsed = timestamps[i] - startTime;
                    if (elapsed > 0) {
                        rollingTwap.push(cumulatives[i] / elapsed / 1e9);
                    } else {
                        rollingTwap.push(data[i]);
                    }
                }
            }
            // Add current TWAP as final point if needed
            if (rollingTwap.length > 0 && rollingTwap.length < data.length) {
                rollingTwap.push(twap);
            }

            // Calculate Y range (include rolling TWAP in range calculation)
            const allValues = [...data, twap];
            if (rollingTwap.length > 0) allValues.push(...rollingTwap);
            let max = Math.max(...allValues) * 1.1;
            let min = Math.min(...allValues) * 0.9;

            const range = max - min;
            const gweiToY = (gwei) => padding + (height - padding * 2) * (1 - (gwei - min) / range);

            // Determine decimal places based on range
            const getDecimals = (r) => {
                if (r >= 10) return 0;
                if (r >= 1) return 1;
                if (r >= 0.1) return 2;
                if (r >= 0.01) return 3;
                return 4;
            };
            const decimals = getDecimals(range);

            // Draw grid
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (height - padding * 2) * i / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = '10px Helvetica';
                ctx.textAlign = 'right';
                ctx.fillText((max - range * i / 4).toFixed(decimals), padding - 5, y + 4);
            }

            // Draw time axis labels (X-axis)
            if (timestamps.length > 1) {
                const firstTime = timestamps[0];
                const lastTime = timestamps[timestamps.length - 1];
                const timeSpan = lastTime - firstTime;

                // Determine time format based on span
                const formatTime = (ts) => {
                    const d = new Date(ts * 1000);
                    if (timeSpan < 86400) { // < 1 day: show hours
                        return d.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                    } else if (timeSpan < 604800) { // < 1 week: show day + hour
                        return d.toLocaleDateString(undefined, { weekday: 'short', hour: '2-digit' });
                    } else { // >= 1 week: show date
                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    }
                };

                // Draw 3-5 time labels evenly spaced
                const numLabels = Math.min(5, data.length);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = '9px Helvetica';
                ctx.textAlign = 'center';
                for (let i = 0; i < numLabels; i++) {
                    const idx = Math.floor(i * (timestamps.length - 1) / (numLabels - 1));
                    const x = padding + (width - padding * 2) * idx / Math.max(1, data.length - 1);
                    const label = formatTime(timestamps[idx]);
                    ctx.fillText(label, x, height - padding + 28);
                }
            }

            // Draw rolling TWAP line (cyan, behind spot line)
            if (rollingTwap.length > 1) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                for (let i = 0; i < rollingTwap.length; i++) {
                    const x = padding + (width - padding * 2) * i / Math.max(1, data.length - 1);
                    const y = gweiToY(rollingTwap[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw current TWAP reference (final value as horizontal dashed line)
            const twapY = gweiToY(twap);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, twapY);
            ctx.lineTo(width - padding, twapY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#3b82f6';
            ctx.font = '10px Helvetica';
            ctx.textAlign = 'left';
            ctx.fillText('TWAP ' + twap.toFixed(decimals), width - padding + 5, twapY + 4);

            // Draw line chart connecting data points (spot prices)
            if (data.length > 0) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + (width - padding * 2) * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw gradient fill under spot line
                const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
                gradient.addColorStop(0, 'rgba(34, 197, 94, 0.15)');
                gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                for (let i = 0; i < data.length; i++) {
                    const x = padding + (width - padding * 2) * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(width - padding, height - padding);
                ctx.closePath();
                ctx.fill();

                // Find min/max values and indices
                let minVal = Infinity, maxVal = -Infinity, minIdx = 0, maxIdx = 0;
                for (let i = 0; i < data.length; i++) {
                    if (data[i] < minVal) { minVal = data[i]; minIdx = i; }
                    if (data[i] > maxVal) { maxVal = data[i]; maxIdx = i; }
                }

                // Draw data points (skip for large datasets - line is enough)
                if (data.length <= 100) {
                    const pointSize = data.length > 50 ? 2 : (data.length > 20 ? 3 : 4);
                    ctx.fillStyle = '#22c55e';
                    for (let i = 0; i < data.length; i++) {
                        const x = padding + (width - padding * 2) * i / Math.max(1, data.length - 1);
                        const y = gweiToY(data[i]);
                        ctx.beginPath();
                        ctx.arc(x, y, i === data.length - 1 ? 6 : pointSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw min/max markers (subtle, just small indicators)
                if (data.length > 3) {
                    // Max marker - small diamond
                    const maxX = padding + (width - padding * 2) * maxIdx / Math.max(1, data.length - 1);
                    const maxY = gweiToY(maxVal);
                    if (maxIdx !== data.length - 1) { // Don't mark if it's the current point
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(maxX, maxY - 6);
                        ctx.lineTo(maxX + 4, maxY);
                        ctx.lineTo(maxX, maxY + 6);
                        ctx.lineTo(maxX - 4, maxY);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Min marker - small diamond (only if significantly different position)
                    if (Math.abs(minIdx - maxIdx) > 2 && minIdx !== data.length - 1) {
                        const minX = padding + (width - padding * 2) * minIdx / Math.max(1, data.length - 1);
                        const minY = gweiToY(minVal);
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(minX, minY - 5);
                        ctx.lineTo(minX + 3, minY);
                        ctx.lineTo(minX, minY + 5);
                        ctx.lineTo(minX - 3, minY);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw crosshair on hover
                if (hoverIndex >= 0 && hoverIndex < data.length) {
                    const hoverX = padding + (width - padding * 2) * hoverIndex / Math.max(1, data.length - 1);
                    const hoverY = gweiToY(data[hoverIndex]);

                    // Vertical line
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(hoverX, padding);
                    ctx.lineTo(hoverX, height - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Highlight circle on spot line
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hoverX, hoverY, 8, 0, Math.PI * 2);
                    ctx.stroke();

                    // Also highlight TWAP point if available
                    if (rollingTwap && rollingTwap[hoverIndex]) {
                        const twapHoverY = gweiToY(rollingTwap[hoverIndex]);
                        ctx.strokeStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(hoverX, twapHoverY, 6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Pulsing live point (outer glow)
                const lastX = padding + (width - padding * 2);
                const lastY = gweiToY(data[data.length - 1]);
                const pulseTime = Date.now() / 1000;
                const pulseScale = 1 + 0.3 * Math.sin(pulseTime * 3);
                ctx.fillStyle = 'rgba(34, 197, 94, 0.25)';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 12 * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                // White center on current point
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(lastX, lastY, 2, 0, Math.PI * 2);
                ctx.fill();

                // Current value label (next to live point)
                const currentLabel = data[data.length - 1].toFixed(decimals);
                ctx.font = 'bold 10px Helvetica';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#22c55e';
                const labelY = lastY < padding + 30 ? lastY + 18 : lastY - 12;
                ctx.fillText(currentLabel, lastX + 10, labelY);
            }

            // Price change badge (top-left, inside chart with subtle background)
            if (data.length > 1) {
                const firstVal = data[0];
                const lastVal = data[data.length - 1];
                const change = ((lastVal - firstVal) / firstVal) * 100;
                const changeColor = change >= 0 ? '#22c55e' : '#ef4444';
                const changeSign = change >= 0 ? '+' : '';
                const changeText = changeSign + change.toFixed(1) + '%';

                ctx.font = 'bold 10px Helvetica';
                const textWidth = ctx.measureText(changeText).width;

                // Draw subtle pill background
                const pillX = padding + 8;
                const pillY = padding + 8;
                const pillPadX = 6;
                const pillPadY = 4;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.roundRect(pillX - pillPadX, pillY - pillPadY - 8, textWidth + pillPadX * 2, 16, 4);
                ctx.fill();

                // Draw text
                ctx.textAlign = 'left';
                ctx.fillStyle = changeColor;
                ctx.fillText(changeText, pillX, pillY);
            }

            // Legend (top-right corner, more subtle)
            ctx.font = '9px Helvetica';
            ctx.textAlign = 'right';
            ctx.fillStyle = 'rgba(34, 197, 94, 0.7)';
            ctx.fillText('â— Spot', width - padding - 45, padding + 12);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
            ctx.fillText('â€• TWAP', width - padding, padding + 12);

            // Observation count (bottom-left) - show original count, not downsampled
            const originalCount = chartDataPoints.length || 1;
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = '9px Helvetica';
            ctx.fillText(`${originalCount} obs`, padding, height - padding + 12);

            // Store state for tooltips (include rolling TWAP for tooltip display)
            chartState = { data, rollingTwap, padding, min, max, width, height, twap, current, timestamps, downsampleFactor };
        }

        // ======================== COUNTDOWNS ========================
        function updateCountdowns() {
            const now = Math.floor(Date.now() / 1000);

            // Hourly
            if (markets.hourly) {
                document.getElementById('hourlyCountdown').textContent = formatTime(markets.hourly.close - now);
            } else {
                const nextHour = new Date();
                nextHour.setUTCMinutes(60, 0, 0);
                document.getElementById('hourlyCountdown').textContent = formatTime(Math.floor(nextHour.getTime() / 1000) - now);
            }

            // Daily
            if (markets.daily) {
                document.getElementById('dailyCountdown').textContent = formatTime(markets.daily.close - now);
            } else {
                const tomorrow = new Date();
                tomorrow.setUTCHours(24, 0, 0, 0);
                document.getElementById('dailyCountdown').textContent = formatTime(Math.floor(tomorrow.getTime() / 1000) - now);
            }

            // Weekly
            if (markets.weekly) {
                document.getElementById('weeklyCountdown').textContent = formatTime(markets.weekly.close - now);
            } else {
                const sun = new Date();
                sun.setUTCDate(sun.getUTCDate() + (7 - sun.getUTCDay()));
                sun.setUTCHours(0, 0, 0, 0);
                document.getElementById('weeklyCountdown').textContent = formatTime(Math.floor(sun.getTime() / 1000) - now);
            }

            // Extreme
            if (markets.extreme) {
                const remaining = markets.extreme.close - now;
                if (remaining <= 0) {
                    document.getElementById('extremeCountdown').textContent = 'Ended';
                } else {
                    const days = Math.floor(remaining / 86400);
                    document.getElementById('extremeCountdown').textContent = days + ' days';
                }
            }
        }

        function formatTime(s) {
            if (s <= 0) return 'Ended';
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h >= 24) return Math.floor(h / 24) + 'd ' + (h % 24) + 'h';
            if (h > 0) return h + 'h ' + m + 'm';
            if (m > 0) return m + 'm ' + sec + 's';
            return sec + 's';
        }

        // ======================== TRADING ========================
        async function openTrade(type, isYes) {
            const market = markets[type];
            if (!market) { alert('No active market'); return; }
            if (!connectedAddress) { alert('Connect wallet first'); return; }

            currentTrade = { type, isYes, marketId: market.id };
            currentTradeMode = 'buy';

            // Load user position and orderbook in parallel
            await Promise.all([
                loadUserPosition(market.id),
                loadOrderbook(market.id, isYes)
            ]);

            const label = isYes ? (type === 'extreme' ? 'YES' : 'UP') : (type === 'extreme' ? 'NO' : 'DOWN');
            document.getElementById('tradeTitle').textContent = 'Trade ' + label;

            // Reset to buy mode
            setTradeMode('buy');

            document.getElementById('tradeAmount').value = '';
            updatePreview();
            document.getElementById('tradeModal').classList.add('active');
        }

        async function loadUserPosition(marketId) {
            if (!connectedAddress) {
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
                return;
            }

            try {
                const rpc = provider || new ethers.JsonRpcProvider('https://1rpc.io/eth');
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, rpc);

                // Get noId and poolKey for LP balance
                const [noId, poolKey] = await Promise.all([
                    pamm.getNoId(marketId),
                    pamm.poolKey(marketId, FEE_TIER)
                ]);

                // Compute pool ID (LP token ID) = keccak256(abi.encode(id0, id1, token0, token1, feeOrHook))
                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                    [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                ));

                const [yesBal, noBal, lpBal] = await Promise.all([
                    pamm.balanceOf(connectedAddress, marketId),
                    pamm.balanceOf(connectedAddress, noId),
                    zamm.balanceOf(connectedAddress, poolId)
                ]);
                currentUserPosition = { yesBalance: yesBal, noBalance: noBal, lpBalance: lpBal, poolId };
            } catch (e) {
                console.error('Failed to load position:', e);
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
            }

            // Update modal display
            document.getElementById('tradeModalYes').textContent = parseFloat(ethers.formatEther(currentUserPosition.yesBalance)).toFixed(4);
            document.getElementById('tradeModalNo').textContent = parseFloat(ethers.formatEther(currentUserPosition.noBalance)).toFixed(4);
            document.getElementById('tradeModalLP').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
        }

        let currentOrderbook = { bids: [], asks: [], bidHashes: [], askHashes: [], ammPrice: 0, rYes: 0n, rNo: 0n };

        async function loadOrderbook(marketId, isYes) {
            const asksContainer = document.getElementById('orderbookAsks');
            const bidsContainer = document.getElementById('orderbookBids');
            const spreadEl = document.getElementById('orderbookSpread');
            const emptyEl = document.getElementById('orderbookEmpty');
            const bodyEl = document.querySelector('.orderbook-body');

            // Clear and show loading state
            asksContainer.innerHTML = '<div class="orderbook-empty">Loading...</div>';
            bidsContainer.innerHTML = '';
            spreadEl.textContent = 'Spread: --';

            try {
                const rpc = provider || await getRpcProvider();

                // Always fetch AMM pool price first (available even without PMRouter)
                let ammPrice = 0;
                let rYesBigInt = 0n, rNoBigInt = 0n;
                try {
                    const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                    const [rYes, rNo, pYesNum, pYesDen] = await pamm.getPoolState(marketId, FEE_TIER);
                    rYesBigInt = rYes;
                    rNoBigInt = rNo;
                    // AMM price for YES = rNo / (rYes + rNo), for NO = rYes / (rYes + rNo)
                    ammPrice = isYes ?
                        Number(pYesNum) / Number(pYesDen) :
                        (Number(pYesDen) - Number(pYesNum)) / Number(pYesDen);
                } catch (e) {
                    console.warn('Could not get AMM price:', e);
                }

                currentOrderbook.ammPrice = ammPrice;
                currentOrderbook.rYes = rYesBigInt;
                currentOrderbook.rNo = rNoBigInt;

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                const depth = 10; // Max orders per side
                const [bidHashes, bidOrders, askHashes, askOrders] = await pmRouter.getOrderbook(marketId, isYes, depth);

                // Preserve rYes/rNo when updating orderbook
                currentOrderbook = {
                    bids: bidOrders.map((o, i) => ({ ...o, hash: bidHashes[i] })),
                    asks: askOrders.map((o, i) => ({ ...o, hash: askHashes[i] })),
                    bidHashes,
                    askHashes,
                    ammPrice,
                    rYes: rYesBigInt,
                    rNo: rNoBigInt
                };

                // Process and display orders
                const formatOrder = (order) => {
                    // Price = collateral / shares
                    const price = Number(order.collateral) / Number(order.shares);
                    const size = Number(order.shares) / 1e18;
                    return { price, size, order };
                };

                const bids = currentOrderbook.bids.map(o => formatOrder(o)).sort((a, b) => b.price - a.price);
                const asks = currentOrderbook.asks.map(o => formatOrder(o)).sort((a, b) => a.price - b.price);

                // Clear containers
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';

                bodyEl.style.display = 'block';
                emptyEl.style.display = 'none';

                // Render asks (sell orders) - displayed in reverse (lowest at bottom)
                // Asks that are cheaper than AMM are better deals for buyers
                // Calculate cumulative depth for asks (from lowest price up)
                let askCumulative = 0;
                const asksWithCumulative = asks.map(a => {
                    askCumulative += a.size;
                    return { ...a, cumulative: askCumulative };
                });

                // Render asks (sell orders) - note: asks are displayed in reverse order
                // So we need to reverse the cumulative calculation for display
                asksWithCumulative.forEach((a, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && a.price < ammPrice;
                    row.className = 'orderbook-row ask' + (isBetterDeal ? ' better-deal' : '');
                    row.innerHTML = `<span class="price">${a.price.toFixed(4)}${isBetterDeal ? ' â˜…' : ''}</span><span class="size">${a.size.toFixed(4)}</span><span class="total">${a.cumulative.toFixed(2)}</span>`;
                    row.title = isBetterDeal ? `Better than AMM (${ammPrice.toFixed(4)}) - Click to fill` : `Click to fill`;
                    row.onclick = () => fillOrderFromBook(a.order, false, idx);
                    asksContainer.appendChild(row);
                });

                // Calculate cumulative depth for bids (from highest price down)
                let bidCumulative = 0;
                const bidsWithCumulative = bids.map(b => {
                    bidCumulative += b.size;
                    return { ...b, cumulative: bidCumulative };
                });

                // Render bids (buy orders)
                // Bids that are higher than AMM are better deals for sellers
                bidsWithCumulative.forEach((b, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && b.price > ammPrice;
                    row.className = 'orderbook-row bid' + (isBetterDeal ? ' better-deal' : '');
                    row.innerHTML = `<span class="price">${b.price.toFixed(4)}${isBetterDeal ? ' â˜…' : ''}</span><span class="size">${b.size.toFixed(4)}</span><span class="total">${b.cumulative.toFixed(2)}</span>`;
                    row.title = isBetterDeal ? `Better than AMM (${ammPrice.toFixed(4)}) - Click to fill` : `Click to fill`;
                    row.onclick = () => fillOrderFromBook(b.order, true, idx);
                    bidsContainer.appendChild(row);
                });

                // Show AMM price in spread area if no orders
                if (bids.length === 0 && asks.length === 0) {
                    if (ammPrice > 0) {
                        spreadEl.textContent = `AMM: ${ammPrice.toFixed(4)} ETH`;
                    } else {
                        bodyEl.style.display = 'none';
                        emptyEl.style.display = 'block';
                        emptyEl.textContent = 'No liquidity';
                    }
                    return;
                }

                // Calculate and display spread with AMM reference
                const bestAsk = asks.length > 0 ? asks[0].price : null;
                const bestBid = bids.length > 0 ? bids[0].price : null;

                if (bestAsk && bestBid) {
                    const spread = ((bestAsk - bestBid) / bestAsk * 100).toFixed(1);
                    spreadEl.innerHTML = ammPrice > 0 ?
                        `AMM: ${ammPrice.toFixed(4)} | Spread: ${spread}%` :
                        `Spread: ${spread}%`;
                } else if (ammPrice > 0) {
                    const ref = bestAsk ? `Ask: ${bestAsk.toFixed(4)}` : bestBid ? `Bid: ${bestBid.toFixed(4)}` : '';
                    spreadEl.textContent = `AMM: ${ammPrice.toFixed(4)} | ${ref}`;
                } else {
                    spreadEl.textContent = bestAsk ? `Best Ask: ${bestAsk.toFixed(4)}` :
                                          bestBid ? `Best Bid: ${bestBid.toFixed(4)}` : '--';
                }

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';
                bodyEl.style.display = 'none';
                emptyEl.style.display = 'block';
                emptyEl.textContent = 'Failed to load orderbook';
            }
        }

        async function fillOrderFromBook(order, isBid, idx) {
            if (!signer) {
                alert('Connect wallet to fill orders');
                return;
            }

            // Calculate order details
            const shares = Number(order.shares) / 1e18;
            const collateral = Number(order.collateral) / 1e18;
            const price = collateral / shares;

            // isBid means it's a BID order in the orderbook (maker wants to buy)
            // If user clicks a BID, they are selling shares to the maker
            // If user clicks an ASK, they are buying shares from the maker
            const userIsBuying = !isBid;
            const actionText = userIsBuying ?
                `Buy ${shares.toFixed(4)} shares for ${collateral.toFixed(4)} ETH (${price.toFixed(4)} ETH/share)?` :
                `Sell ${shares.toFixed(4)} shares for ${collateral.toFixed(4)} ETH (${price.toFixed(4)} ETH/share)?`;

            if (!confirm(actionText)) return;

            try {
                showStatus('Confirm in wallet...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const orderHash = order.hash;
                const sharesToFill = 0; // 0 = fill all available

                let tx;
                if (userIsBuying) {
                    // User buying shares: send collateral as msg.value (for ETH markets)
                    tx = await pmRouter.fillOrder(
                        orderHash,
                        sharesToFill,
                        connectedAddress,
                        { value: order.collateral }
                    );
                } else {
                    // User selling shares: need PMRouter approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    showStatus('Confirm in wallet...', 'pending');
                    tx = await pmRouter.fillOrder(
                        orderHash,
                        sharesToFill,
                        connectedAddress
                    );
                }

                showStatus('Waiting for confirmation...', 'pending');
                const receipt = await tx.wait();

                showStatus(`Order filled! Tx: ${receipt.hash.slice(0, 10)}...`, 'success');

                // Refresh orderbook and balances
                await Promise.all([
                    loadOrderbook(currentTrade.marketId, currentTrade.isYes),
                    loadUserPosition(currentTrade.marketId),
                    loadBalance()
                ]);

            } catch (e) {
                console.error('Fill order failed:', e);
                if (isUserRejection(e)) {
                    showStatus('Transaction cancelled', 'pending');
                } else {
                    showStatus(e.reason || e.message || 'Transaction failed', 'error');
                }
            }
        }

        let currentLpMode = 'add'; // 'add' or 'remove'
        let mintKeepYes = true; // true = keep YES, false = keep NO
        let limitIsBuy = true; // true = buy order, false = sell order
        let userOrders = []; // User's active orders for this market

        function setSlippage(pct) {
            if (!pct || pct <= 0) pct = 0.5;
            slippageTolerance = pct;

            // Update button states
            document.getElementById('slip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';

            // Clear custom if using preset
            if (pct === 0.5 || pct === 1 || pct === 2) {
                document.getElementById('slipCustom').value = '';
            }

            updatePreview();
        }

        function setTradeMode(mode) {
            currentTradeMode = mode;

            const buyBtn = document.getElementById('buyModeBtn');
            const sellBtn = document.getElementById('sellModeBtn');
            const limitBtn = document.getElementById('limitModeBtn');
            const lpBtn = document.getElementById('lpModeBtn');
            const mintBtn = document.getElementById('mintModeBtn');
            const submitBtn = document.getElementById('tradeSubmit');
            const tradeSection = document.getElementById('tradeSection');
            const lpSection = document.getElementById('lpSection');
            const mintSection = document.getElementById('mintSection');
            const limitSection = document.getElementById('limitSection');
            const yourOrdersSection = document.getElementById('yourOrdersSection');
            const orderbookContainer = document.getElementById('orderbookContainer');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            // Reset all buttons using CSS classes
            buyBtn.className = 'mode-toggle-btn';
            sellBtn.className = 'mode-toggle-btn';
            limitBtn.className = 'mode-toggle-btn';
            lpBtn.className = 'mode-toggle-btn';
            mintBtn.className = 'mode-toggle-btn';

            // Hide your orders section by default
            yourOrdersSection.style.display = 'none';

            if (mode === 'buy') {
                buyBtn.className = 'mode-toggle-btn active-buy';
                tradeSection.style.display = 'block';
                lpSection.style.display = 'none';
                mintSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'block';
                document.getElementById('tradeInputLabel').textContent = 'Amount (ETH)';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Profit if win';
                submitBtn.textContent = 'Buy ' + label;
                submitBtn.className = 'trade-submit ' + (currentTrade.isYes ? 'buy-up' : 'buy-down');
            } else if (mode === 'sell') {
                sellBtn.className = 'mode-toggle-btn active-sell';
                tradeSection.style.display = 'block';
                lpSection.style.display = 'none';
                mintSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'block';
                document.getElementById('tradeInputLabel').textContent = 'Shares to sell';
                document.getElementById('tradeBalanceUnit').textContent = 'shares';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Slippage';
                submitBtn.textContent = 'Sell ' + label;
                submitBtn.className = 'trade-submit buy-down';
            } else if (mode === 'limit') {
                limitBtn.className = 'mode-toggle-btn active-limit';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                mintSection.style.display = 'none';
                limitSection.style.display = 'block';
                orderbookContainer.style.display = 'block';
                yourOrdersSection.style.display = 'block';
                updateLimitPreview();
                refreshUserOrders();
            } else if (mode === 'lp') {
                lpBtn.className = 'mode-toggle-btn active-lp';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'block';
                mintSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                document.getElementById('tradeInputLabel').textContent = currentLpMode === 'add' ? 'ETH to deposit' : 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = currentLpMode === 'add' ? 'ETH' : 'LP';
                updateLpPreview();
            } else if (mode === 'mint') {
                mintBtn.className = 'mode-toggle-btn active-mint';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                mintSection.style.display = 'block';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                document.getElementById('tradeInputLabel').textContent = 'ETH to mint';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                updateMintPreview();
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            if (mode !== 'lp' && mode !== 'mint' && mode !== 'limit') updatePreview();
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            const addBtn = document.getElementById('addLpBtn');
            const removeBtn = document.getElementById('removeLpBtn');
            const lpSubmit = document.getElementById('lpSubmit');
            const explainer = document.getElementById('lpExplainer');

            if (mode === 'add') {
                addBtn.className = 'lp-toggle-btn active-add';
                removeBtn.className = 'lp-toggle-btn';
                document.getElementById('tradeInputLabel').textContent = 'ETH to deposit';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.';
                lpSubmit.textContent = 'Deposit Liquidity';
                lpSubmit.style.background = 'var(--blue)';
            } else {
                addBtn.className = 'lp-toggle-btn';
                removeBtn.className = 'lp-toggle-btn active-remove';
                document.getElementById('tradeInputLabel').textContent = 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = 'LP';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Withdraw your liquidity. Your LP tokens are burned and you receive ETH back.';
                lpSubmit.textContent = 'Withdraw Liquidity';
                lpSubmit.style.background = 'var(--red)';
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            updateLpPreview();
        }

        function updateLpPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;
            const warningEl = document.getElementById('lpWarning');

            // Calculate pool metrics
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;
            const poolTvl = (rYesNum + rNoNum) / 2; // ETH value (YES + NO = 2 * collateral)
            const totalLpSupply = Math.sqrt(rYesNum * rNoNum); // LP = sqrt(rYes * rNo)

            // Pool price (YES probability)
            const yesPrice = rYesNum > 0 && rNoNum > 0 ? rNoNum / (rYesNum + rNoNum) : 0.5;
            const yesPct = (yesPrice * 100).toFixed(0);

            // Display pool TVL and price
            if (rYes > 0n && rNo > 0n) {
                document.getElementById('lpPoolReserves').textContent = poolTvl.toFixed(2) + ' ETH';
                document.getElementById('lpPoolPrice').textContent = yesPrice.toFixed(2) + ' (' + yesPct + '% YES)';
            } else {
                document.getElementById('lpPoolReserves').textContent = '--';
                document.getElementById('lpPoolPrice').textContent = '-- (--% YES)';
            }

            // Current user position value and share
            if (userLp > 0 && totalLpSupply > 0) {
                const userShare = userLp / totalLpSupply;
                const positionValue = userShare * poolTvl * 2; // Value in ETH terms
                document.getElementById('lpPositionValue').textContent = positionValue.toFixed(4) + ' ETH';
                document.getElementById('lpCurrentShare').textContent = (userShare * 100).toFixed(2) + '%';
            } else {
                document.getElementById('lpPositionValue').textContent = userLp > 0 ? userLp.toFixed(4) + ' LP' : '0 ETH';
                document.getElementById('lpCurrentShare').textContent = '0%';
            }

            // Hide warning by default
            warningEl.style.display = 'none';

            if (amt === 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP
                document.getElementById('lpPreview').textContent = amt.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = '100%';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: ETH -> split -> add to pool
                // User gets LP tokens proportional to their contribution
                // New LP = (amt / poolTvl) * totalLpSupply (simplified)
                const estLp = (amt / poolTvl) * totalLpSupply;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const newShare = (newUserLp / newTotalLp) * 100;

                document.getElementById('lpPreview').textContent = estLp.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';

                // Show IL warning for imbalanced pools
                if (yesPrice < 0.2 || yesPrice > 0.8) {
                    warningEl.textContent = 'âš ï¸ Pool is imbalanced (' + yesPct + '% YES). Higher impermanent loss risk if price moves toward 50%.';
                    warningEl.style.display = 'block';
                }
            } else {
                // Removing liquidity: LP tokens -> YES + NO -> merge -> ETH
                if (amt > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    return;
                }

                // Calculate how much YES + NO user gets from burning LP
                const shareOfPool = amt / totalLpSupply;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;

                // Merge gives min(yesOut, noOut) ETH back, leftover shares remain
                const ethOut = Math.min(yesOut, noOut);
                const leftoverYes = yesOut - ethOut;
                const leftoverNo = noOut - ethOut;

                // Display estimated ETH back
                document.getElementById('lpPreview').textContent = ethOut.toFixed(4) + ' ETH';

                // Calculate new share
                const newUserLp = userLp - amt;
                const newTotalLp = totalLpSupply - amt;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';

                // Show leftover warning if pool is imbalanced
                if (leftoverYes > 0.0001 || leftoverNo > 0.0001) {
                    const leftover = leftoverYes > leftoverNo ?
                        leftoverYes.toFixed(4) + ' YES' :
                        leftoverNo.toFixed(4) + ' NO';
                    warningEl.textContent = 'âš ï¸ Pool imbalanced. You\'ll also receive ~' + leftover + ' shares (can\'t merge).';
                    warningEl.style.display = 'block';
                }
            }
        }

        // ======================== MINT & LIST ========================
        function setMintKeep(keepYes) {
            mintKeepYes = keepYes;
            const keepYesBtn = document.getElementById('keepYesBtn');
            const keepNoBtn = document.getElementById('keepNoBtn');

            if (keepYes) {
                keepYesBtn.className = 'lp-toggle-btn active-add';
                keepNoBtn.className = 'lp-toggle-btn';
            } else {
                keepYesBtn.className = 'lp-toggle-btn';
                keepNoBtn.className = 'lp-toggle-btn active-remove';
            }
            updateMintPreview();
        }

        function updateMintPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value) || 0;

            const keepLabel = mintKeepYes ? 'YES' : 'NO';
            const sellLabel = mintKeepYes ? 'NO' : 'YES';

            document.getElementById('mintDeposit').textContent = amt > 0 ? amt.toFixed(4) + ' ETH' : '-- ETH';
            document.getElementById('mintReceive').textContent = amt > 0 ? amt.toFixed(4) + ' YES + ' + amt.toFixed(4) + ' NO' : '-- YES + -- NO';
            document.getElementById('mintKeep').textContent = amt > 0 ? amt.toFixed(4) + ' ' + keepLabel : '-- ' + keepLabel;

            if (amt > 0 && limitPrice > 0) {
                const sellShares = amt;
                const expectedReturn = sellShares * limitPrice;
                const netCost = amt - expectedReturn;

                document.getElementById('mintList').textContent = sellShares.toFixed(4) + ' ' + sellLabel + ' @ ' + limitPrice.toFixed(2) + ' ETH';

                if (netCost > 0) {
                    document.getElementById('mintProfit').textContent = 'Net cost: ' + netCost.toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--text-muted)';
                } else {
                    document.getElementById('mintProfit').textContent = 'Net profit: ' + Math.abs(netCost).toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--green)';
                }
            } else {
                document.getElementById('mintList').textContent = '-- ' + sellLabel + ' @ -- ETH';
                document.getElementById('mintProfit').textContent = 'Net cost: -- ETH';
                document.getElementById('mintProfit').style.color = 'var(--text-muted)';
            }
        }

        async function executeMintAndList() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value);

            if (!amt || amt <= 0) {
                showStatus('Please enter an amount', 'error');
                return;
            }
            if (!limitPrice || limitPrice <= 0 || limitPrice >= 1) {
                showStatus('Please enter a valid limit price (0.01 - 0.99)', 'error');
                return;
            }

            try {
                // Check approvals first
                const approved = await checkAndRequestApprovals('mint');
                if (!approved) return;

                showStatus('Preparing transaction...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                const marketId = currentTrade.marketId;
                const amountWei = ethers.parseEther(amt.toString());
                const sharesWei = amountWei; // 1 ETH = 1 YES + 1 NO
                const collateralWei = ethers.parseEther((amt * limitPrice).toString());

                // Get market close time for deadline
                const market = await pamm.getMarket(marketId);
                const closeTime = market[5]; // close timestamp
                const deadline = closeTime;

                // Encode multicall data:
                // 1. split(marketId, amount, address(0)) - sends to msg.sender
                // 2. placeOrder(marketId, isYes, isBuy=false, shares, collateral, deadline, partialFill=true)
                const splitData = pmRouter.interface.encodeFunctionData('split', [
                    marketId,
                    amountWei,
                    ethers.ZeroAddress // defaults to msg.sender
                ]);

                const placeOrderData = pmRouter.interface.encodeFunctionData('placeOrder', [
                    marketId,
                    !mintKeepYes, // isYes = opposite of what we keep (sell the other side)
                    false, // isBuy = false (sell order)
                    sharesWei, // shares to sell
                    collateralWei, // price in ETH
                    deadline,
                    true // partialFill
                ]);

                showStatus('Minting shares and placing order...', 'pending');

                const tx = await pmRouter.multicall([splitData, placeOrderData], { value: amountWei });
                showStatus('Transaction pending...', 'pending');

                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    showStatus('Success! Shares minted and order placed.', 'success');
                    await loadUserPosition();
                    await loadOrderbook(marketId, currentTrade.isYes);
                    document.getElementById('tradeAmount').value = '';
                    document.getElementById('mintLimitPrice').value = '';
                    updateMintPreview();
                } else {
                    showStatus('Transaction failed', 'error');
                }
            } catch (err) {
                console.error('Mint & List error:', err);
                if (err.code === 4001 || err.code === 'ACTION_REJECTED') {
                    showStatus('Transaction cancelled', 'error');
                } else {
                    showStatus('Error: ' + (err.reason || err.message || 'Transaction failed'), 'error');
                }
            }
        }

        // ======================== LIMIT ORDERS ========================
        function setLimitSide(side) {
            limitIsBuy = (side === 'buy');
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const submitBtn = document.getElementById('limitSubmit');
            const costLabel = document.getElementById('limitCostLabel');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            if (limitIsBuy) {
                buyBtn.className = 'lp-toggle-btn active-add';
                sellBtn.className = 'lp-toggle-btn';
                costLabel.textContent = 'You escrow';
                submitBtn.textContent = 'Place Buy Order';
                submitBtn.style.background = 'var(--green)';
            } else {
                buyBtn.className = 'lp-toggle-btn';
                sellBtn.className = 'lp-toggle-btn active-remove';
                costLabel.textContent = 'You escrow';
                submitBtn.textContent = 'Place Sell Order';
                submitBtn.style.background = 'var(--red)';
            }
            updateLimitPreview();
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const shares = parseFloat(document.getElementById('limitShares').value) || 0;
            const ammPrice = currentOrderbook.ammPrice || 0;

            const label = currentTrade.isYes ? 'YES' : 'NO';

            if (price <= 0 || shares <= 0) {
                document.getElementById('limitCost').textContent = '-- ETH';
                document.getElementById('limitReceive').textContent = '-- ' + label;
                document.getElementById('limitVsAmm').textContent = '--';
                return;
            }

            const totalCost = price * shares;

            if (limitIsBuy) {
                // Buy order: escrow ETH, receive shares when filled
                document.getElementById('limitCost').textContent = totalCost.toFixed(4) + ' ETH';
                document.getElementById('limitReceive').textContent = shares.toFixed(4) + ' ' + label;
            } else {
                // Sell order: escrow shares, receive ETH when filled
                document.getElementById('limitCost').textContent = shares.toFixed(4) + ' ' + label;
                document.getElementById('limitReceive').textContent = totalCost.toFixed(4) + ' ETH';
            }

            // Compare to AMM price
            if (ammPrice > 0) {
                const diff = ((price - ammPrice) / ammPrice * 100).toFixed(1);
                const isBetter = limitIsBuy ? price < ammPrice : price > ammPrice;
                const color = isBetter ? 'var(--green)' : 'var(--red)';
                const sign = price > ammPrice ? '+' : '';
                document.getElementById('limitVsAmm').innerHTML =
                    `<span style="color:${color}">${sign}${diff}% vs ${ammPrice.toFixed(4)}</span>`;
            } else {
                document.getElementById('limitVsAmm').textContent = 'No AMM price';
            }
        }

        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const price = parseFloat(document.getElementById('limitPrice').value);
            const shares = parseFloat(document.getElementById('limitShares').value);

            if (!price || price <= 0 || price >= 1) {
                showStatus('Enter valid price (0.01 - 0.99)', 'error');
                return;
            }
            if (!shares || shares <= 0) {
                showStatus('Enter valid shares amount', 'error');
                return;
            }

            try {
                // For sell orders, need approval
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('limit');
                    if (!approved) return;
                }

                showStatus('Preparing order...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                const marketId = currentTrade.marketId;
                const sharesWei = ethers.parseEther(shares.toString());
                const collateralWei = ethers.parseEther((price * shares).toString());

                // Get market close time for deadline
                const market = await pamm.getMarket(marketId);
                const closeTime = market[5];

                showStatus('Confirm in wallet...', 'pending');

                let tx;
                if (limitIsBuy) {
                    // Buy order: send ETH as value
                    tx = await pmRouter.placeOrder(
                        marketId,
                        currentTrade.isYes,
                        true, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true, // partialFill
                        { value: collateralWei }
                    );
                } else {
                    // Sell order: no ETH value
                    tx = await pmRouter.placeOrder(
                        marketId,
                        currentTrade.isYes,
                        false, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true // partialFill
                    );
                }

                showStatus('Transaction pending...', 'pending');
                const receipt = await tx.wait();

                if (receipt.status === 1) {
                    showStatus('Order placed!', 'success');
                    document.getElementById('limitPrice').value = '';
                    document.getElementById('limitShares').value = '';
                    updateLimitPreview();
                    await loadOrderbook(marketId, currentTrade.isYes);
                    await refreshUserOrders();
                } else {
                    showStatus('Transaction failed', 'error');
                }
            } catch (err) {
                console.error('Limit order error:', err);
                if (err.code === 4001 || err.code === 'ACTION_REJECTED') {
                    showStatus('Transaction cancelled', 'error');
                } else {
                    showStatus('Error: ' + (err.reason || err.message || 'Failed'), 'error');
                }
            }
        }

        async function refreshUserOrders() {
            const listEl = document.getElementById('yourOrdersList');

            if (!connectedAddress || !currentTrade.marketId) {
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Connect wallet to see orders</div>';
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                // Get user's order hashes
                const orderCount = await pmRouter.getUserOrderCount(connectedAddress);
                if (orderCount === 0n) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No open orders</div>';
                    userOrders = [];
                    return;
                }

                const orderHashes = await pmRouter.getUserOrderHashes(connectedAddress, 0, 50);

                // Fetch order details and filter for current market
                const orders = [];
                for (const hash of orderHashes) {
                    try {
                        const order = await pmRouter.orders(hash);
                        // Filter: same market AND (order not fully filled, i.e., owner still set)
                        if (order.owner !== ethers.ZeroAddress &&
                            order.marketId.toString() === currentTrade.marketId.toString()) {
                            orders.push({ hash, ...order });
                        }
                    } catch (e) {
                        // Order might be cancelled/filled
                    }
                }

                userOrders = orders;

                if (orders.length === 0) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No open orders for this market</div>';
                    return;
                }

                // Render orders
                listEl.innerHTML = orders.map(o => {
                    const shares = Number(o.shares) / 1e18;
                    const collateral = Number(o.collateral) / 1e18;
                    const price = collateral / shares;
                    const side = o.isBuy ? 'BUY' : 'SELL';
                    const sideColor = o.isBuy ? 'var(--green)' : 'var(--red)';
                    const shareType = o.isYes ? 'YES' : 'NO';

                    return `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-bottom:1px solid var(--border);">
                            <div>
                                <span style="color:${sideColor};font-weight:600;">${side}</span>
                                <span style="color:var(--text-muted);">${shares.toFixed(2)} ${shareType} @ ${price.toFixed(4)}</span>
                            </div>
                            <button onclick="cancelUserOrder('${o.hash}')"
                                style="padding:2px 8px;font-size:var(--font-xs);background:transparent;border:1px solid var(--red);color:var(--red);border-radius:var(--radius);cursor:pointer;">
                                Cancel
                            </button>
                        </div>
                    `;
                }).join('');

            } catch (e) {
                console.error('Failed to load user orders:', e);
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Failed to load orders</div>';
            }
        }

        async function cancelUserOrder(orderHash) {
            if (!signer) {
                showStatus('Connect wallet first', 'error');
                return;
            }

            if (!confirm('Cancel this order?')) return;

            try {
                showStatus('Cancelling order...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const tx = await pmRouter.cancelOrder(orderHash);

                showStatus('Transaction pending...', 'pending');
                await tx.wait();

                showStatus('Order cancelled!', 'success');
                await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                await refreshUserOrders();
                await loadUserPosition();

            } catch (err) {
                console.error('Cancel order error:', err);
                if (err.code === 4001 || err.code === 'ACTION_REJECTED') {
                    showStatus('Transaction cancelled', 'error');
                } else {
                    showStatus('Error: ' + (err.reason || err.message || 'Failed'), 'error');
                }
            }
        }

        async function setMaxTrade() {
            if (currentTradeMode === 'lp') {
                if (currentLpMode === 'add') {
                    // Set max ETH for adding LP
                    if (provider && connectedAddress) {
                        try {
                            const bal = await provider.getBalance(connectedAddress);
                            const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                            document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                            updateLpPreview();
                        } catch (e) {}
                    }
                } else {
                    // Set max LP tokens for removing
                    document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    updateLpPreview();
                }
            } else if (currentTradeMode === 'buy' || currentTradeMode === 'mint') {
                // Set max ETH balance (leave some for gas)
                if (provider && connectedAddress) {
                    try {
                        const bal = await provider.getBalance(connectedAddress);
                        const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                        document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                        if (currentTradeMode === 'mint') {
                            updateMintPreview();
                        } else {
                            updatePreview();
                        }
                    } catch (e) {}
                }
            } else {
                // Set max shares
                const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal)).toFixed(4);
                updatePreview();
            }
        }

        function closeModal() {
            document.getElementById('tradeModal').classList.remove('active');
            document.getElementById('tradeStatus').className = 'status-message';
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            try {
                showStatus('Preparing...', 'pending');

                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                if (currentLpMode === 'add') {
                    // Add liquidity: splitAndAddLiquidity
                    showStatus('Confirm in wallet...', 'pending');
                    const tx = await pamm.splitAndAddLiquidity(
                        currentTrade.marketId,
                        amtWei,
                        FEE_TIER,
                        0, // amount0Min (0 for no slippage protection)
                        0, // amount1Min
                        0, // minLiquidity
                        connectedAddress,
                        0, // deadline (0 = current block)
                        { value: amtWei }
                    );

                    showStatus('Waiting for confirmation...', 'pending');
                    await tx.wait();

                    showStatus('Liquidity added!', 'success');
                } else {
                    // Remove liquidity: need PAMM approved as operator on ZAMM
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    showStatus('Confirm in wallet...', 'pending');
                    const tx = await pamm.removeLiquidityToCollateral(
                        currentTrade.marketId,
                        FEE_TIER,
                        amtWei,
                        0, // amount0Min
                        0, // amount1Min
                        0, // minCollateralOut
                        connectedAddress,
                        0 // deadline
                    );

                    showStatus('Waiting for confirmation...', 'pending');
                    await tx.wait();

                    showStatus('Liquidity removed!', 'success');
                }

                // Refresh data
                await Promise.all([
                    loadUserPosition(currentTrade.marketId),
                    loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                ]);
                loadBalance();
                updateLpPreview();

            } catch (e) {
                console.error('LP operation failed:', e);
                if (isUserRejection(e)) {
                    showStatus('Transaction cancelled', 'pending');
                } else {
                    showStatus(e.reason || e.message || 'Failed', 'error');
                }
            }
        }

        async function loadBalance() {
            if (!provider || !connectedAddress) return;
            try {
                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        const bal = await provider.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    } else {
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    }
                } else if (currentTradeMode === 'buy' || currentTradeMode === 'mint') {
                    const bal = await provider.getBalance(connectedAddress);
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                } else {
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal)).toFixed(4);
                }
            } catch (e) {
                document.getElementById('tradeBalance').textContent = '--';
            }
        }

        function updatePreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const m = markets[currentTrade.type];
            const routeEl = document.getElementById('previewRoute');
            const breakdownEl = document.getElementById('previewBreakdown');
            const savingsEl = document.getElementById('previewSavings');
            const breakdownDetails = document.getElementById('breakdownDetails');

            if (!m || amt === 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--blue)';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            const price = currentTrade.isYes ? m.yesPrice : m.noPrice;
            const ammPrice = currentOrderbook.ammPrice || price;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            // Simulate mixed fill execution
            const execution = simulateMixedFill(amt, currentTradeMode === 'buy', rYes, rNo, ammPrice);

            // Update route indicator
            if (execution.orderbookFills.length > 0) {
                routeEl.innerHTML = `Orderbook + AMM <span style="color:var(--green);">â˜…</span>`;
                routeEl.style.color = 'var(--green)';
            } else {
                routeEl.textContent = 'AMM only';
                routeEl.style.color = 'var(--blue)';
            }

            // Update main preview
            if (execution.totalOutput <= 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = 'No liquidity';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            if (currentTradeMode === 'buy') {
                const effectivePrice = amt / execution.totalOutput;
                const profit = execution.totalOutput - amt;
                const roi = (profit / amt) * 100;

                document.getElementById('previewShares').textContent = execution.totalOutput.toFixed(4);
                document.getElementById('previewPrice').textContent = effectivePrice.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').textContent = `+${profit.toFixed(4)} ETH (+${roi.toFixed(0)}%)`;
            } else {
                const effectivePrice = execution.totalOutput / amt;

                document.getElementById('previewShares').textContent = execution.totalOutput.toFixed(4) + ' ETH';
                document.getElementById('previewPrice').textContent = effectivePrice.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').textContent = `Min: ${(execution.totalOutput * (1 - slippageTolerance / 100)).toFixed(4)} ETH`;
            }

            // Show execution breakdown if using orderbook
            if (execution.orderbookFills.length > 0) {
                breakdownEl.style.display = 'flex';
                let breakdownHtml = '';
                execution.orderbookFills.forEach(fill => {
                    if (currentTradeMode === 'buy') {
                        breakdownHtml += `<div>â€¢ ${fill.sharesOut.toFixed(4)} shares @ ${fill.price.toFixed(4)} (OB)</div>`;
                    } else {
                        breakdownHtml += `<div>â€¢ ${fill.sharesIn.toFixed(4)} shares @ ${fill.price.toFixed(4)} (OB)</div>`;
                    }
                });
                if (execution.ammOutput > 0) {
                    if (currentTradeMode === 'buy') {
                        breakdownHtml += `<div>â€¢ ${execution.ammOutput.toFixed(4)} shares @ ~${execution.ammEffectivePrice.toFixed(4)} (AMM)</div>`;
                    } else {
                        breakdownHtml += `<div>â€¢ ${execution.ammSharesIn.toFixed(4)} shares â†’ ${execution.ammOutput.toFixed(4)} ETH (AMM)</div>`;
                    }
                }
                breakdownDetails.innerHTML = breakdownHtml;
            } else {
                breakdownEl.style.display = 'none';
            }

            // Show savings vs pure AMM
            if (execution.savings > 0.0001) {
                savingsEl.style.display = 'flex';
                const savingsPct = (execution.savings / execution.pureAmmOutput * 100).toFixed(1);
                document.getElementById('savingsAmount').textContent = `+${execution.savings.toFixed(4)} (+${savingsPct}%)`;
                document.getElementById('savingsAmount').style.color = 'var(--green)';
            } else {
                savingsEl.style.display = 'none';
            }
        }

        // Simulate execution through orderbook first, then AMM for remainder
        function simulateMixedFill(inputAmt, isBuy, rYes, rNo, ammPrice) {
            const result = {
                orderbookFills: [],
                ammInput: 0,
                ammOutput: 0,
                ammSharesIn: 0,
                ammEffectivePrice: 0,
                totalOutput: 0,
                pureAmmOutput: 0,
                savings: 0
            };

            let remaining = inputAmt;
            const amtWei = BigInt(Math.floor(inputAmt * 1e18));

            // Calculate pure AMM output for comparison
            if (rYes > 0n && rNo > 0n) {
                if (isBuy) {
                    const pureAmm = currentTrade.isYes ?
                        quoteBuyYes(amtWei, rYes, rNo, FEE_TIER) :
                        quoteBuyNo(amtWei, rYes, rNo, FEE_TIER);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                } else {
                    const pureAmm = currentTrade.isYes ?
                        quoteSellYes(amtWei, rYes, rNo, FEE_TIER) :
                        quoteSellNo(amtWei, rYes, rNo, FEE_TIER);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                }
            }

            // Get orders better than AMM
            let betterOrders = [];
            if (isBuy) {
                // For buying: asks cheaper than AMM, sorted by price ascending
                betterOrders = (currentOrderbook.asks || [])
                    .map(o => ({
                        price: Number(o.collateral) / Number(o.shares),
                        shares: Number(o.shares) / 1e18,
                        collateral: Number(o.collateral) / 1e18,
                        hash: o.hash
                    }))
                    .filter(o => ammPrice > 0 ? o.price < ammPrice : true)
                    .sort((a, b) => a.price - b.price);
            } else {
                // For selling: bids higher than AMM, sorted by price descending
                betterOrders = (currentOrderbook.bids || [])
                    .map(o => ({
                        price: Number(o.collateral) / Number(o.shares),
                        shares: Number(o.shares) / 1e18,
                        collateral: Number(o.collateral) / 1e18,
                        hash: o.hash
                    }))
                    .filter(o => ammPrice > 0 ? o.price > ammPrice : true)
                    .sort((a, b) => b.price - a.price);
            }

            // Fill through orderbook
            for (const order of betterOrders) {
                if (remaining <= 0) break;

                if (isBuy) {
                    // Buying: we spend ETH, get shares
                    const maxEthForOrder = order.collateral;
                    const ethToSpend = Math.min(remaining, maxEthForOrder);
                    const sharesOut = ethToSpend / order.price;

                    result.orderbookFills.push({
                        price: order.price,
                        ethSpent: ethToSpend,
                        sharesOut: sharesOut,
                        hash: order.hash
                    });
                    result.totalOutput += sharesOut;
                    remaining -= ethToSpend;
                } else {
                    // Selling: we spend shares, get ETH
                    const maxSharesForOrder = order.shares;
                    const sharesToSell = Math.min(remaining, maxSharesForOrder);
                    const ethOut = sharesToSell * order.price;

                    result.orderbookFills.push({
                        price: order.price,
                        sharesIn: sharesToSell,
                        ethOut: ethOut,
                        hash: order.hash
                    });
                    result.totalOutput += ethOut;
                    remaining -= sharesToSell;
                }
            }

            // Remainder goes to AMM
            if (remaining > 0 && rYes > 0n && rNo > 0n) {
                const remainingWei = BigInt(Math.floor(remaining * 1e18));
                result.ammInput = remaining;

                if (isBuy) {
                    const ammOut = currentTrade.isYes ?
                        quoteBuyYes(remainingWei, rYes, rNo, FEE_TIER) :
                        quoteBuyNo(remainingWei, rYes, rNo, FEE_TIER);
                    result.ammOutput = Number(ammOut) / 1e18;
                    result.ammEffectivePrice = remaining / result.ammOutput;
                    result.totalOutput += result.ammOutput;
                } else {
                    const ammOut = currentTrade.isYes ?
                        quoteSellYes(remainingWei, rYes, rNo, FEE_TIER) :
                        quoteSellNo(remainingWei, rYes, rNo, FEE_TIER);
                    result.ammOutput = Number(ammOut) / 1e18;
                    result.ammSharesIn = remaining;
                    result.totalOutput += result.ammOutput;
                }
            } else if (remaining > 0) {
                // No AMM, use ammPrice as fallback
                if (isBuy) {
                    const shares = remaining / ammPrice;
                    result.ammOutput = shares;
                    result.ammEffectivePrice = ammPrice;
                    result.totalOutput += shares;
                } else {
                    const ethOut = remaining * ammPrice;
                    result.ammOutput = ethOut;
                    result.ammSharesIn = remaining;
                    result.totalOutput += ethOut;
                }
            }

            // Calculate savings vs pure AMM
            if (result.pureAmmOutput > 0) {
                result.savings = result.totalOutput - result.pureAmmOutput;
            }

            return result;
        }

        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            try {
                showStatus('Preparing...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                const ammPrice = currentOrderbook.ammPrice || 0;
                const rYes = currentOrderbook.rYes || 0n;
                const rNo = currentOrderbook.rNo || 0n;

                // Simulate execution to get expected output and order hashes
                const execution = simulateMixedFill(amt, currentTradeMode === 'buy', rYes, rNo, ammPrice);

                if (execution.totalOutput <= 0) {
                    showStatus('No liquidity available', 'error');
                    return;
                }

                // Calculate minOutput with slippage tolerance
                const minOutput = Math.max(0, execution.totalOutput * (1 - slippageTolerance / 100));
                const minOutputWei = ethers.parseEther(minOutput.toFixed(18));

                // Get order hashes from simulation
                const betterOrderHashes = execution.orderbookFills.map(f => f.hash);

                showStatus('Confirm in wallet...', 'pending');

                let tx;
                if (currentTradeMode === 'buy') {
                    // Use fillOrdersThenSwap if we have better limit orders
                    if (betterOrderHashes.length > 0) {
                        tx = await pmRouter.fillOrdersThenSwap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            true, // isBuy
                            amtWei,
                            minOutputWei, // slippage protected
                            betterOrderHashes,
                            FEE_TIER,
                            connectedAddress,
                            0, // deadline (0 = no deadline)
                            { value: amtWei }
                        );
                    } else {
                        tx = await pmRouter.buy(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei, // slippage protected
                            FEE_TIER,
                            connectedAddress,
                            0,
                            { value: amtWei }
                        );
                    }
                } else {
                    // Sell - need PMRouter approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    showStatus('Confirm in wallet...', 'pending');

                    // Use fillOrdersThenSwap if we have better limit orders
                    if (betterOrderHashes.length > 0) {
                        tx = await pmRouter.fillOrdersThenSwap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            false, // isBuy
                            amtWei,
                            minOutputWei, // slippage protected
                            betterOrderHashes,
                            FEE_TIER,
                            connectedAddress,
                            0 // deadline
                        );
                    } else {
                        tx = await pmRouter.sell(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei, // slippage protected
                            FEE_TIER,
                            connectedAddress,
                            0
                        );
                    }
                }

                showStatus('Waiting for confirmation...', 'pending');
                await tx.wait();

                showStatus('Success!', 'success');
                await loadData();
                await loadPositions();
                setTimeout(closeModal, 1500);

            } catch (e) {
                console.error('Trade failed:', e);
                if (isUserRejection(e)) {
                    showStatus('Transaction cancelled', 'pending');
                } else {
                    showStatus(e.reason || e.message || 'Failed', 'error');
                }
            }
        }

        function showStatus(msg, type) {
            const el = document.getElementById('tradeStatus');
            el.textContent = msg;
            el.className = 'status-message show ' + type;
        }

        // ======================== APPROVALS ========================

        /**
         * Ensure operator approval for a contract.
         * @param {string} tokenContract - 'pamm' or 'zamm'
         * @param {string} operatorAddress - Address to approve as operator
         * @param {string} operatorName - Human-readable name for status messages
         * @returns {Promise<boolean>} - true if approved (or already approved), false if rejected
         */
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                showStatus(`Approve ${operatorName} as operator...`, 'pending');
                const tx = await contract.setOperator(operatorAddress, true);
                showStatus('Waiting for approval confirmation...', 'pending');
                await tx.wait();
                return true;
            } catch (err) {
                console.error('Approval error:', err);
                if (err.code === 4001 || err.code === 'ACTION_REJECTED') {
                    showStatus('Approval rejected by user', 'error');
                } else {
                    showStatus('Approval failed: ' + (err.reason || err.message), 'error');
                }
                return false;
            }
        }

        /**
         * Check all required approvals for the current operation
         * @param {string} operation - 'sell', 'lp', 'mint', 'limit'
         * @returns {Promise<boolean>} - true if all approvals granted
         */
        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showStatus('Please connect wallet first', 'error');
                return false;
            }

            // PMRouter needs to be operator on PAMM for: sell, mint & list, limit orders
            if (operation === 'sell' || operation === 'mint' || operation === 'limit') {
                const approved = await ensureOperatorApproval('pamm', PMROUTER_ADDRESS, 'PMRouter');
                if (!approved) return false;
            }

            // PAMM needs to be operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                const approved = await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
                if (!approved) return false;
            }

            return true;
        }

        // ======================== HELPERS ========================

        // AMM constant product formula (matches ZAMM._getAmountOut)
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        // AMM reverse calculation (matches ZAMM._getAmountIn)
        function getAmountIn(amountOut, reserveIn, reserveOut, feeBps = 30n) {
            if (amountOut === 0n || reserveIn === 0n || amountOut >= reserveOut) return 0n;
            const numerator = reserveIn * amountOut * 10000n;
            const denominator = (reserveOut - amountOut) * (10000n - feeBps);
            return (numerator / denominator) + 1n;
        }

        // Quote buying YES shares with collateral
        // PAMM buyYes: split collateral â†’ YES + NO, then swap NO â†’ YES
        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn â†’ collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn NO â†’ yesFromSwap YES (pool: NO in, YES out)
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            // Total YES = from split + from swap
            return collateralIn + yesFromSwap;
        }

        // Quote buying NO shares with collateral
        // PAMM buyNo: split collateral â†’ YES + NO, then swap YES â†’ NO
        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn â†’ collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn YES â†’ noFromSwap NO (pool: YES in, NO out)
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            // Total NO = from split + from swap
            return collateralIn + noFromSwap;
        }

        // Quote selling YES shares for collateral
        // PAMM sellYes: swap some YES â†’ NO, then merge YES + NO â†’ collateral
        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of YES â†’ NO, then merge
            // Actual: swap yesIn/2 â†’ NO, merge min(yesIn/2, noFromSwap)
            const yesToSwap = yesIn / 2n;
            const noFromSwap = getAmountOut(yesToSwap, rYes, rNo, feeBps);
            const yesRemaining = yesIn - yesToSwap;
            // Merge: min(yesRemaining, noFromSwap) â†’ collateral
            const merged = yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
            return merged;
        }

        // Quote selling NO shares for collateral
        // PAMM sellNo: swap some NO â†’ YES, then merge YES + NO â†’ collateral
        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of NO â†’ YES, then merge
            const noToSwap = noIn / 2n;
            const yesFromSwap = getAmountOut(noToSwap, rNo, rYes, feeBps);
            const noRemaining = noIn - noToSwap;
            // Merge: min(yesFromSwap, noRemaining) â†’ collateral
            const merged = yesFromSwap < noRemaining ? yesFromSwap : noRemaining;
            return merged;
        }

        function formatGwei(wei) {
            const gwei = Number(wei) / 1e9;
            if (gwei >= 100) return Math.round(gwei).toString();
            if (gwei >= 10) return gwei.toFixed(1);
            return gwei.toFixed(2);
        }

        // ======================== MARKET CREATION ========================
        async function createHourly() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('hourlySeed').value);
            if (!seed || seed <= 0) { alert('Enter seed amount'); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close at next top of hour UTC
                const close = new Date();
                close.setUTCMinutes(60, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                const tx = await gasPm.createComparisonMarket(
                    '0x0000000000000000000000000000000000000000', // ETH
                    closeTs,
                    ethers.parseEther(seed.toString()),
                    FEE_TIER,
                    0,
                    connectedAddress,
                    { value: ethers.parseEther(seed.toString()) }
                );

                await tx.wait();
                alert('Hourly market created!');
                await loadData();
            } catch (e) {
                console.error('Create failed:', e);
                if (!isUserRejection(e)) alert(e.reason || e.message || 'Failed');
            }
        }

        async function createDaily() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('dailySeed').value);
            if (!seed || seed <= 0) { alert('Enter seed amount'); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close at next midnight UTC
                const close = new Date();
                close.setUTCHours(24, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                const tx = await gasPm.createComparisonMarket(
                    '0x0000000000000000000000000000000000000000', // ETH
                    closeTs,
                    ethers.parseEther(seed.toString()),
                    FEE_TIER,
                    0,
                    connectedAddress,
                    { value: ethers.parseEther(seed.toString()) }
                );

                await tx.wait();
                alert('Daily market created!');
                await loadData();
            } catch (e) {
                console.error('Create failed:', e);
                if (!isUserRejection(e)) alert(e.reason || e.message || 'Failed');
            }
        }

        async function createWeekly() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('weeklySeed').value);
            if (!seed || seed <= 0) { alert('Enter seed amount'); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close next Sunday midnight UTC
                const close = new Date();
                close.setUTCDate(close.getUTCDate() + (7 - close.getUTCDay()));
                close.setUTCHours(0, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                const tx = await gasPm.createComparisonMarket(
                    '0x0000000000000000000000000000000000000000',
                    closeTs,
                    ethers.parseEther(seed.toString()),
                    FEE_TIER,
                    0,
                    connectedAddress,
                    { value: ethers.parseEther(seed.toString()) }
                );

                await tx.wait();
                alert('Weekly market created!');
                await loadData();
            } catch (e) {
                console.error('Create failed:', e);
                if (!isUserRejection(e)) alert(e.reason || e.message || 'Failed');
            }
        }

        async function createExtreme() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('extremeSeed').value);
            if (!seed || seed <= 0) { alert('Enter seed amount'); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Fixed deadline: Dec 31, 2025 23:59:59 UTC
                const closeTs = 1735689599;
                const threshold = ethers.parseUnits('100', 'gwei'); // 100 gwei

                const tx = await gasPm.createWindowPeakMarket(
                    threshold,
                    '0x0000000000000000000000000000000000000000',
                    closeTs,
                    ethers.parseEther(seed.toString()),
                    FEE_TIER,
                    0,
                    connectedAddress,
                    { value: ethers.parseEther(seed.toString()) }
                );

                await tx.wait();
                alert('100 Gwei Challenge created! Deadline: Dec 31, 2025');
                await loadData();
            } catch (e) {
                console.error('Create failed:', e);
                if (!isUserRejection(e)) alert(e.reason || e.message || 'Failed');
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
