<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ethPM</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23000' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='700' fill='%23627EEA' text-anchor='middle'>eth</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='700' fill='%2300FF00' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    button, input, select { font: inherit; }
    :root { --bg: #fff; --fg: #000; }
    [data-theme="dark"] { --bg: #000; --fg: #fff; }

    body {
      font: bold 16px Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      padding: 20px;
      transition: background 0.2s, color 0.2s;
    }

    .corner {
      position: fixed;
      font-size: 14px;
      text-decoration: underline;
      text-underline-offset: 3px;
      cursor: pointer;
      background: none;
      border: none;
      color: var(--fg);
    }
    .corner:hover { opacity: 0.5; }
    #wallet { top: 20px; right: 20px; text-decoration-color: #0FF; }
    #theme { bottom: 20px; right: 20px; text-decoration-color: #F0F; }
    #create { top: 20px; left: 20px; text-decoration-color: #0F0; }
    #browse { top: 44px; left: 20px; text-decoration-color: #0FF; }

    .logo {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: clamp(32px, 10vw, 64px);
      letter-spacing: -2px;
      z-index: 10;
    }
    .logo span { text-decoration: underline; text-underline-offset: 4px; cursor: pointer; }
    .logo span:hover { opacity: 0.5; }

    @media (max-width: 600px) {
      .logo { font-size: 28px; bottom: 12px; left: 12px; }
      #browse { top: 36px; left: 12px; right: auto; font-size: 12px; }
      #theme { bottom: 12px; right: 12px; }
      #create { top: 12px; left: 12px; }
      #wallet { top: 12px; right: 12px; }
    }

    .main { max-width: 500px; margin: 80px auto 100px; }

    h1 {
      font-size: clamp(28px, 7vw, 44px);
      text-align: center;
      line-height: 1.15;
      letter-spacing: -1px;
      margin-bottom: 32px;
    }
    h1 u { text-decoration-thickness: 3px; text-underline-offset: 4px; }

    .meta {
      text-align: center;
      font-size: 12px;
      margin-bottom: 16px;
      opacity: 0.6;
    }
    .meta a { color: inherit; }

    .odds { display: flex; height: 72px; border: 3px solid var(--fg); position: relative; }
    .bar {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(22px, 6vw, 30px);
      cursor: pointer;
      transition: opacity 0.2s, width 0.3s;
    }
    .bar:hover { opacity: 0.7; }
    .bar.dim { opacity: 0.2; pointer-events: none; }
    .y { background: var(--fg); color: #0F0; }
    .n { background: var(--bg); color: #F00; border-left: 3px solid var(--fg); }

    .liq-toggle {
      position: absolute;
      bottom: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: none;
      border: none;
      font-size: 14px;
      cursor: pointer;
      opacity: 0.3;
      transition: opacity 0.2s;
      padding: 4px 8px;
    }
    .liq-toggle:hover { opacity: 0.7; }
    .liq-toggle.active { opacity: 1; }

    .drop {
      position: absolute;
      top: calc(100% + 10px);
      left: 0;
      right: 0;
      border: 3px solid #000;
      padding: 16px;
      display: flex;
      gap: 12px;
      align-items: center;
      transform: translateY(-8px);
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }
    .drop.open { transform: translateY(0); opacity: 1; visibility: visible; }
    .drop.yes { background: #0F0; }
    .drop.no { background: #F00; }

    .drop input {
      flex: 1;
      min-width: 0;
      border: 3px solid #000;
      padding: 12px;
      font-size: clamp(20px, 5vw, 26px);
      background: rgba(255,255,255,0.25);
      outline: none;
    }
    .drop input::placeholder { color: rgba(0,0,0,0.4); }
    .drop.no input { border-color: #fff; background: rgba(0,0,0,0.15); color: #fff; }
    .drop.no input::placeholder { color: rgba(255,255,255,0.5); }

    .drop .info { font-size: 14px; letter-spacing: 0.5px; white-space: nowrap; }
    .drop.no .info { color: #fff; }

    .drop button {
      padding: 12px 28px;
      font-size: clamp(16px, 4vw, 20px);
      letter-spacing: 1px;
      cursor: pointer;
      border: none;
      background: #000;
      color: #fff;
    }
    .drop button:hover { opacity: 0.7; }
    .drop button:disabled { opacity: 0.3; cursor: not-allowed; }
    .drop.no button { background: #fff; color: #000; }

    @media (max-width: 500px) {
      .drop { flex-wrap: wrap; }
      .drop input { flex: 1 1 55%; }
      .drop .info { flex: 1 1 30%; text-align: right; }
      .drop button { flex: 1 1 100%; margin-top: 6px; }
    }

    /* Modals */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      overflow-y: auto;
      padding: 20px;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: var(--bg);
      border: 3px solid var(--fg);
      padding: 20px;
      width: 100%;
      max-width: 400px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    .modal-title { font-size: 18px; }
    .modal-close {
      background: none;
      border: none;
      color: var(--fg);
      font-size: 24px;
      cursor: pointer;
      line-height: 1;
    }
    .modal-close:hover { opacity: 0.5; }
    .wallet-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border: 2px solid var(--fg);
      cursor: pointer;
      margin-bottom: 8px;
      transition: all 0.15s;
    }
    .wallet-option:hover { background: var(--fg); color: var(--bg); }
    .wallet-option-icon { font-size: 1.5rem; }
    .wallet-option-name { font-weight: 600; }
    .wallet-option.disconnect {
      border-color: #F00;
      color: #F00;
      justify-content: center;
    }
    .wallet-option.disconnect:hover {
      background: #F00;
      color: #fff;
    }

    /* Create Market Form */
    .form-group { margin-bottom: 16px; }
    .form-label { display: block; font-size: 12px; margin-bottom: 6px; opacity: 0.7; }
    .form-input {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--fg);
      background: var(--bg);
      color: var(--fg);
      font-size: 16px;
    }
    .form-input:focus { outline: none; border-color: #0F0; }
    .form-row { display: flex; gap: 12px; }
    .form-row > * { flex: 1; }
    .form-hint { font-size: 11px; margin-top: 4px; opacity: 0.5; }
    .form-btn {
      width: 100%;
      padding: 14px;
      border: none;
      background: var(--fg);
      color: var(--bg);
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
    }
    .form-btn:hover { opacity: 0.8; }
    .form-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .form-divider {
      text-align: center;
      margin: 20px 0;
      font-size: 12px;
      opacity: 0.5;
    }
    .live-price {
      text-align: center;
      padding: 8px;
      border: 1px solid rgba(128,128,128,0.3);
      margin-bottom: 16px;
      font-size: 12px;
      opacity: 0.7;
    }
    .live-price b { color: #0F0; font-size: 14px; }

    /* Market type tabs - brutalist */
    .market-type-tabs {
      display: flex;
      gap: 0;
      margin-bottom: 20px;
    }
    .market-type-tab {
      flex: 1;
      padding: 12px 6px;
      border: 2px solid var(--fg);
      border-right: none;
      background: transparent;
      color: var(--fg);
      font-size: 10px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
      text-align: center;
    }
    .market-type-tab:last-child { border-right: 2px solid var(--fg); }
    .market-type-tab.active { background: var(--fg); color: var(--bg); }
    .market-type-tab:hover:not(.active) { opacity: 0.6; }
    .market-type-tab .tab-icon { display: none; }

    .market-form-section { display: none; }
    .market-form-section.active { display: block; }

    .live-info {
      text-align: center;
      padding: 8px;
      border: 1px solid rgba(128,128,128,0.3);
      margin-bottom: 16px;
      font-size: 11px;
      opacity: 0.6;
    }
    .live-info b { font-size: 13px; color: #0F0; }

    /* Positions */
    .positions {
      margin-top: 24px;
      padding: 16px;
      border: 2px solid var(--fg);
      font-size: 14px;
    }
    .positions-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      margin-bottom: 12px;
    }
    .positions-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }
    .positions-row + .positions-row { border-top: 1px solid rgba(128,128,128,0.2); }
    .positions-label { display: flex; align-items: center; gap: 8px; }
    .positions-dot { width: 10px; height: 10px; border-radius: 50%; }
    .positions-dot.yes { background: #0F0; }
    .positions-dot.no { background: #F00; }
    .positions-value { font-variant-numeric: tabular-nums; }
    .positions-empty { opacity: 0.4; font-size: 12px; }

    /* Trade mode toggle */
    .trade-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 12px;
    }
    .trade-toggle button {
      flex: 1;
      padding: 8px;
      border: 2px solid #000;
      background: transparent;
      color: #000;
      font-size: 12px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .trade-toggle button:first-child { border-right: none; }
    .trade-toggle button.active { background: #000; color: #fff; }
    .trade-toggle button:hover:not(.active) { opacity: 0.6; }
    .drop.yes .trade-toggle button { border-color: #000; }
    .drop.yes .trade-toggle button.active { background: #000; color: #0F0; }
    .drop.no .trade-toggle button { border-color: #fff; color: #fff; }
    .drop.no .trade-toggle button.active { background: #fff; color: #F00; }

    /* Sell mode styling */
    .drop.sell-mode .info { font-size: 13px; }

    /* Resolved market */
    .resolved-badge {
      display: inline-block;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: bold;
      letter-spacing: 1px;
      text-transform: uppercase;
      border-radius: 2px;
      margin-left: 8px;
    }
    .resolved-badge.yes { background: #0F0; color: #000; }
    .resolved-badge.no { background: #F00; color: #fff; }

    .claim-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(128,128,128,0.2);
    }
    .claim-info {
      font-size: 13px;
      margin-bottom: 12px;
      opacity: 0.8;
    }
    .claim-amount {
      font-size: 18px;
      font-weight: bold;
      color: #0F0;
      margin-bottom: 12px;
    }
    .claim-btn {
      width: 100%;
      padding: 12px;
      border: none;
      background: #0F0;
      color: #000;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
    }
    .claim-btn:hover { opacity: 0.8; }
    .claim-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .claim-btn.claimed {
      background: var(--fg);
      color: var(--bg);
      opacity: 0.5;
    }

    /* Resolved market - dim the bars */
    .odds.resolved .bar { cursor: default; }
    .odds.resolved .bar:hover { opacity: 1; }

    /* LP Modal */
    .lp-summary {
      display: flex;
      justify-content: space-between;
      padding: 12px;
      background: rgba(128,128,128,0.1);
      border: 2px solid var(--fg);
      margin-bottom: 16px;
      font-size: 13px;
    }
    .lp-summary-item { text-align: center; }
    .lp-summary-label { font-size: 10px; opacity: 0.6; text-transform: uppercase; letter-spacing: 0.5px; }
    .lp-summary-value { font-size: 16px; font-weight: bold; margin-top: 4px; }

    .lp-allocation {
      margin-bottom: 20px;
    }
    .lp-alloc-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .lp-alloc-label {
      width: 80px;
      font-size: 12px;
      font-weight: bold;
    }
    .lp-alloc-label.yes { color: #0F0; }
    .lp-alloc-label.no { color: #F00; }
    .lp-alloc-label.amm { color: #0FF; }
    .lp-alloc-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: rgba(128,128,128,0.3);
      border-radius: 4px;
      outline: none;
    }
    .lp-alloc-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--fg);
      border-radius: 50%;
      cursor: pointer;
    }
    .lp-alloc-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: var(--fg);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }
    .lp-alloc-pct {
      width: 50px;
      text-align: right;
      font-size: 14px;
      font-weight: bold;
      font-variant-numeric: tabular-nums;
    }
    .lp-alloc-hint {
      font-size: 11px;
      opacity: 0.5;
      margin-top: -8px;
      margin-bottom: 12px;
      padding-left: 92px;
    }

    .lp-preview {
      padding: 12px;
      background: rgba(0,255,255,0.1);
      border: 2px solid #0FF;
      margin-bottom: 16px;
      font-size: 12px;
    }
    .lp-preview-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
      margin-bottom: 8px;
    }
    .lp-preview-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }
    .lp-preview-row:last-child { margin-bottom: 0; }

    /* LP Button in positions */
    .lp-btn {
      width: 100%;
      padding: 10px;
      margin-top: 12px;
      border: 2px solid #0FF;
      background: transparent;
      color: #0FF;
      font-size: 12px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .lp-btn:hover { background: #0FF; color: #000; }

    /* LP Positions */
    .lp-positions {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid rgba(128,128,128,0.2);
    }
    .lp-positions-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.5;
      margin-bottom: 12px;
      color: #0FF;
    }
    .lp-pos-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }
    .lp-pos-row + .lp-pos-row { border-top: 1px solid rgba(128,128,128,0.1); }
    .lp-pos-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    .lp-pos-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .lp-pos-dot.yes { background: #0F0; }
    .lp-pos-dot.no { background: #F00; }
    .lp-pos-dot.amm { background: #0FF; }
    .lp-pos-right {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .lp-pos-value {
      font-size: 12px;
      font-variant-numeric: tabular-nums;
    }
    .lp-withdraw-btn {
      padding: 4px 10px;
      font-size: 10px;
      font-weight: bold;
      letter-spacing: 0.5px;
      border: 1px solid var(--fg);
      background: transparent;
      color: var(--fg);
      cursor: pointer;
      opacity: 0.6;
      transition: all 0.15s;
    }
    .lp-withdraw-btn:hover { opacity: 1; background: var(--fg); color: var(--bg); }
    .lp-withdraw-btn:disabled { opacity: 0.2; cursor: not-allowed; }

    .lp-pos-fees {
      display: inline-block;
      margin-left: 6px;
      padding: 2px 5px;
      font-size: 9px;
      font-weight: bold;
      background: rgba(0,255,0,0.15);
      color: #0F0;
      border-radius: 2px;
    }
    .lp-pos-fees:empty { display: none; }

    .lp-harvest-btn {
      padding: 4px 8px;
      font-size: 9px;
      font-weight: bold;
      letter-spacing: 0.5px;
      border: 1px solid #0F0;
      background: transparent;
      color: #0F0;
      cursor: pointer;
      opacity: 0.8;
      transition: all 0.15s;
    }
    .lp-harvest-btn:hover { opacity: 1; background: #0F0; color: #000; }
    .lp-harvest-btn:disabled { opacity: 0.2; cursor: not-allowed; border-color: var(--fg); color: var(--fg); }

    /* Vault Stats */
    .vault-stats {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .vault-stat {
      flex: 1;
      padding: 8px;
      background: rgba(128,128,128,0.08);
      border: 1px solid rgba(128,128,128,0.2);
      border-radius: 4px;
    }
    .vault-stat-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.5;
      margin-bottom: 4px;
    }
    .vault-stat-value {
      font-size: 13px;
      font-weight: bold;
      font-variant-numeric: tabular-nums;
    }
    .vault-stat-value.yes { color: #0F0; }
    .vault-stat-value.no { color: #F00; }
    .vault-stat-yield {
      font-size: 10px;
      opacity: 0.7;
      margin-top: 2px;
    }

    /* Pool Stats */
    .pool-stats {
      padding: 10px;
      background: rgba(0,255,255,0.05);
      border: 1px solid rgba(0,255,255,0.2);
      border-radius: 4px;
      margin-top: 8px;
    }
    .pool-stats-title {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #0FF;
      opacity: 0.7;
      margin-bottom: 8px;
    }
    .pool-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .pool-stat-item {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
    }
    .pool-stat-label { opacity: 0.6; }
    .pool-stat-val { font-weight: bold; font-variant-numeric: tabular-nums; }
    .pool-stat-val.yes { color: #0F0; }
    .pool-stat-val.no { color: #F00; }
    .pool-stat-val.cyan { color: #0FF; }

    /* Resolve Section */
    .resolve-section {
      margin-top: 24px;
      padding: 16px;
      border: 2px solid #F50;
      background: rgba(255,85,0,0.05);
    }
    .resolve-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #F50;
      margin-bottom: 12px;
    }
    .resolve-status {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 12px;
    }
    .resolve-status-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
    }
    .resolve-status-label { opacity: 0.6; }
    .resolve-status-val { font-weight: bold; }
    .resolve-status-val.ready { color: #0F0; }
    .resolve-status-val.pending { color: #F50; }
    .resolve-status-val.yes { color: #0F0; }
    .resolve-status-val.no { color: #F00; }
    .resolve-btn {
      width: 100%;
      padding: 12px;
      border: none;
      background: #F50;
      color: #fff;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
      cursor: pointer;
    }
    .resolve-btn:hover { opacity: 0.8; }
    .resolve-btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .resolve-hint {
      font-size: 10px;
      opacity: 0.5;
      margin-top: 8px;
      text-align: center;
    }

    /* Price Chart Section */
    .chart-section {
      margin-top: 24px;
      padding: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(0,0,0,0.2);
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .chart-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.6;
    }
    .chart-prices {
      display: flex;
      gap: 16px;
      font-size: 12px;
    }
    .chart-price {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .chart-price-label { opacity: 0.5; }
    .chart-price-val { font-weight: bold; }
    .chart-price-val.spot { color: #0FF; }
    .chart-price-val.twap { color: #F0F; }
    .chart-container {
      height: 40px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 8px;
    }
    .price-visual {
      display: flex;
      height: 100%;
      border-radius: 4px;
      overflow: hidden;
    }
    .price-bar {
      display: flex;
      align-items: center;
      justify-content: center;
      transition: width 0.3s;
      min-width: 40px;
    }
    .price-bar.yes {
      background: linear-gradient(90deg, #0A0, #0F0);
    }
    .price-bar.no {
      background: linear-gradient(90deg, #F00, #A00);
    }
    .price-label {
      font-size: 11px;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .chart-footer {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      opacity: 0.4;
      margin-top: 4px;
    }
    .chart-link {
      font-size: 10px;
      color: #0FF;
      text-decoration: none;
      opacity: 0.7;
    }
    .chart-link:hover { opacity: 1; }
    .chart-empty {
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.3;
      font-size: 11px;
    }
    .chart-price-val.fee {
      color: #fa0;
    }
    .liquidity-breakdown {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,0.1);
    }
    .liquidity-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 4px;
    }
    .liq-label { opacity: 0.6; }
    .liq-value { font-family: monospace; }
    .orderbook-title {
      font-size: 10px;
      opacity: 0.6;
      margin: 8px 0 4px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.05);
    }
    .orderbook-side { margin-bottom: 4px; }
    .ob-level {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      padding: 1px 0;
      font-family: monospace;
    }
    .ob-price { opacity: 0.7; }
    .ob-depth.ask { color: #0f0; }
    .ob-depth.bid { color: #0cf; }
    /* Liquidity presets - brutalist */
    .liq-presets {
      display: flex;
      gap: 0;
      margin-bottom: 12px;
    }
    .liq-preset {
      flex: 1;
      padding: 10px 4px;
      background: transparent;
      border: 2px solid var(--fg);
      border-right: none;
      color: inherit;
      font-size: 12px;
      cursor: pointer;
      text-align: center;
    }
    .liq-preset:last-child { border-right: 2px solid var(--fg); }
    .liq-preset:hover { opacity: 0.6; }
    .liq-preset.active { background: var(--fg); color: var(--bg); }
    /* Split summary - minimal */
    .liq-split-bar { display: none; }
    .liq-split-legend {
      display: flex;
      justify-content: center;
      gap: 16px;
      font-size: 10px;
      opacity: 0.5;
      margin: 8px 0 16px;
    }
    .liq-leg-item { display: flex; align-items: center; gap: 4px; }
    .liq-leg-dot { width: 6px; height: 6px; }
    .liq-leg-dot.amm { background: #0f0; }
    .liq-leg-dot.vault { background: #0cf; }
    .liq-leg-dot.bids { background: #fa0; }
    /* Advanced - hidden by default */
    .advanced-toggle {
      font-size: 10px;
      opacity: 0.3;
      cursor: pointer;
      margin: 8px 0;
      text-align: center;
    }
    .advanced-toggle:hover { opacity: 0.6; }
    .advanced-toggle svg { display: none; }
    .advanced-section {
      display: none;
      padding: 12px 0;
      border-top: 1px solid rgba(128,128,128,0.2);
      margin-bottom: 12px;
    }
    .advanced-section.open { display: block; }

    /* Market Browser */
    .market-browser { width: 100%; max-width: 500px; }
    .market-filters { display: flex; gap: 0; margin-bottom: 12px; }
    .market-filter {
      flex: 1;
      padding: 10px 4px;
      background: transparent;
      border: 2px solid var(--fg);
      border-right: none;
      color: inherit;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
    }
    .market-filter:last-child { border-right: 2px solid var(--fg); }
    .market-filter:hover { opacity: 0.6; }
    .market-filter.active { background: var(--fg); color: var(--bg); }
    .market-status-filters { display: flex; gap: 0; margin-bottom: 12px; }
    .market-status-filter {
      flex: 1;
      padding: 8px 4px;
      background: transparent;
      border: 2px solid var(--fg);
      border-right: none;
      color: inherit;
      font-size: 10px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
    }
    .market-status-filter:last-child { border-right: 2px solid var(--fg); }
    .market-status-filter:hover { opacity: 0.6; }
    .market-status-filter.active { background: var(--fg); color: var(--bg); }
    .market-search {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--fg);
      background: var(--bg);
      color: var(--fg);
      font-size: 14px;
      margin-bottom: 12px;
    }
    .market-search:focus { outline: none; border-color: #0FF; }
    .market-list { max-height: 400px; overflow-y: auto; }
    .market-item {
      padding: 12px;
      border: 2px solid var(--fg);
      border-top: none;
      cursor: pointer;
    }
    .market-item:first-child { border-top: 2px solid var(--fg); }
    .market-item:hover { opacity: 0.7; }
    .market-item-q { font-size: 14px; font-weight: bold; }
    .market-item-meta { font-size: 11px; opacity: 0.6; margin-top: 4px; }
    .market-item-pct { float: right; font-size: 18px; font-weight: bold; }
    .market-type-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      margin-right: 6px;
    }
    .market-type-dot.price { background: #627EEA; }
    .market-type-dot.gas { background: #FF6B6B; }
    .market-type-dot.balance { background: #8247E5; }
    .market-empty { padding: 40px; text-align: center; opacity: 0.5; font-size: 14px; }

    /* Raw description viewer */
    .raw-desc-btn {
      cursor: pointer;
      opacity: 0.3;
      font-size: 10px;
      margin-left: 4px;
      transition: opacity 0.15s;
    }
    .raw-desc-btn:hover { opacity: 0.8; }
    .raw-desc-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--fg);
      color: var(--bg);
      padding: 8px 12px;
      font-size: 11px;
      font-family: monospace;
      white-space: nowrap;
      max-width: 90vw;
      overflow-x: auto;
      border: 2px solid var(--fg);
      z-index: 100;
      display: none;
    }
    .meta { position: relative; }

    /* Resolver info line */
    .resolver-info {
      font-size: 11px;
      opacity: 0.5;
      margin-top: 4px;
      text-align: center;
    }
    .resolver-info a {
      color: inherit;
      text-decoration: underline;
      text-decoration-color: #666;
    }
    .resolver-info a:hover { opacity: 0.7; }
    .liq-indicator {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-left: 6px;
      vertical-align: middle;
    }
    .liq-indicator.vault { background: #0F0; }
    .liq-indicator.bid { background: #FF0; }
    .liq-indicator.amm { background: #0FF; }
    .liq-indicator.none { background: #F00; opacity: 0.5; }
  </style>
</head>
<body>

<button class="corner" id="create" onclick="showCreateModal()">+ create</button>
<button class="corner" id="wallet" onclick="toggleWallet()">connect</button>
<button class="corner" id="theme" onclick="toggleTheme()">dark</button>
<button class="corner" id="browse" onclick="showBrowserModal()"># browse</button>

<div class="main">
  <h1 id="q"></h1>
  <div class="meta" id="meta"></div>
  <div class="resolver-info" id="resolverInfo" style="display:none;"></div>
  <div class="odds">
    <div class="bar y" id="yBar" onclick="vote('Y')"></div>
    <div class="bar n" id="nBar" onclick="vote('N')"></div>
    <div class="drop" id="drop">
      <div class="trade-toggle">
        <button id="buyToggle" class="active" onclick="setTradeMode('buy')">BUY</button>
        <button id="sellToggle" onclick="setTradeMode('sell')">SELL</button>
      </div>
      <input id="amt" inputmode="decimal" placeholder="0.00" oninput="calc()" onkeydown="if(event.key==='Enter')executeTrade()">
      <span class="info" id="tradeInfo">ETH &rarr; <b id="out">0.00</b> <b id="side">Y</b></span>
      <button id="tradeBtn" onclick="executeTrade()">BUY</button>
    </div>
    <button class="liq-toggle" id="liqToggle" onclick="toggleLiquidityPanel()" title="Liquidity">ðŸ’§</button>
  </div>
  <div class="positions" id="positions" style="display:none;">
    <div class="positions-title">Your Position</div>
    <div class="positions-row">
      <span class="positions-label"><span class="positions-dot yes"></span> YES</span>
      <span class="positions-value" id="yesBalance">0</span>
    </div>
    <div class="positions-row">
      <span class="positions-label"><span class="positions-dot no"></span> NO</span>
      <span class="positions-value" id="noBalance">0</span>
    </div>
    <div class="claim-section" id="claimSection" style="display:none;">
      <div class="claim-info" id="claimInfo">You have winning shares to claim</div>
      <div class="claim-amount" id="claimAmount">0 ETH</div>
      <button class="claim-btn" id="claimBtn" onclick="claim()">CLAIM</button>
    </div>
    <div class="lp-positions" id="lpPositions" style="display:none;">
      <div class="lp-positions-title">Your LP Positions</div>
      <div class="vault-stats" id="vaultStats">
        <div class="vault-stat">
          <div class="vault-stat-label">YES Vault Fees</div>
          <div class="vault-stat-value yes" id="yesVaultTotalFees">0 ETH</div>
          <div class="vault-stat-yield" id="yesVaultYield">0% yield</div>
        </div>
        <div class="vault-stat">
          <div class="vault-stat-label">NO Vault Fees</div>
          <div class="vault-stat-value no" id="noVaultTotalFees">0 ETH</div>
          <div class="vault-stat-yield" id="noVaultYield">0% yield</div>
        </div>
      </div>
      <div class="lp-pos-row" id="yesVaultRow">
        <span class="lp-pos-label"><span class="lp-pos-dot yes"></span> YES Vault</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value"><span id="yesVaultBalance">0</span><span class="lp-pos-fees" id="yesVaultFees"></span></span>
          <button class="lp-harvest-btn" id="yesHarvestBtn" onclick="harvestFees(true)">HARVEST</button>
          <button class="lp-withdraw-btn" id="yesVaultWithdrawBtn" onclick="withdrawVault(true)">WITHDRAW</button>
        </span>
      </div>
      <div class="lp-pos-row" id="noVaultRow">
        <span class="lp-pos-label"><span class="lp-pos-dot no"></span> NO Vault</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value"><span id="noVaultBalance">0</span><span class="lp-pos-fees" id="noVaultFees"></span></span>
          <button class="lp-harvest-btn" id="noHarvestBtn" onclick="harvestFees(false)">HARVEST</button>
          <button class="lp-withdraw-btn" id="noVaultWithdrawBtn" onclick="withdrawVault(false)">WITHDRAW</button>
        </span>
      </div>
      <div class="lp-pos-row" id="ammLpRow">
        <span class="lp-pos-label"><span class="lp-pos-dot amm"></span> AMM LP</span>
        <span class="lp-pos-right">
          <span class="lp-pos-value" id="ammLpBalance">0</span>
          <button class="lp-withdraw-btn" id="ammLpWithdrawBtn" onclick="withdrawAmmLP()">WITHDRAW</button>
        </span>
      </div>
      <div class="pool-stats" id="poolStats" style="display:none;">
        <div class="pool-stats-title">AMM Pool Stats</div>
        <div class="pool-stats-grid">
          <div class="pool-stat-item">
            <span class="pool-stat-label">YES Reserve</span>
            <span class="pool-stat-val yes" id="poolYesReserve">0</span>
          </div>
          <div class="pool-stat-item">
            <span class="pool-stat-label">NO Reserve</span>
            <span class="pool-stat-val no" id="poolNoReserve">0</span>
          </div>
          <div class="pool-stat-item">
            <span class="pool-stat-label">Total LP</span>
            <span class="pool-stat-val" id="poolTotalSupply">0</span>
          </div>
          <div class="pool-stat-item">
            <span class="pool-stat-label">Your Share</span>
            <span class="pool-stat-val cyan" id="poolUserShare">0%</span>
          </div>
        </div>
      </div>
    </div>
    <button class="lp-btn" id="lpBtnPos" onclick="showLPModal()" style="display:none;">+ PROVIDE LIQUIDITY</button>
  </div>
  <div class="chart-section" id="chartSection" style="display:none;">
    <div class="chart-header">
      <span class="chart-title">Market Info</span>
      <div class="chart-prices">
        <div class="chart-price">
          <span class="chart-price-label">Spot:</span>
          <span class="chart-price-val spot" id="chartSpot">--</span>
        </div>
        <div class="chart-price" id="chartTwapRow">
          <span class="chart-price-label">TWAP:</span>
          <span class="chart-price-val twap" id="chartTwap">--</span>
        </div>
        <div class="chart-price">
          <span class="chart-price-label">Fee:</span>
          <span class="chart-price-val fee" id="chartFee">--</span>
        </div>
      </div>
    </div>
    <div class="chart-container" id="chartContainer">
      <div class="chart-empty">Loading...</div>
    </div>
    <div class="liquidity-breakdown" id="liquidityBreakdown" style="display:none;">
      <div class="liquidity-row" id="liqVaultRow">
        <span class="liq-label">Vault OTC</span>
        <span class="liq-value" id="liqVault">--</span>
      </div>
      <div class="liquidity-row">
        <span class="liq-label">AMM Pool</span>
        <span class="liq-value" id="liqAmm">--</span>
      </div>
      <div id="orderbookLevels"></div>
    </div>
    <div class="chart-footer">
      <span id="chartOldest">--</span>
      <a href="#" class="chart-link" id="chartLink" target="_blank">View on ZAMM â†’</a>
      <span id="chartNewest">--</span>
    </div>
  </div>
  <div class="resolve-section" id="resolveSection" style="display:none;">
    <div class="resolve-title">MARKET RESOLUTION</div>
    <div class="resolve-status">
      <div class="resolve-status-item" id="resolveOracleRow" style="display:none;">
        <span class="resolve-status-label">Oracle</span>
        <span class="resolve-status-val" id="resolveOracle">...</span>
      </div>
      <div class="resolve-status-item">
        <span class="resolve-status-label">Oracle Value</span>
        <span class="resolve-status-val" id="resolveValue">...</span>
      </div>
      <div class="resolve-status-item">
        <span class="resolve-status-label">Threshold</span>
        <span class="resolve-status-val" id="resolveThreshold">...</span>
      </div>
      <div class="resolve-status-item">
        <span class="resolve-status-label">Condition Met</span>
        <span class="resolve-status-val" id="resolveCondition">...</span>
      </div>
      <div class="resolve-status-item">
        <span class="resolve-status-label">Status</span>
        <span class="resolve-status-val" id="resolveStatus">...</span>
      </div>
    </div>
    <button class="resolve-btn" id="resolveBtn" onclick="resolveMarket()" disabled>RESOLVE MARKET</button>
    <div class="resolve-hint" id="resolveHint">Anyone can resolve once market is ready</div>
  </div>
</div>

<div class="logo"><span id="logo" onclick="showBrowserModal()">eth</span>PM</div>

<!-- Wallet Modal -->
<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<!-- Create Market Modal -->
<div class="modal-overlay" id="createModal" onclick="if(event.target===this)closeCreateModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title" id="createModalTitle">Create Market</div>
      <button class="modal-close" onclick="closeCreateModal()">&times;</button>
    </div>

    <!-- Market Type Tabs -->
    <div class="market-type-tabs">
      <button class="market-type-tab active" onclick="switchMarketType('price')">
        <span class="tab-icon">$</span>PRICE
      </button>
      <button class="market-type-tab" onclick="switchMarketType('gas')">
        <span class="tab-icon">&#9981;</span>GAS
      </button>
      <button class="market-type-tab" onclick="switchMarketType('ethBalance')">
        <span class="tab-icon">&#9830;</span>ETH BAL
      </button>
      <button class="market-type-tab" onclick="switchMarketType('tokenBalance')">
        <span class="tab-icon">&#9673;</span>TOKEN
      </button>
    </div>

    <!-- PRICE MARKET FORM -->
    <div class="market-form-section active" id="priceForm">
      <div class="live-price">ETH <b id="livePrice">...</b></div>
      <div class="form-group">
        <label class="form-label">TARGET PRICE</label>
        <input class="form-input" id="targetPrice" type="text" inputmode="numeric" placeholder="10000" oninput="formatTargetPrice()" onblur="formatTargetPrice()">
        <div class="form-hint" id="priceDiffHint"></div>
      </div>
      <div class="form-group">
        <label class="form-label">CLOSE (UTC)</label>
        <input class="form-input" id="closeDate" type="datetime-local" oninput="updateLocalTimeHint('closeDate','closeDateHint')">
        <div class="form-hint" id="closeDateHint"></div>
      </div>
    </div>

    <!-- GAS MARKET FORM -->
    <div class="market-form-section" id="gasForm">
      <div class="live-info">GAS <b id="liveGasPrice">...</b> gwei</div>
      <div class="form-group">
        <label class="form-label">TYPE</label>
        <select class="form-input" id="gasMarketType" onchange="updateGasFormHints()">
          <option value="twap">TWAP (avg)</option>
          <option value="range">Range</option>
          <option value="peak">Peak</option>
          <option value="trough">Trough</option>
        </select>
      </div>
      <div class="form-group" id="gasThresholdGroup">
        <label class="form-label">THRESHOLD (GWEI)</label>
        <input class="form-input" id="gasThreshold" type="number" placeholder="30" step="1" min="1">
      </div>
      <div class="form-group" id="gasRangeGroup" style="display: none;">
        <label class="form-label">RANGE (GWEI)</label>
        <div class="form-row">
          <input class="form-input" id="gasLower" type="number" placeholder="20" step="1" min="1">
          <input class="form-input" id="gasUpper" type="number" placeholder="50" step="1" min="1">
        </div>
      </div>
      <div class="form-group" id="gasOpGroup">
        <label class="form-label">COMPARE</label>
        <select class="form-input" id="gasOp">
          <option value="2">â‰¤</option>
          <option value="3">â‰¥</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">CLOSE (UTC)</label>
        <input class="form-input" id="gasCloseDate" type="datetime-local" oninput="updateLocalTimeHint('gasCloseDate','gasCloseDateHint')">
        <div class="form-hint" id="gasCloseDateHint"></div>
      </div>
    </div>

    <!-- ETH BALANCE MARKET FORM -->
    <div class="market-form-section" id="ethBalanceForm">
      <div class="form-group">
        <label class="form-label">ADDRESS</label>
        <input class="form-input" id="ethBalanceAddress" type="text" placeholder="0x... or ENS" oninput="resolveENS('ethBalance')">
        <div class="form-hint" id="ethBalanceResolved"></div>
      </div>
      <div class="form-group">
        <label class="form-label">â‰¥ ETH</label>
        <input class="form-input" id="ethBalanceThreshold" type="number" placeholder="100" step="0.01" min="0">
      </div>
      <div class="form-group">
        <label class="form-label">CLOSE (UTC)</label>
        <input class="form-input" id="ethBalanceCloseDate" type="datetime-local" oninput="updateLocalTimeHint('ethBalanceCloseDate','ethBalanceCloseDateHint')">
        <div class="form-hint" id="ethBalanceCloseDateHint"></div>
      </div>
    </div>

    <!-- TOKEN BALANCE MARKET FORM -->
    <div class="market-form-section" id="tokenBalanceForm">
      <div class="form-group">
        <label class="form-label">TOKEN</label>
        <input class="form-input" id="tokenAddress" type="text" placeholder="0x...">
        <div class="form-hint" id="tokenInfo"></div>
      </div>
      <div class="form-group">
        <label class="form-label">ADDRESS</label>
        <input class="form-input" id="tokenBalanceAddress" type="text" placeholder="0x... or ENS" oninput="resolveENS('tokenBalance')">
        <div class="form-hint" id="tokenBalanceResolved"></div>
      </div>
      <div class="form-group">
        <label class="form-label">â‰¥ TOKENS</label>
        <input class="form-input" id="tokenBalanceThreshold" type="number" placeholder="1000000" step="1" min="0">
      </div>
      <div class="form-group">
        <label class="form-label">CLOSE (UTC)</label>
        <input class="form-input" id="tokenBalanceCloseDate" type="datetime-local" oninput="updateLocalTimeHint('tokenBalanceCloseDate','tokenBalanceCloseDateHint')">
        <div class="form-hint" id="tokenBalanceCloseDateHint"></div>
      </div>
    </div>

    <!-- SEED LIQUIDITY -->
    <div class="form-divider">SEED LIQUIDITY (ETH)</div>

    <div class="liq-presets">
      <button type="button" class="liq-preset active" onclick="setLiqPreset(0.01)">0.01</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(0.1)">0.1</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(0.5)">0.5</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(1)">1.0</button>
    </div>

    <input class="form-input" id="totalLiquidity" type="number" placeholder="0.01" step="0.01" min="0.001" value="0.01" oninput="updateLiqSplit()" style="margin-bottom:8px">

    <div class="liq-split-bar" id="liqSplitBar"></div>
    <div class="liq-split-legend">
      <span id="liqLegAmm">AMM</span>
      <span id="liqLegVault">Vault</span>
      <span id="liqLegBids">Bids</span>
    </div>

    <div class="advanced-toggle" id="advancedToggle" onclick="toggleAdvanced()">+ advanced</div>

    <div class="advanced-section" id="advancedSection">
      <!-- Hidden inputs to hold computed values (used by existing code) -->
      <input type="hidden" id="seedAmount">
      <input type="checkbox" id="enableVault" style="display:none">
      <input type="hidden" id="vaultAmount">
      <input type="hidden" id="vaultYesPct" value="50">
      <input type="hidden" id="vaultNoPct" value="50">
      <input type="checkbox" id="enableBids" style="display:none">
      <input type="hidden" id="bidsAmount">
      <input type="hidden" id="bidSpreadPreset" value="balanced">
      <input type="checkbox" id="enableInitialBuy" style="display:none">
      <input type="hidden" id="initialBuySide" value="yes">
      <input type="hidden" id="initialBuyAmount">

      <!-- Manual AMM override -->
      <div class="form-group">
        <label class="form-label">AMM (ETH)</label>
        <input class="form-input" id="manualAmmAmount" type="number" placeholder="auto" step="0.01" min="0" oninput="onManualSplitChange()">
      </div>

      <!-- Vault config -->
      <div class="form-group">
        <label class="form-label">VAULT (ETH)</label>
        <input class="form-input" id="manualVaultAmount" type="number" placeholder="auto" step="0.01" min="0" oninput="onManualSplitChange()">
      </div>
      <div style="display:flex;gap:8px">
        <div class="form-group" style="flex:1">
          <label class="form-label">YES %</label>
          <input class="form-input" id="manualVaultYesPct" type="number" placeholder="50" step="1" min="0" max="100" value="50">
        </div>
        <div class="form-group" style="flex:1">
          <label class="form-label">NO %</label>
          <input class="form-input" id="manualVaultNoPct" type="number" placeholder="50" step="1" min="0" max="100" value="50">
        </div>
      </div>

      <!-- Orderbook config -->
      <div class="form-group">
        <label class="form-label">BIDS (ETH)</label>
        <input class="form-input" id="manualBidsAmount" type="number" placeholder="auto" step="0.01" min="0" oninput="onManualSplitChange()">
      </div>
      <div class="form-group">
        <label class="form-label">SPREAD</label>
        <select class="form-input" id="manualBidSpread">
          <option value="balanced">25-75%</option>
          <option value="tight">35-65%</option>
          <option value="wide">15-85%</option>
          <option value="yesOnly">YES 20-45%</option>
          <option value="noOnly">NO 55-80%</option>
        </select>
      </div>

      <!-- Initial buy -->
      <div class="form-group">
        <label class="form-label">
          <input type="checkbox" id="manualEnableInitialBuy" style="margin-right:6px">
          SKEW ODDS
        </label>
      </div>
      <div id="initialBuyAdvanced" style="display:none">
        <div style="display:flex;gap:8px">
          <div class="form-group" style="flex:1">
            <label class="form-label">SIDE</label>
            <select class="form-input" id="manualInitialBuySide">
              <option value="yes">YES</option>
              <option value="no">NO</option>
            </select>
          </div>
          <div class="form-group" style="flex:1">
            <label class="form-label">AMOUNT</label>
            <input class="form-input" id="manualInitialBuyAmount" type="number" placeholder="0.01" step="0.001" min="0">
          </div>
        </div>
      </div>
    </div>

    <button class="form-btn" id="createBtn" onclick="createMarket()">CREATE MARKET</button>
  </div>
</div>

<!-- LP Modal -->
<div class="modal-overlay" id="lpModal" onclick="if(event.target===this)closeLPModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Provide Liquidity</div>
      <button class="modal-close" onclick="closeLPModal()">&times;</button>
    </div>
    <div class="lp-summary">
      <div class="lp-summary-item">
        <div class="lp-summary-label">Market</div>
        <div class="lp-summary-value" id="lpMarketName">ETH $10K</div>
      </div>
      <div class="lp-summary-item">
        <div class="lp-summary-label">TVL</div>
        <div class="lp-summary-value" id="lpTvl">0 ETH</div>
      </div>
    </div>
    <div class="form-group">
      <label class="form-label">AMOUNT (ETH)</label>
      <input class="form-input" id="lpAmount" type="number" placeholder="0.1" step="0.01" min="0.001" oninput="updateLPPreview()">
    </div>
    <div class="lp-allocation">
      <div class="lp-alloc-row">
        <span class="lp-alloc-label yes">YES Vault</span>
        <input type="range" class="lp-alloc-slider" id="lpYesSlider" min="0" max="100" value="0" oninput="updateLPAllocation('yes')">
        <span class="lp-alloc-pct" id="lpYesPct">0%</span>
      </div>
      <div class="lp-alloc-hint">Earn from YES share sells</div>
      <div class="lp-alloc-row">
        <span class="lp-alloc-label no">NO Vault</span>
        <input type="range" class="lp-alloc-slider" id="lpNoSlider" min="0" max="100" value="0" oninput="updateLPAllocation('no')">
        <span class="lp-alloc-pct" id="lpNoPct">0%</span>
      </div>
      <div class="lp-alloc-hint">Earn from NO share sells</div>
      <div class="lp-alloc-row">
        <span class="lp-alloc-label amm">AMM LP</span>
        <input type="range" class="lp-alloc-slider" id="lpAmmSlider" min="0" max="100" value="100" oninput="updateLPAllocation('amm')">
        <span class="lp-alloc-pct" id="lpAmmPct">100%</span>
      </div>
      <div class="lp-alloc-hint">Earn swap fees from both sides</div>
    </div>
    <div class="lp-preview">
      <div class="lp-preview-title">You will receive</div>
      <div class="lp-preview-row">
        <span>YES Vault Shares</span>
        <span id="lpPreviewYes">0</span>
      </div>
      <div class="lp-preview-row">
        <span>NO Vault Shares</span>
        <span id="lpPreviewNo">0</span>
      </div>
      <div class="lp-preview-row">
        <span>AMM LP Tokens</span>
        <span id="lpPreviewAmm">0</span>
      </div>
    </div>
    <button class="form-btn" id="lpBtn" onclick="provideLiquidity()">PROVIDE LIQUIDITY</button>
  </div>
</div>

<!-- Browser Modal -->
<div class="modal-overlay" id="browserModal" onclick="if(event.target===this)closeBrowserModal()">
  <div class="modal market-browser">
    <div class="modal-header">
      <div class="modal-title">MARKETS</div>
      <button class="modal-close" onclick="closeBrowserModal()">&times;</button>
    </div>
    <div class="market-filters">
      <button class="market-filter active" onclick="setBrowserFilter('all')">ALL</button>
      <button class="market-filter" onclick="setBrowserFilter('price')">PRICE</button>
      <button class="market-filter" onclick="setBrowserFilter('gas')">GAS</button>
      <button class="market-filter" onclick="setBrowserFilter('balance')">BALANCE</button>
    </div>
    <div class="market-status-filters">
      <button class="market-status-filter active" onclick="setBrowserStatus('open')">OPEN</button>
      <button class="market-status-filter" onclick="setBrowserStatus('resolved')">RESOLVED</button>
      <button class="market-status-filter" onclick="setBrowserStatus('all')">ALL</button>
    </div>
    <input class="market-search" id="browserSearch" type="text" placeholder="search..." oninput="onBrowserSearch(event)">
    <div class="market-list" id="browserList"></div>
  </div>
</div>

<script>
// ======================== CONTRACTS ========================
const CONTRACTS = {
  PAMM: '0x000000000044bfe6c2BBFeD8862973E0612f07C0',
  ZAMM: '0x000000000000040470635EB91b7CE4D132D616eD',
  MASTER_ROUTER: '0x000000000055CdB14b66f37B96a571108FFEeA5C',
  PM_ROUTER: '0x000000000055ff709f26efb262fba8b0ae8c35dc', // Legacy router for 30 bps fee tier markets
  RESOLVER: '0x00000000002205020E387b6a378c05639047BcFB',
  PM_HOOK_ROUTER: '0x0000000000BADa259Cb860c12ccD9500d9496B3e',
  PM_FEE_HOOK: '0x0000000000Cc736804447C7E1dC8d3683a37f1a9', // ZAMM pool hook for dynamic fees
  QUOTER: '0x0000000000F0Bf4EA3A43560324376e62FE390BC',
  BOOTSTRAPPER: '0x000000000011Cc5e626DAA3077B655057B37E8bb',
  GASPM: '0x0000000000ee3d4294438093EaA34308f47Bc0b4',
  CHAINLINK_ETH_USD: '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419'
};

const PAMM_ABI = [
  'function markets(uint256) view returns (address resolver, bool resolved, bool outcome, bool canClose, uint64 close, address collateral, uint256 collateralLocked)',
  'function totalSupplyId(uint256) view returns (uint256)',
  'function tradingOpen(uint256) view returns (bool)',
  'function getMarketId(string description, address resolver, address collateral) pure returns (uint256)',
  'function getNoId(uint256 marketId) pure returns (uint256)',
  'function balanceOf(address, uint256) view returns (uint256)',
  'function setOperator(address, bool)',
  'function isOperator(address, address) view returns (bool)',
  'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
  'function claimMany(uint256[] marketIds, address to) returns (uint256 totalPayout)',
  'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
  'function getMarkets(uint256 start, uint256 count) view returns (uint256[] marketIds, address[] resolvers, address[] collaterals, uint8[] states, uint64[] closes, uint256[] collateralAmounts, uint256[] yesSupplies, uint256[] noSupplies, string[] descs, uint256 next)',
  'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
  'function poolKey(uint256 marketId, uint256 feeOrHook) view returns (tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook))',
  'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
  'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)'
];

const ZAMM_ABI = [
  'function balanceOf(address, uint256) view returns (uint256)',
  'function pools(uint256) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)',
  'function setOperator(address, bool)',
  'function isOperator(address, address) view returns (bool)',
  'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)',
  'event Swap(uint256 indexed poolId, address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to)'
];

// Legacy PM Router for 30 bps fee tier markets (atomic split+swap)
const PM_ROUTER_ABI = [
  'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
  'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)',
  'function claim(uint256 marketId, address to) returns (uint256 payout)',
  'function split(uint256 marketId, uint256 amount, address to) payable'
];

const QUOTER_ABI = [
  'function getTWAPPrice(uint256 marketId) view returns (uint256 twapBps)',
  'function getMarketSummary(uint256 marketId) view returns (uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammPriceYesBps, uint256 feeBps, uint112 vaultYesShares, uint112 vaultNoShares, uint256 totalYesVaultLP, uint256 totalNoVaultLP, uint256 vaultBudget, uint256 twapPriceYesBps, uint64 closeTime, bool resolved, bool inCloseWindow)',
  'function getUserFullPosition(uint256 marketId, address user) view returns (uint256 yesShareBalance, uint256 noShareBalance, uint112 yesVaultLP, uint112 noVaultLP, uint256 pendingYesCollateral, uint256 pendingNoCollateral)',
  'function quoteBootstrapBuy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut) view returns (uint256 totalSharesOut, bool usesVault, bytes4 source, uint256 vaultSharesMinted)',
  'function quoteSellWithBootstrap(uint256 marketId, bool sellYes, uint256 sharesIn) view returns (uint256 collateralOut, bytes4 source)',
  'function getLiquidityBreakdown(uint256 marketId, bool buyYes) view returns (uint256 vaultOtcShares, uint256 vaultOtcPriceBps, bool vaultOtcAvailable, uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammSpotPriceBps, uint256 ammMaxImpactBps, uint256 poolAskDepth, uint256 poolBestAskBps, uint256 poolBidDepth, uint256 poolBestBidBps)',
  'function quoteBuyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, uint256 pmSharesOut, bytes4 pmSource)',
  'function quoteSellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, uint256 pmCollateralOut, bytes4 pmSource)',
  'function getActiveLevels(uint256 marketId, bool isYes, uint256 maxLevels) view returns (uint256[] askPrices, uint256[] askDepths, uint256[] bidPrices, uint256[] bidDepths)'
];

const PM_HOOK_ROUTER_ABI = [
  'function vaultPositions(uint256, address) view returns (uint112 yesVaultShares, uint112 noVaultShares, uint32 lastDepositTime, uint256 yesRewardDebt, uint256 noRewardDebt)',
  'function withdrawFromVault(uint256 marketId, bool isYes, uint256 vaultSharesToRedeem, address receiver, uint256 deadline) returns (uint256 sharesReturned, uint256 feesEarned)',
  'function harvestVaultFees(uint256 marketId, bool isYes) returns (uint256 feesEarned)',
  'function totalYesVaultShares(uint256) view returns (uint256)',
  'function totalNoVaultShares(uint256) view returns (uint256)',
  'function accYesCollateralPerShare(uint256) view returns (uint256)',
  'function accNoCollateralPerShare(uint256) view returns (uint256)',
  'function bootstrapVaults(uint256) view returns (uint112 yesShares, uint112 noShares, uint32 lastActivity)',
  'function bootstrapMarket(string description, address resolver, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)'
];

const MASTER_ROUTER_ABI = [
  'function buy(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 poolPriceInBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, bytes4[] sources)',
  'function buyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function sell(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 bidPoolPriceInBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, bytes4[] sources)',
  'function sellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function provideLiquidity(uint256 marketId, uint256 collateralAmount, uint256 vaultYesShares, uint256 vaultNoShares, uint256 ammLPShares, uint256 minAmount0, uint256 minAmount1, address receiver, uint256 deadline) payable returns (uint256 yesVaultSharesMinted, uint256 noVaultSharesMinted, uint256 ammLiquidity)'
];

const RESOLVER_ABI = [
  'function createNumericMarketAndSeed(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose, tuple(uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) seed) payable returns (uint256 marketId, uint256 noId, uint256 shares, uint256 liquidity)',
  'function createNumericMarket(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose) returns (uint256 marketId, uint256 noId)',
  'function registerConditionForExistingMarket(uint256 marketId, address target, bytes callData, uint8 op, uint256 threshold)',
  'function resolveMarket(uint256 marketId)',
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)'
];

const BOOTSTRAPPER_ABI = [
  // Open resolver markets (UMA, Reality.eth, EOA, etc.)
  'function bootstrapMarket(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapMarketWithBids(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapMarketWithVault(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapMarketWithVaultAndBids(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - generic condition
  'function bootstrapWithCondition(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapWithConditionAndBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapWithConditionAndVault(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapWithConditionAndVaultAndBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - price feed markets (Chainlink)
  'function bootstrapPriceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapPriceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapPriceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapPriceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - ETH balance markets
  'function bootstrapETHBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapETHBalanceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapETHBalanceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapETHBalanceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Resolver.sol - ERC20 token balance markets
  'function bootstrapTokenBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapTokenBalanceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapTokenBalanceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapTokenBalanceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // GasPM-style gas markets (via HookRouter + Resolver)
  'function bootstrapGasTWAPMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasTWAPMarketWithVault(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapGasRangeMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 lower, uint256 upper, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasVolatilityMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasPeakMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasTroughMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  // Gas markets (no bids variants)
  'function bootstrapGasTWAPMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasRangeMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 lower, uint256 upper) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasVolatilityMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasPeakMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasTroughMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  // Spot gas markets (checks block.basefee at resolution)
  'function bootstrapGasSpotMarket(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapGasSpotMarketWithBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, uint8 op, uint256 threshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  // Orderbook liquidity
  'function addOrderbookBids(uint256 marketId, address collateral, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids, address to) payable',
  // View helpers
  'function computeMarketId(string description, address resolverAddr, address collateral) view returns (uint256)',
  'function computeMarketIdResolver(string description, address collateral) view returns (uint256)',
  // Multicall & permit
  'function multicall(bytes[] data) payable returns (bytes[] results)',
  'function permit(address token, address owner, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  'function permitDAI(address token, address owner, uint256 nonce, uint256 deadline, bool allowed, uint8 v, bytes32 r, bytes32 s)'
];

const CHAINLINK_ABI = [
  'function latestAnswer() view returns (int256)',
  'function decimals() view returns (uint8)'
];

// Op enum: 0=LT, 1=GT, 2=LTE, 3=GTE, 4=EQ, 5=NEQ
const OP = { LT: 0, GT: 1, LTE: 2, GTE: 3, EQ: 4, NEQ: 5 };

// ======================== STATE ========================
let markets = [];
let currentIndex = 0;
let dir = null;
let dark = localStorage.theme === 'dark' || (!localStorage.theme && matchMedia('(prefers-color-scheme:dark)').matches);
let isTrading = false;
let tradeMode = 'buy'; // 'buy' or 'sell'
let userPositions = { yes: 0n, no: 0n };
let lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
let vaultStats = {
  yesTotalShares: 0n, noTotalShares: 0n,       // Total vault shares (LP tokens)
  yesUnderlying: 0n, noUnderlying: 0n,         // Underlying Y/N shares in vault
  yesTotalFees: 0n, noTotalFees: 0n            // Total fees distributed
};
let poolStats = {
  reserve0: 0n, reserve1: 0n,                  // Pool reserves (YES/NO)
  totalSupply: 0n,                             // Total LP tokens
  userShare: 0,                                // User's % of pool
  yesReserve: 0n, noReserve: 0n,              // Mapped reserves
  impliedYesPrice: 50                          // Implied YES price %
};
let resolutionStatus = {
  value: 0n,        // Current oracle value
  threshold: 0n,    // Target threshold
  condTrue: false,  // Is condition met
  ready: false,     // Can be resolved
  op: 0             // Operator (0=LT, 1=GT, 2=LTE, 3=GTE)
};
let priceChart = {
  spotBps: 0,       // Current spot price in bps
  twapBps: 0,       // Current TWAP in bps
  poolId: null      // ZAMM pool ID for link
};
let liquiditySources = {
  hasVault: false,      // Has OTC vault liquidity
  hasBidPool: false,    // Has bid pool liquidity
  hasAmm: false         // Has AMM liquidity
};

// ENS reverse lookup cache
const ensCache = new Map();

// Token logos - extensible registry mapping address (lowercase) to SVG
// Add new tokens here as needed
const TOKEN_LOGOS = {
  // Chainlink (LINK)
  '0x514910771af9ca656af840dff83e8264ecf986ca': `<svg width="16" height="16" viewBox="0 0 24 24" role="img" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><path fill="currentColor" d="M12 0 9.798 1.266l-6 3.468L1.596 6v12l2.202 1.266 6.055 3.468L12.055 24l2.202-1.266 5.945-3.468L22.404 18V6l-2.202-1.266-6-3.468zM6 15.468V8.532l6-3.468 6 3.468v6.936l-6 3.468z"/></svg>`,
  // ETH (for reference, used in balance displays)
  'eth': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><path fill="currentColor" d="M16 0l-1 3.4v18.8l1 1 7.5-4.4zm0 24.5l7.5-4.4-7.5-3.4zm0-8.8l7.5 4.4L16 3.4zM8.5 20.1L16 24.5v-8.8zm0-3.5L16 21.1V3.4z"/></svg>`,
};

// Chainlink price feed addresses (for displaying logo next to price feeds)
const CHAINLINK_FEEDS = new Set([
  '0x5f4ec3df9cbd43714fe2740f5e3616155c5b8419', // ETH/USD
  '0xf4030086522a5beea4988f8ca5b36dbc97bee88c', // BTC/USD
  '0x2c1d072e956affc0d435cb7ac38ef18d24d9127c', // LINK/USD
  // Add more feeds as needed
].map(a => a.toLowerCase()));

// Get token logo SVG by address, returns empty string if not found
function getTokenLogo(address) {
  if (!address) return '';
  return TOKEN_LOGOS[address.toLowerCase()] || '';
}

// Check if address is a known Chainlink feed
function isChainlinkFeed(address) {
  if (!address) return false;
  return CHAINLINK_FEEDS.has(address.toLowerCase());
}

// Check if market uses our labeling convention (PRICE|, GAS|, TOKBAL|, ETHBAL|)
// Markets with our labels have the full infrastructure (vault, bid pools, etc)
// Legacy/external markets only have PAMM AMM liquidity with 30 bps fee
function isOurLabeledMarket(description) {
  if (!description) return false;
  return description.startsWith('PRICE|') ||
         description.startsWith('GAS|') ||
         description.startsWith('TOKBAL|') ||
         description.startsWith('ETHBAL|');
}

// ======================== LOCAL AMM QUOTE FUNCTIONS ========================
// Constant product AMM math for direct PAMM/ZAMM trading fallback
// Used for legacy/external markets without vault infrastructure

const LEGACY_FEE_BPS = 30; // 0.3% fee for legacy markets

// Quote buying YES shares with ETH (constant product formula)
// collateralIn â†’ YES shares out
function quoteBuyYes(collateralInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  // fee applied to input
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = collateralInWei * feeMultiplier / 10000n;
  // Mint YES+NO, sell NO to pool: out = rNo - (rYes * rNo) / (rYes + amountInWithFee)
  // Simplified: sharesOut â‰ˆ collateralIn * rNo / (rYes + collateralIn)
  const numerator = amountInWithFee * rNo;
  const denominator = rYes + amountInWithFee;
  return numerator / denominator;
}

// Quote buying NO shares with ETH
function quoteBuyNo(collateralInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = collateralInWei * feeMultiplier / 10000n;
  const numerator = amountInWithFee * rYes;
  const denominator = rNo + amountInWithFee;
  return numerator / denominator;
}

// Quote selling YES shares for ETH
function quoteSellYes(sharesInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  // Sell YES to pool for NO, merge NO+YES â†’ collateral
  const feeMultiplier = 10000n - BigInt(feeBps);
  // noOut = rNo - (rYes * rNo) / (rYes + sharesIn * feeMultiplier)
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const numerator = amountInWithFee * rNo;
  const denominator = rYes + amountInWithFee;
  const noOut = numerator / denominator;
  // Can redeem min(sharesIn, noOut) for collateral
  return noOut < sharesInWei ? noOut : sharesInWei;
}

// Quote selling NO shares for ETH
function quoteSellNo(sharesInWei, rYes, rNo, feeBps = LEGACY_FEE_BPS) {
  if (rYes === 0n || rNo === 0n) return 0n;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const numerator = amountInWithFee * rYes;
  const denominator = rNo + amountInWithFee;
  const yesOut = numerator / denominator;
  return yesOut < sharesInWei ? yesOut : sharesInWei;
}

// Get effective price impact for a given trade size
function getAmmPriceImpact(inputWei, rIn, rOut, feeBps = LEGACY_FEE_BPS) {
  if (rIn === 0n || rOut === 0n) return 0;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = inputWei * feeMultiplier / 10000n;
  // spotPrice before = rOut / rIn
  // effective price = output / input
  const output = amountInWithFee * rOut / (rIn + amountInWithFee);
  const spotBefore = Number(rOut) / Number(rIn);
  const effectivePrice = Number(output) / Number(inputWei);
  const impact = ((spotBefore - effectivePrice) / spotBefore) * 100;
  return Math.max(0, impact);
}

// Wallet state
let provider = null;
let signer = null;
let connectedAddress = null;
let connectedWalletProvider = null;
let walletConnectProvider = null;
let isConnecting = false;
const eip6963Providers = new Map();

// RPC provider for read-only calls with fallbacks
const RPC_ENDPOINTS = [
  'https://eth.llamarpc.com',
  'https://ethereum.publicnode.com',
  'https://1rpc.io/eth',
  'https://rpc.ankr.com/eth'
];
let rpcProvider = null;

async function getRpc() {
  if (rpcProvider) return rpcProvider;

  for (const rpc of RPC_ENDPOINTS) {
    try {
      const p = new ethers.JsonRpcProvider(rpc);
      await p.getBlockNumber(); // test connection
      rpcProvider = p;
      console.log('Connected to RPC:', rpc);
      return rpcProvider;
    } catch (e) {
      console.warn(`RPC ${rpc} failed, trying next...`);
    }
  }
  throw new Error('All RPC endpoints failed');
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
  coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
  rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
  rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
  walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
};

const $ = id => document.getElementById(id);

// ======================== INIT ========================
async function init() {
  if (dark) { document.documentElement.dataset.theme = 'dark'; $('theme').textContent = 'light'; }
  initEIP6963();
  handleDeepLink();

  // Show loading state
  $('q').innerHTML = 'Loading markets...';
  $('meta').textContent = 'scanning blockchain for prediction markets';

  // Auto-reconnect wallet
  const savedWallet = localStorage.getItem('ethpm_wallet');
  if (savedWallet) {
    setTimeout(() => connectWithWallet(savedWallet).catch(() => localStorage.removeItem('ethpm_wallet')), 100);
  }

  // Load markets and render
  await loadMarkets();
  render();
  startCountdownTimer();
  startAutoRefresh();
  loadPositions();
  loadResolutionStatus();
  loadPriceChart();
}

// ======================== DEEP LINKING ========================
function handleDeepLink() {
  const path = window.location.pathname;
  const hash = window.location.hash;

  // Support /MARKET_ID or #MARKET_ID
  let marketId = null;
  if (path && path.length > 1) {
    marketId = path.slice(1);
  } else if (hash && hash.length > 1) {
    marketId = hash.slice(1);
  }

  if (marketId && /^[0-9]+$/.test(marketId)) {
    // Will be handled after markets load
    window.deepLinkMarketId = marketId;
  }
}

function getMarketUrl(marketId) {
  return `${window.location.origin}/#${marketId}`;
}

function shareMarket() {
  const m = markets[currentIndex];
  if (!m?.marketId) return;
  const url = getMarketUrl(m.marketId);
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('shareBtn');
    if (btn) {
      btn.textContent = '\u2713';
      setTimeout(() => btn.innerHTML = '&#128279;', 1500);
    }
  });
}

// ENS reverse lookup with caching
async function lookupENS(address) {
  if (!address) return null;
  const key = address.toLowerCase();

  // Check cache first
  if (ensCache.has(key)) return ensCache.get(key);

  // Mark as pending to avoid duplicate lookups
  ensCache.set(key, null);

  try {
    const rpc = provider || await getRpc();
    const name = await rpc.lookupAddress(address);
    ensCache.set(key, name);
    return name;
  } catch (e) {
    // ENS lookup failed, leave as null
    return null;
  }
}

// Format address with optional ENS and Etherscan link
function formatAddressLink(address, ensName = null) {
  const short = `${address.slice(0,6)}...${address.slice(-4)}`;
  const display = ensName || short;
  return `<a href="https://etherscan.io/address/${address}" target="_blank" rel="noopener" style="opacity:0.6">${display}</a>`;
}

// ======================== MARKET LOADING ========================
function formatQuestion(threshold, close) {
  const price = threshold >= 1000 ? `$${(threshold/1000).toFixed(0)}K` : `$${threshold}`;
  const date = new Date(close * 1000);
  const dateStr = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
  return `WILL <u style="text-decoration-color:#627EEA">ETH</u> HIT <u style="text-decoration-color:#0F0">${price}</u> BY <u style="text-decoration-color:#F50">${dateStr}</u>?`;
}

// localStorage cache keys
const CACHE_MARKETS_KEY = 'ethpm_markets';
const CACHE_VERSION = 2; // Bump to invalidate cache on schema changes

// Demo market (always shown last)
const DEMO_MARKET = {
  id: 'demo',
  marketId: null,
  q: 'WILL <u style="text-decoration-color:#627EEA">ETH</u> HIT <u style="text-decoration-color:#0F0">$10K</u> BY <u style="text-decoration-color:#F50">2027</u>?',
  c: '#627EEA',
  logo: 'eth',
  y: 50,
  isDemo: true,
  threshold: 10000,
  close: Math.floor(new Date('2027-01-01').getTime() / 1000)
};

// Load cached markets from localStorage
function loadCachedMarkets() {
  try {
    const cached = localStorage.getItem(CACHE_MARKETS_KEY);
    if (!cached) return { markets: [], timestamp: 0 };
    const data = JSON.parse(cached);
    if (data.version !== CACHE_VERSION) return { markets: [], timestamp: 0 };
    return { markets: data.markets || [], timestamp: data.timestamp || 0 };
  } catch (e) {
    return { markets: [], timestamp: 0 };
  }
}

// Save markets to localStorage
function cacheMarkets(marketList) {
  try {
    localStorage.setItem(CACHE_MARKETS_KEY, JSON.stringify({
      version: CACHE_VERSION,
      markets: marketList.filter(m => !m.isDemo),
      timestamp: Date.now()
    }));
  } catch (e) {
    console.warn('Failed to cache markets:', e);
  }
}

async function loadMarkets() {
  try {
    const rpc = await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

    // 1. Load from cache first for instant display
    const { markets: cachedMarkets, timestamp: cacheTime } = loadCachedMarkets();
    markets = [...cachedMarkets, DEMO_MARKET];

    // If we have cached markets, show them immediately
    if (cachedMarkets.length > 0) {
      console.log(`Loaded ${cachedMarkets.length} markets from cache`);
      render();
    }

    // 2. Skip refresh if cache is less than 30 seconds old (unless no cache)
    const cacheAge = Date.now() - cacheTime;
    if (cachedMarkets.length > 0 && cacheAge < 30000) {
      console.log('Using fresh cache, skipping RPC fetch');
      return;
    }

    // 3. Try to fetch all markets in one batch call
    console.log('Fetching markets via getMarkets...');

    let allFetched = [];
    let fetchSuccess = false;

    try {
      const PAGE_SIZE = 50;
      let start = 0;

      // Paginate through all markets from PAMM.getMarkets
      while (true) {
        console.log(`Fetching markets ${start} to ${start + PAGE_SIZE}...`);
        const result = await pamm.getMarkets(start, PAGE_SIZE, { gasLimit: 5000000 });

        const batchSize = result.marketIds.length;
        console.log(`Got ${batchSize} markets in batch`);

        // Process this batch
        for (let i = 0; i < batchSize; i++) {
          const resolver = result.resolvers[i];
          // Filter for our Resolver only
          if (resolver.toLowerCase() !== CONTRACTS.RESOLVER.toLowerCase()) continue;

          const marketId = result.marketIds[i].toString();
          const description = result.descs[i];
          const close = Number(result.closes[i]);
          const yesSupply = result.yesSupplies[i];
          const noSupply = result.noSupplies[i];
          const tvl = Number(result.collateralAmounts[i]) / 1e18;
          const states = Number(result.states[i]);
          const resolved = (states & 1) !== 0;
          const outcome = (states & 2) !== 0;

          const parsed = parseMarketDescription(description);
          const total = yesSupply + noSupply;
          const yPct = total > 0n ? Number((noSupply * 100n) / total) : 50;

          allFetched.push({
            id: marketId.slice(-6),
            marketId: marketId,
            q: parsed.question,
            c: parsed.color,
            logo: parsed.logo,
            y: yPct,
            isDemo: false,
            close: close,
            resolved: resolved,
            outcome: outcome,
            threshold: parsed.threshold,
            tvl: tvl,
            description: description,
            resolver: resolver
          });
        }

        // Check if more pages
        const next = Number(result.next);
        if (next === 0) break;
        start = next;
      }

      console.log(`Fetched ${allFetched.length} markets from our Resolver`);
      fetchSuccess = true;
    } catch (fetchErr) {
      console.warn('getMarkets failed, using cache:', fetchErr.message);
      // Keep using cached markets, don't update
    }

    if (fetchSuccess) {
      // Sort by TVL (highest first)
      allFetched.sort((a, b) => (b.tvl || 0) - (a.tvl || 0));

      // Update markets list
      markets = [...allFetched, DEMO_MARKET];

      // Cache updated list
      cacheMarkets(allFetched);
    }

    // Handle deep link - find and move to front
    if (window.deepLinkMarketId) {
      const idx = markets.findIndex(m => m.marketId === window.deepLinkMarketId);
      if (idx > 0) {
        const [market] = markets.splice(idx, 1);
        markets.unshift(market);
      } else if (idx === -1) {
        // Market not in discovered list, try to load directly
        await loadMarketById(window.deepLinkMarketId);
      }
      currentIndex = 0;
    }
  } catch (e) {
    console.warn('Failed to load markets:', e);
  }
}

// Load a single market by ID and add to the list
async function loadMarketById(marketIdStr) {
  try {
    const rpc = await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const marketId = BigInt(marketIdStr);
    const market = await pamm.markets(marketId);

    if (market.resolver === ethers.ZeroAddress) {
      console.warn('Market not found:', marketIdStr);
      return null;
    }

    const yesSupply = await pamm.totalSupplyId(marketId);
    const noId = await pamm.getNoId(marketId);
    const noSupply = await pamm.totalSupplyId(noId);
    const total = yesSupply + noSupply;
    const yPct = total > 0n ? Number((noSupply * 100n) / total) : 50;

    // Try to get description from Quoter or use generic
    let description = '';
    let question = `Market #${marketIdStr.slice(0,8)}...`;
    let color = '#627EEA';
    let logo = 'eth';

    const newMarket = {
      id: marketIdStr.slice(-6),
      marketId: marketIdStr,
      q: question,
      c: color,
      logo: logo,
      y: yPct,
      isDemo: false,
      close: Number(market.close),
      resolved: market.resolved,
      outcome: market.outcome,
      description: description
    };

    // Add to front of list if not already present
    const existing = markets.findIndex(m => m.marketId === marketIdStr);
    if (existing === -1) {
      markets.unshift(newMarket);
    } else {
      markets[existing] = newMarket;
    }

    render();
    return newMarket;
  } catch (e) {
    console.warn('Failed to load market by ID:', e);
    return null;
  }
}

// Parse market description to extract display info
// Format: TYPE|...fields...|CLOSE
// PRICE|ASSET|QUOTE|OP|THRESHOLD|CLOSE  (e.g., PRICE|ETH|USD|3|5000|1800048311)
// ETHBAL|ADDRESS|OP|THRESHOLD|CLOSE
// TOKBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
// GAS|RANGE|LOWER|UPPER|CLOSE
// GAS|TWAP|THRESHOLD|CLOSE  (also: VOLATILITY, PEAK, TROUGH)
const COLORS = {
  ETH: '#627EEA', BTC: '#F7931A', SOL: '#14F195', LINK: '#375BD2',
  UNI: '#FF007A', AAVE: '#B6509E', MKR: '#1AAB9B', SNX: '#00D1FF',
  COMP: '#00D395', YFI: '#006AE3', CRV: '#FF4C4C', BAL: '#1E1E1E',
  SUSHI: '#FA52A0', MATIC: '#8247E5', ARB: '#28A0F0', OP: '#FF0420'
};
const OPS = ['<', '>', 'â‰¤', 'â‰¥', '=', 'â‰ '];

// Format close date - show year if not current year
function formatCloseDate(timestamp) {
  const d = new Date(timestamp * 1000);
  const now = new Date();
  const sameYear = d.getFullYear() === now.getFullYear();
  if (sameYear) {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

// Format price for display
function formatPrice(val) {
  if (val >= 1e6) return `$${(val/1e6).toFixed(val % 1e6 === 0 ? 0 : 1)}M`;
  if (val >= 1000) return `$${(val/1000).toFixed(val % 1000 === 0 ? 0 : 1)}K`;
  return `$${val}`;
}

// Format balance for display
function formatBalance(val, decimals = 1) {
  if (val >= 1e9) return `${(val/1e9).toFixed(1)}B`;
  if (val >= 1e6) return `${(val/1e6).toFixed(1)}M`;
  if (val >= 1000) return `${(val/1000).toFixed(1)}K`;
  return val.toFixed(decimals);
}

function parseMarketDescription(description) {
  if (!description) return { question: 'Unknown market', color: '#627EEA', logo: 'eth', threshold: 0, raw: '' };

  // For non-standard descriptions, clean up raw thresholds and format nicely
  let displayDesc = description;
  let threshold = 0;

  // Strip raw threshold patterns like ">= 40000000000000000000000000" from display
  const threshMatch = displayDesc.match(/\s*(>=|<=|>|<|=)\s*(\d{10,})/);
  if (threshMatch) {
    const rawThresh = BigInt(threshMatch[2]);
    threshold = Number(rawThresh);
    // Format large numbers nicely (assume 18 decimals for most tokens)
    const scaled = Number(rawThresh / 10n**18n);
    const formatted = scaled >= 1e9 ? (scaled/1e9).toFixed(1) + 'B' :
                      scaled >= 1e6 ? (scaled/1e6).toFixed(1) + 'M' :
                      scaled >= 1e3 ? (scaled/1e3).toFixed(1) + 'K' : scaled.toString();
    displayDesc = displayDesc.replace(/\s*(>=|<=|>|<|=)\s*\d{10,}/, ` ${threshMatch[1]} ${formatted}`);
  }

  if (displayDesc.length > 120) displayDesc = displayDesc.slice(0, 117) + '...';
  const defaults = { question: displayDesc, color: '#888', logo: '?', threshold, raw: description };
  try {
    const p = description.split('|');
    const type = p[0];

    // PRICE markets: PRICE|ASSET|QUOTE|OP|THRESHOLD|CLOSE
    if (type === 'PRICE' && p.length >= 6) {
      const [, asset, quote, op, thresh, close] = p;
      const t = parseInt(thresh);
      const price = formatPrice(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      // Op: 0=LT, 1=GT, 2=LTE, 3=GTE, 4=EQ, 5=NEQ
      const verb = opNum >= 2 ? 'hit' : 'drop to';
      const color = COLORS[asset] || '#627EEA';
      return {
        question: `<u style="text-decoration-color:${color}">${asset}</u> ${verb} <u style="text-decoration-color:#0F0">${price}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color, logo: asset.toLowerCase(), threshold: t, raw: description
      };
    }

    // ETH Balance markets: ETHBAL|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'ETHBAL' && p.length >= 5) {
      const [, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const shortAddr = `${addr.slice(0,6)}...${addr.slice(-4)}`;
      return {
        question: `<u style="text-decoration-color:#627EEA">${shortAddr}</u> ${verb} <u style="text-decoration-color:#0F0">${bal} ETH</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#627EEA', logo: 'eth', threshold: t, raw: description
      };
    }

    // Token Balance markets: TOKBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'TOKBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const shortAddr = `${addr.slice(0,6)}...${addr.slice(-4)}`;
      const shortToken = `${token.slice(0,6)}...`;
      return {
        question: `<u style="text-decoration-color:#8247E5">${shortAddr}</u> ${verb} <u style="text-decoration-color:#0F0">${bal}</u> <u style="text-decoration-color:#FF007A">${shortToken}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', logo: 'tok', threshold: t, raw: description
      };
    }

    // Gas markets: GAS|SUBTYPE|...params...|CLOSE
    if (type === 'GAS' && p.length >= 4) {
      const [, subtype, ...rest] = p;
      const close = rest[rest.length - 1];
      const date = formatCloseDate(parseInt(close));
      let q, thresh = parseFloat(rest[0]);

      if (subtype === 'RANGE') {
        const [lower, upper] = rest;
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> stay in <u style="text-decoration-color:#0F0">${lower}-${upper} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
        thresh = parseFloat(lower);
      } else {
        const labels = { TWAP: 'avg', PEAK: 'spike to', TROUGH: 'dip to', VOL: 'swing', VOLATILITY: 'swing' };
        const label = labels[subtype] || subtype.toLowerCase();
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> ${label} <u style="text-decoration-color:#0F0">${rest[0]} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
      }
      return { question: q, color: '#FF6B6B', logo: 'gas', threshold: thresh, raw: description };
    }
  } catch (e) { console.warn('Parse error:', e); }
  return defaults;
}

async function loadMarketOdds(marketId) {
  try {
    const rpc = provider || await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

    const yesSupply = await pamm.totalSupplyId(marketId);
    const noId = await pamm.getNoId(marketId);
    const noSupply = await pamm.totalSupplyId(noId);
    const total = yesSupply + noSupply;

    return total > 0n ? Number((yesSupply * 100n) / total) : 50;
  } catch (e) {
    console.warn('Failed to load odds:', e);
    return 50;
  }
}

// ======================== RENDER ========================
function render() {
  const m = markets[currentIndex];
  if (!m) return;

  // Show resolved badge if market is resolved
  let questionHtml = m.q;
  if (m.resolved) {
    const winner = m.outcome ? 'YES' : 'NO';
    const badgeClass = m.outcome ? 'yes' : 'no';
    questionHtml += `<span class="resolved-badge ${badgeClass}">${winner} WINS</span>`;
  }
  $('q').innerHTML = questionHtml;

  $('yBar').textContent = `Y ${m.y}%`;
  $('yBar').style.width = m.y + '%';
  $('nBar').textContent = `N ${100 - m.y}%`;
  $('nBar').style.width = (100 - m.y) + '%';
  $('logo').textContent = m.logo || m.id;
  $('logo').style.textDecorationColor = m.c;

  // Add resolved class to odds container
  const oddsEl = document.querySelector('.odds');
  oddsEl.classList.toggle('resolved', !!m.resolved);

  // Meta info with market count
  const marketCount = markets.filter(x => !x.isDemo).length;
  const countText = marketCount > 0 ? ` | ${currentIndex + 1}/${markets.length} markets` : '';

  if (m.marketId) {
    const status = m.resolved ? 'resolved' : `<span id="countdown">${formatCountdown(m.close)}</span>`;
    const tvlText = m.tvl ? ` | ${m.tvl.toFixed(3)} ETH` : '';
    const shareBtn = `<span id="shareBtn" onclick="shareMarket()" style="cursor:pointer;margin-left:4px" title="Share market">&#128279;</span>`;
    // Add subtle raw description button if we have raw description
    const rawBtn = m.description ? `<span class="raw-desc-btn" onclick="showRawDescription(event)" title="View raw description">&#x22EF;</span>` : '';
    $('meta').innerHTML = `<a href="${getMarketUrl(m.marketId)}" onclick="event.preventDefault();shareMarket()">#${m.marketId.slice(0,8)}...</a>${shareBtn}${rawBtn} | ${status}${tvlText}${countText}`;

    // Show resolver info below meta (async ENS lookup)
    updateResolverDisplay(m);
  } else {
    $('meta').innerHTML = m.isDemo ? `demo market (create to trade)${countText}` : countText;
    $('resolverInfo').style.display = 'none';
  }
}

// Update resolver display with ENS lookup
async function updateResolverDisplay(m) {
  const el = $('resolverInfo');
  if (!m?.resolver) {
    el.style.display = 'none';
    return;
  }

  const short = `${m.resolver.slice(0,6)}...${m.resolver.slice(-4)}`;
  const etherscanUrl = `https://etherscan.io/address/${m.resolver}`;

  // Show immediately with short address
  el.innerHTML = `resolver: <a href="${etherscanUrl}" target="_blank" rel="noopener">${short}</a><span id="liqSourcesIndicator"></span>`;
  el.style.display = 'block';

  // Async ENS lookup
  const ensName = await lookupENS(m.resolver);
  if (ensName && markets[currentIndex]?.marketId === m.marketId) {
    // Still on same market, update with ENS name
    el.innerHTML = `resolver: <a href="${etherscanUrl}" target="_blank" rel="noopener">${ensName}</a><span id="liqSourcesIndicator"></span>`;
  }
}

// Update liquidity source indicators
function updateLiquidityIndicator() {
  const el = $('liqSourcesIndicator');
  if (!el) return;

  const { hasVault, hasBidPool, hasAmm } = liquiditySources;

  // Build indicator dots with tooltips
  let html = '';
  if (hasVault) {
    html += '<span class="liq-indicator vault" title="OTC vault active"></span>';
  }
  if (hasBidPool) {
    html += '<span class="liq-indicator bid" title="Bid pool active"></span>';
  }
  if (hasAmm) {
    html += '<span class="liq-indicator amm" title="AMM pool active"></span>';
  }
  if (!hasVault && !hasBidPool && !hasAmm) {
    html += '<span class="liq-indicator none" title="No liquidity"></span>';
  }

  el.innerHTML = html;
}

// Show raw description tooltip
function showRawDescription(event) {
  event.stopPropagation();
  const m = markets[currentIndex];
  if (!m?.description) return;

  // Create or get tooltip
  let tooltip = document.getElementById('rawDescTooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'rawDescTooltip';
    tooltip.className = 'raw-desc-tooltip';
    $('meta').appendChild(tooltip);
  }

  // Toggle visibility
  if (tooltip.style.display === 'block') {
    tooltip.style.display = 'none';
  } else {
    tooltip.textContent = m.description;
    tooltip.style.display = 'block';

    // Auto-hide after 5 seconds or on click elsewhere
    setTimeout(() => { tooltip.style.display = 'none'; }, 5000);
    document.addEventListener('click', function hideTooltip(e) {
      if (!e.target.classList.contains('raw-desc-btn')) {
        tooltip.style.display = 'none';
        document.removeEventListener('click', hideTooltip);
      }
    }, { once: true });
  }
}

function next() {
  currentIndex = (currentIndex + 1) % markets.length;
  closeDrop();
  render();
  loadPositions();
  loadResolutionStatus();
  loadPriceChart();
}

function vote(d) {
  const m = markets[currentIndex];
  if (!m) return;
  // Don't allow trading on resolved markets
  if (m.resolved) return;

  if (dir === d) return closeDrop();
  dir = d;
  $('drop').className = 'drop open ' + (d === 'Y' ? 'yes' : 'no') + (tradeMode === 'sell' ? ' sell-mode' : '');
  $('side').textContent = d;
  $('yBar').classList.toggle('dim', d !== 'Y');
  $('nBar').classList.toggle('dim', d !== 'N');
  $('amt').focus();
  updateTradeUI();
  calc();
}

function closeDrop() {
  dir = null;
  $('drop').className = 'drop';
  $('yBar').classList.remove('dim');
  $('nBar').classList.remove('dim');
  tradeMode = 'buy';
  $('buyToggle').classList.add('active');
  $('sellToggle').classList.remove('active');
}

let liqPanelOpen = false;

function toggleLiquidityPanel() {
  liqPanelOpen = !liqPanelOpen;
  const toggle = $('liqToggle');

  toggle.classList.toggle('active', liqPanelOpen);

  if (liqPanelOpen) {
    // Re-render positions and load chart (respects liqPanelOpen state)
    renderPositions();
    loadPriceChart();
  } else {
    // Hide LP section and chart
    const lpSection = $('lpPositions');
    const lpBtn = $('lpBtnPos');
    const chartSection = $('chartSection');
    if (lpSection) lpSection.style.display = 'none';
    if (lpBtn) lpBtn.style.display = 'none';
    if (chartSection) chartSection.style.display = 'none';
  }
}

function setTradeMode(mode) {
  tradeMode = mode;
  $('buyToggle').classList.toggle('active', mode === 'buy');
  $('sellToggle').classList.toggle('active', mode === 'sell');
  $('drop').classList.toggle('sell-mode', mode === 'sell');
  updateTradeUI();
  calc();
}

function updateTradeUI() {
  const isBuy = tradeMode === 'buy';
  $('tradeBtn').textContent = isBuy ? 'BUY' : 'SELL';
  $('amt').placeholder = isBuy ? '0.00' : 'shares';

  if (isBuy) {
    $('tradeInfo').innerHTML = `ETH &rarr; <b id="out">0.00</b> <b id="side">${dir || 'Y'}</b>`;
  } else {
    const bal = dir === 'Y' ? userPositions.yes : userPositions.no;
    const balStr = formatShares(bal);
    $('tradeInfo').innerHTML = `<b id="side">${dir || 'Y'}</b> &rarr; <b id="out">0.00</b> ETH <span style="opacity:0.6;font-size:11px;">(${balStr})</span>`;
  }
}

let quoteTimeout = null;

function calc() {
  const v = parseFloat($('amt').value) || 0;
  const m = markets[currentIndex];
  if (!m) return;
  const odds = dir === 'Y' ? m.y : 100 - m.y;

  // Show instant linear estimate while quote loads
  if (tradeMode === 'buy') {
    const sharesEst = odds > 0 ? (v * 100 / odds) : 0;
    $('out').textContent = formatQuoteOutput(sharesEst);
  } else {
    const ethOut = (v * odds / 100);
    $('out').textContent = formatQuoteOutput(ethOut, true);
  }

  // Clear stale quote info
  const slipEl = document.getElementById('slippageInfo');
  if (slipEl) slipEl.textContent = '';

  // Debounced quote fetch for accurate preview
  if (quoteTimeout) clearTimeout(quoteTimeout);
  if (v > 0 && m.marketId) {
    quoteTimeout = setTimeout(() => fetchQuote(v, m), 300);
  }
}

let lastQuote = null; // Store quote for execution

async function fetchQuote(amount, m) {
  try {
    const rpc = provider || await getRpc();
    const buyYes = dir === 'Y';
    const isLabeled = isOurLabeledMarket(m.description);

    // For legacy/external markets, use local AMM quote
    if (!isLabeled) {
      return await fetchLegacyQuote(amount, m, buyYes, rpc);
    }

    const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

    if (tradeMode === 'buy') {
      const collateralIn = ethers.parseEther(amount.toString());
      // Use sweep quote to check orderbook + vault/amm routing
      const quote = await quoter.quoteBuyWithSweep(m.marketId, buyYes, collateralIn, 10000); // maxPrice 100%
      console.log('quoteBuyWithSweep result:', {
        totalSharesOut: quote.totalSharesOut.toString(),
        poolSharesOut: quote.poolSharesOut.toString(),
        poolLevelsFilled: quote.poolLevelsFilled.toString(),
        pmSharesOut: quote.pmSharesOut.toString(),
        pmSource: quote.pmSource
      });
      const sharesOut = Number(quote.totalSharesOut) / 1e18;
      const poolShares = Number(quote.poolSharesOut) / 1e18;
      const poolLevels = Number(quote.poolLevelsFilled);

      // Store quote for execution (include expected output for slippage protection)
      lastQuote = {
        useSweep: poolLevels > 0,
        poolLevels,
        amount,
        expectedOut: quote.totalSharesOut, // For minSharesOut
        isBuy: true,
        isLegacy: false
      };

      // Build source description
      let sourceName = '';
      if (poolLevels > 0 && quote.pmSharesOut > 0) {
        sourceName = `pool(${poolLevels})+pm`;
      } else if (poolLevels > 0) {
        sourceName = `pool(${poolLevels})`;
      } else {
        sourceName = decodeSource(quote.pmSource);
      }

      // Calculate effective price vs spot
      const effectivePrice = sharesOut > 0 ? amount / sharesOut * 100 : 0;
      const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
      const slippage = effectivePrice - spotPrice;

      $('out').textContent = formatQuoteOutput(sharesOut);
      updateQuoteInfo(sourceName, slippage, poolShares > 0 ? poolShares : null);
    } else {
      const sharesIn = ethers.parseEther(amount.toString());
      // Use sweep quote to check bid pools + vault/amm routing
      const quote = await quoter.quoteSellWithSweep(m.marketId, buyYes, sharesIn, 0); // minPrice 0%
      const collateralOut = Number(quote.totalCollateralOut) / 1e18;
      const poolCollateral = Number(quote.poolCollateralOut) / 1e18;
      const poolLevels = Number(quote.poolLevelsFilled);

      // Store quote for execution (include expected output for slippage protection)
      lastQuote = {
        useSweep: poolLevels > 0,
        poolLevels,
        amount,
        expectedOut: quote.totalCollateralOut, // For minCollateralOut
        isBuy: false,
        isLegacy: false
      };

      // Build source description
      let sourceName = '';
      if (poolLevels > 0 && quote.pmCollateralOut > 0) {
        sourceName = `bid(${poolLevels})+pm`;
      } else if (poolLevels > 0) {
        sourceName = `bid(${poolLevels})`;
      } else {
        sourceName = decodeSource(quote.pmSource);
      }

      // Calculate effective price vs spot
      const effectivePrice = collateralOut / amount * 100;
      const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
      const slippage = spotPrice - effectivePrice;

      $('out').textContent = formatQuoteOutput(collateralOut, true);
      updateQuoteInfo(sourceName, slippage, poolCollateral > 0 ? poolCollateral : null);
    }
  } catch (e) {
    console.log('Quote error:', e.message);
    // For labeled markets that failed quoter, try legacy fallback
    if (isOurLabeledMarket(m.description)) {
      try {
        const rpc = provider || await getRpc();
        return await fetchLegacyQuote(amount, m, dir === 'Y', rpc);
      } catch (e2) {
        console.log('Legacy fallback also failed:', e2.message);
      }
    }
    lastQuote = null;
  }
}

// Fetch quote for legacy/external markets using local AMM math
async function fetchLegacyQuote(amount, m, buyYes, rpc) {
  const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

  // Get pool state with 30 bps fee tier (legacy markets)
  const poolState = await pamm.getPoolState(m.marketId, LEGACY_FEE_BPS);
  const rYes = poolState.rYes;
  const rNo = poolState.rNo;

  if (rYes === 0n || rNo === 0n) {
    $('out').textContent = '0.00';
    updateQuoteInfo('no liq', 0, null);
    lastQuote = null;
    return;
  }

  if (tradeMode === 'buy') {
    const collateralIn = ethers.parseEther(amount.toString());
    const sharesOut = buyYes
      ? quoteBuyYes(collateralIn, rYes, rNo, LEGACY_FEE_BPS)
      : quoteBuyNo(collateralIn, rYes, rNo, LEGACY_FEE_BPS);
    const sharesOutNum = Number(sharesOut) / 1e18;

    // Store quote for execution
    lastQuote = {
      useSweep: false,
      poolLevels: 0,
      amount,
      expectedOut: sharesOut,
      isBuy: true,
      isLegacy: true,
      rYes,
      rNo
    };

    // Calculate effective price vs spot
    const effectivePrice = sharesOutNum > 0 ? amount / sharesOutNum * 100 : 0;
    const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
    const slippage = effectivePrice - spotPrice;

    $('out').textContent = formatQuoteOutput(sharesOutNum);
    updateQuoteInfo('ammâ†¯', slippage, null); // â†¯ indicates legacy PM_ROUTER
  } else {
    const sharesIn = ethers.parseEther(amount.toString());
    const collateralOut = buyYes
      ? quoteSellYes(sharesIn, rYes, rNo, LEGACY_FEE_BPS)
      : quoteSellNo(sharesIn, rYes, rNo, LEGACY_FEE_BPS);
    const collateralOutNum = Number(collateralOut) / 1e18;

    // Store quote for execution
    lastQuote = {
      useSweep: false,
      poolLevels: 0,
      amount,
      expectedOut: collateralOut,
      isBuy: false,
      isLegacy: true,
      rYes,
      rNo
    };

    // Calculate effective price vs spot
    const effectivePrice = collateralOutNum / amount * 100;
    const spotPrice = dir === 'Y' ? m.y : (100 - m.y);
    const slippage = spotPrice - effectivePrice;

    $('out').textContent = formatQuoteOutput(collateralOutNum, true);
    updateQuoteInfo('ammâ†¯', slippage, null);
  }
}

function decodeSource(source) {
  if (!source || source === '0x00000000') return 'amm';
  // Common sources: otc, amm, mint, mult
  const hex = source.toLowerCase();
  if (hex === '0x6f746300' || hex.includes('otc')) return 'vault';
  if (hex === '0x616d6d00' || hex.includes('amm')) return 'amm';
  if (hex === '0x6d696e74' || hex.includes('mint')) return 'mint';
  if (hex === '0x6d756c74' || hex.includes('mult')) return 'multi';
  return 'pm';
}

function updateQuoteInfo(source, slippage, poolFill) {
  let el = document.getElementById('slippageInfo');
  if (!el) {
    const tradeInfo = $('tradeInfo');
    el = document.createElement('span');
    el.id = 'slippageInfo';
    el.style.cssText = 'font-size:10px;opacity:0.7;margin-left:6px;';
    tradeInfo.appendChild(el);
  }

  const slipStr = slippage > 0.01 ? `+${slippage.toFixed(2)}%` : slippage < -0.01 ? `${slippage.toFixed(2)}%` : '';
  const color = Math.abs(slippage) > 1 ? '#f66' : Math.abs(slippage) > 0.5 ? '#fa0' : '';
  const poolStr = poolFill ? ` <span style="color:#0f0">${poolFill.toFixed(2)} pool</span>` : '';
  el.innerHTML = slipStr ? `<span style="color:${color}">${slipStr}</span> ${source}${poolStr}` : `${source}${poolStr}`;
}

function formatShares(wei) {
  if (wei === 0n) return '0';
  const eth = Number(wei) / 1e18;
  if (eth < 0.0001) return '<0.0001';
  if (eth < 1) return eth.toFixed(4);
  if (eth < 1000) return eth.toFixed(2);
  return eth.toLocaleString('en-US', { maximumFractionDigits: 2 });
}

// Format quote output - show more decimals for small values
function formatQuoteOutput(val, isEth = false) {
  if (val === 0) return '0.00';
  if (val < 0.0001) return val.toExponential(2);
  if (val < 0.01) return val.toFixed(4);
  if (val < 1) return val.toFixed(isEth ? 4 : 3);
  if (val < 100) return val.toFixed(2);
  return val.toFixed(1);
}

function formatFeesETH(wei) {
  if (wei === 0n) return '0';
  const eth = Number(wei) / 1e18;
  if (eth < 0.0001) return '<0.0001 ETH';
  if (eth < 0.01) return eth.toFixed(6) + ' ETH';
  return eth.toFixed(4) + ' ETH';
}

function formatCountdown(closeTimestamp) {
  const now = Math.floor(Date.now() / 1000);
  const diff = closeTimestamp - now;
  if (diff <= 0) return 'closed';
  const days = Math.floor(diff / 86400);
  const hours = Math.floor((diff % 86400) / 3600);
  const mins = Math.floor((diff % 3600) / 60);
  if (days > 30) return new Date(closeTimestamp * 1000).toLocaleDateString();
  if (days > 0) return `${days}d ${hours}h`;
  if (hours > 0) return `${hours}h ${mins}m`;
  return `${mins}m`;
}

// Start countdown timer to update display
let countdownInterval;
function startCountdownTimer() {
  if (countdownInterval) clearInterval(countdownInterval);
  countdownInterval = setInterval(() => {
    const m = markets[currentIndex];
    if (m?.marketId && !m.resolved && m.close) {
      const el = document.getElementById('countdown');
      if (el) el.textContent = formatCountdown(m.close);
    }
  }, 1000);
}

// Auto-refresh market data every 30s
let refreshInterval;
function startAutoRefresh() {
  if (refreshInterval) clearInterval(refreshInterval);
  refreshInterval = setInterval(async () => {
    const m = markets[currentIndex];
    if (m?.marketId && !m.resolved) {
      try {
        m.y = await loadMarketOdds(m.marketId);
        if (connectedAddress) await loadPositions();
        render();
      } catch (e) { /* silent refresh */ }
    }
  }, 30000);
}

// ======================== TRADE ========================
function executeTrade() {
  if (tradeMode === 'buy') {
    buy();
  } else {
    sell();
  }
}

async function buy() {
  if (!connectedAddress) return toggleWallet();
  if (isTrading) return;

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('This is a demo market. Create a real market first using "+ create"');
    return;
  }

  const amtStr = $('amt').value;
  const amt = parseFloat(amtStr);
  if (!amt || amt <= 0) return;

  const buyYes = dir === 'Y';
  const collateralIn = ethers.parseEther(amtStr);
  const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

  isTrading = true;
  $('tradeBtn').disabled = true;
  $('tradeBtn').textContent = '...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    let tx;

    // Calculate minSharesOut with 1% slippage buffer (99% of quoted)
    const minSharesOut = lastQuote?.expectedOut ? lastQuote.expectedOut * 99n / 100n : 0n;

    // For legacy/external markets, use PM_ROUTER (atomic split+swap)
    if (lastQuote?.isLegacy) {
      console.log('Using PM_ROUTER for legacy market buy');

      const pmRouter = new ethers.Contract(CONTRACTS.PM_ROUTER, PM_ROUTER_ABI, signer);

      // No operator approval needed for ETH buys - router receives ETH directly
      // PM_ROUTER.buy handles the split+swap atomically
      tx = await pmRouter.buy(
        m.marketId,
        buyYes,
        collateralIn,
        minSharesOut,
        LEGACY_FEE_BPS, // 30 bps fee tier
        connectedAddress,
        deadline,
        { value: collateralIn }
      );
    } else {
      // No operator approval needed for ETH buys - router receives ETH directly
      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);

      // Use sweep if orderbook pools have liquidity, otherwise use regular buy
      if (lastQuote?.useSweep) {
        console.log('Using buyWithSweep for better execution');
        tx = await router.buyWithSweep(
          m.marketId,
          buyYes,
          collateralIn,
          minSharesOut,
          10000, // maxPriceBps (100% = accept any price)
          connectedAddress,
          deadline,
          { value: collateralIn }
        );
      } else {
        tx = await router.buy(
          m.marketId,
          buyYes,
          collateralIn,
          minSharesOut,
          0, // poolPriceInBps (0 = skip orderbook, go to vault)
          connectedAddress,
          deadline,
          { value: collateralIn }
        );
      }
    }

    const receipt = await tx.wait();
    console.log('Buy tx:', receipt.hash);

    // Refresh odds and positions
    m.y = await loadMarketOdds(m.marketId);
    await loadPositions();
    render();

    $('amt').value = '';
    $('out').textContent = '0.00';
    lastQuote = null;
    closeDrop();

    alert(`Bought ${dir} shares! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Buy failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Buy failed: ' + msg);
    }
  } finally {
    isTrading = false;
    $('tradeBtn').disabled = false;
    $('tradeBtn').textContent = 'BUY';
  }
}

async function sell() {
  if (!connectedAddress) return toggleWallet();
  if (isTrading) return;

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('This is a demo market. Create a real market first using "+ create"');
    return;
  }

  const amtStr = $('amt').value;
  const amt = parseFloat(amtStr);
  if (!amt || amt <= 0) return;

  const sellYes = dir === 'Y';
  const sharesIn = ethers.parseEther(amtStr);
  const deadline = Math.floor(Date.now() / 1000) + 3600;

  // Check if user has enough shares
  const balance = sellYes ? userPositions.yes : userPositions.no;
  if (sharesIn > balance) {
    alert(`Insufficient ${dir} shares. You have ${formatShares(balance)}`);
    return;
  }

  isTrading = true;
  $('tradeBtn').disabled = true;
  $('tradeBtn').textContent = '...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    let tx;

    // Calculate minCollateralOut with 1% slippage buffer (99% of quoted)
    const minCollateralOut = lastQuote?.expectedOut ? lastQuote.expectedOut * 99n / 100n : 0n;

    // For legacy/external markets, use PM_ROUTER (atomic swap+merge)
    if (lastQuote?.isLegacy) {
      console.log('Using PM_ROUTER for legacy market sell');

      const pmRouter = new ethers.Contract(CONTRACTS.PM_ROUTER, PM_ROUTER_ABI, signer);

      // Check operator approval for PM_ROUTER
      const isOp = await pamm.isOperator(connectedAddress, CONTRACTS.PM_ROUTER);
      if (!isOp) {
        const approveTx = await pamm.setOperator(CONTRACTS.PM_ROUTER, true);
        await approveTx.wait();
      }

      // PM_ROUTER.sell handles the swap+merge atomically
      tx = await pmRouter.sell(
        m.marketId,
        sellYes,
        sharesIn,
        minCollateralOut,
        LEGACY_FEE_BPS, // 30 bps fee tier
        connectedAddress,
        deadline
      );
    } else {
      // Check operator approval for MasterRouter
      const isOp = await pamm.isOperator(connectedAddress, CONTRACTS.MASTER_ROUTER);
      if (!isOp) {
        const approveTx = await pamm.setOperator(CONTRACTS.MASTER_ROUTER, true);
        await approveTx.wait();
      }

      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);

      // Use sweep if bid pools have liquidity, otherwise use regular sell
      if (lastQuote?.useSweep) {
        console.log('Using sellWithSweep for better execution');
        tx = await router.sellWithSweep(
          m.marketId,
          sellYes,
          sharesIn,
          minCollateralOut,
          0, // minPriceBps (0% = accept any price)
          connectedAddress,
          deadline
        );
      } else {
        tx = await router.sell(
          m.marketId,
          sellYes,
          sharesIn,
          minCollateralOut,
          0, // bidPoolPriceInBps (0 = skip orderbook, go to vault)
          connectedAddress,
          deadline
        );
      }
    }

    const receipt = await tx.wait();
    console.log('Sell tx:', receipt.hash);

    // Refresh odds and positions
    m.y = await loadMarketOdds(m.marketId);
    await loadPositions();
    render();

    $('amt').value = '';
    $('out').textContent = '0.00';
    lastQuote = null;
    closeDrop();

    alert(`Sold ${dir} shares! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Sell failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Sell failed: ' + msg);
    }
  } finally {
    isTrading = false;
    $('tradeBtn').disabled = false;
    $('tradeBtn').textContent = 'SELL';
  }
}

// ======================== POSITIONS ========================
async function loadPositions() {
  const m = markets[currentIndex];
  if (!connectedAddress || !m?.marketId) {
    userPositions = { yes: 0n, no: 0n };
    lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
    vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };
    poolStats = { reserve0: 0n, reserve1: 0n, totalSupply: 0n, userShare: 0, yesReserve: 0n, noReserve: 0n, impliedYesPrice: 50 };
    renderPositions();
    return;
  }

  try {
    const rpc = provider || await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const zamm = new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, rpc);
    const isLabeled = isOurLabeledMarket(m.description);
    const noId = await pamm.getNoId(m.marketId);
    const yesId = BigInt(m.marketId);
    const yesIsId0 = yesId < noId;

    // For labeled markets, use Quoter; for legacy/external, query directly
    if (isLabeled) {
      const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);

      // Single call for user positions + vault LP + pending fees (replaces ~6 calls)
      // Single call for market summary (replaces ~5 calls)
      const [userPos, marketSummary] = await Promise.all([
        quoter.getUserFullPosition(m.marketId, connectedAddress),
        quoter.getMarketSummary(m.marketId)
      ]);

      // User trading positions
      userPositions = {
        yes: BigInt(userPos.yesShareBalance),
        no: BigInt(userPos.noShareBalance)
      };

      // User vault LP positions + pending fees (already calculated by quoter!)
      lpPositions.yesVault = BigInt(userPos.yesVaultLP);
      lpPositions.noVault = BigInt(userPos.noVaultLP);
      lpPositions.yesFees = BigInt(userPos.pendingYesCollateral);
      lpPositions.noFees = BigInt(userPos.pendingNoCollateral);

      // Market/vault stats from summary
      vaultStats.yesTotalShares = BigInt(marketSummary.totalYesVaultLP);
      vaultStats.noTotalShares = BigInt(marketSummary.totalNoVaultLP);
      vaultStats.yesUnderlying = BigInt(marketSummary.vaultYesShares);
      vaultStats.noUnderlying = BigInt(marketSummary.vaultNoShares);
      vaultStats.yesTotalFees = 0n;
      vaultStats.noTotalFees = 0n;

      // Pool stats from summary
      poolStats.yesReserve = BigInt(marketSummary.ammYesReserve);
      poolStats.noReserve = BigInt(marketSummary.ammNoReserve);
      poolStats.reserve0 = yesIsId0 ? poolStats.yesReserve : poolStats.noReserve;
      poolStats.reserve1 = yesIsId0 ? poolStats.noReserve : poolStats.yesReserve;
      poolStats.impliedYesPrice = Number(marketSummary.ammPriceYesBps) / 100;
    } else {
      // Legacy/external market - query PAMM directly
      console.log('Loading positions for legacy market');

      // Get user share balances directly from PAMM
      const [yesBal, noBal] = await Promise.all([
        pamm.balanceOf(connectedAddress, m.marketId),
        pamm.balanceOf(connectedAddress, noId)
      ]);

      userPositions = {
        yes: BigInt(yesBal),
        no: BigInt(noBal)
      };

      // Legacy markets don't have vault infrastructure
      lpPositions.yesVault = 0n;
      lpPositions.noVault = 0n;
      lpPositions.yesFees = 0n;
      lpPositions.noFees = 0n;
      vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };

      // Get pool state for legacy market (30 bps fee)
      const poolState = await pamm.getPoolState(m.marketId, LEGACY_FEE_BPS);
      poolStats.yesReserve = BigInt(poolState.rYes);
      poolStats.noReserve = BigInt(poolState.rNo);
      poolStats.reserve0 = yesIsId0 ? poolStats.yesReserve : poolStats.noReserve;
      poolStats.reserve1 = yesIsId0 ? poolStats.noReserve : poolStats.yesReserve;
      const total = poolStats.yesReserve + poolStats.noReserve;
      poolStats.impliedYesPrice = total > 0n ? Number(poolStats.noReserve * 10000n / total) / 100 : 50;
    }

    // Determine feeOrHook for pool ID calculation
    const feeOrHook = isLabeled ? CONTRACTS.PM_FEE_HOOK : LEGACY_FEE_BPS;

    // AMM LP balance still needs separate call (not in quoter)
    try {
      const [id0, id1] = yesIsId0 ? [yesId, noId] : [noId, yesId];
      const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
        ['uint256', 'uint256', 'address', 'address', 'uint256'],
        [id0, id1, CONTRACTS.PAMM, CONTRACTS.PAMM, feeOrHook]
      ));

      const [userLpBal, poolData] = await Promise.all([
        zamm.balanceOf(connectedAddress, poolId),
        zamm.pools(poolId)
      ]);

      lpPositions.ammLP = userLpBal;
      poolStats.totalSupply = BigInt(poolData.supply);
      poolStats.userShare = poolStats.totalSupply > 0n
        ? Number(userLpBal * 10000n / poolStats.totalSupply) / 100
        : 0;
    } catch (e) {
      lpPositions.ammLP = 0n;
      poolStats.totalSupply = 0n;
      poolStats.userShare = 0;
    }

    renderPositions();
  } catch (e) {
    console.warn('Failed to load positions:', e);
    userPositions = { yes: 0n, no: 0n };
    lpPositions = { yesVault: 0n, noVault: 0n, ammLP: 0n, yesFees: 0n, noFees: 0n };
    vaultStats = { yesTotalShares: 0n, noTotalShares: 0n, yesUnderlying: 0n, noUnderlying: 0n, yesTotalFees: 0n, noTotalFees: 0n };
    poolStats = { reserve0: 0n, reserve1: 0n, totalSupply: 0n, userShare: 0, yesReserve: 0n, noReserve: 0n, impliedYesPrice: 50 };
    renderPositions();
  }
}

function renderPositions() {
  const m = markets[currentIndex];
  const hasPosition = userPositions.yes > 0n || userPositions.no > 0n;
  const hasLPPosition = lpPositions.yesVault > 0n || lpPositions.noVault > 0n || lpPositions.ammLP > 0n;
  $('positions').style.display = connectedAddress && m?.marketId ? 'block' : 'none';

  $('yesBalance').textContent = formatShares(userPositions.yes);
  $('noBalance').textContent = formatShares(userPositions.no);

  // Show/hide LP button based on market state and liq panel toggle
  $('lpBtnPos').style.display = (m?.resolved || !liqPanelOpen) ? 'none' : 'block';

  // Handle LP positions display (only if liq panel is open)
  const lpPosSection = $('lpPositions');
  if (hasLPPosition && liqPanelOpen) {
    lpPosSection.style.display = 'block';
    $('yesVaultBalance').textContent = formatShares(lpPositions.yesVault);
    $('noVaultBalance').textContent = formatShares(lpPositions.noVault);
    $('ammLpBalance').textContent = formatShares(lpPositions.ammLP);

    // Display vault stats (total fees and yield)
    $('yesVaultTotalFees').textContent = formatFeesETH(vaultStats.yesTotalFees);
    $('noVaultTotalFees').textContent = formatFeesETH(vaultStats.noTotalFees);

    // Calculate yield % = (totalFees / underlying) * 100
    const yesYield = vaultStats.yesUnderlying > 0n
      ? (Number(vaultStats.yesTotalFees) / Number(vaultStats.yesUnderlying) * 100).toFixed(2)
      : '0.00';
    const noYield = vaultStats.noUnderlying > 0n
      ? (Number(vaultStats.noTotalFees) / Number(vaultStats.noUnderlying) * 100).toFixed(2)
      : '0.00';
    $('yesVaultYield').textContent = `${yesYield}% yield`;
    $('noVaultYield').textContent = `${noYield}% yield`;

    // Show vault stats only if there's vault activity
    $('vaultStats').style.display = (vaultStats.yesTotalShares > 0n || vaultStats.noTotalShares > 0n) ? 'flex' : 'none';

    // Display pending fees
    $('yesVaultFees').textContent = lpPositions.yesFees > 0n ? `+${formatFeesETH(lpPositions.yesFees)}` : '';
    $('noVaultFees').textContent = lpPositions.noFees > 0n ? `+${formatFeesETH(lpPositions.noFees)}` : '';

    // Enable/disable harvest buttons (only when fees > 0)
    $('yesHarvestBtn').disabled = lpPositions.yesFees === 0n;
    $('noHarvestBtn').disabled = lpPositions.noFees === 0n;

    // Enable/disable withdraw buttons
    $('yesVaultWithdrawBtn').disabled = lpPositions.yesVault === 0n;
    $('noVaultWithdrawBtn').disabled = lpPositions.noVault === 0n;
    $('ammLpWithdrawBtn').disabled = lpPositions.ammLP === 0n;

    // Display pool stats (only if user has AMM LP)
    const poolStatsEl = $('poolStats');
    if (lpPositions.ammLP > 0n && poolStats.totalSupply > 0n) {
      poolStatsEl.style.display = 'block';
      $('poolYesReserve').textContent = formatShares(poolStats.yesReserve);
      $('poolNoReserve').textContent = formatShares(poolStats.noReserve);
      $('poolTotalSupply').textContent = formatShares(poolStats.totalSupply);
      $('poolUserShare').textContent = poolStats.userShare.toFixed(2) + '%';
    } else {
      poolStatsEl.style.display = 'none';
    }
  } else {
    lpPosSection.style.display = 'none';
  }

  // Handle claim section for resolved markets
  const claimSection = $('claimSection');
  if (m?.resolved && hasPosition) {
    const winningShares = m.outcome ? userPositions.yes : userPositions.no;
    const losingShares = m.outcome ? userPositions.no : userPositions.yes;

    if (winningShares > 0n) {
      // User has winning shares - can claim
      const claimableEth = Number(winningShares) / 1e18;
      claimSection.style.display = 'block';
      $('claimInfo').textContent = `You have winning ${m.outcome ? 'YES' : 'NO'} shares`;
      $('claimAmount').textContent = `~${claimableEth.toFixed(4)} ETH`;
      $('claimBtn').textContent = 'CLAIM';
      $('claimBtn').disabled = false;
      $('claimBtn').classList.remove('claimed');
    } else if (losingShares > 0n) {
      // User only has losing shares
      claimSection.style.display = 'block';
      $('claimInfo').textContent = `Your ${m.outcome ? 'NO' : 'YES'} shares lost`;
      $('claimAmount').textContent = '0 ETH';
      $('claimBtn').textContent = 'NO PAYOUT';
      $('claimBtn').disabled = true;
      $('claimBtn').classList.add('claimed');
    } else {
      claimSection.style.display = 'none';
    }
  } else {
    claimSection.style.display = 'none';
  }
}

async function claim() {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId || !m.resolved) {
    alert('Market is not resolved yet');
    return;
  }

  const winningShares = m.outcome ? userPositions.yes : userPositions.no;
  if (winningShares <= 0n) {
    alert('No winning shares to claim');
    return;
  }

  $('claimBtn').disabled = true;
  $('claimBtn').textContent = '...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    const tx = await pamm.claim(m.marketId, connectedAddress);
    const receipt = await tx.wait();

    console.log('Claim tx:', receipt.hash);

    // Refresh positions
    await loadPositions();

    // Update claim UI to show claimed state
    $('claimBtn').textContent = 'CLAIMED';
    $('claimBtn').classList.add('claimed');
    $('claimInfo').textContent = 'Successfully claimed!';

    alert(`Claimed! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Claim failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Claim failed: ' + msg);
    }
    $('claimBtn').disabled = false;
    $('claimBtn').textContent = 'CLAIM';
  }
}

// ======================== RESOLUTION ========================
async function loadResolutionStatus() {
  const m = markets[currentIndex];
  const resolveSection = $('resolveSection');

  if (!m?.marketId || m.resolved) {
    resolveSection.style.display = 'none';
    return;
  }

  try {
    const rpc = provider || await getRpc();
    const resolver = new ethers.Contract(CONTRACTS.RESOLVER, RESOLVER_ABI, rpc);

    // Get resolution preview
    const [value, condTrue, ready] = await resolver.preview(m.marketId);

    // Get condition details from market
    const [condData] = await Promise.all([
      resolver.conditions(m.marketId)
    ]);

    resolutionStatus.value = value;
    resolutionStatus.threshold = condData.threshold;
    resolutionStatus.condTrue = condTrue;
    resolutionStatus.ready = ready;
    resolutionStatus.op = condData.op;

    const oracleAddr = condData.targetA;
    const callData = condData.callDataA;
    const opNames = ['<', '>', 'â‰¤', 'â‰¥', '=', 'â‰ '];
    const opName = opNames[condData.op] || '?';

    // Detect market type from condition data (not just description)
    // ETH balance: targetA = account, callData = empty
    // ERC20 balance: targetA = token, callData = balanceOf(account)
    // Chainlink price: targetA = feed, callData = latestAnswer()
    const isBalanceOfCall = callData && callData.length >= 74 && callData.slice(0, 10).toLowerCase() === '0x70a08231';
    const isLatestAnswerCall = callData && callData.slice(0, 10).toLowerCase() === '0x50d25bcd';
    const isETHBalanceCheck = oracleAddr && (!callData || callData === '0x' || callData === '');

    // Determine decimals, prefix, suffix based on detected type
    let decimals = 8;
    let prefix = '$';
    let suffix = '';
    let tokenSymbol = '';
    let accountAddr = '';
    let oracleHtml = '';

    if (isBalanceOfCall) {
      // ERC20 balance market
      accountAddr = '0x' + callData.slice(34, 74);
      decimals = 18; // Default, will try to fetch actual decimals
      prefix = '';

      // Try to fetch token symbol and decimals
      try {
        const tokenContract = new ethers.Contract(oracleAddr, [
          'function symbol() view returns (string)',
          'function decimals() view returns (uint8)'
        ], rpc);
        const [sym, dec] = await Promise.all([
          tokenContract.symbol().catch(() => null),
          tokenContract.decimals().catch(() => 18)
        ]);
        tokenSymbol = sym || oracleAddr.slice(0, 6);
        decimals = Number(dec);
        suffix = ` ${tokenSymbol}`;
      } catch (e) {
        suffix = ' tokens';
      }

      // Build oracle display: account on token (with logo if available)
      const shortAccount = `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
      const shortToken = tokenSymbol || `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      const tokenLogo = getTokenLogo(oracleAddr);
      oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#0F0" title="Account being checked">${shortAccount}</a>`;
      oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
      oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#666" title="${tokenSymbol || 'Token'} contract">${tokenLogo}${shortToken}</a>`;

    } else if (isETHBalanceCheck) {
      // ETH balance market - targetA is the account being checked
      accountAddr = oracleAddr;
      decimals = 18;
      prefix = '';
      suffix = ' ETH';

      const shortAccount = `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
      const ethLogo = TOKEN_LOGOS['eth'] || '';
      oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#627EEA" title="Account ETH balance">${shortAccount}</a> <span style="opacity:0.5">${ethLogo}ETH bal</span>`;

    } else if (isLatestAnswerCall) {
      // Chainlink price feed
      decimals = 8;
      prefix = '$';
      suffix = '';

      const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      // Use LINK token logo for Chainlink price feeds
      const chainlinkLogo = TOKEN_LOGOS['0x514910771af9ca656af840dff83e8264ecf986ca'] || '';
      oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#375BD2" title="Chainlink price feed">${chainlinkLogo}${shortOracle}</a> <span style="opacity:0.5">price feed</span>`;

    } else {
      // Unknown oracle type - use heuristics
      const threshold = Number(condData.threshold);
      if (threshold > 1e15) {
        decimals = 18;
        prefix = '';
        suffix = ' units';
      }

      if (oracleAddr && oracleAddr !== ethers.ZeroAddress) {
        const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
        oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#666">${shortOracle}</a>`;
      }
    }

    // Format values
    const valueFormatted = Number(value) / Math.pow(10, decimals);
    const thresholdFormatted = Number(condData.threshold) / Math.pow(10, decimals);

    const formatVal = (v) => {
      if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
      if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
      if (v >= 1e3) return (v / 1e3).toFixed(2) + 'K';
      if (v < 0.01 && v > 0) return v.toFixed(6);
      return v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    };

    // Update oracle display
    if (oracleHtml) {
      $('resolveOracle').innerHTML = oracleHtml;
      $('resolveOracleRow').style.display = '';
    } else {
      $('resolveOracleRow').style.display = 'none';
    }

    $('resolveValue').textContent = prefix + formatVal(valueFormatted) + suffix;
    $('resolveThreshold').textContent = opName + ' ' + prefix + formatVal(thresholdFormatted) + suffix;

    $('resolveCondition').textContent = condTrue ? 'YES' : 'NO';
    $('resolveCondition').className = 'resolve-status-val ' + (condTrue ? 'yes' : 'no');

    $('resolveStatus').textContent = ready ? 'READY' : 'PENDING';
    $('resolveStatus').className = 'resolve-status-val ' + (ready ? 'ready' : 'pending');

    $('resolveBtn').disabled = !ready;
    $('resolveHint').textContent = ready
      ? 'Click to resolve and settle the market'
      : 'Waiting for close time or condition to be met';

    resolveSection.style.display = 'block';
  } catch (e) {
    console.warn('Failed to load resolution status:', e);
    resolveSection.style.display = 'none';
  }
}

async function resolveMarket() {
  const m = markets[currentIndex];
  if (!m?.marketId || !resolutionStatus.ready) return;

  $('resolveBtn').disabled = true;
  $('resolveBtn').textContent = '...';

  try {
    const resolverSigner = signer || (await connectWithWallet('metamask'), signer);
    if (!resolverSigner) {
      throw new Error('Please connect wallet first');
    }

    const resolver = new ethers.Contract(CONTRACTS.RESOLVER, RESOLVER_ABI, resolverSigner);
    const tx = await resolver.resolveMarket(m.marketId);
    const receipt = await tx.wait();

    console.log('Resolve tx:', receipt.hash);

    // Update local state
    m.resolved = true;
    m.outcome = resolutionStatus.condTrue;

    // Refresh UI
    await loadPositions();
    render();

    alert(`Market resolved! Outcome: ${m.outcome ? 'YES' : 'NO'}\nTX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Resolution failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Resolution failed: ' + msg);
    }
    $('resolveBtn').disabled = !resolutionStatus.ready;
    $('resolveBtn').textContent = 'RESOLVE MARKET';
  }
}

// ======================== PRICE CHART ========================
async function loadPriceChart() {
  const m = markets[currentIndex];
  const chartSection = $('chartSection');

  if (!m?.marketId || m.isDemo || !liqPanelOpen) {
    chartSection.style.display = 'none';
    return;
  }

  chartSection.style.display = 'block';

  try {
    const rpc = provider || await getRpc();
    const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);

    // Detect if this is our labeled market or external
    const isOurMarket = m.description && /^(PRICE|ETHBAL|TOKBAL|GAS)\|/.test(m.description);
    const buyYes = dir !== 'N';
    const noId = await pamm.getNoId(m.marketId);

    // For external markets, try direct pool query with 30 bps fee
    let ammYes = 0, ammNo = 0, spotBps = 0, feeBps = 0;
    let vaultShares = 0, vaultPrice = 0, hasVault = false;
    let liqBreakdown = null;

    if (isOurMarket) {
      // Use Quoter for our labeled markets (they use PM_FEE_HOOK)
      const [summary, breakdown] = await Promise.all([
        quoter.getMarketSummary(m.marketId),
        quoter.getLiquidityBreakdown(m.marketId, buyYes)
      ]);
      liqBreakdown = breakdown;
      spotBps = Number(summary.ammPriceYesBps);
      priceChart.twapBps = Number(summary.twapPriceYesBps);
      feeBps = Number(summary.feeBps);
      ammYes = Number(summary.ammYesReserve) / 1e18;
      ammNo = Number(summary.ammNoReserve) / 1e18;
      vaultShares = Number(breakdown.vaultOtcShares) / 1e18;
      vaultPrice = Number(breakdown.vaultOtcPriceBps) / 100;
      hasVault = breakdown.vaultOtcAvailable && vaultShares > 0;
    } else {
      // External market - query PAMM directly with 30 bps fee
      try {
        const poolState = await pamm.getPoolState(m.marketId, 30);
        ammYes = Number(poolState.rYes) / 1e18;
        ammNo = Number(poolState.rNo) / 1e18;
        // Compute spot price from reserves
        const total = ammYes + ammNo;
        spotBps = total > 0 ? Math.round((ammNo / total) * 10000) : 0;
        feeBps = 30;
        priceChart.twapBps = 0; // No TWAP for external
      } catch (e) {
        console.log('External pool query failed:', e.message);
      }
      // External markets don't have our vault system
      hasVault = false;
    }

    priceChart.spotBps = spotBps;

    // Update spot/TWAP/fee display
    $('chartSpot').textContent = spotBps > 0 ? (spotBps / 100).toFixed(1) + '%' : '--';
    $('chartFee').textContent = feeBps > 0 ? (feeBps / 100).toFixed(2) + '%' : '--';

    // Hide TWAP row if no TWAP available
    const twapRow = $('chartTwapRow');
    if (priceChart.twapBps > 0) {
      $('chartTwap').textContent = (priceChart.twapBps / 100).toFixed(1) + '%';
      twapRow.style.display = '';
    } else {
      twapRow.style.display = 'none';
    }

    // Update liquidity breakdown
    const liqSection = $('liquidityBreakdown');
    liqSection.style.display = 'block';

    // Vault OTC liquidity - hide row if no vault
    const vaultRow = $('liqVaultRow');
    if (hasVault) {
      $('liqVault').textContent = `${vaultShares.toFixed(2)} @ ${vaultPrice.toFixed(1)}%`;
      vaultRow.style.display = '';
    } else {
      vaultRow.style.display = 'none';
    }

    // AMM liquidity (use already computed values)
    const ammSpot = spotBps / 100;
    const hasAmm = ammYes > 0.001 || ammNo > 0.001;
    $('liqAmm').textContent = hasAmm
      ? `${ammYes.toFixed(2)}Y / ${ammNo.toFixed(2)}N @ ${ammSpot.toFixed(1)}%`
      : 'no pool';

    // Fetch and display orderbook levels (only for our markets)
    const orderbookEl = $('orderbookLevels');
    let hasBidPool = false;
    if (!isOurMarket) {
      // External markets don't use our bid pool system
      orderbookEl.innerHTML = '';
    } else try {
      const levels = await quoter.getActiveLevels(m.marketId, buyYes, 5);
      const { askPrices, askDepths, bidPrices, bidDepths } = levels;

      let html = '';
      const hasAsks = askPrices.some(p => Number(p) > 0);
      const hasBids = bidPrices.some(p => Number(p) > 0);
      hasBidPool = hasAsks || hasBids;

      if (hasAsks || hasBids) {
        html += '<div class="orderbook-title">Orderbook</div>';

        // Show asks (selling to buyers in the pool)
        if (hasAsks) {
          html += '<div class="orderbook-side asks">';
          for (let i = 0; i < askPrices.length; i++) {
            const price = Number(askPrices[i]);
            const depth = Number(askDepths[i]) / 1e18;
            if (price > 0 && depth > 0) {
              html += `<div class="ob-level"><span class="ob-price">${(price / 100).toFixed(0)}%</span><span class="ob-depth ask">${depth.toFixed(2)} shares</span></div>`;
            }
          }
          html += '</div>';
        }

        // Show bids (buying from sellers in the pool)
        if (hasBids) {
          html += '<div class="orderbook-side bids">';
          for (let i = 0; i < bidPrices.length; i++) {
            const price = Number(bidPrices[i]);
            const depth = Number(bidDepths[i]) / 1e18;
            if (price > 0 && depth > 0) {
              html += `<div class="ob-level"><span class="ob-price">${(price / 100).toFixed(0)}%</span><span class="ob-depth bid">${depth.toFixed(4)} ETH</span></div>`;
            }
          }
          html += '</div>';
        }
      }

      orderbookEl.innerHTML = html;
    } catch (e) {
      console.log('Orderbook fetch error:', e.message);
      orderbookEl.innerHTML = '';
    }

    // Update liquidity sources state and indicator
    liquiditySources = { hasVault, hasBidPool, hasAmm };
    updateLiquidityIndicator();

    // Compute pool ID for ZAMM link
    // Use PM_FEE_HOOK for our labeled markets, 30 bps for external markets
    const yesId = BigInt(m.marketId);
    const yesIsId0 = yesId < noId;
    const [id0, id1] = yesIsId0 ? [yesId, noId] : [noId, yesId];
    const feeOrHook = isOurMarket ? CONTRACTS.PM_FEE_HOOK : 30; // 30 bps default for external
    const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
      ['uint256', 'uint256', 'address', 'address', 'uint256'],
      [id0, id1, CONTRACTS.PAMM, CONTRACTS.PAMM, feeOrHook]
    ));
    priceChart.poolId = poolId;

    // Set ZAMM link (use decimal pool ID)
    const poolIdDecimal = BigInt(poolId).toString();
    $('chartLink').href = `https://zamm.finance/p/${poolIdDecimal}`;

    // Render simple price visualization
    renderPriceChart();

  } catch (e) {
    console.warn('Failed to load price chart:', e);
    $('chartContainer').innerHTML = '<div class="chart-empty">Price data unavailable</div>';
    $('liquidityBreakdown').style.display = 'none';
  }
}

function renderPriceChart() {
  const container = $('chartContainer');

  if (priceChart.spotBps === 0) {
    container.innerHTML = '<div class="chart-empty">No liquidity yet</div>';
    $('chartOldest').textContent = '--';
    $('chartNewest').textContent = '--';
    return;
  }

  // Show current price as visual indicator with YES/NO split
  const yesPct = priceChart.spotBps / 100;
  const noPct = 100 - yesPct;

  container.innerHTML = `
    <div class="price-visual">
      <div class="price-bar yes" style="width: ${yesPct}%">
        <span class="price-label">YES ${yesPct.toFixed(1)}%</span>
      </div>
      <div class="price-bar no" style="width: ${noPct}%">
        <span class="price-label">NO ${noPct.toFixed(1)}%</span>
      </div>
    </div>
  `;

  // Update footer
  $('chartOldest').textContent = priceChart.twapBps > 0 ? `TWAP: ${(priceChart.twapBps / 100).toFixed(1)}%` : '';
  $('chartNewest').textContent = 'now';
}

// ======================== CREATE MARKET ========================
let currentEthPrice = 0; // Store for price diff calculation
let currentMarketType = 'price'; // 'price', 'ethBalance', 'tokenBalance'
let resolvedAddresses = { ethBalance: null, tokenBalance: null };

// Parse datetime-local input as UTC (not local time)
function parseUTCDateTime(dateStr) {
  if (!dateStr) return 0;
  // Append 'Z' to treat as UTC
  return Math.floor(new Date(dateStr + ':00Z').getTime() / 1000);
}

// Show local time equivalent for UTC datetime input
function updateLocalTimeHint(inputId, hintId) {
  const dateStr = $(inputId).value;
  const hint = $(hintId);
  if (!dateStr) {
    hint.textContent = '';
    return;
  }
  const utcTimestamp = parseUTCDateTime(dateStr);
  const localDate = new Date(utcTimestamp * 1000);
  const options = { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', timeZoneName: 'short' };
  hint.textContent = 'â†’ ' + localDate.toLocaleString('en-US', options) + ' your time';
}

function switchMarketType(type) {
  currentMarketType = type;

  // Update tabs
  document.querySelectorAll('.market-type-tab').forEach((tab, i) => {
    const types = ['price', 'gas', 'ethBalance', 'tokenBalance'];
    tab.classList.toggle('active', types[i] === type);
  });

  // Update form sections
  $('priceForm').classList.toggle('active', type === 'price');
  $('gasForm').classList.toggle('active', type === 'gas');
  $('ethBalanceForm').classList.toggle('active', type === 'ethBalance');
  $('tokenBalanceForm').classList.toggle('active', type === 'tokenBalance');

  // Update title
  const titles = {
    price: 'Create Price Market',
    gas: 'Create Gas Market',
    ethBalance: 'Create ETH Balance Market',
    tokenBalance: 'Create Token Balance Market'
  };
  $('createModalTitle').textContent = titles[type];

  // Load gas price if switching to gas tab
  if (type === 'gas') loadGasPrice();
}

async function loadGasPrice() {
  try {
    const rpc = await getRpc();
    const feeData = await rpc.getFeeData();
    const gasGwei = Number(feeData.gasPrice) / 1e9;
    $('liveGasPrice').textContent = gasGwei.toFixed(2);
  } catch (e) {
    $('liveGasPrice').textContent = '...';
  }
}

function updateGasFormHints() {
  const marketType = $('gasMarketType').value;
  const thresholdGroup = $('gasThresholdGroup');
  const rangeGroup = $('gasRangeGroup');
  const opGroup = $('gasOpGroup');
  const thresholdHint = $('gasThresholdHint');

  // Range market uses lower/upper, others use threshold
  if (marketType === 'range') {
    thresholdGroup.style.display = 'none';
    rangeGroup.style.display = 'block';
    opGroup.style.display = 'none';
  } else {
    thresholdGroup.style.display = 'block';
    rangeGroup.style.display = 'none';
    opGroup.style.display = marketType === 'twap' ? 'block' : 'none';

    // Update hint based on market type
    const hints = {
      twap: 'Resolves YES if avg gas meets condition',
      volatility: 'Resolves YES if gas swing (max-min) >= threshold',
      peak: 'Resolves YES if gas spikes >= threshold',
      trough: 'Resolves YES if gas dips <= threshold'
    };
    thresholdHint.textContent = hints[marketType] || hints.twap;
  }
}

async function resolveENS(type) {
  const inputId = type === 'ethBalance' ? 'ethBalanceAddress' : 'tokenBalanceAddress';
  const hintId = type === 'ethBalance' ? 'ethBalanceResolved' : 'tokenBalanceResolved';
  const input = $(inputId).value.trim();
  const hint = $(hintId);

  resolvedAddresses[type] = null;

  if (!input) {
    hint.textContent = '';
    return;
  }

  // Check if already a valid address
  if (ethers.isAddress(input)) {
    resolvedAddresses[type] = input;
    hint.innerHTML = `<span style="color:#0F0">Valid address</span>`;
    if (type === 'ethBalance') loadAddressETHBalance(input);
    return;
  }

  // Try ENS resolution
  if (input.includes('.')) {
    hint.textContent = 'Resolving ENS...';
    try {
      const rpc = await getRpc();
      const resolved = await rpc.resolveName(input);
      if (resolved) {
        resolvedAddresses[type] = resolved;
        hint.innerHTML = `<span style="color:#0F0">${resolved.slice(0,6)}...${resolved.slice(-4)}</span>`;
        if (type === 'ethBalance') loadAddressETHBalance(resolved);
      } else {
        hint.innerHTML = `<span style="color:#F00">ENS not found</span>`;
      }
    } catch (e) {
      hint.innerHTML = `<span style="color:#F00">ENS resolution failed</span>`;
    }
  } else {
    hint.innerHTML = `<span style="color:#F00">Invalid address</span>`;
  }
}

async function loadAddressETHBalance(address) {
  try {
    const rpc = await getRpc();
    const balance = await rpc.getBalance(address);
    const ethBal = Number(ethers.formatEther(balance)).toFixed(4);
    const hint = $('ethBalanceResolved');
    hint.innerHTML += ` <span style="opacity:0.6">(${ethBal} ETH)</span>`;
  } catch (e) {}
}

async function showCreateModal() {
  $('createModal').classList.add('active');

  // Reset to price market type
  switchMarketType('price');

  // Set default close datetime to 1 year from now at midnight
  const oneYear = new Date();
  oneYear.setFullYear(oneYear.getFullYear() + 1);
  oneYear.setHours(0, 0, 0, 0);
  const defaultDate = oneYear.toISOString().slice(0, 16);

  // Set all date inputs
  $('closeDate').value = defaultDate;
  $('gasCloseDate').value = defaultDate;
  $('ethBalanceCloseDate').value = defaultDate;
  $('tokenBalanceCloseDate').value = defaultDate;

  // Set defaults
  $('targetPrice').value = '$10,000';
  $('totalLiquidity').value = '0.01'; // Default liquidity
  $('gasThreshold').value = '30';
  $('gasLower').value = '20';
  $('gasUpper').value = '50';
  $('ethBalanceThreshold').value = '100';
  $('tokenBalanceThreshold').value = '1000000';

  // Clear address fields
  $('ethBalanceAddress').value = '';
  $('ethBalanceResolved').textContent = '';
  $('tokenAddress').value = '';
  $('tokenInfo').textContent = '';
  $('tokenBalanceAddress').value = '';
  $('tokenBalanceResolved').textContent = '';
  resolvedAddresses = { ethBalance: null, tokenBalance: null };

  // Reset advanced liquidity options
  $('manualAmmAmount').value = '';
  $('manualVaultAmount').value = '';
  $('manualBidsAmount').value = '';
  $('manualEnableInitialBuy').checked = false;
  $('initialBuyAdvanced').style.display = 'none';
  $('advancedToggle').classList.remove('open');
  $('advancedSection').classList.remove('open');

  // Initialize liquidity split
  updateLiqSplit();

  // Load live ETH price
  try {
    const rpc = await getRpc();
    const chainlink = new ethers.Contract(CONTRACTS.CHAINLINK_ETH_USD, CHAINLINK_ABI, rpc);
    const price = await chainlink.latestAnswer();
    currentEthPrice = Number(price) / 1e8;
    $('livePrice').textContent = '$' + currentEthPrice.toLocaleString('en-US', { maximumFractionDigits: 2 });
    updatePriceDiffHint();
  } catch (e) {
    $('livePrice').textContent = 'Error loading price';
    currentEthPrice = 0;
  }
}

function formatTargetPrice() {
  const input = $('targetPrice');
  // Extract digits only
  const raw = input.value.replace(/[^0-9]/g, '');
  if (!raw) {
    input.value = '';
    $('priceDiffHint').textContent = '';
    return;
  }
  const num = parseInt(raw);
  // Format with $ and commas
  input.value = '$' + num.toLocaleString('en-US');
  updatePriceDiffHint();
}

function updatePriceDiffHint() {
  const hint = $('priceDiffHint');
  if (!currentEthPrice) {
    hint.textContent = '';
    return;
  }
  const raw = $('targetPrice').value.replace(/[^0-9]/g, '');
  if (!raw) {
    hint.textContent = '';
    return;
  }
  const target = parseInt(raw);
  const diff = target - currentEthPrice;
  const pct = (diff / currentEthPrice * 100).toFixed(1);
  const sign = diff >= 0 ? '+' : '';
  const color = diff >= 0 ? '#0F0' : '#F00';
  hint.innerHTML = `<span style="color:${color}">${sign}$${Math.abs(diff).toLocaleString('en-US', {maximumFractionDigits: 0})} (${sign}${pct}%)</span> from current price`;
}

function closeCreateModal() {
  $('createModal').classList.remove('active');
}

// ============ SMART LIQUIDITY SPLIT ============

// Compute optimal split using smooth scaling formula
// Small amounts â†’ heavier AMM (60/20/20)
// Large amounts â†’ more depth (40/30/30)
// Smooth logarithmic transition between extremes
function computeOptimalSplit(totalETH) {
  if (totalETH <= 0) {
    return { amm: 0, vault: 0, bids: 0, ammPct: 60, vaultPct: 20, bidsPct: 20 };
  }

  // Scale factor: 0 at 0.01 ETH, 1 at ~10 ETH, using log curve
  // log10(0.01*100) = 0, log10(10*100) = 3
  const scale = Math.min(1, Math.max(0, Math.log10(totalETH * 100) / 3));

  // Interpolate: AMM 60%â†’40%, Vault 20%â†’30%, Bids 20%â†’30%
  const ammPct = Math.round(60 - 20 * scale);
  const vaultPct = Math.round(20 + 10 * scale);
  const bidsPct = 100 - ammPct - vaultPct; // Ensure adds to 100

  return {
    amm: totalETH * ammPct / 100,
    vault: totalETH * vaultPct / 100,
    bids: totalETH * bidsPct / 100,
    ammPct, vaultPct, bidsPct
  };
}

// Set liquidity from preset button
function setLiqPreset(amount) {
  $('totalLiquidity').value = amount;
  // Update active state on buttons
  document.querySelectorAll('.liq-preset').forEach(btn => {
    btn.classList.toggle('active', parseFloat(btn.textContent) === amount);
  });
  updateLiqSplit();
}

// Update the visual split bar and hidden inputs
function updateLiqSplit() {
  const total = parseFloat($('totalLiquidity').value) || 0;

  // Check for manual overrides in advanced section
  const manualAmm = parseFloat($('manualAmmAmount').value);
  const manualVault = parseFloat($('manualVaultAmount').value);
  const manualBids = parseFloat($('manualBidsAmount').value);

  let split;
  if (!isNaN(manualAmm) || !isNaN(manualVault) || !isNaN(manualBids)) {
    // Manual mode - use specified values
    const amm = isNaN(manualAmm) ? 0 : manualAmm;
    const vault = isNaN(manualVault) ? 0 : manualVault;
    const bids = isNaN(manualBids) ? 0 : manualBids;
    const manualTotal = amm + vault + bids;
    split = {
      amm, vault, bids,
      ammPct: manualTotal > 0 ? Math.round(amm / manualTotal * 100) : 0,
      vaultPct: manualTotal > 0 ? Math.round(vault / manualTotal * 100) : 0,
      bidsPct: manualTotal > 0 ? Math.round(bids / manualTotal * 100) : 0
    };
    // Update total to match manual inputs
    if (manualTotal > 0) {
      $('totalLiquidity').value = manualTotal.toFixed(4);
    }
  } else {
    // Auto mode - compute optimal split
    split = computeOptimalSplit(total);
  }

  // Update legend with amounts
  $('liqLegAmm').textContent = `${split.amm.toFixed(3)} AMM`;
  $('liqLegVault').textContent = `${split.vault.toFixed(3)} Vault`;
  $('liqLegBids').textContent = `${split.bids.toFixed(3)} Bids`;

  // Update hidden inputs for existing createMarket logic
  $('seedAmount').value = split.amm;
  $('enableVault').checked = split.vault > 0;
  $('vaultAmount').value = split.vault;
  $('enableBids').checked = split.bids > 0;
  $('bidsAmount').value = split.bids;

  // Use manual vault percentages if set, otherwise 50/50
  const yesPct = parseInt($('manualVaultYesPct').value) || 50;
  const noPct = parseInt($('manualVaultNoPct').value) || 50;
  $('vaultYesPct').value = yesPct;
  $('vaultNoPct').value = noPct;

  // Use manual bid spread if set
  $('bidSpreadPreset').value = $('manualBidSpread').value || 'balanced';

  // Handle initial buy from advanced
  const buyEnabled = $('manualEnableInitialBuy').checked;
  $('enableInitialBuy').checked = buyEnabled;
  if (buyEnabled) {
    $('initialBuySide').value = $('manualInitialBuySide').value;
    $('initialBuyAmount').value = $('manualInitialBuyAmount').value;
  }

  // Update preset button states
  const presets = [0.01, 0.1, 0.5, 1];
  const currentTotal = parseFloat($('totalLiquidity').value) || 0;
  document.querySelectorAll('.liq-preset').forEach((btn, i) => {
    btn.classList.toggle('active', Math.abs(presets[i] - currentTotal) < 0.001);
  });
}

// Toggle advanced section
function toggleAdvanced() {
  const toggle = $('advancedToggle');
  const section = $('advancedSection');
  const isOpen = toggle.classList.toggle('open');
  section.classList.toggle('open', isOpen);
}

// Handle manual override changes
function onManualSplitChange() {
  updateLiqSplit();
}

// Show/hide initial buy inputs in advanced section
document.addEventListener('DOMContentLoaded', () => {
  const checkbox = $('manualEnableInitialBuy');
  if (checkbox) {
    checkbox.addEventListener('change', () => {
      $('initialBuyAdvanced').style.display = checkbox.checked ? 'block' : 'none';
      updateLiqSplit();
    });
  }
  // Initialize split on load
  updateLiqSplit();
});

// Bid spread presets: array of { buyYes, priceInBps }
// YES bids (buyYes=true) are placed below 50% - buying YES cheap
// NO bids (buyYes=false) are placed above 50% - buying NO cheap (= selling YES high)
const BID_PRESETS = {
  balanced: [
    { buyYes: true, priceInBps: 2500 },  // YES @ 25%
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: true, priceInBps: 4500 },  // YES @ 45%
    { buyYes: false, priceInBps: 5500 }, // NO @ 55% (YES sell @ 45%)
    { buyYes: false, priceInBps: 6500 }, // NO @ 65% (YES sell @ 35%)
    { buyYes: false, priceInBps: 7500 }, // NO @ 75% (YES sell @ 25%)
  ],
  tight: [
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: true, priceInBps: 4000 },  // YES @ 40%
    { buyYes: true, priceInBps: 4500 },  // YES @ 45%
    { buyYes: false, priceInBps: 5500 }, // NO @ 55%
    { buyYes: false, priceInBps: 6000 }, // NO @ 60%
    { buyYes: false, priceInBps: 6500 }, // NO @ 65%
  ],
  wide: [
    { buyYes: true, priceInBps: 1500 },  // YES @ 15%
    { buyYes: true, priceInBps: 2500 },  // YES @ 25%
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: false, priceInBps: 6500 }, // NO @ 65%
    { buyYes: false, priceInBps: 7500 }, // NO @ 75%
    { buyYes: false, priceInBps: 8500 }, // NO @ 85%
  ],
  yesOnly: [
    { buyYes: true, priceInBps: 2000 },  // YES @ 20%
    { buyYes: true, priceInBps: 3000 },  // YES @ 30%
    { buyYes: true, priceInBps: 3500 },  // YES @ 35%
    { buyYes: true, priceInBps: 4000 },  // YES @ 40%
    { buyYes: true, priceInBps: 4500 },  // YES @ 45%
  ],
  noOnly: [
    { buyYes: false, priceInBps: 5500 }, // NO @ 55%
    { buyYes: false, priceInBps: 6000 }, // NO @ 60%
    { buyYes: false, priceInBps: 6500 }, // NO @ 65%
    { buyYes: false, priceInBps: 7500 }, // NO @ 75%
    { buyYes: false, priceInBps: 8000 }, // NO @ 80%
  ]
};

function getBidsParams() {
  if (!$('enableBids').checked) return null;
  const amount = parseFloat($('bidsAmount').value) || 0;
  if (amount <= 0) return null;

  const preset = $('bidSpreadPreset').value;
  const levels = BID_PRESETS[preset];
  if (!levels || levels.length === 0) return null;

  const totalWei = ethers.parseEther(amount.toString());
  const perLevel = totalWei / BigInt(levels.length);
  const remainder = totalWei % BigInt(levels.length);

  // Build bids array: { buyYes, priceInBps, amount, minShares }
  // Add any remainder to first bid to avoid losing dust
  return levels.map((level, i) => ({
    buyYes: level.buyYes,
    priceInBps: BigInt(level.priceInBps), // Must be BigInt for proper ABI encoding
    amount: i === 0 ? perLevel + remainder : perLevel,
    minShares: 0n // No slippage check for initial seeding
  }));
}

function getVaultParams() {
  if (!$('enableVault').checked) return null;
  const vaultAmount = parseFloat($('vaultAmount').value) || 0;
  if (vaultAmount <= 0) return null;
  const yesPct = parseInt($('vaultYesPct').value) || 0;
  const noPct = parseInt($('vaultNoPct').value) || 0;
  const collateralForVault = ethers.parseEther(vaultAmount.toString());
  // Shares are in wei - pct of total vault collateral
  const vaultYesShares = collateralForVault * BigInt(yesPct) / 100n;
  const vaultNoShares = collateralForVault * BigInt(noPct) / 100n;
  return { collateralForVault, vaultYesShares, vaultNoShares };
}

function getInitialBuyParams() {
  if (!$('enableInitialBuy').checked) return null;
  const amount = parseFloat($('initialBuyAmount').value) || 0;
  if (amount <= 0) return null;
  const buyYes = $('initialBuySide').value === 'yes';
  const collateralForBuy = ethers.parseEther(amount.toString());
  return { buyYes, collateralForBuy };
}

function getTotalCollateral() {
  const seedAmount = parseFloat($('seedAmount').value) || 0;
  const vaultAmount = $('enableVault').checked ? (parseFloat($('vaultAmount').value) || 0) : 0;
  const buyAmount = $('enableInitialBuy').checked ? (parseFloat($('initialBuyAmount').value) || 0) : 0;
  const bidsAmount = $('enableBids').checked ? (parseFloat($('bidsAmount').value) || 0) : 0;
  return seedAmount + vaultAmount + buyAmount + bidsAmount;
}

async function createMarket() {
  if (!connectedAddress) {
    closeCreateModal();
    return toggleWallet();
  }

  const seedAmount = parseFloat($('seedAmount').value) || 0;
  const totalCollateral = getTotalCollateral();
  if (totalCollateral < 0.001) {
    alert('Enter at least 0.001 ETH total liquidity (AMM + Vault + Buy)');
    return;
  }

  const collateralForLP = ethers.parseEther(seedAmount.toString());
  const totalWei = ethers.parseEther(totalCollateral.toString());
  const deadline = Math.floor(Date.now() / 1000) + 3600;
  const vaultParams = getVaultParams();
  const buyParams = getInitialBuyParams();
  const bidsParams = getBidsParams();

  // Route to appropriate handler based on market type
  if (currentMarketType === 'price') {
    await createPriceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  } else if (currentMarketType === 'gas') {
    await createGasMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  } else if (currentMarketType === 'ethBalance') {
    await createETHBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  } else if (currentMarketType === 'tokenBalance') {
    await createTokenBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams);
  }
}

async function createPriceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const targetPriceRaw = $('targetPrice').value.replace(/[^0-9]/g, '');
  const targetPrice = parseInt(targetPriceRaw);
  const closeDateStr = $('closeDate').value;

  if (!targetPrice || targetPrice < 1) {
    alert('Enter a valid target price');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  // Chainlink uses 8 decimals
  const threshold = BigInt(targetPrice) * BigInt(1e8);

  // Build tagged description for parsing: TYPE|ASSET|QUOTE|OP|PRICE|CLOSE (OP 3 = GTE)
  const description = `PRICE|ETH|USD|3|${targetPrice}|${closeTimestamp}`;

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;

    const hasVaultOrBuy = vaultParams || buyParams;
    const hasBids = bidsParams && bidsParams.length > 0;

    if (hasVaultOrBuy && hasBids) {
      // Full bootstrap: AMM + Vault + Initial Buy + Bids
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
      tx = await bootstrapper.bootstrapPriceMarketWithVaultAndBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        vault,
        buy,
        bidsParams,
        { value: totalWei }
      );
    } else if (hasVaultOrBuy) {
      // AMM + Vault + Initial Buy (no bids)
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
      tx = await bootstrapper.bootstrapPriceMarketWithVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        vault,
        buy,
        { value: totalWei }
      );
    } else if (hasBids) {
      // AMM + Bids only (no vault/buy)
      tx = await bootstrapper.bootstrapPriceMarketWithBids(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        bidsParams,
        { value: totalWei }
      );
    } else {
      // Simple bootstrap (AMM only)
      tx = await bootstrapper.bootstrapPriceMarket(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        CONTRACTS.CHAINLINK_ETH_USD,
        OP.GTE,
        threshold,
        { value: collateralForLP }
      );
    }

    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      addMarketToUI(marketId, formatQuestion(targetPrice, closeTimestamp), targetPrice, closeTimestamp);
    }

    closeCreateModal();
    showTxSuccess(receipt, marketId, vaultParams, buyParams, bidsParams);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function showTxSuccess(receipt, marketId, vaultParams, buyParams, bidsParams) {
  const extras = [];
  if (vaultParams) extras.push('vault');
  if (buyParams && buyParams.collateralForBuy > 0n) extras.push('initial buy');
  if (bidsParams && bidsParams.length > 0) extras.push(`${bidsParams.length} bids`);
  const extraMsg = extras.length ? ` with ${extras.join(' + ')}` : '';

  const etherscanUrl = `https://etherscan.io/tx/${receipt.hash}`;
  const marketIdStr = marketId ? marketId.toString() : null;
  const marketIdShort = marketIdStr ? `#${marketIdStr.slice(0,8)}...` : '';

  // Show success modal or enhanced alert
  const msg = `Market created${extraMsg}!\n\n${marketIdShort}\n\nView on Etherscan?`;
  if (confirm(msg)) {
    window.open(etherscanUrl, '_blank');
  }

  // Load the specific market directly (more reliable than loadMarkets when getMarkets fails)
  if (marketIdStr) {
    await loadMarketById(marketIdStr);
    // Update URL to deep link to this market
    window.history.pushState({}, '', `#${marketIdStr}`);
  } else {
    // Fallback to reload all markets
    loadMarkets();
  }
}

async function createETHBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const accountAddress = resolvedAddresses.ethBalance || $('ethBalanceAddress').value.trim();
  const threshold = parseFloat($('ethBalanceThreshold').value);
  const closeDateStr = $('ethBalanceCloseDate').value;

  if (!accountAddress || !ethers.isAddress(accountAddress)) {
    alert('Enter a valid wallet address');
    return;
  }
  if (!threshold || threshold <= 0) {
    alert('Enter a valid ETH threshold');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  const thresholdWei = ethers.parseEther(threshold.toString());

  // Build tagged description: TYPE|ACCOUNT|OP|THRESHOLD|CLOSE (OP 3 = GTE)
  const description = `ETHBAL|${accountAddress}|3|${threshold}|${closeTimestamp}`;

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;

    if (vaultParams || buyParams) {
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapETHBalanceMarketWithVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        accountAddress,
        OP.GTE,
        thresholdWei,
        vault,
        buy,
        { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapETHBalanceMarket(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        accountAddress,
        OP.GTE,
        thresholdWei,
        { value: collateralForLP }
      );
    }

    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const shortAddr = `${accountAddress.slice(0,6)}...${accountAddress.slice(-4)}`;
      const q = `WILL <u style="text-decoration-color:#0F0">${shortAddr}</u> HOLD <u style="text-decoration-color:#627EEA">${threshold} ETH</u>?`;
      addMarketToUI(marketId, q, threshold, closeTimestamp, 'ethbal');
    }

    closeCreateModal();
    showTxSuccess(receipt, marketId, vaultParams, buyParams, null);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function createTokenBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const tokenAddress = $('tokenAddress').value.trim();
  const accountAddress = resolvedAddresses.tokenBalance || $('tokenBalanceAddress').value.trim();
  const threshold = parseFloat($('tokenBalanceThreshold').value);
  const closeDateStr = $('tokenBalanceCloseDate').value;

  if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
    alert('Enter a valid token address');
    return;
  }
  if (!accountAddress || !ethers.isAddress(accountAddress)) {
    alert('Enter a valid wallet address');
    return;
  }
  if (!threshold || threshold <= 0) {
    alert('Enter a valid token threshold');
    return;
  }
  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  // Get token decimals
  let decimals = 18;
  let symbol = 'TOKEN';
  try {
    const rpc = await getRpc();
    const token = new ethers.Contract(tokenAddress, [
      'function decimals() view returns (uint8)',
      'function symbol() view returns (string)'
    ], rpc);
    decimals = await token.decimals();
    symbol = await token.symbol();
  } catch (e) {
    console.warn('Could not fetch token info, using defaults');
  }

  const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);

  // Build tagged description: TYPE|TOKEN|ACCOUNT|OP|THRESHOLD|CLOSE (OP 3 = GTE)
  const description = `TOKBAL|${tokenAddress}|${accountAddress}|3|${threshold}|${closeTimestamp}`;

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    let tx;

    if (vaultParams || buyParams) {
      const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
      const buy = buyParams || { buyYes: false, collateralForBuy: 0n };

      tx = await bootstrapper.bootstrapTokenBalanceMarketWithVault(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        accountAddress,
        OP.GTE,
        thresholdUnits,
        vault,
        buy,
        { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapTokenBalanceMarket(
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        tokenAddress,
        accountAddress,
        OP.GTE,
        thresholdUnits,
        { value: collateralForLP }
      );
    }

    const receipt = await tx.wait();
    console.log('Bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const shortAddr = `${accountAddress.slice(0,6)}...${accountAddress.slice(-4)}`;
      const formattedThreshold = threshold >= 1e6 ? `${(threshold/1e6).toFixed(1)}M` : threshold.toLocaleString();
      const q = `WILL <u style="text-decoration-color:#0F0">${shortAddr}</u> HOLD <u style="text-decoration-color:#627EEA">${formattedThreshold} ${symbol}</u>?`;
      addMarketToUI(marketId, q, threshold, closeTimestamp, 'tokbal');
    }

    closeCreateModal();
    showTxSuccess(receipt, marketId, vaultParams, buyParams, null);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

async function createGasMarket(collateralForLP, totalWei, deadline, vaultParams, buyParams, bidsParams) {
  const marketType = $('gasMarketType').value;
  const closeDateStr = $('gasCloseDate').value;

  if (!closeDateStr) {
    alert('Select a close date and time');
    return;
  }

  const closeTimestamp = parseUTCDateTime(closeDateStr);
  const minCloseTime = Math.floor(Date.now() / 1000) + 3600; // At least 1 hour from now
  if (closeTimestamp < minCloseTime) {
    alert('Close date must be at least 1 hour in the future');
    return;
  }

  let description, methodName, methodArgs, useVault = false;

  if (marketType === 'range') {
    const lower = parseInt($('gasLower').value);
    const upper = parseInt($('gasUpper').value);
    if (!lower || !upper || lower >= upper) {
      alert('Enter valid gas range (lower < upper)');
      return;
    }
    // Gwei to wei for gas thresholds
    const lowerWei = BigInt(lower) * BigInt(1e9);
    const upperWei = BigInt(upper) * BigInt(1e9);
    description = `GAS|RANGE|${lower}|${upper}|${closeTimestamp}`;
    methodName = 'bootstrapGasRangeMarket';
    methodArgs = [
      description,
      ethers.ZeroAddress,
      closeTimestamp,
      false,
      CONTRACTS.PM_FEE_HOOK,
      collateralForLP,
      connectedAddress,
      deadline,
      lowerWei,
      upperWei
    ];
  } else {
    const threshold = parseInt($('gasThreshold').value);
    if (!threshold || threshold <= 0) {
      alert('Enter a valid gas threshold');
      return;
    }
    const thresholdWei = BigInt(threshold) * BigInt(1e9);
    const op = parseInt($('gasOp').value);

    const typeNames = { twap: 'TWAP', volatility: 'VOLATILITY', peak: 'PEAK', trough: 'TROUGH' };
    description = `GAS|${typeNames[marketType]}|${threshold}|${closeTimestamp}`;

    if (marketType === 'twap') {
      // TWAP supports vault deposits
      if (vaultParams || buyParams) {
        const vault = vaultParams || { collateralForVault: 0n, vaultYesShares: 0n, vaultNoShares: 0n };
        const buy = buyParams || { buyYes: false, collateralForBuy: 0n };
        methodName = 'bootstrapGasTWAPMarketWithVault';
        methodArgs = [
          description,
          ethers.ZeroAddress,
          closeTimestamp,
          false,
          CONTRACTS.PM_FEE_HOOK,
          collateralForLP,
          connectedAddress,
          deadline,
          op,
          thresholdWei,
          vault,
          buy
        ];
        useVault = true;
      } else {
        methodName = 'bootstrapGasTWAPMarket';
        methodArgs = [
          description,
          ethers.ZeroAddress,
          closeTimestamp,
          false,
          CONTRACTS.PM_FEE_HOOK,
          collateralForLP,
          connectedAddress,
          deadline,
          op,
          thresholdWei
        ];
      }
    } else if (marketType === 'volatility') {
      methodName = 'bootstrapGasVolatilityMarket';
      methodArgs = [
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        false,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        thresholdWei
      ];
    } else if (marketType === 'peak') {
      methodName = 'bootstrapGasPeakMarket';
      methodArgs = [
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        false,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        thresholdWei
      ];
    } else if (marketType === 'trough') {
      methodName = 'bootstrapGasTroughMarket';
      methodArgs = [
        description,
        ethers.ZeroAddress,
        closeTimestamp,
        false,
        CONTRACTS.PM_FEE_HOOK,
        collateralForLP,
        connectedAddress,
        deadline,
        thresholdWei
      ];
    }
  }

  $('createBtn').disabled = true;
  $('createBtn').textContent = 'CREATING...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, signer);
    const tx = await bootstrapper[methodName](...methodArgs, { value: useVault ? totalWei : collateralForLP });
    const receipt = await tx.wait();
    console.log('Gas market bootstrap tx:', receipt.hash);

    const marketId = parseMarketIdFromReceipt(receipt);
    if (marketId) {
      const threshold = parseInt($('gasThreshold').value) || 0;
      const lower = parseInt($('gasLower').value) || 0;
      const upper = parseInt($('gasUpper').value) || 0;
      const typeLabel = marketType.toUpperCase();
      const q = marketType === 'range'
        ? `WILL <u style="text-decoration-color:#F90">GAS</u> STAY BETWEEN <u style="text-decoration-color:#0F0">${lower}-${upper} GWEI</u>?`
        : `WILL <u style="text-decoration-color:#F90">GAS ${typeLabel}</u> REACH <u style="text-decoration-color:#0F0">${threshold} GWEI</u>?`;
      addMarketToUI(marketId, q, threshold || lower, closeTimestamp, 'gas');
    }

    closeCreateModal();
    showTxSuccess(receipt, marketId, useVault ? vaultParams : null, useVault ? buyParams : null, null);

  } catch (e) {
    handleCreateError(e);
  } finally {
    $('createBtn').disabled = false;
    $('createBtn').textContent = 'CREATE MARKET';
  }
}

function parseMarketIdFromReceipt(receipt) {
  // Try multiple known event signatures
  const eventSignatures = [
    'MarketCreated(uint256,uint256,string,address,address,uint64,bool)',
    'MarketCreated(uint256,address,address)',
    'MarketCreated(uint256)',
    'Transfer(address,address,uint256)' // ERC1155 mint to get market ID
  ];

  for (const log of receipt.logs) {
    try {
      for (const sig of eventSignatures) {
        if (log.topics[0] === ethers.id(sig)) {
          // Market ID is typically in topics[1]
          if (log.topics[1]) {
            console.log('Found market ID from event:', sig, log.topics[1]);
            return log.topics[1];
          }
        }
      }
    } catch (e) {}
  }

  // Fallback: look for any log from PAMM with a market-like ID in topics
  for (const log of receipt.logs) {
    try {
      if (log.address.toLowerCase() === CONTRACTS.PAMM.toLowerCase() && log.topics[1]) {
        console.log('Found potential market ID from PAMM log:', log.topics[1]);
        return log.topics[1];
      }
    } catch (e) {}
  }

  console.warn('Could not find market ID in receipt logs');
  return null;
}

function addMarketToUI(marketId, question, threshold, closeTimestamp, type = 'price') {
  const newMarket = {
    id: marketId.toString().slice(-6),
    marketId: marketId.toString(),
    q: question,
    c: type === 'price' ? '#627EEA' : '#0F0',
    logo: type === 'price' ? 'eth' : (type === 'ethbal' ? 'eth' : 'token'),
    y: 50,
    isDemo: false,
    threshold: threshold,
    close: closeTimestamp,
    type: type
  };
  markets.unshift(newMarket);
  currentIndex = 0;
  render();
  window.history.pushState({}, '', `#${marketId}`);
}

function handleCreateError(e) {
  console.error('Create failed:', e);

  // Try to extract the most useful error message
  let msg = 'Unknown error';

  // Check for revert reason in various places ethers.js might put it
  if (e.reason) {
    msg = e.reason;
  } else if (e.data?.message) {
    msg = e.data.message;
  } else if (e.error?.message) {
    msg = e.error.message;
  } else if (e.shortMessage) {
    msg = e.shortMessage;
  } else if (e.message) {
    msg = e.message;
  }

  // For CALL_EXCEPTION, try to decode the revert data
  if (e.code === 'CALL_EXCEPTION' || msg.includes('CALL_EXCEPTION')) {
    const revertData = e.data || e.revert?.data || e.error?.data;
    if (revertData) {
      // Known error selectors from Bootstrapper
      const knownErrors = {
        '0x2929f974': 'TransferError',
        '0xab143c06': 'Reentrancy',
        '0x077a9c33': 'ValidationError'
      };
      const selector = revertData.slice(0, 10);
      if (knownErrors[selector]) {
        msg = `${knownErrors[selector]} - ${revertData}`;
      } else {
        msg = `Revert: ${revertData}`;
      }
    } else {
      msg = 'Transaction reverted (no revert data available)';
    }
  }

  // Log full error details to console
  console.log('Error details:', {
    code: e.code,
    reason: e.reason,
    data: e.data,
    revert: e.revert,
    error: e.error,
    shortMessage: e.shortMessage
  });

  if (!msg.toLowerCase().includes('user rejected') && !msg.toLowerCase().includes('user denied')) {
    alert('Create failed: ' + msg);
  }
}

// ======================== WALLET ========================
function initEIP6963() {
  if (typeof window === 'undefined') return;
  window.addEventListener('eip6963:announceProvider', (event) => {
    const { info, provider } = event.detail;
    eip6963Providers.set(info.uuid, { info, provider });
  });
  window.dispatchEvent(new Event('eip6963:requestProvider'));
}

function detectWallets() {
  const detected = [];
  const seenNames = new Set();

  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    if (config.detect && config.detect()) {
      detected.push({ key, ...config });
      seenNames.add(config.name.toLowerCase());
    }
  }

  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    if (!seenNames.has(info.name.toLowerCase())) {
      const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
      const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({
        key: `eip6963_${uuid}`,
        name: safeName,
        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'ðŸ”Œ',
        getProvider: () => provider
      });
      seenNames.add(info.name.toLowerCase());
    }
  }

  if (detected.length === 0 && window.ethereum) {
    detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'ðŸ”—', getProvider: () => window.ethereum });
  }

  const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) {
    detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'ðŸ“±', isWalletConnect: true });
  }

  return detected;
}

function showWalletModal() {
  const wallets = detectWallets();
  const container = $('walletOptions');

  if (connectedAddress) {
    container.innerHTML = `
      <div style="padding: 12px; border: 2px solid var(--fg); margin-bottom: 12px;">
        <div style="font-weight: 600; margin-bottom: 6px;">Connected</div>
        <div style="font-size: 14px; word-break: break-all; color: #0F0;">${connectedAddress}</div>
      </div>
      <div class="wallet-option disconnect" onclick="disconnectWallet()">
        <span class="wallet-option-name">Disconnect</span>
      </div>
    `;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `
      <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
        <span class="wallet-option-icon">${w.icon}</span>
        <span class="wallet-option-name">${w.name}</span>
      </div>
    `).join('') : '<div style="padding:12px;text-align:center;">No wallets detected. Install MetaMask or use WalletConnect.</div>';
  }

  $('walletModal').classList.add('active');
}

function closeWalletModal() {
  $('walletModal').classList.remove('active');
}

function toggleWallet() {
  showWalletModal();
}

async function connectWithWallet(walletKey) {
  if (isConnecting) return;
  isConnecting = true;

  try {
    closeWalletModal();
    let walletProvider;

    if (walletKey === 'walletconnect') {
      const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;

      if (!WCProvider?.init) throw new Error('WalletConnect not available');

      if (walletConnectProvider) {
        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
        walletConnectProvider = null;
      }

      walletConnectProvider = await WCProvider.init({
        projectId: '1e8390ef1c1d8a185e035912a1409749',
        chains: [1],
        showQrModal: true,
        rpcMap: { 1: 'https://1rpc.io/eth' },
        metadata: {
          name: 'ethPM',
          description: 'Ethereum Prediction Markets',
          url: window.location.origin,
          icons: []
        }
      });

      await walletConnectProvider.enable();
      walletProvider = walletConnectProvider;
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
    }

    if (!walletProvider) throw new Error('Wallet not found');

    if (walletKey !== 'walletconnect') {
      await walletProvider.request({ method: 'eth_requestAccounts' });
    }

    provider = new ethers.BrowserProvider(walletProvider);
    signer = await provider.getSigner();
    connectedAddress = await signer.getAddress();
    connectedWalletProvider = walletProvider;

    $('wallet').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);

    walletProvider.on('accountsChanged', () => window.location.reload());
    walletProvider.on('chainChanged', () => window.location.reload());

    localStorage.setItem('ethpm_wallet', walletKey);

    // Load positions after wallet connect
    await loadPositions();
    loadResolutionStatus();
    loadPriceChart();

  } catch (error) {
    console.error('Connection failed:', error);
    const msg = (error.message || '').toLowerCase();
    if (!msg.includes('user rejected') && !msg.includes('user denied')) {
      alert('Connection failed: ' + (error.message || 'Unknown error'));
    }
  } finally {
    isConnecting = false;
  }
}

function disconnectWallet() {
  if (walletConnectProvider) {
    try { walletConnectProvider.disconnect(); } catch (e) {}
    walletConnectProvider = null;
  }
  provider = null;
  signer = null;
  connectedAddress = null;
  connectedWalletProvider = null;
  userPositions = { yes: 0n, no: 0n };
  $('wallet').textContent = 'connect';
  $('positions').style.display = 'none';
  closeWalletModal();
  localStorage.removeItem('ethpm_wallet');
}

function toggleTheme() {
  dark = !dark;
  document.documentElement.dataset.theme = dark ? 'dark' : '';
  $('theme').textContent = dark ? 'light' : 'dark';
  localStorage.theme = dark ? 'dark' : 'light';
}

document.addEventListener('click', e => { if (!e.target.closest('.odds')) closeDrop(); });

// ======================== LP MODAL ========================
let lpAllocation = { yes: 0, no: 0, amm: 100 };

function showLPModal() {
  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('This is a demo market. Create a real market first using "+ create"');
    return;
  }
  if (m.resolved) {
    alert('Cannot provide liquidity to a resolved market');
    return;
  }

  // Set market info in modal
  const priceStr = m.threshold >= 1000 ? `$${(m.threshold/1000).toFixed(0)}K` : `$${m.threshold}`;
  $('lpMarketName').textContent = `ETH ${priceStr}`;

  // Load TVL
  loadMarketTVL(m.marketId);

  // Reset allocation to default
  lpAllocation = { yes: 0, no: 0, amm: 100 };
  $('lpYesSlider').value = 0;
  $('lpNoSlider').value = 0;
  $('lpAmmSlider').value = 100;
  $('lpYesPct').textContent = '0%';
  $('lpNoPct').textContent = '0%';
  $('lpAmmPct').textContent = '100%';
  $('lpAmount').value = '';
  updateLPPreview();

  $('lpModal').classList.add('active');
}

function closeLPModal() {
  $('lpModal').classList.remove('active');
}

async function loadMarketTVL(marketId) {
  try {
    const rpc = provider || await getRpc();
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
    const market = await pamm.markets(marketId);
    const tvlEth = Number(market.collateralLocked) / 1e18;
    $('lpTvl').textContent = tvlEth < 1 ? tvlEth.toFixed(4) + ' ETH' : tvlEth.toFixed(2) + ' ETH';
  } catch (e) {
    $('lpTvl').textContent = '-- ETH';
  }
}

function updateLPAllocation(changed) {
  const newVal = parseInt($(`lp${changed.charAt(0).toUpperCase() + changed.slice(1)}Slider`).value);
  lpAllocation[changed] = newVal;

  // Calculate remaining for other two sliders
  const remaining = 100 - newVal;
  const others = ['yes', 'no', 'amm'].filter(k => k !== changed);

  // Distribute remaining proportionally, or evenly if both were 0
  const otherSum = lpAllocation[others[0]] + lpAllocation[others[1]];
  if (otherSum > 0 && remaining > 0) {
    lpAllocation[others[0]] = Math.round(lpAllocation[others[0]] * remaining / otherSum);
    lpAllocation[others[1]] = remaining - lpAllocation[others[0]];
  } else if (remaining > 0) {
    lpAllocation[others[0]] = Math.floor(remaining / 2);
    lpAllocation[others[1]] = remaining - lpAllocation[others[0]];
  } else {
    lpAllocation[others[0]] = 0;
    lpAllocation[others[1]] = 0;
  }

  // Update sliders and percentages
  $('lpYesSlider').value = lpAllocation.yes;
  $('lpNoSlider').value = lpAllocation.no;
  $('lpAmmSlider').value = lpAllocation.amm;
  $('lpYesPct').textContent = lpAllocation.yes + '%';
  $('lpNoPct').textContent = lpAllocation.no + '%';
  $('lpAmmPct').textContent = lpAllocation.amm + '%';

  updateLPPreview();
}

function updateLPPreview() {
  const amount = parseFloat($('lpAmount').value) || 0;

  // Calculate allocation amounts
  const yesAmount = amount * lpAllocation.yes / 100;
  const noAmount = amount * lpAllocation.no / 100;
  const ammAmount = amount * lpAllocation.amm / 100;

  // Preview values (simplified - actual values depend on market state)
  $('lpPreviewYes').textContent = yesAmount > 0 ? yesAmount.toFixed(4) : '0';
  $('lpPreviewNo').textContent = noAmount > 0 ? noAmount.toFixed(4) : '0';
  $('lpPreviewAmm').textContent = ammAmount > 0 ? ammAmount.toFixed(4) : '0';
}

async function provideLiquidity() {
  if (!connectedAddress) {
    closeLPModal();
    return toggleWallet();
  }

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('This is a demo market. Create a real market first.');
    return;
  }

  const amount = parseFloat($('lpAmount').value);
  if (!amount || amount <= 0) {
    alert('Enter an amount');
    return;
  }

  // Calculate allocation in wei
  const collateralWei = ethers.parseEther(amount.toString());
  const yesWei = ethers.parseEther((amount * lpAllocation.yes / 100).toString());
  const noWei = ethers.parseEther((amount * lpAllocation.no / 100).toString());
  const ammWei = ethers.parseEther((amount * lpAllocation.amm / 100).toString());

  const deadline = Math.floor(Date.now() / 1000) + 3600;

  $('lpBtn').disabled = true;
  $('lpBtn').textContent = 'PROVIDING...';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    const isLabeled = isOurLabeledMarket(m.description);
    let tx;

    // For legacy/external markets, use direct PAMM.splitAndAddLiquidity (AMM only)
    if (!isLabeled) {
      console.log('Using direct PAMM for legacy market LP');

      // Legacy markets only support AMM LP via splitAndAddLiquidity
      if (lpAllocation.yes > 0 || lpAllocation.no > 0) {
        alert('Legacy markets only support AMM LP. Set YES/NO vault allocation to 0%.');
        return;
      }

      tx = await pamm.splitAndAddLiquidity(
        m.marketId,
        collateralWei,
        LEGACY_FEE_BPS,  // 30 bps fee tier for legacy markets
        0,               // amount0Min
        0,               // amount1Min
        0,               // minLiquidity
        connectedAddress,
        deadline,
        { value: collateralWei }
      );
    } else {
      // Check operator approval for MasterRouter
      const isOp = await pamm.isOperator(connectedAddress, CONTRACTS.MASTER_ROUTER);
      if (!isOp) {
        const approveTx = await pamm.setOperator(CONTRACTS.MASTER_ROUTER, true);
        await approveTx.wait();
      }

      // Provide liquidity via MasterRouter
      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, signer);
      tx = await router.provideLiquidity(
        m.marketId,
        collateralWei,
        yesWei,      // vaultYesShares
        noWei,       // vaultNoShares
        ammWei,      // ammLPShares
        0,           // minAmount0 (0 = accept any)
        0,           // minAmount1 (0 = accept any)
        connectedAddress,
        deadline,
        { value: collateralWei }
      );
    }

    const receipt = await tx.wait();
    console.log('Provide liquidity tx:', receipt.hash);

    // Refresh market data
    m.y = await loadMarketOdds(m.marketId);
    await loadPositions();
    render();

    closeLPModal();
    alert(`Liquidity provided! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Provide liquidity failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Provide liquidity failed: ' + msg);
    }
  } finally {
    $('lpBtn').disabled = false;
    $('lpBtn').textContent = 'PROVIDE LIQUIDITY';
  }
}

// ======================== WITHDRAW LIQUIDITY ========================
async function withdrawVault(isYes) {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const vaultShares = isYes ? lpPositions.yesVault : lpPositions.noVault;
  if (vaultShares <= 0n) {
    alert(`No ${isYes ? 'YES' : 'NO'} vault shares to withdraw`);
    return;
  }

  const btnId = isYes ? 'yesVaultWithdrawBtn' : 'noVaultWithdrawBtn';
  $(btnId).disabled = true;
  $(btnId).textContent = '...';

  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, signer);
    const deadline = Math.floor(Date.now() / 1000) + 3600;

    const tx = await hookRouter.withdrawFromVault(
      m.marketId,
      isYes,
      vaultShares,  // Withdraw all
      connectedAddress,
      deadline
    );

    const receipt = await tx.wait();
    console.log('Withdraw vault tx:', receipt.hash);

    // Refresh positions
    await loadPositions();

    alert(`Withdrew ${isYes ? 'YES' : 'NO'} vault! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Withdraw vault failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Withdraw failed: ' + msg);
    }
  } finally {
    $(btnId).disabled = false;
    $(btnId).textContent = 'WITHDRAW';
  }
}

async function harvestFees(isYes) {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  const pendingFees = isYes ? lpPositions.yesFees : lpPositions.noFees;
  if (pendingFees <= 0n) {
    alert(`No ${isYes ? 'YES' : 'NO'} vault fees to harvest`);
    return;
  }

  const btnId = isYes ? 'yesHarvestBtn' : 'noHarvestBtn';
  $(btnId).disabled = true;
  $(btnId).textContent = '...';

  try {
    const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, signer);

    const tx = await hookRouter.harvestVaultFees(m.marketId, isYes);

    const receipt = await tx.wait();
    console.log('Harvest fees tx:', receipt.hash);

    // Refresh positions
    await loadPositions();

    const harvestedEth = formatFeesETH(pendingFees);
    alert(`Harvested ${harvestedEth}! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Harvest fees failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Harvest failed: ' + msg);
    }
  } finally {
    $(btnId).disabled = false;
    $(btnId).textContent = 'HARVEST';
  }
}

async function withdrawAmmLP() {
  if (!connectedAddress) return toggleWallet();

  const m = markets[currentIndex];
  if (!m?.marketId) {
    alert('No market selected');
    return;
  }

  if (lpPositions.ammLP <= 0n) {
    alert('No AMM LP to withdraw');
    return;
  }

  $('ammLpWithdrawBtn').disabled = true;
  $('ammLpWithdrawBtn').textContent = '...';

  try {
    // First approve ZAMM operator for PAMM if needed
    const zamm = new ethers.Contract(CONTRACTS.ZAMM, ZAMM_ABI, signer);
    const isOp = await zamm.isOperator(connectedAddress, CONTRACTS.PAMM);
    if (!isOp) {
      const approveTx = await zamm.setOperator(CONTRACTS.PAMM, true);
      await approveTx.wait();
    }

    // Call PAMM.removeLiquidityToCollateral
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, signer);
    const deadline = Math.floor(Date.now() / 1000) + 3600;

    // Determine feeOrHook based on market type
    const isLabeled = isOurLabeledMarket(m.description);
    const feeOrHook = isLabeled ? CONTRACTS.PM_FEE_HOOK : LEGACY_FEE_BPS;

    const tx = await pamm.removeLiquidityToCollateral(
      m.marketId,
      feeOrHook,                 // feeOrHook (hook for our markets, 30 bps for legacy)
      lpPositions.ammLP,         // liquidity
      0,                          // amount0Min
      0,                          // amount1Min
      0,                          // minCollateralOut
      connectedAddress,
      deadline
    );

    const receipt = await tx.wait();
    console.log('Withdraw AMM LP tx:', receipt.hash);

    // Refresh positions
    await loadPositions();

    alert(`Withdrew AMM LP! TX: ${receipt.hash.slice(0,10)}...`);

  } catch (e) {
    console.error('Withdraw AMM LP failed:', e);
    const msg = e.reason || e.message || 'Unknown error';
    if (!msg.toLowerCase().includes('user rejected')) {
      alert('Withdraw failed: ' + msg);
    }
  } finally {
    $('ammLpWithdrawBtn').disabled = false;
    $('ammLpWithdrawBtn').textContent = 'WITHDRAW';
  }
}

// ======================== MARKET BROWSER ========================
let browserFilter = 'all';    // 'all', 'price', 'gas', 'balance'
let browserStatus = 'open';   // 'open', 'resolved', 'all'
let browserSearch = '';

function showBrowserModal() {
  $('browserModal').classList.add('active');
  $('browserSearch').value = '';
  browserSearch = '';
  renderBrowserList();
}

function closeBrowserModal() {
  $('browserModal').classList.remove('active');
}

function setBrowserFilter(f) {
  browserFilter = f;
  // Update active state on buttons
  document.querySelectorAll('.market-filter').forEach((btn, i) => {
    const filters = ['all', 'price', 'gas', 'balance'];
    btn.classList.toggle('active', filters[i] === f);
  });
  renderBrowserList();
}

function setBrowserStatus(s) {
  browserStatus = s;
  // Update active state on buttons
  document.querySelectorAll('.market-status-filter').forEach((btn, i) => {
    const statuses = ['open', 'resolved', 'all'];
    btn.classList.toggle('active', statuses[i] === s);
  });
  renderBrowserList();
}

function onBrowserSearch(e) {
  browserSearch = e.target.value.toLowerCase();
  renderBrowserList();
}

function getMarketType(m) {
  // Determine type from description or parsed data
  if (!m.q) return 'unknown';
  const q = m.q.toLowerCase();
  if (q.includes('gas') || q.includes('gwei')) return 'gas';
  if (q.includes('0x') && (q.includes('eth') || q.includes('bal'))) return 'balance';
  if (q.includes('$') || q.includes('price') || q.includes('hit') || q.includes('drop')) return 'price';
  // Check the raw description if available
  if (m.description) {
    if (m.description.startsWith('GAS|')) return 'gas';
    if (m.description.startsWith('ETHBAL|') || m.description.startsWith('TOKBAL|')) return 'balance';
    if (m.description.startsWith('PRICE|')) return 'price';
  }
  return 'price'; // default
}

function stripHtml(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  return tmp.textContent || tmp.innerText || '';
}

function renderBrowserList() {
  const listEl = $('browserList');

  // Filter markets
  let filtered = markets.filter(m => {
    // Skip demo markets
    if (m.isDemo) return false;

    // Status filter
    if (browserStatus === 'open' && m.resolved) return false;
    if (browserStatus === 'resolved' && !m.resolved) return false;

    // Type filter
    if (browserFilter !== 'all') {
      const type = getMarketType(m);
      if (type !== browserFilter) return false;
    }

    // Search filter
    if (browserSearch) {
      const text = (stripHtml(m.q) + ' ' + (m.marketId || '')).toLowerCase();
      if (!text.includes(browserSearch)) return false;
    }

    return true;
  });

  // Render
  if (filtered.length === 0) {
    listEl.innerHTML = '<div class="market-empty">No markets found</div>';
    return;
  }

  listEl.innerHTML = filtered.map((m, idx) => {
    const type = getMarketType(m);
    const question = stripHtml(m.q);
    const shortQ = question.length > 50 ? question.slice(0, 47) + '...' : question;
    const pct = m.y || 50;
    const idShort = m.marketId ? '#' + m.marketId.slice(0, 8) : '';
    const tvl = m.tvl ? m.tvl.toFixed(2) + ' ETH' : '--';
    const countdown = m.resolved ? 'RESOLVED' : formatCountdown(m.close);

    // Find the actual index in the main markets array
    const realIdx = markets.indexOf(m);

    return `
      <div class="market-item" onclick="selectMarket(${realIdx})">
        <span class="market-item-pct">${pct}%</span>
        <div class="market-item-q">
          <span class="market-type-dot ${type}"></span>${shortQ}
        </div>
        <div class="market-item-meta">${idShort} | ${tvl} | ${countdown}</div>
      </div>
    `;
  }).join('');
}

function selectMarket(idx) {
  currentIndex = idx;
  closeBrowserModal();
  closeDrop();
  render();
  loadPositions();
  loadResolutionStatus();
  loadPriceChart();
}

// Initialize on load
init();
</script>
</body>
</html>
