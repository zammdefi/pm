<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>uniPM - Uniswap Bets</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='600' fill='%23FF007A' text-anchor='middle'>uni</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='600' fill='%233b82f6' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --blue-dim: rgba(59, 130, 246, 0.15);
            --amber: #f59e0b;
            --amber-dim: rgba(245, 158, 11, 0.15);
            --pink: #FF007A;
            --pink-dim: rgba(255, 0, 122, 0.15);
            --purple: #a855f7;
            --gray: #27272a;
            --light-gray: #3f3f46;
            --black: #09090b;

            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;
            --font-mono: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--pink); }

        .tagline {
            font-size: var(--font-xs);
            color: var(--text-dim);
            margin-left: 0.75rem;
        }

        .tagline:hover {
            color: var(--pink);
        }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.pink { color: var(--pink); }
        .live-stat-value.green { color: var(--green); }
        .live-stat-value.blue { color: var(--blue); }
        .live-stat-value.amber { color: var(--amber); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--pink);
            color: var(--bg);
            border-color: var(--pink);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* HERO SECTION */
        .hero-section {
            padding: 2rem 1.5rem;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }

        .hero-title {
            font-size: var(--font-2xl);
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .hero-subtitle {
            color: var(--text-muted);
            font-size: var(--font-sm);
            margin-bottom: 0.5rem;
        }

        .hero-subtext {
            color: var(--text-dim);
            font-size: var(--font-xs);
            margin-bottom: 1.5rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .treasury-display {
            display: inline-flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 2rem;
            background: var(--surface);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .treasury-balance {
            font-size: var(--font-2xl);
            font-weight: 700;
            color: var(--pink);
        }

        .treasury-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .stats-summary {
            display: flex;
            justify-content: center;
            gap: 2rem;
            padding: 0.875rem;
            margin-bottom: 1rem;
            background: var(--surface);
            border-radius: var(--radius);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        .market-row {
            display: grid;
            grid-template-columns: minmax(320px, 400px) 1fr;
            gap: 1rem;
            align-items: start;
        }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--pink);
        }

        .bet-card.resolved {
            opacity: 0.7;
        }

        .inline-orderbook {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1rem;
            min-height: 300px;
        }

        .inline-orderbook-header {
            display: grid;
            grid-template-columns: 1fr 56px 1fr;
            gap: 0;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border);
        }

        .inline-orderbook-ladder {
            font-family: var(--font-mono);
            font-size: 11px;
            max-height: 350px;
            overflow-y: auto;
        }

        .inline-ob-cell {
            transition: background 0.15s ease;
        }

        .inline-ob-cell:hover {
            background: rgba(255, 255, 255, 0.08) !important;
        }

        .inline-ob-yes:hover {
            background: rgba(0, 200, 83, 0.15) !important;
        }

        .inline-ob-no:hover {
            background: rgba(255, 82, 82, 0.15) !important;
        }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
            color: var(--pink);
        }

        .bet-status {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 3px;
        }

        .bet-status.active {
            background: var(--green-dim);
            color: var(--green);
        }

        .bet-status.resolved {
            background: var(--surface-2);
            color: var(--text-muted);
        }

        .bet-status.ready {
            background: rgba(245, 158, 11, 0.15);
            color: var(--amber);
        }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
        }

        .onchain-details {
            margin-top: 0.25rem;
            opacity: 0.5;
            transition: opacity 0.2s;
        }
        .onchain-details:hover {
            opacity: 0.8;
        }
        .onchain-details[open] {
            opacity: 0.8;
        }
        .onchain-details summary {
            font-size: 9px;
            color: var(--text-dim);
            cursor: pointer;
            user-select: none;
            list-style: none;
        }
        .onchain-details summary::-webkit-details-marker {
            display: none;
        }
        .onchain-details summary:hover {
            color: var(--text-muted);
        }
        .onchain-desc {
            font-size: 9px;
            color: var(--text-dim);
            background: var(--surface-2);
            padding: 0.4rem;
            border-radius: var(--radius);
            margin-top: 0.25rem;
            word-break: break-all;
            margin-bottom: 0.75rem;
            font-family: monospace;
        }

        .condition-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .condition-point { text-align: center; }

        .condition-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .condition-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .condition-op {
            font-size: 1.25rem;
            color: var(--text-muted);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.3); }

        .bet-btn.yes { border-color: var(--green); background: var(--green-dim); }
        .bet-btn.yes:hover { background: var(--green); }
        .bet-btn.yes:hover .bet-btn-label,
        .bet-btn.yes:hover .bet-btn-odds,
        .bet-btn.yes:hover .bet-btn-price { color: var(--bg); }
        .bet-btn.no { border-color: var(--red); background: var(--red-dim); }
        .bet-btn.no:hover { background: var(--red); }
        .bet-btn.no:hover .bet-btn-label,
        .bet-btn.no:hover .bet-btn-odds,
        .bet-btn.no:hover .bet-btn-price { color: var(--bg); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.yes .bet-btn-label { color: var(--green); }
        .bet-btn.no .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .liquidity-stats {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-top: 1px solid var(--border);
            margin-top: 0.5rem;
            font-size: var(--font-xs);
            color: var(--text-muted);
        }

        .resolve-btn {
            width: 100%;
            margin-top: 0.5rem;
            padding: 0.75rem;
            background: var(--amber);
            color: var(--black);
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .resolve-btn:hover { opacity: 0.9; }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }


        .market-tab {
            font-family: inherit;
            font-size: var(--font-sm);
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            background: transparent;
            color: var(--text-muted);
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .market-tab:hover {
            color: var(--text);
        }

        .market-tab.active {
            color: var(--pink);
            border-bottom-color: var(--pink);
        }
        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            max-width: 500px;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--pink);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--pink);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* CUSTOM COLLATERAL DROPDOWN */
        .collateral-dropdown {
            position: relative;
            width: 100%;
        }

        .collateral-dropdown-selected {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: border-color 0.15s;
        }

        .collateral-dropdown-selected:hover {
            border-color: var(--pink);
        }

        .collateral-dropdown-selected.active {
            border-color: var(--pink);
        }

        .collateral-dropdown-icon {
            flex-shrink: 0;
        }

        .collateral-dropdown-text {
            flex: 1;
        }

        .collateral-dropdown-arrow {
            flex-shrink: 0;
            color: var(--text-dim);
            font-size: 10px;
        }

        .collateral-dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-top: 0.25rem;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .collateral-dropdown-options.active {
            display: block;
        }

        .collateral-dropdown-option {
            padding: 0.625rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .collateral-dropdown-option:hover {
            background: var(--surface-2);
        }

        .collateral-dropdown-option:first-child {
            border-top-left-radius: var(--radius);
            border-top-right-radius: var(--radius);
        }

        .collateral-dropdown-option:last-child {
            border-bottom-left-radius: var(--radius);
            border-bottom-right-radius: var(--radius);
        }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--pink);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-yes { background: var(--green); color: var(--bg); }
        .trade-submit.buy-no { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Wallet Options */
        .wallet-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--gray);
            border: 1px solid var(--light-gray);
            border-radius: var(--radius);
            cursor: pointer;
            margin-bottom: var(--spacing-xs);
            transition: all 0.15s ease;
        }
        .wallet-option:hover { border-color: var(--pink); }
        .wallet-option-icon { font-size: 1.5rem; }
        .wallet-option-name { font-weight: 600; }
        .wallet-option.disconnect {
            border-color: var(--red);
            color: var(--red);
            justify-content: center;
        }
        .wallet-option.disconnect:hover {
            background: var(--red);
            color: var(--black);
        }

        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 380px;
            pointer-events: none;
        }
        .toast {
            padding: 1rem 1.25rem;
            border-radius: var(--radius);
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: var(--font-sm);
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-in forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toast-out {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); }
        }
        .toast-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        .toast.pending .toast-header { color: var(--blue); }
        .toast.success .toast-header { color: var(--green); }
        .toast.error .toast-header { color: var(--red); }
        .toast-body {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }
        .toast-body a {
            color: var(--blue);
            text-decoration: underline;
        }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* CHART */
        .chart-container {
            background: #0a0a0a;
            border-radius: var(--radius);
            overflow: hidden;
        }

        .chart-container iframe {
            display: block;
            width: 100%;
            height: 360px;
            border: none;
            background: #0a0a0a;
        }

        /* EMPTY STATE */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: var(--text-muted);
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        /* MOBILE */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; flex-wrap: wrap; }
            .header-center { gap: 1rem; }
            .tagline { display: none; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .hero-section { padding: 1rem; }
            .treasury-display { padding: 0.75rem 1rem; }
            .chart-container iframe { height: 300px; }
            .modal {
                margin: 0.5rem;
                padding: 0.75rem;
                max-width: calc(100vw - 1rem);
            }
            .modal-header { padding: 0.5rem 0.75rem; }
            .modal-body { padding: 0.5rem !important; }
        }

        @media (max-width: 480px) {
            .header-center {
                order: 3;
                width: 100%;
                justify-content: space-around;
                padding-top: 0.5rem;
                border-top: 1px solid var(--border);
                margin-top: 0.5rem;
            }
            .bets-grid { grid-template-columns: 1fr; }
            .market-row { grid-template-columns: 1fr; }
            .inline-orderbook { min-height: 200px; }
            .chart-container iframe { height: 240px; }
            /* Trade modal position info - stack on mobile */
            #tradeMarketInfo > div { flex-direction: column; gap: 0.5rem; }
            #tradeMarketInfo > div > div:last-child { text-align: left; }
            /* Compact mode buttons */
            .mode-toggle-btn { padding: 0.4rem !important; font-size: 10px !important; }
            /* Limit price buttons - smaller */
            #limitSection .trade-input-group button { padding: 0.4rem 0.5rem; font-size: 10px; }
            /* My Orders - smaller buttons */
            #myOrdersList button { padding: 1px 4px; font-size: 9px; }
        }

        @media (max-width: 380px) {
            /* Extra small screens */
            .bet-buttons { grid-template-columns: 1fr; gap: 0.5rem; }
            .bet-btn { width: 100%; }
            /* Depth ladder - narrower center column */
            #depthLadder > div { grid-template-columns: 1fr 44px 1fr !important; }
        }
    </style>
</head>
<body>
    <!-- Toast Notifications Container -->
    <div id="toastContainer" class="toast-container"></div>

    <header class="header">
        <div style="display:flex;align-items:center;gap:0.5rem;">
            <svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="opacity:0.7;">
                <g fill="none" fill-rule="evenodd">
                    <circle fill="#FF007A" fill-rule="nonzero" cx="16" cy="16" r="16"/>
                    <g fill="#FFF">
                        <path d="M12.261 5.767c-.285-.044-.297-.05-.163-.07.257-.04.865.015 1.284.114.977.233 1.866.828 2.816 1.885l.252.28.36-.057c1.52-.245 3.067-.05 4.36.547.356.164.917.491.987.576.023.026.064.199.091.383.096.637.048 1.125-.146 1.49-.106.198-.112.26-.041.43a.416.416 0 00.372.236c.322 0 .668-.52.828-1.243l.064-.287.126.143c.692.784 1.235 1.853 1.328 2.613l.025.199-.117-.18c-.2-.31-.4-.522-.658-.693-.464-.307-.955-.411-2.255-.48-1.174-.062-1.839-.162-2.497-.377-1.121-.365-1.686-.852-3.018-2.599-.591-.776-.957-1.205-1.32-1.55-.827-.786-1.639-1.198-2.678-1.36z" fill-rule="nonzero"/>
                        <path d="M22.422 7.5c.03-.52.1-.863.242-1.176.056-.124.109-.226.117-.226a.773.773 0 01-.055.204c-.103.304-.12.72-.049 1.203.09.614.142.702.79 1.365.305.311.659.703.787.872l.233.306-.233-.219c-.285-.267-.941-.79-1.086-.864-.097-.05-.112-.049-.172.01-.055.056-.067.138-.074.529-.012.608-.095 1-.296 1.39-.108.21-.125.166-.027-.073.073-.178.08-.256.08-.845 0-1.184-.141-1.468-.966-1.956a9.046 9.046 0 00-.764-.396 2.916 2.916 0 01-.374-.182c.023-.023.827.211 1.15.336.482.185.561.209.62.186.039-.015.058-.129.077-.464zm-9.607 2.025c-.579-.797-.937-2.02-.86-2.934l.024-.283.132.024c.248.045.675.204.875.326.548.333.786.772 1.027 1.898.071.33.164.703.207.83.068.203.328.678.54.987.152.222.05.327-.286.297-.514-.047-1.21-.527-1.659-1.145zm8.905 5.935c-2.707-1.09-3.66-2.036-3.66-3.632 0-.235.008-.427.017-.427.01 0 .115.077.233.172.549.44 1.164.628 2.865.876 1.001.147 1.565.265 2.085.437 1.652.548 2.674 1.66 2.918 3.174.07.44.029 1.265-.086 1.7-.09.344-.367.963-.44.987-.02.006-.04-.071-.046-.178-.028-.568-.315-1.122-.798-1.537-.549-.471-1.286-.847-3.089-1.572zm-1.9.452a4.808 4.808 0 00-.131-.572l-.07-.206.129.144c.177.2.318.454.436.794.091.259.101.336.1.757 0 .414-.011.5-.095.734a2.32 2.32 0 01-.571.908c-.495.504-1.13.782-2.048.898-.16.02-.624.054-1.033.075-1.03.054-1.707.164-2.316.378a.488.488 0 01-.174.042c-.024-.025.39-.272.733-.437.483-.233.963-.36 2.04-.539.532-.089 1.082-.196 1.221-.239 1.318-.404 1.995-1.446 1.778-2.737z" fill-rule="nonzero"/>
                        <path d="M21.06 18.116c-.36-.773-.442-1.52-.245-2.216.021-.074.055-.135.075-.135a.73.73 0 01.189.102c.166.112.498.3 1.383.782 1.105.603 1.735 1.07 2.164 1.602.375.467.607.999.719 1.647.063.367.026 1.25-.068 1.62-.297 1.166-.988 2.082-1.972 2.616a2.53 2.53 0 01-.288.143c-.014 0 .038-.133.117-.297.33-.692.369-1.366.118-2.116-.153-.459-.466-1.02-1.097-1.966-.734-1.1-.914-1.394-1.095-1.782zm-10.167 4.171c1.005-.848 2.254-1.45 3.393-1.635.49-.08 1.308-.048 1.762.068.728.186 1.38.604 1.719 1.101.33.486.473.91.62 1.852.06.372.123.745.142.83.11.488.327.879.595 1.075.425.311 1.158.33 1.878.05a.981.981 0 01.236-.074c.026.026-.336.269-.592.397a2.014 2.014 0 01-.983.238c-.66 0-1.208-.335-1.665-1.02-.09-.135-.292-.538-.45-.897-.482-1.1-.72-1.436-1.28-1.803-.489-.32-1.118-.377-1.591-.145-.622.305-.795 1.1-.35 1.603.177.2.507.373.777.406a.83.83 0 00.939-.83c0-.332-.128-.52-.448-.665-.437-.197-.907.033-.905.444.001.175.077.285.253.365.113.05.115.055.023.036-.401-.084-.495-.567-.172-.888.387-.386 1.188-.216 1.463.31.116.221.129.662.028.928-.225.595-.883.907-1.55.737-.454-.116-.639-.241-1.186-.805-.951-.98-1.32-1.17-2.692-1.384l-.263-.041.3-.253z" fill-rule="nonzero"/>
                        <path d="M6.196 3.35l.096.117c3.708 4.54 5.624 6.896 5.746 7.064.2.278.125.527-.219.723-.191.109-.585.219-.781.219-.223 0-.474-.107-.657-.28-.129-.123-.65-.901-1.853-2.768a188.53 188.53 0 00-1.712-2.633c-.049-.046-.048-.045 1.618 2.936 1.046 1.872 1.4 2.533 1.4 2.622 0 .18-.05.274-.272.522-.37.413-.535.877-.655 1.837-.134 1.077-.51 1.837-1.554 3.138-.61.762-.71.902-.865 1.209-.194.386-.247.603-.269 1.091-.023.516.022.85.18 1.343.138.432.282.718.65 1.288.318.493.501.859.501 1.002 0 .114.022.114.515.003 1.179-.266 2.136-.735 2.675-1.309.333-.355.411-.551.414-1.038.001-.318-.01-.385-.096-.568-.14-.298-.395-.546-.957-.93-.737-.504-1.051-.91-1.138-1.467-.072-.457.011-.78.419-1.634.421-.884.526-1.26.597-2.151.045-.576.108-.803.274-.985.172-.19.328-.255.755-.313.696-.095 1.139-.275 1.503-.61.316-.292.448-.573.468-.995l.016-.32-.177-.206c-.254-.296-2.355-2.614-6.304-6.956l-.106-.115-.212.165zM7.91 19.732a.566.566 0 00-.174-.746c-.228-.152-.583-.08-.583.118 0 .06.033.104.108.143.127.065.136.139.037.288-.101.152-.093.286.023.377.186.146.45.065.59-.18zm5.524-7.176c-.327.1-.644.447-.743.81-.06.221-.026.61.064.73.145.194.286.245.666.242.744-.005 1.39-.324 1.466-.723.062-.327-.223-.78-.614-.98-.202-.102-.631-.143-.839-.079zm.87.68c.115-.163.064-.34-.13-.458-.372-.227-.934-.04-.934.312 0 .174.293.365.561.365.18 0 .424-.107.503-.219z"/>
                    </g>
                </g>
            </svg>
            <div class="logo">uni<span>PM</span></div>
            <a href="https://uniswap.org/" target="_blank" rel="noopener" class="tagline" style="text-decoration: none; transition: color 0.2s;">Uniswap Prediction Markets ‚Üó</a>
        </div>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">V4 Fee Switch</div>
                <div class="live-stat-value pink" id="livePunks">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Markets</div>
                <div class="live-stat-value blue" id="marketCount">0</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">UNI Price</div>
                <div class="live-stat-value" style="color:#FF007A;" id="uniPrice">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">UNI Supply</div>
                <div class="live-stat-value" style="color:#FF007A;" id="uniTotalSupply">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Pool TVL</div>
                <div class="live-stat-value green" id="totalTvl">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Book TVL</div>
                <div class="live-stat-value" style="color:#f59e0b;" id="orderbookTvl">--</div>
            </div>
        </div>
        <div style="display:flex;align-items:center;gap:0.5rem;">
            <div id="walletBalances" style="display:none;font-size:var(--font-xs);text-align:right;margin-right:0.5rem;">
                <div style="color:var(--text-muted);">ETH: <span id="ethBalance" style="color:var(--text);">--</span></div>
                <div style="color:var(--text-muted);">UNI: <span id="uniBalance" style="color:var(--pink);">--</span></div>
            </div>
            <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
        </div>
    </header>

    <main class="main">
        <!-- Hero Section -->
        <section class="hero-section">
            <h1 class="hero-title">Uniswap Prediction Markets</h1>
            <p class="hero-subtitle">Bet on V4 fee activation, UNI token balances, and Uniswap ecosystem metrics</p>
            <p class="hero-subtext">All markets use an on-chain <a href="https://etherscan.io/address/0x00000000002205020E387b6a378c05639047BcFB#code" target="_blank" style="color:var(--pink);text-decoration:none;">Resolver</a> that settles automatically when conditions are met or deadlines pass</p>
            <div class="treasury-display">
                <div>
                    <div class="treasury-label">V4 Fee Controller</div>
                    <div class="treasury-balance"><span id="heroBalance">--</span></div>
                </div>
                <div style="border-left:1px solid var(--border);padding-left:1rem;">
                    <div class="treasury-label">Pool Manager</div>
                    <a href="https://etherscan.io/address/0x000000000004444c5dc75cB358380D2e3dE08A90" target="_blank" style="color:var(--text-muted);font-size:var(--font-xs);text-decoration:none;display:flex;align-items:center;gap:4px;">
                        0x0000...08A90 <span style="opacity:0.5;">‚Üó</span>
                    </a>
                </div>
                <div style="border-left:1px solid var(--border);padding-left:1rem;">
                    <div class="treasury-label">UNI Token</div>
                    <a href="https://etherscan.io/token/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984" target="_blank" style="color:var(--text-muted);font-size:var(--font-xs);text-decoration:none;display:flex;align-items:center;gap:4px;">
                        0x1f98...F984 <span style="opacity:0.5;">‚Üó</span>
                    </a>
                </div>
            </div>
        </section>

        <!-- Chart Section -->
        <section class="bets-section" id="chartSection" style="padding-bottom:0;display:none;">
            <h2 class="section-title">Odds <span id="featuredOdds" style="font-weight:400;color:var(--text-muted);font-size:var(--font-sm);">--</span></h2>
            <div class="chart-container">
                <iframe
                    id="chartIframe"
                    src=""
                    title="Market Odds"
                    loading="lazy"
                ></iframe>
            </div>
        </section>

        <!-- Active Markets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Markets</h2>
            <div class="stats-summary">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Active</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Ready to Resolve</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="readyCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Resolved</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--text-muted);" id="resolvedCount">0</div>
                </div>
            </div>
            <div class="bets-grid" id="marketsGrid">
                <div class="empty-state">
                    <div class="empty-state-icon">üîç</div>
                    <p>Loading markets...</p>
                </div>
            </div>
        </section>

        <!-- Create Section -->
        <section class="create-section" id="createSection" style="display:none;">
            <h2 class="section-title">Create Market</h2>

            <!-- Market Type Tabs -->
            <div style="display:flex;gap:0.5rem;margin-bottom:1.5rem;border-bottom:1px solid var(--border);">
                <button id="tabFeeSwitch" class="market-tab active" onclick="switchMarketTab('feeSwitch')">
                    V4 Fee Switch
                </button>
                <button id="tabUniBalance" class="market-tab" onclick="switchMarketTab('uniBalance')">
                    UNI Balance
                </button>
                <button id="tabUniVotes" class="market-tab" onclick="switchMarketTab('uniVotes')">
                    UNI Voting Power
                </button>
                <button id="tabTotalSupply" class="market-tab" onclick="switchMarketTab('totalSupply')">
                    UNI Total Supply
                </button>
                <button id="tabUniPrice" class="market-tab" onclick="switchMarketTab('uniPrice')">
                    UNI Price
                </button>
            </div>

            <!-- Fee Switch Market Creator -->
            <div id="creatorFeeSwitch" class="create-card">
                <div class="create-card-title">V4 Protocol Fee Controller Market</div>
                <div class="create-card-desc">Create a market on whether Uniswap V4 will activate protocol fees by a deadline.</div>

                <div class="create-input-group">
                    <label class="create-label">Condition</label>
                    <input type="text" class="create-input" value="protocolFeeController() != 0" readonly style="background:var(--surface-2);cursor:not-allowed;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">Market resolves YES if Uniswap V4 activates protocol fees</div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadlineFeeSwitch" onchange="if(this.value==='custom'){document.getElementById('customDeadlineGroupFeeSwitch').style.display='block'}else{document.getElementById('customDeadlineGroupFeeSwitch').style.display='none'}">
                        <option value="eoy2026">End of 2026 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom Unix Timestamp...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroupFeeSwitch" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadlineFeeSwitch" placeholder="1798761599">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        <a href="https://www.unixtimestamp.com/" target="_blank" style="color:var(--pink);">Unix Timestamp Converter ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanCloseFeeSwitch">
                        <option value="true" selected>Yes - Resolve early when condition met</option>
                        <option value="false">No - Wait until deadline</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Collateral Token</label>
                    <div id="createCollateralFeeSwitch"></div>
                    <script>
                        document.getElementById('createCollateralFeeSwitch').innerHTML = createCollateralDropdown('createCollateralFeeSwitch', 'FeeSwitch');
                    </script>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose which token to use for betting. UNI requires approval.
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label" id="seedLabelFeeSwitch">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeedFeeSwitch" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreviewFeeSwitch" style="color:var(--text);">
                        Uniswap V4 protocolFeeController() != 0 by Dec 31, 2026
                    </div>
                </div>

                <button class="create-btn" onclick="createFeeSwitchMarket()">Create Fee Switch Market</button>
            </div>

            <!-- UNI Balance Market Creator -->
            <div id="creatorUniBalance" class="create-card" style="display:none;">
                <div class="create-card-title">UNI Token Balance Market</div>
                <div class="create-card-desc">Create a market on whether an address will hold a target amount of UNI tokens by a deadline. Perfect for tracking treasury or multisig holdings.</div>

                <div class="create-input-group">
                    <label class="create-label">Target Address (or ENS name)</label>
                    <input type="text" class="create-input" id="createTargetAddress" placeholder="vitalik.eth or 0x..." onblur="resolveENS(this.value)">
                    <div id="resolvedAddress" style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;display:none;">
                        <span id="resolvedAddressText"></span>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Condition</label>
                    <select class="create-input" id="createOperator">
                        <option value="1">Greater than (>)</option>
                        <option value="2">Less than (<)</option>
                        <option value="3">Greater than or equal (>=)</option>
                        <option value="4">Less than or equal (<=)</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Target Balance (UNI tokens)</label>
                    <input type="number" class="create-input" id="createUniThreshold" placeholder="1000000" step="0.01" min="0">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">Enter amount in UNI (e.g., 1000000 = 1M UNI tokens)</div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadlineUniBalance" onchange="if(this.value==='custom'){document.getElementById('customDeadlineGroupUniBalance').style.display='block'}else{document.getElementById('customDeadlineGroupUniBalance').style.display='none'}">
                        <option value="eoy2026">End of 2026 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom Unix Timestamp...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroupUniBalance" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadlineUniBalance" placeholder="1798761599">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        <a href="https://www.unixtimestamp.com/" target="_blank" style="color:var(--pink);">Unix Timestamp Converter ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanCloseUniBalance">
                        <option value="true" selected>Yes - Resolve early when condition met</option>
                        <option value="false">No - Wait until deadline</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Collateral Token</label>
                    <div id="createCollateralUniBalance"></div>
                    <script>
                        document.getElementById('createCollateralUniBalance').innerHTML = createCollateralDropdown('createCollateralUniBalance', 'UniBalance');
                    </script>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose which token to use for betting. UNI requires approval.
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label" id="seedLabelUniBalance">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeedUniBalance" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreviewUniBalance" style="color:var(--text);">
                        UNI balance of [address] > [amount] by Dec 31, 2026
                    </div>
                </div>

                <button class="create-btn" onclick="createUniBalanceMarket()">Create UNI Balance Market</button>
            </div>

            <!-- UNI Delegation Market Creator -->
            <div id="creatorUniVotes" class="create-card" style="display:none;">
                <div class="create-card-title">UNI Voting Power Market</div>
                <div class="create-card-desc">Create a market on whether an address will have a target amount of delegated UNI voting power by a deadline. Track governance influence over time.</div>

                <div class="create-input-group">
                    <label class="create-label">Target Address (or ENS name)</label>
                    <input type="text" class="create-input" id="createTargetAddressVotes" placeholder="vitalik.eth or 0x..." onblur="resolveENSVotes(this.value)">
                    <div id="resolvedAddressVotes" style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;display:none;">
                        <span id="resolvedAddressTextVotes"></span>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Condition</label>
                    <select class="create-input" id="createOperatorVotes">
                        <option value="1">Greater than (>)</option>
                        <option value="2">Less than (<)</option>
                        <option value="3">Greater than or equal (>=)</option>
                        <option value="4">Less than or equal (<=)</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Target Voting Power (UNI votes)</label>
                    <input type="number" class="create-input" id="createUniVotesThreshold" placeholder="1000000" step="0.01" min="0">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Enter amount in UNI votes (e.g., 1000000 = 1M UNI voting power). See
                        <a href="https://docs.uniswap.org/concepts/governance/guide-to-voting" target="_blank" style="color:var(--pink);">delegation docs ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadlineUniVotes" onchange="if(this.value==='custom'){document.getElementById('customDeadlineGroupUniVotes').style.display='block'}else{document.getElementById('customDeadlineGroupUniVotes').style.display='none'}">
                        <option value="eoy2026">End of 2026 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom Unix Timestamp...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroupUniVotes" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadlineUniVotes" placeholder="1798761599">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        <a href="https://www.unixtimestamp.com/" target="_blank" style="color:var(--pink);">Unix Timestamp Converter ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanCloseUniVotes">
                        <option value="true" selected>Yes - Resolve early when condition met</option>
                        <option value="false">No - Wait until deadline</option>
                    </select>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Collateral Token</label>
                    <div id="createCollateralUniVotes"></div>
                    <script>
                        document.getElementById('createCollateralUniVotes').innerHTML = createCollateralDropdown('createCollateralUniVotes', 'UniVotes');
                    </script>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose which token to use for betting. UNI requires approval.
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label" id="seedLabelUniVotes">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeedUniVotes" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreviewUniVotes" style="color:var(--text);">
                        UNI voting power of [address] > [amount] by Dec 31, 2026
                    </div>
                </div>

                <button class="create-btn" onclick="createUniVotesMarket()">Create Voting Power Market</button>
            </div>

            <!-- Total Supply Market Creator -->
            <div id="creatorTotalSupply" class="create-card" style="display:none;">
                <div class="create-card-title">UNI Total Supply Market</div>
                <div class="create-card-desc">Create a market on whether UNI total supply will change by a deadline. Track token emissions, burns, or supply stability. Uses EQ (==) to bet supply stays the same, or NEQ (!=) to bet it changes.</div>

                <div class="create-input-group">
                    <label class="create-label">Market Type</label>
                    <select class="create-input" id="createSupplyMarketType">
                        <option value="eq">Supply Stays Same (==) - YES if no change</option>
                        <option value="neq">Supply Changes (!=) - YES if any change</option>
                    </select>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose whether to bet supply remains unchanged or changes
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Current Total Supply</label>
                    <input type="text" class="create-input" id="currentTotalSupply" readonly style="background:var(--surface-2);cursor:not-allowed;" value="Loading...">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        This value will be fetched from the UNI token contract
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadlineTotalSupply" onchange="if(this.value==='custom'){document.getElementById('customDeadlineGroupTotalSupply').style.display='block'}else{document.getElementById('customDeadlineGroupTotalSupply').style.display='none'}">
                        <option value="eoy2026">End of 2026 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom Unix Timestamp...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroupTotalSupply" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadlineTotalSupply" placeholder="1798761599">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        <a href="https://www.unixtimestamp.com/" target="_blank" style="color:var(--pink);">Unix Timestamp Converter ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanCloseTotalSupply">
                        <option value="false">No - Wait until deadline</option>
                        <option value="true">Yes - Resolve early when condition met</option>
                    </select>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        For NEQ markets, early close allows immediate resolution when supply changes
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Collateral Token</label>
                    <div id="createCollateralTotalSupply"></div>
                    <script>
                        document.getElementById('createCollateralTotalSupply').innerHTML = createCollateralDropdown('createCollateralTotalSupply', 'TotalSupply');
                    </script>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose which token to use for betting. UNI requires approval.
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label" id="seedLabelTotalSupply">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeedTotalSupply" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreviewTotalSupply" style="color:var(--text);">
                        UNI totalSupply() == [current] by Dec 31, 2026
                    </div>
                </div>

                <button class="create-btn" onclick="createTotalSupplyMarket()">Create Supply Market</button>
            </div>

            <!-- UNI Price Market Creator -->
            <div id="creatorUniPrice" class="create-card" style="display:none;">
                <div class="create-card-title">UNI/USD Price Market</div>
                <div class="create-card-desc">Create a market on UNI token price reaching or crossing a USD threshold by a deadline. Uses real-time Chainlink oracle data (8 decimal precision).</div>

                <div class="create-input-group">
                    <label class="create-label">Current UNI Price (Live)</label>
                    <input type="text" class="create-input" id="currentUniPrice" readonly style="background:var(--surface-2);cursor:not-allowed;" value="Loading...">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Fetched from <a href="https://data.chain.link/ethereum/mainnet/crypto-usd/uni-usd" target="_blank" style="color:var(--pink);">Chainlink UNI/USD Oracle ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Target Price (USD)</label>
                    <input type="number" class="create-input" id="createTargetPrice" placeholder="10.00" step="0.01" min="0.01" oninput="updateUniPricePreview()">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        The USD price threshold for this market (e.g., $10.00)
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Condition</label>
                    <select class="create-input" id="createPriceOperator" onchange="updateUniPricePreview()">
                        <option value="3">At or above (>=) - YES if price reaches target or higher</option>
                        <option value="1">Above (>) - YES if price exceeds target</option>
                        <option value="2">At or below (<=) - YES if price drops to target or lower</option>
                        <option value="0">Below (<) - YES if price falls below target</option>
                    </select>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose the price condition that makes YES win
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Deadline</label>
                    <select class="create-input" id="createDeadlineUniPrice" onchange="if(this.value==='custom'){document.getElementById('customDeadlineGroupUniPrice').style.display='block';updateUniPricePreview()}else{document.getElementById('customDeadlineGroupUniPrice').style.display='none';updateUniPricePreview()}">
                        <option value="eoy2026">End of 2026 (Dec 31, 23:59:59 UTC)</option>
                        <option value="custom">Custom Unix Timestamp...</option>
                    </select>
                </div>

                <div class="create-input-group" id="customDeadlineGroupUniPrice" style="display:none;">
                    <label class="create-label">Custom Deadline (Unix Timestamp)</label>
                    <input type="number" class="create-input" id="createCustomDeadlineUniPrice" placeholder="1798761599" oninput="updateUniPricePreview()">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        <a href="https://www.unixtimestamp.com/" target="_blank" style="color:var(--pink);">Unix Timestamp Converter ‚Üó</a>
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Early Close on Success</label>
                    <select class="create-input" id="createCanCloseUniPrice" onchange="updateUniPricePreview()">
                        <option value="true">Yes - Resolve early when price hits target</option>
                        <option value="false">No - Must wait until deadline</option>
                    </select>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Early close allows immediate resolution when condition is met
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label">Collateral Token</label>
                    <div id="createCollateralUniPrice"></div>
                    <script>
                        document.getElementById('createCollateralUniPrice').innerHTML = createCollateralDropdown('createCollateralUniPrice', 'UniPrice');
                    </script>
                    <div style="font-size:var(--font-xs);color:var(--text-dim);margin-top:0.25rem;">
                        Choose which token to use for betting. UNI requires approval.
                    </div>
                </div>

                <div class="create-input-group">
                    <label class="create-label" id="seedLabelUniPrice">Seed Liquidity (ETH)</label>
                    <input type="number" class="create-input" id="createSeedUniPrice" value="0.1" step="0.01" min="0.001">
                </div>

                <div style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                    <div style="color:var(--text-dim);margin-bottom:0.5rem;">Preview:</div>
                    <div id="createPreviewUniPrice" style="color:var(--text);">
                        UNI price >= $10.00 by Dec 31, 2026
                    </div>
                </div>

                <button class="create-btn" onclick="createUniPriceMarket()">Create Price Market</button>
            </div>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>V4 Fee Switch Markets:</strong> Track whether Uniswap V4 activates protocol fees by checking if protocolFeeController() returns a non-zero address. Read directly from the <a href="https://etherscan.io/address/0x000000000004444c5dc75cB358380D2e3dE08A90" target="_blank" style="color:var(--pink);">V4 PoolManager</a> on-chain.<br><br>
                <strong>UNI Balance Markets:</strong> Track UNI token holdings of any address (treasury, multisig, EOA). Uses the <a href="https://etherscan.io/token/0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984" target="_blank" style="color:var(--pink);">UNI token contract</a> balanceOf() with 18 decimals. Supports ENS names for easy targeting.<br><br>
                <strong>UNI Voting Power Markets:</strong> Track delegated UNI voting power using getCurrentVotes(). Perfect for monitoring governance influence. <a href="https://docs.uniswap.org/concepts/governance/guide-to-voting" target="_blank" style="color:var(--pink);">Learn about delegation ‚Üó</a><br><br>
                <strong>UNI Total Supply Markets:</strong> Bet on whether UNI totalSupply() will change by a deadline. Use EQ (==) to bet supply stays the same, or NEQ (!=) to bet it changes. Track token burns, emissions, or supply stability over time.<br><br>
                <strong>UNI Price Markets:</strong> Predict UNI token price movements using live <a href="https://data.chain.link/ethereum/mainnet/crypto-usd/uni-usd" target="_blank" style="color:var(--pink);">Chainlink UNI/USD oracle</a> data. Set target prices (e.g., $10.00) and conditions (>=, >, <=, <). Oracle uses 8 decimal precision for accurate USD pricing. Perfect for price predictions and volatility bets.<br><br>
                <strong>Resolution:</strong> Markets resolve YES if the condition is met by the deadline, otherwise NO. Early close allows instant resolution when condition becomes true.<br><br>
                <strong>Trading:</strong> Price = Probability. If YES shows 60%, one share costs ~0.60 ETH and pays 1 ETH if YES wins. Losing shares pay nothing.<br><br>
                <strong>Related:</strong>
                <a href="https://blog.uniswap.org/unification" target="_blank" style="color:var(--pink);">Uniswap Fee Unification Blog Post ‚Üó</a> ¬∑ 
                <a href="https://snapshot.org/#/s:uniswapgovernance.eth/proposal/0x58d854c1f2468db6b67baab026cca1329c7bcaa5bf834146aa7563a5b45ad09f" target="_blank" style="color:var(--pink);">Governance Proposal ‚Üó</a>
            </div>
        </section>

        <!-- Footer -->
        <footer style="text-align:center;padding:2rem 0;margin-top:1rem;border-top:1px solid var(--border);color:var(--text-dim);font-size:var(--font-xs);">
            <div style="display:flex;justify-content:center;align-items:center;gap:1.5rem;">
                <a href="https://uniswap.org/" target="_blank" style="color:var(--text-muted);text-decoration:none;">Uniswap</a>
                <a href="https://etherscan.io/address/0x000000000004444c5dc75cB358380D2e3dE08A90" target="_blank" style="color:var(--text-muted);text-decoration:none;">UniV4 PoolManager</a>
                <a href="https://zamm.finance/" target="_blank" style="display:flex;align-items:center;gap:0.5rem;color:var(--text-muted);text-decoration:none;">
                    <img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:20px;height:20px;border-radius:4px;">
                    Built on zAMM
                </a>
            </div>
        </footer>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal" style="max-width:360px;">
            <div class="modal-header">
                <div class="modal-title">Connect Wallet</div>
                <button class="modal-close" onclick="closeWalletModal()">&times;</button>
            </div>
            <div class="modal-body" id="walletOptions"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal">
        <div class="modal" style="max-width:420px;">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeTradeModal()">&times;</button>
            </div>

            <!-- Market Info -->
            <div id="tradeMarketInfo" style="background:var(--surface-2);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;font-size:var(--font-xs);">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                        <div style="color:var(--text-dim);margin-bottom:0.25rem;">Market</div>
                        <div id="tradeMarketDesc" style="color:var(--text);">--</div>
                    </div>
                    <div style="text-align:right;">
                        <div style="font-size:var(--font-xs);color:var(--text-dim);">Your Position</div>
                        <div style="font-size:var(--font-xs);">
                            <span style="color:var(--green);">YES: <span id="tradeModalYes">0</span></span>
                            <span style="margin-left:0.5rem;color:var(--red);">NO: <span id="tradeModalNo">0</span></span>
                            <span style="margin-left:0.5rem;color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Orderbook Preview (Coinbase-style best prices) -->
            <div id="orderbookPreview" style="background:var(--surface);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                <div style="text-align:center;font-size:var(--font-xs);color:var(--text-dim);">Loading orderbook...</div>
            </div>

            <!-- My Orders Section (only visible when user has orders) -->
            <div id="myOrdersSection" style="display:none;background:var(--amber-dim);border:1px solid var(--amber);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);font-weight:600;color:var(--amber);">Your Active Orders</span>
                    <span id="myOrdersCount" style="font-size:10px;color:var(--amber);background:rgba(245,158,11,0.2);padding:2px 6px;border-radius:4px;">0</span>
                </div>
                <div id="myOrdersList" style="font-size:11px;max-height:120px;overflow-y:auto;">
                </div>
            </div>

            <!-- Mode Toggle -->
            <div style="display:flex;gap:4px;margin-bottom:1rem;background:var(--surface);padding:4px;border-radius:var(--radius);">
                <button id="tradeModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('trade')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green);color:var(--bg);">Trade</button>
                <button id="swapModeBtn" class="mode-toggle-btn" onclick="setTradeMode('swap')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">Swap</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);">LP</button>
            </div>

            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <!-- Buy/Sell Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="buyBtn" class="mode-toggle-btn active-buy" onclick="setTradeDirection('buy')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green-dim);color:var(--green);border:1px solid var(--green);">Buy</button>
                    <button id="sellBtn" class="mode-toggle-btn" onclick="setTradeDirection('sell')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Sell</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;flex-wrap:wrap;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="tradeSlip5" class="slip-btn" onclick="setTradeSlippage(5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">5%</button>
                    <button id="tradeSlip10" class="slip-btn slip-active" onclick="setTradeSlippage(10)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">10%</button>
                    <button id="tradeSlip20" class="slip-btn" onclick="setTradeSlippage(20)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">20%</button>
                    <input type="number" id="tradeSlipCustom" placeholder="%" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);border-radius:4px;" onchange="setTradeSlippage(parseFloat(this.value)||10)">
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="tradeAmountLabel">Amount (ETH)</span>
                        <span style="display:flex;align-items:center;gap:0.5rem;">
                            Balance: <span id="tradeBalance">--</span>
                            <button id="tradeMaxBtn" onclick="setTradeMax()" style="display:none;padding:0.25rem 0.5rem;background:var(--red-dim);border:1px solid var(--red);border-radius:var(--radius);color:var(--red);font-weight:600;font-size:10px;cursor:pointer;">Max</button>
                        </span>
                    </div>
                    <input type="number" class="trade-input" id="tradeAmount" value="0.01" step="0.01" min="0" oninput="handleTradeInput()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. Shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPriceLabel">Avg. Price</span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">If you win</span>
                        <span id="previewPayout" style="color:var(--green);">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="font-size:11px;">--</span>
                    </div>
                </div>
                <button class="trade-submit buy-yes" id="tradeSubmit" onclick="executeTrade()">Buy YES</button>
            </div>

            <!-- Swap Section (YES‚ÜîNO) -->
            <div id="swapSection" style="display:none;">
                <div style="font-size:var(--font-xs);color:var(--text-dim);margin-bottom:0.75rem;">
                    Swap shares directly via the pool. No ETH needed - trade one outcome for the other.
                </div>

                <!-- Swap Direction Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="yesToNoBtn" class="mode-toggle-btn active-buy" onclick="setSwapDirection(true)" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--green-dim);color:var(--green);border:1px solid var(--green);">YES ‚Üí NO</button>
                    <button id="noToYesBtn" class="mode-toggle-btn" onclick="setSwapDirection(false)" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">NO ‚Üí YES</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="swapSlip05" class="slip-btn slip-active" onclick="setSwapSlippage(0.5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">0.5%</button>
                    <button id="swapSlip1" class="slip-btn" onclick="setSwapSlippage(1)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">1%</button>
                    <button id="swapSlip2" class="slip-btn" onclick="setSwapSlippage(2)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">2%</button>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="swapInputLabel">YES Amount</span>
                        <span>Balance: <span id="swapBalance">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="swapAmount" placeholder="0.1" step="0.01" min="0" oninput="swapMaxRaw=null;updateSwapPreview()" style="flex:1;">
                        <button onclick="setSwapMax()" style="padding:0.5rem 1rem;background:var(--pink-dim);border:1px solid var(--pink);border-radius:var(--radius);color:var(--pink);font-weight:600;font-size:var(--font-xs);cursor:pointer;">Max</button>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="swapOutput">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Swap Fee (0.3%)</span>
                        <span id="swapFee">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Min Output</span>
                        <span id="swapMinOutput">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="swapSubmit" onclick="executeSwap()" style="background:var(--pink);">Swap YES ‚Üí NO</button>
            </div>

            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div style="font-size:var(--font-xs);color:var(--text-dim);margin-bottom:0.75rem;">
                    Add or remove liquidity from the prediction market pool.
                </div>

                <!-- Add/Remove Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="lpAddBtn" class="mode-toggle-btn active-add" onclick="setLpMode('add')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:var(--blue);color:white;">Add</button>
                    <button id="lpRemoveBtn" class="mode-toggle-btn" onclick="setLpMode('remove')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Remove</button>
                </div>

                <!-- Slippage -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;flex-wrap:wrap;">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage:</span>
                    <button id="lpSlip5" class="slip-btn" onclick="setLpSlippage(5)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">5%</button>
                    <button id="lpSlip10" class="slip-btn slip-active" onclick="setLpSlippage(10)" style="padding:2px 8px;font-size:10px;border:1px solid var(--pink);background:var(--pink-dim);color:var(--pink);border-radius:4px;cursor:pointer;">10%</button>
                    <button id="lpSlip20" class="slip-btn" onclick="setLpSlippage(20)" style="padding:2px 8px;font-size:10px;border:1px solid var(--border);background:transparent;color:var(--text-muted);border-radius:4px;cursor:pointer;">20%</button>
                    <input type="number" id="lpSlipCustom" placeholder="%" min="0.1" max="50" step="0.1" style="width:44px;padding:2px 4px;font-size:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);border-radius:4px;" onchange="setLpSlippage(parseFloat(this.value)||10)">
                </div>

                <div style="background:var(--surface);padding:0.75rem;border-radius:var(--radius);margin-bottom:1rem;">
                    <div style="display:flex;justify-content:space-between;font-size:var(--font-xs);">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span style="color:var(--blue);font-weight:600;" id="lpPosition">0 LP</span>
                    </div>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="lpAmountLabel">ETH to Add</span>
                        <span style="display:flex;align-items:center;gap:0.5rem;">
                            Balance: <span id="lpBalance">--</span>
                            <button id="lpMaxBtn" onclick="setLpMax()" style="padding:0.25rem 0.5rem;background:var(--blue-dim);border:1px solid var(--blue);border-radius:var(--radius);color:var(--blue);font-weight:600;font-size:10px;cursor:pointer;">Max</button>
                        </span>
                    </div>
                    <input type="number" class="trade-input" id="lpAmount" placeholder="0.1" step="0.01" min="0" oninput="lpMaxRaw=null;updateLpPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">Est. LP Tokens</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Your Pool Share</span>
                        <span><span id="lpPoolShare">--%</span> <span id="lpShareChange" style="font-size:10px;"></span></span>
                    </div>
                </div>
                <button class="trade-submit" id="lpSubmit" onclick="executeLp()" style="background:var(--blue);">Deposit Liquidity</button>
            </div>

            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <!-- Side indicator -->
                <div style="display:flex;align-items:center;gap:0.5rem;margin-bottom:0.75rem;">
                    <span id="limitSideIndicator" style="padding:0.25rem 0.75rem;border-radius:4px;font-size:var(--font-xs);font-weight:700;background:var(--green-dim);color:var(--green);">YES</span>
                    <span style="font-size:var(--font-xs);color:var(--text-dim);" id="limitExplainerText">Bid below pool price to get better odds. ETH escrowed until filled.</span>
                </div>

                <!-- Buy/Sell Toggle -->
                <div style="display:flex;gap:4px;margin-bottom:1rem;">
                    <button id="limitBuyBtn" class="mode-toggle-btn active-add" onclick="setLimitSide('buy')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:#8b5cf6;color:white;">Buy Order</button>
                    <button id="limitSellBtn" class="mode-toggle-btn" onclick="setLimitSide('sell')" style="flex:1;padding:0.5rem;border:none;border-radius:4px;cursor:pointer;font-size:var(--font-xs);font-weight:600;background:transparent;color:var(--text-muted);border:1px solid var(--border);">Sell Order</button>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span>Your Odds</span>
                        <span id="limitOddsDisplay" style="font-weight:600;color:var(--text);">--</span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="limitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99" oninput="updateLimitPreview()" style="flex:1;">
                        <button onclick="adjustLimitPrice(-0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--red);font-weight:600;cursor:pointer;font-size:var(--font-sm);">-1%</button>
                        <button onclick="adjustLimitPrice(0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-sm);">+1%</button>
                    </div>
                </div>

                <div class="trade-input-group">
                    <div class="trade-label">
                        <span id="limitAmountLabel">Spend (ETH)</span>
                        <span>Balance: <span id="limitBalance">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <input type="number" class="trade-input" id="limitAmount" value="0.01" step="0.01" min="0" oninput="limitMaxRaw=null;updateLimitPreview()" style="flex:1;">
                        <button onclick="setLimitMax()" style="padding:0.5rem 1rem;background:var(--surface-2);border:1px solid #8b5cf6;border-radius:var(--radius);color:#8b5cf6;font-weight:600;font-size:var(--font-xs);cursor:pointer;">Max</button>
                    </div>
                </div>

                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitResultLabel">You receive</span>
                        <span id="limitResult">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="limitPoolPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="limitSavingsLabel">vs Pool</span>
                        <span id="limitSavings" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" onclick="executeLimitOrder()" style="background:#8b5cf6;">Place Buy Order</button>

                <!-- Compact Orderbook for Limit Tab -->
                <div style="margin-top:1rem;border-top:1px solid var(--border);padding-top:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                        <span style="font-size:var(--font-xs);font-weight:600;color:var(--text-muted);">Open Orders</span>
                        <button onclick="openOrderbookModal()" style="font-size:10px;color:var(--pink);background:none;border:none;cursor:pointer;text-decoration:underline;">Full Depth ‚Üí</button>
                    </div>
                    <div id="limitBookPreview" style="font-size:11px;max-height:120px;overflow-y:auto;">
                        <div style="color:var(--text-dim);text-align:center;padding:0.5rem;">No orders</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Orderbook Modal - Probability Ladder Design -->
    <div class="modal-overlay" id="orderbookModal">
        <div class="modal" style="max-width:580px;">
            <div class="modal-header">
                <div class="modal-title">Market Depth</div>
                <button class="modal-close" onclick="closeOrderbookModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding:0.75rem;">
                <!-- Header with AMM prices -->
                <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;margin-bottom:0.25rem;padding-bottom:0.25rem;border-bottom:2px solid var(--border);">
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--green);font-size:13px;">YES</div>
                        <div id="yesAmmRef" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                    <div style="text-align:center;font-size:9px;color:var(--text-dim);display:flex;align-items:center;justify-content:center;">Odds</div>
                    <div style="text-align:center;">
                        <div style="font-weight:700;color:var(--red);font-size:13px;">NO</div>
                        <div id="noAmmRef" style="font-size:10px;color:var(--text-dim);">--</div>
                    </div>
                </div>
                <!-- Probability Ladder -->
                <div id="depthLadder" style="background:var(--surface);border-radius:var(--radius);padding:0.5rem;max-height:400px;overflow-y:auto;">
                    <div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading...</div>
                </div>
                <!-- Actions -->
                <div style="display:flex;gap:0.5rem;margin-top:0.75rem;">
                    <button onclick="closeOrderbookModal(); openTrade(currentTrade.marketId.toString(), true)" style="flex:1;padding:0.5rem;background:var(--green);color:var(--bg);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade YES</button>
                    <button onclick="closeOrderbookModal(); openTrade(currentTrade.marketId.toString(), false)" style="flex:1;padding:0.5rem;background:var(--red);color:white;border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;font-size:var(--font-xs);">Trade NO</button>
                </div>
                <!-- Legend -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);font-size:9px;color:var(--text-dim);">
                    <span><span style="color:var(--green);">‚ñ†</span> Bids (buy)</span>
                    <span>Depth in ETH | Click to fill</span>
                    <span><span style="color:var(--red);">‚ñ†</span> Asks (sell)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const UNI_TOKEN_ADDRESS = '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984';
        const UNIV4_ADDRESS = '0x000000000004444c5dc75cB358380D2e3dE08A90';
        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        // New routing system (MasterRouter + PMHookRouter)
        const PMHOOKROUTER_ADDRESS = '0x0000000000BADa259Cb860c12ccD9500d9496B3e';
        const PMHOOKQUOTER_ADDRESS = '0x0000000000f0bf4ea3a43560324376e62fe390bc';
        const MASTERROUTER_ADDRESS = '0x000000000055CdB14b66f37B96a571108FFEeA5C';

        // Legacy router removed - using MasterRouter + PMHookRouter
        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        const CHAINLINK_UNI_USD_ORACLE = '0x553303d460EE0afB37EdFf9bE42922D8FF63220e'; // uni-usd.data.eth
        const ADMIN_ADDRESS = '0x1C0Aa8cCD568d90d61659F060D1bFb1e6f855A20'; // Admin wallet for market creation
        const FEE_TIER = 30n; // 0.30%
        const EOY_2026 = 1798761599; // Dec 31, 2026 23:59:59 UTC

        // protocolFeeController() selector
        // balanceOf(address) selector
        const BALANCE_OF_SELECTOR = '0x70a08231';
        // protocolFeeController() selector
        const PROTOCOL_FEE_CONTROLLER_SELECTOR = '0x91d14854';
        // getCurrentVotes(address) selector
        const GET_CURRENT_VOTES_SELECTOR = '0x9ab24eb0';
        // getPriorVotes(address,uint256) selector
        const GET_PRIOR_VOTES_SELECTOR = '0x782d6fe1';
        // totalSupply() selector
        const TOTAL_SUPPLY_SELECTOR = '0x18160ddd';
        // latestAnswer() selector (Chainlink oracle)
        const LATEST_ANSWER_SELECTOR = '0x50d25bcd';

        // Market type identifiers
        const MARKET_TYPE = {
            V4_FEE_SWITCH: 'V4_FEE_SWITCH',
            UNI_BALANCE: 'UNI_BALANCE',
            UNI_VOTES: 'UNI_VOTES',
            TOTAL_SUPPLY: 'TOTAL_SUPPLY',
            UNI_PRICE_USD: 'UNI_PRICE_USD',
            UNKNOWN: 'UNKNOWN'
        };

        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc, 1, { staticNetwork: true });
                    await Promise.race([
                        p.getBlockNumber(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 5000))
                    ]);
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const UNI_TOKEN_ABI = [
            'function balanceOf(address owner) view returns (uint256)',
            'function decimals() view returns (uint8)',
            'function symbol() view returns (string)',
            'function getCurrentVotes(address account) view returns (uint256)',
            'function getPriorVotes(address account, uint256 blockNumber) view returns (uint256)',
            'function delegates(address delegator) view returns (address)',
            'function totalSupply() view returns (uint256)',
            'function approve(address spender, uint256 amount) returns (bool)',
            'function allowance(address owner, address spender) view returns (uint256)'
        ];

        const UNIV4_ABI = [
            'function protocolFeeController() view returns (address)'
        ];

        const RESOLVER_ABI = [
            'function conditions(uint256 marketId) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)',
            'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
            'function resolveMarket(uint256 marketId)',
            'function createNumericMarketAndSeed(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose, tuple(uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) seed) payable returns (uint256 marketId, uint256 noId, uint256 shares, uint256 liquidity)',
            'event ConditionCreated(uint256 indexed marketId, address indexed targetA, uint8 op, uint256 threshold, uint64 close, bool canClose, bool isRatio, string description)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function balanceOf(address owner, uint256 id) view returns (uint256)',
            'function getNoId(uint256 marketId) pure returns (uint256)',
            'function isOperator(address owner, address operator) view returns (bool)',
            'function setOperator(address operator, bool approved) returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
            'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
            'function multicall(bytes[] data) returns (bytes[])'
        ];

        // Legacy PMROUTER_ABI removed - using MasterRouter + PMHookRouter instead

        const PMHOOKROUTER_ABI = [
            'function provideLiquidity(uint256 marketId, uint256 collateralAmount, uint256 vaultYesShares, uint256 vaultNoShares, uint256 ammLPShares, uint256 minAmount0, uint256 minAmount1, address receiver, uint256 deadline) payable returns (uint256 yesVaultSharesMinted, uint256 noVaultSharesMinted, uint256 ammLiquidity)',
            'function bootstrapMarket(uint256 marketId, uint256 collateralAmount, uint256 vaultYesShares, uint256 vaultNoShares, address receiver) payable returns (uint256 yesShares, uint256 noShares)'
        ];

        const PMHOOKQUOTER_ABI = [
            'function getActiveLevels(uint256 marketId, bool isYes, uint256 maxLevels) view returns (uint256[] askPrices, uint256[] askDepths, uint256[] bidPrices, uint256[] bidDepths)',
            'function getUserActivePositions(uint256 marketId, bool isYes, address user) view returns (uint256[] askPrices, uint256[] askShares, uint256[] askPendingColl, uint256[] bidPrices, uint256[] bidCollateral, uint256[] bidPendingShares)',
            'function getUserFullPosition(uint256 marketId, address user) view returns (uint256 yesShareBalance, uint256 noShareBalance, uint256 yesVaultLP, uint256 noVaultLP, uint256 pendingYesCollateral, uint256 pendingNoCollateral, uint256 ammLPBalance)',
            'function getUserAllLimitOrders(uint256 marketId, address user) view returns (uint256[] yesAskPrices, uint256[] yesAskShares, uint256[] yesAskPending, uint256[] yesBidPrices, uint256[] yesBidCollateral, uint256[] yesBidPending, uint256[] noAskPrices, uint256[] noAskShares, uint256[] noAskPending, uint256[] noBidPrices, uint256[] noBidCollateral, uint256[] noBidPending)',
            'function quoteBuyWithSweep(uint256 marketId, bool isYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 fromPool, uint256 fromAmm, uint256 effectivePriceBps)',
            'function quoteSellWithSweep(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 fromPool, uint256 fromAmm, uint256 effectivePriceBps)'
        ];

        const MASTERROUTER_ABI = [
            'function buyWithSweep(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut)',
            'function sellWithSweep(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut)',
            'function mintAndPool(uint256 marketId, uint256 collateralIn, bool keepYes, uint256 priceInBps, address to) payable returns (uint256 sharesKept, uint256 sharesPooled)',
            'function depositSharesToPool(uint256 marketId, bool isYes, uint256 shares, uint256 priceInBps, address to) returns (uint256 sharesPooled)',
            'function withdrawFromPool(uint256 marketId, bool isYes, uint256 priceInBps) returns (uint256 sharesOut, uint256 collateralOut)',
            'function withdrawFromBidPool(uint256 marketId, bool isYes, uint256 priceInBps) returns (uint256 sharesOut, uint256 collateralOut)'
        ];

        const ZAMM_ABI = [
            'function isOperator(address owner, address operator) view returns (bool)',
            'function setOperator(address operator, bool approved) returns (bool)',
            'function balanceOf(address owner, uint256 id) view returns (uint256)',
            'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)',
            'function pools(uint256 poolId) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // ======================== MARKET TYPE DETECTION ========================
        function detectMarketType(condition) {
            const { targetA, callDataA } = condition;

            // V4 Fee Switch: target is UniV4, calling protocolFeeController()
            if (targetA.toLowerCase() === UNIV4_ADDRESS.toLowerCase() &&
                callDataA.toLowerCase() === PROTOCOL_FEE_CONTROLLER_SELECTOR.toLowerCase()) {
                return MARKET_TYPE.V4_FEE_SWITCH;
            }

            // Chainlink UNI/USD Oracle Price Markets
            if (targetA.toLowerCase() === CHAINLINK_UNI_USD_ORACLE.toLowerCase()) {
                const selector = callDataA.toLowerCase().slice(0, 10);
                if (selector === LATEST_ANSWER_SELECTOR.toLowerCase()) {
                    return MARKET_TYPE.UNI_PRICE_USD;
                }
            }

            // UNI Token markets
            if (targetA.toLowerCase() === UNI_TOKEN_ADDRESS.toLowerCase()) {
                const selector = callDataA.toLowerCase().slice(0, 10);

                // UNI Balance: calling balanceOf(address)
                if (selector === BALANCE_OF_SELECTOR.toLowerCase()) {
                    return MARKET_TYPE.UNI_BALANCE;
                }

                // UNI Voting Power: calling getCurrentVotes(address)
                if (selector === GET_CURRENT_VOTES_SELECTOR.toLowerCase()) {
                    return MARKET_TYPE.UNI_VOTES;
                }

                // UNI Total Supply: calling totalSupply()
                if (selector === TOTAL_SUPPLY_SELECTOR.toLowerCase()) {
                    return MARKET_TYPE.TOTAL_SUPPLY;
                }
            }

            return MARKET_TYPE.UNKNOWN;
        }

        function getMarketTypeLabel(marketType) {
            switch (marketType) {
                case MARKET_TYPE.V4_FEE_SWITCH: return 'UNIV4';
                case MARKET_TYPE.UNI_BALANCE: return 'UNI-BAL';
                case MARKET_TYPE.UNI_VOTES: return 'UNI-VOTES';
                case MARKET_TYPE.TOTAL_SUPPLY: return 'UNI-SUPPLY';
                case MARKET_TYPE.UNI_PRICE_USD: return 'UNI-PRICE';
                default: return 'OTHER';
            }
        }

        function getMarketTypeDescription(marketType, condition) {
            const opSymbols = { 0: '<', 1: '>', 2: '<=', 3: '>=', 4: '==', 5: '!=' };
            const opSym = opSymbols[condition.op] || '?';

            switch (marketType) {
                case MARKET_TYPE.V4_FEE_SWITCH:
                    return 'V4 fee controller activated';

                case MARKET_TYPE.UNI_PRICE_USD:
                    const priceUSD = (Number(condition.threshold) / 1e8).toFixed(2);
                    return `UNI price ${opSym} $${priceUSD}`;

                case MARKET_TYPE.UNI_BALANCE:
                    const address = '0x' + condition.callDataA.slice(34);
                    const balanceThreshold = ethers.formatUnits(condition.threshold, 18);
                    return `UNI balance of ${address.slice(0,6)}...${address.slice(-4)} ${opSym} ${balanceThreshold}`;

                case MARKET_TYPE.UNI_VOTES:
                    const delegatee = '0x' + condition.callDataA.slice(34);
                    const votesThreshold = ethers.formatUnits(condition.threshold, 18);
                    return `UNI votes for ${delegatee.slice(0,6)}...${delegatee.slice(-4)} ${opSym} ${votesThreshold}`;

                case MARKET_TYPE.TOTAL_SUPPLY:
                    const supplyThreshold = ethers.formatUnits(condition.threshold, 18);
                    return `UNI totalSupply() ${opSym} ${supplyThreshold}`;

                default:
                    return 'Unknown market type';
            }
        }

        // Compute pool ID from pool key (keccak256 of encoded key)
        function computePoolId(id0, id1, token0, token1, feeOrHook) {
            const abiCoder = ethers.AbiCoder.defaultAbiCoder();
            const encoded = abiCoder.encode(
                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                [id0, id1, token0, token1, feeOrHook]
            );
            return ethers.keccak256(encoded);
        }

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let connectedWalletProvider = null;
        let walletConnectProvider = null;
        let isConnecting = false;
        let walletEventHandlers = null;
        const eip6963Providers = new Map();

        let univ4Markets = []; // Markets related to UniV4
        let currentTrade = { marketId: null, collateral: null, isYes: true, yesId: null, noId: null, rYes: 0n, rNo: 0n };
        let pendingToasts = new Map(); // Track pending toasts by ID
        let toastIdCounter = 0;

        // UNI token state
        let uniBalance = 0n;
        let uniApprovalAmount = 0n;

        // Trade mode state
        let currentTradeMode = 'trade'; // 'trade', 'swap', 'limit', 'lp'
        let currentTradeDirection = 'buy'; // 'buy' or 'sell'
        let currentLpMode = 'add'; // 'add' or 'remove'
        let currentSwapDirection = true; // true = YES‚ÜíNO, false = NO‚ÜíYES
        let limitIsBuy = true;
        let slippageTolerance = 10; // 10% default for small pools
        let swapSlippage = 0.5; // 0.5%

        // User position state
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n, lpTotalSupply: null };

        // Orderbook state - stores both YES and NO orderbooks
        let currentOrderbook = {
            yes: { bids: [], asks: [], ammPrice: null },
            no: { bids: [], asks: [], ammPrice: null }
        };

        // User pool positions for pooled orderbook
        let userPoolPositions = { yes: { asks: [], bids: [] }, no: { asks: [], bids: [] } };

        // ======================== INIT ========================
        async function init() {
            initEIP6963();

            // Auto-reconnect wallet if previously connected
            const savedWallet = localStorage.getItem('unipm_wallet');
            if (savedWallet) {
                // Small delay to let EIP-6963 providers announce themselves
                setTimeout(async () => {
                    try {
                        await connectWithWallet(savedWallet);
                    } catch (e) {
                        console.warn('Auto-reconnect failed:', e);
                        localStorage.removeItem('unipm_wallet');
                    }
                }, 100);
            }

            await loadData();
            startSmartPolling();

            // Setup create form listeners
            document.getElementById('createDeadline').addEventListener('change', updateCreatePreview);
            document.getElementById('createThreshold').addEventListener('input', updateCreatePreview);
            document.getElementById('createCanClose').addEventListener('change', updateCreatePreview);
        }

        // ======================== DATA LOADING ========================
        // Always use public RPC for reading (more reliable than wallet provider)
        let readProvider = null;
        async function getReadProvider() {
            if (readProvider) return readProvider;
            readProvider = await getRpcProvider();
            return readProvider;
        }

        let loadDataRetries = 0;
        async function loadData() {
            try {
                const rpc = await getReadProvider();

                // Load UniV4 protocolFeeController, UNI total supply, and UNI price
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const oracleABI = ['function latestAnswer() external view returns (int256)'];
                const results = await multicall.aggregate3([
                    {
                        target: UNIV4_ADDRESS,
                        allowFailure: true,
                        callData: new ethers.Interface(UNIV4_ABI).encodeFunctionData('protocolFeeController', [])
                    },
                    {
                        target: UNI_TOKEN_ADDRESS,
                        allowFailure: true,
                        callData: new ethers.Interface(UNI_TOKEN_ABI).encodeFunctionData('totalSupply', [])
                    },
                    {
                        target: CHAINLINK_UNI_USD_ORACLE,
                        allowFailure: true,
                        callData: new ethers.Interface(oracleABI).encodeFunctionData('latestAnswer', [])
                    }
                ]);

                // Parse fee controller
                if (results[0].success) {
                    try {
                        const controller = new ethers.Interface(UNIV4_ABI).decodeFunctionResult('protocolFeeController', results[0].returnData)[0];
                        const isActive = controller !== ethers.ZeroAddress;
                        document.getElementById('livePunks').textContent = isActive ? 'Active' : 'üò¥';
                        document.getElementById('heroBalance').textContent = isActive ? 'Active' : 'üò¥';
                    } catch {}
                }

                // Parse UNI total supply
                if (results[1].success) {
                    try {
                        const supply = new ethers.Interface(UNI_TOKEN_ABI).decodeFunctionResult('totalSupply', results[1].returnData)[0];
                        document.getElementById('uniTotalSupply').textContent = formatSupplyShorthand(supply);
                    } catch {}
                }

                // Parse UNI price from Chainlink oracle
                if (results[2].success) {
                    try {
                        const price = new ethers.Interface(oracleABI).decodeFunctionResult('latestAnswer', results[2].returnData)[0];
                        document.getElementById('uniPrice').textContent = '$' + formatOraclePrice(price);
                    } catch {}
                }

                // Find UniV4-related markets by scanning ConditionCreated events
                await loadUniswapMarkets(rpc);
                loadDataRetries = 0; // Reset on success

            } catch (error) {
                console.error('Failed to load data:', error);
                // Reset read provider on error to try a different RPC next time
                readProvider = null;
                // Show user-visible error for RPC failures with retry limit
                if (error.message?.includes('RPC') || error.message?.includes('network') || error.message?.includes('timeout')) {
                    if (loadDataRetries < 3) {
                        loadDataRetries++;
                        showToast('Network Error', `Retrying... (${loadDataRetries}/3)`, 'error', 3000);
                        setTimeout(loadData, 5000 * loadDataRetries); // Exponential backoff
                    } else {
                        showToast('Network Error', 'Connection failed. Please refresh.', 'error', 8000);
                    }
                }
            }
        }

        // Smart polling - pauses when tab is hidden, refreshes on return
        let pollInterval = null;
        function startSmartPolling() {
            const ACTIVE_INTERVAL = 60000;   // 60s when active
            const HIDDEN_INTERVAL = 300000;  // 5 min when hidden

            function poll() {
                clearInterval(pollInterval);
                const interval = document.hidden ? HIDDEN_INTERVAL : ACTIVE_INTERVAL;
                pollInterval = setInterval(loadData, interval);
            }

            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    loadDataRetries = 0; // Reset retry counter
                    loadData(); // Refresh immediately when tab becomes visible
                }
                poll(); // Adjust polling interval
            });

            poll(); // Start polling
        }

        // ======================== DYNAMIC MARKET DISCOVERY ========================
        async function loadUniswapMarkets(rpc) {
            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, rpc);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const resolverInterface = new ethers.Interface(RESOLVER_ABI);

                // Scan for ConditionCreated events from Resolver
                // Look back ~1 week of blocks (~50k blocks at 12s/block)
                const currentBlock = await rpc.getBlockNumber();
                const fromBlock = Math.max(0, currentBlock - 50000);

                const filter = resolver.filters.ConditionCreated();
                const events = await resolver.queryFilter(filter, fromBlock, currentBlock);

                console.log(`Found ${events.length} ConditionCreated events`);

                // Extract market IDs and filter for Uniswap-related markets
                const candidateMarkets = [];
                for (const event of events) {
                    const marketId = event.args.marketId;
                    const targetA = event.args.targetA;

                    // Only include markets targeting UniV4 or UNI token
                    if (targetA.toLowerCase() === UNIV4_ADDRESS.toLowerCase() ||
                        targetA.toLowerCase() === UNI_TOKEN_ADDRESS.toLowerCase()) {
                        candidateMarkets.push(marketId);
                    }
                }

                console.log(`Found ${candidateMarkets.length} Uniswap-related markets`);

                if (candidateMarkets.length === 0) {
                    univ4Markets = [];
                    renderMarkets();
                    return;
                }

                // Batch fetch market data
                const marketCalls = candidateMarkets.flatMap(id => [
                    { target: PAMM_ADDRESS, allowFailure: true, callData: pammInterface.encodeFunctionData('getMarket', [id]) },
                    { target: RESOLVER_ADDRESS, allowFailure: true, callData: resolverInterface.encodeFunctionData('conditions', [id]) }
                ]);

                const marketRaw = await multicall.aggregate3(marketCalls);

                // Parse market data
                let allMarketsData = [];
                for (let i = 0; i < candidateMarkets.length; i++) {
                    const marketResult = marketRaw[i * 2];
                    const conditionResult = marketRaw[i * 2 + 1];

                    if (!marketResult.success || !conditionResult.success) continue;

                    try {
                        const market = pammInterface.decodeFunctionResult('getMarket', marketResult.returnData);
                        const condition = resolverInterface.decodeFunctionResult('conditions', conditionResult.returnData);

                        const marketType = detectMarketType(condition);
                        if (marketType === MARKET_TYPE.UNKNOWN) continue; // Skip non-Uniswap markets

                        allMarketsData.push({
                            marketId: candidateMarkets[i],
                            collateral: market.collateral,
                            resolved: market.resolved,
                            outcome: market.outcome,
                            canClose: market.canClose,
                            close: Number(market.close),
                            collateralLocked: market.collateralLocked,
                            description: market.description,
                            condition,
                            marketType
                        });
                    } catch (e) {
                        console.error('Failed to parse market:', e);
                        continue;
                    }
                }

                console.log(`Parsed ${allMarketsData.length} valid Uniswap markets`);

                // Batch fetch additional data
                const dataCalls = [];

                // Pool states
                for (const m of allMarketsData) {
                    dataCalls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('getPoolState', [m.marketId, FEE_TIER])
                    });
                }

                // NoIds
                for (const m of allMarketsData) {
                    dataCalls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('getNoId', [m.marketId])
                    });
                }

                // Previews for unresolved markets
                for (const m of allMarketsData) {
                    if (!m.resolved) {
                        dataCalls.push({
                            target: RESOLVER_ADDRESS,
                            allowFailure: true,
                            callData: resolverInterface.encodeFunctionData('preview', [m.marketId])
                        });
                    }
                }

                // Current values for each market type
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                const univ4 = new ethers.Contract(UNIV4_ADDRESS, UNIV4_ABI, rpc);

                // Get current V4 fee controller status
                dataCalls.push({
                    target: UNIV4_ADDRESS,
                    allowFailure: true,
                    callData: new ethers.Interface(UNIV4_ABI).encodeFunctionData('protocolFeeController', [])
                });

                // Get UNI total supply
                dataCalls.push({
                    target: UNI_TOKEN_ADDRESS,
                    allowFailure: true,
                    callData: new ethers.Interface(UNI_TOKEN_ABI).encodeFunctionData('totalSupply', [])
                });

                // Get UNI price from Chainlink oracle
                const oracleABI = ['function latestAnswer() external view returns (int256)'];
                dataCalls.push({
                    target: CHAINLINK_UNI_USD_ORACLE,
                    allowFailure: true,
                    callData: new ethers.Interface(oracleABI).encodeFunctionData('latestAnswer', [])
                });

                const dataRaw = dataCalls.length > 0 ? await multicall.aggregate3(dataCalls) : [];

                // Parse results
                const poolResults = [];
                const noIdResults = [];
                const previewResults = [];
                let idx = 0;

                // Pool states
                for (const m of allMarketsData) {
                    const r = dataRaw[idx++];
                    if (r.success) {
                        try {
                            poolResults.push(pammInterface.decodeFunctionResult('getPoolState', r.returnData));
                        } catch { poolResults.push(null); }
                    } else {
                        poolResults.push(null);
                    }
                }
                // NoIds
                for (const m of allMarketsData) {
                    const r = dataRaw[idx++];
                    if (r.success) {
                        try {
                            noIdResults.push(pammInterface.decodeFunctionResult('getNoId', r.returnData)[0]);
                        } catch { noIdResults.push(null); }
                    } else {
                        noIdResults.push(null);
                    }
                }
                // Previews
                for (const m of allMarketsData) {
                    if (!m.resolved) {
                        const r = dataRaw[idx++];
                        if (r && r.success) {
                            try {
                                previewResults.push(resolverInterface.decodeFunctionResult('preview', r.returnData));
                            } catch { previewResults.push(null); }
                        } else {
                            previewResults.push(null);
                        }
                    }
                }

                // Fee controller status
                const feeControllerResult = dataRaw[idx];
                if (feeControllerResult && feeControllerResult.success) {
                    try {
                        const controller = new ethers.Interface(UNIV4_ABI).decodeFunctionResult('protocolFeeController', feeControllerResult.returnData)[0];
                        const isActive = controller !== ethers.ZeroAddress;
                        document.getElementById('livePunks').textContent = isActive ? 'Active' : 'üò¥';
                        document.getElementById('heroBalance').textContent = isActive ? 'Active' : 'üò¥';
                    } catch {}
                }
                idx++;

                // UNI total supply
                const totalSupplyResult = dataRaw[idx];
                if (totalSupplyResult && totalSupplyResult.success) {
                    try {
                        const supply = new ethers.Interface(UNI_TOKEN_ABI).decodeFunctionResult('totalSupply', totalSupplyResult.returnData)[0];
                        document.getElementById('uniTotalSupply').textContent = formatSupplyShorthand(supply);
                    } catch {}
                }
                idx++;

                // UNI price from Chainlink oracle
                const uniPriceResult = dataRaw[idx];
                if (uniPriceResult && uniPriceResult.success) {
                    try {
                        const price = new ethers.Interface(oracleABI).decodeFunctionResult('latestAnswer', uniPriceResult.returnData)[0];
                        document.getElementById('uniPrice').textContent = '$' + formatOraclePrice(price);
                    } catch {}
                }

                // Assemble final market objects
                univ4Markets = [];
                let previewIdx = 0;

                for (let i = 0; i < allMarketsData.length; i++) {
                    const m = allMarketsData[i];
                    const pool = poolResults[i];
                    const noId = noIdResults[i];

                    let preview = null;
                    if (!m.resolved) {
                        preview = previewResults[previewIdx++];
                    }

                    univ4Markets.push({
                        ...m,
                        pool,
                        noId,
                        preview,
                        typeLabel: getMarketTypeLabel(m.marketType)
                    });
                }

                // Update chart iframe if we have markets
                updateChartSection();

                // Render markets
                renderMarkets();

                console.log(`Loaded ${univ4Markets.length} Uniswap markets`);

            } catch (error) {
                console.error('Failed to load Uniswap markets:', error);
                univ4Markets = [];
                renderMarkets();
            }
        }

        // ======================== CHART UPDATE ========================
        function updateChartSection() {
            const chartSection = document.getElementById('chartSection');
            const chartIframe = document.getElementById('chartIframe');

            if (univ4Markets.length === 0) {
                // Hide chart if no markets
                if (chartSection) chartSection.style.display = 'none';
            } else {
                // Show chart with first market's pool
                if (chartSection) chartSection.style.display = 'block';

                const firstMarket = univ4Markets[0];
                if (chartIframe && firstMarket.noId) {
                    const poolId = firstMarket.noId; // Use noId as poolId for ZAMM
                    chartIframe.src = `https://www.zamm.finance/embed/pool/${poolId}?theme=dark`;
                }
            }
        }

        function renderMarkets() {
            const grid = document.getElementById('marketsGrid');

            if (!univ4Markets || univ4Markets.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üì≠</div>
                        <p>No Uniswap markets found. Create one below!</p>
                    </div>
                `;
                updateMarketTabsVisibility();
                return;
            }

            grid.innerHTML = univ4Markets.map(m => renderMarketCard(m)).join('');

            // Update stats
            const totalTvl = univ4Markets.reduce((sum, m) => sum + (m.collateralLocked || 0n), 0n);
            const activeMarkets = univ4Markets.filter(m => !m.resolved);
            const readyMarkets = univ4Markets.filter(m => !m.resolved && m.preview?.ready);
            const resolvedMarkets = univ4Markets.filter(m => m.resolved);

            document.getElementById('marketCount').textContent = univ4Markets.length;
            document.getElementById('activeCount').textContent = activeMarkets.length;
            document.getElementById('readyCount').textContent = readyMarkets.length;
            document.getElementById('resolvedCount').textContent = resolvedMarkets.length;
            document.getElementById('totalTvl').textContent = formatEth(totalTvl) + ' ETH';

            // Update featured odds
            const featuredMarket = activeMarkets[0] || univ4Markets[0];
            if (featuredMarket && featuredMarket.pool) {
                const rYes = featuredMarket.pool.rYes || 0n;
                const rNo = featuredMarket.pool.rNo || 0n;
                const total = rYes + rNo;
                if (total > 0n) {
                    const yesOdds = Number(rNo * 100n / total);
                    const noOdds = 100 - yesOdds;
                    document.getElementById('featuredOdds').textContent = `YES ${yesOdds}% / NO ${noOdds}%`;
                }
            }

            // Update tab visibility based on existing markets
            updateMarketTabsVisibility();
        }

        async function loadInlineOrderbook(market) {
            // Set minimal currentTrade data needed for orderbook loading
            currentTrade.marketId = market.marketId;
            currentTrade.yesId = market.marketId;
            currentTrade.noId = market.noId;
            currentTrade.rYes = market.pool?.rYes || 0n;
            currentTrade.rNo = market.pool?.rNo || 0n;
            currentTrade.isYes = true;

            await loadOrderbook();
        }

        function renderMarketCard(market) {
            const now = Math.floor(Date.now() / 1000);
            const timeLeft = market.close - now;

            // Calculate yesOdds from pool state
            let yesOdds = 50;
            const rYes = market.pool?.rYes || 0n;
            const rNo = market.pool?.rNo || 0n;
            const total = rYes + rNo;
            if (total > 0n) {
                yesOdds = Number(rNo * 100n / total);
            }

            let status, statusClass;
            if (market.resolved) {
                status = market.outcome ? 'YES Won' : 'NO Won';
                statusClass = 'resolved';
            } else if (market.preview?.ready) {
                status = 'Ready to Resolve';
                statusClass = 'ready';
            } else {
                status = 'Active';
                statusClass = 'active';
            }

            const opSymbol = ['<', '>', '<=', '>=', '==', '!='][market.condition.op] || '?';
            const noOdds = 100 - yesOdds;
            const currentValue = market.preview?.value || 0n;
            const typeLabel = market.typeLabel || 'OTHER';
            const collateralSymbol = getCollateralSymbol(market.collateral);
            const collateralIcon = getCollateralIcon(market.collateral, '14');

            // Compute ZAMM pool link
            let poolId = null;
            if (market.noId) {
                const yesId = market.marketId;
                const id0 = yesId < market.noId ? yesId : market.noId;
                const id1 = yesId < market.noId ? market.noId : yesId;
                poolId = computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER);
            }

            return `
                <div class="market-row">
                <div class="bet-card ${market.resolved ? 'resolved' : ''}">
                    <div class="bet-header">
                        <span class="bet-type">${typeLabel}</span>
                        <span class="bet-status ${statusClass}">${status}</span>
                        <span style="font-size:10px;color:var(--text-dim);margin-left:auto;">${collateralIcon} ${collateralSymbol}</span>
                    </div>
                    <div class="bet-title">${escapeHtml(market.description)}</div>
                    <div class="bet-question">${getMarketTypeDescription(market.marketType, market.condition)}</div>
                    <details class="onchain-details">
                        <summary>on-chain ‚Üì</summary>
                        <div class="onchain-desc">Market ID: ${market.marketId.toString()}</div>
                    </details>

                    <div class="condition-display">
                        <div class="condition-point">
                            <div class="condition-label">Current</div>
                            <div class="condition-value" style="color:var(--pink);">${currentValue.toString()}</div>
                        </div>
                        <div class="condition-op">${opSymbol}</div>
                        <div class="condition-point">
                            <div class="condition-label">Target</div>
                            <div class="condition-value">${market.condition.threshold.toString()}</div>
                        </div>
                    </div>

                    ${!market.resolved ? `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0.75rem;margin-bottom:0.75rem;background:${yesOdds > 50 ? 'var(--green-dim)' : yesOdds < 50 ? 'var(--red-dim)' : 'var(--surface-2)'};border-radius:var(--radius);font-size:var(--font-xs);">
                            <div>
                                <span style="color:${yesOdds > 50 ? 'var(--green)' : yesOdds < 50 ? 'var(--red)' : 'var(--text-muted)'};">
                                    ${yesOdds > 50 ? '‚ñ≤ Market favors YES' : yesOdds < 50 ? '‚ñº Market favors NO' : '‚óÜ Market is neutral'}
                                </span>
                                <span style="color:var(--text-dim);margin-left:0.5rem;">(${Math.abs(yesOdds - 50)}% edge)</span>
                            </div>
                            <button onclick="viewMarketDepth('${market.marketId}')" style="background:var(--surface);border:1px solid var(--border);border-radius:4px;padding:2px 8px;font-size:10px;color:var(--text-muted);cursor:pointer;">Depth</button>
                        </div>
                        <div class="bet-buttons">
                            <button class="bet-btn yes" onclick="openTrade('${market.marketId}', true)">
                                <div class="bet-btn-label">Buy Yes</div>
                                <div class="bet-btn-odds">${yesOdds}%</div>
                                <div class="bet-btn-price">${(yesOdds / 100).toFixed(2)} ${collateralSymbol}/share</div>
                            </button>
                            <button class="bet-btn no" onclick="openTrade('${market.marketId}', false)">
                                <div class="bet-btn-label">Buy No</div>
                                <div class="bet-btn-odds">${noOdds}%</div>
                                <div class="bet-btn-price">${(noOdds / 100).toFixed(2)} ${collateralSymbol}/share</div>
                            </button>
                        </div>
                    ` : `
                        <div style="padding:1rem;text-align:center;background:var(--surface-2);border-radius:var(--radius);margin-bottom:1rem;">
                            <div style="font-size:var(--font-2xl);font-weight:700;color:${market.outcome ? 'var(--green)' : 'var(--red)'};">
                                ${market.outcome ? 'YES' : 'NO'} Won
                            </div>
                            <button class="resolve-btn" style="margin-top:0.75rem;background:var(--green);color:var(--bg);" onclick="claimWinnings('${market.marketId}')">
                                Claim Winnings
                            </button>
                        </div>
                    `}

                    <div class="bet-countdown">
                        <span>${market.canClose ? 'May close early' : 'Closes'}</span>
                        <span class="countdown-value">${formatCountdown(timeLeft)}</span>
                    </div>

                    <div class="liquidity-stats">
                        <span>TVL: <span style="color:var(--blue);">${formatEth(market.collateralLocked)} ${collateralSymbol}</span></span>
                        <span>ID: ${truncateId(market.marketId.toString())}</span>
                        ${poolId ? `<a href="https://zamm.finance/p/${BigInt(poolId).toString()}" target="_blank" title="View on ZAMM" style="display:flex;align-items:center;gap:3px;color:var(--text-muted);text-decoration:none;font-size:10px;opacity:0.7;transition:opacity 0.2s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"><img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:12px;height:12px;border-radius:2px;">ZAMM</a>` : ''}
                    </div>

                    ${market.preview?.ready && !market.resolved ? `
                        <button class="resolve-btn" onclick="resolveMarket('${market.marketId}')">Resolve Market</button>
                    ` : ''}
                </div>
                ${!market.resolved ? `
                <div class="inline-orderbook" id="inlineOrderbook-${market.marketId}">
                    <div class="inline-orderbook-header">
                        <div style="text-align:center;">
                            <div style="font-weight:700;color:var(--green);font-size:13px;">YES</div>
                            <div style="font-size:10px;color:var(--text-dim);" id="inlineYesAmm-${market.marketId}">--</div>
                        </div>
                        <div style="text-align:center;font-size:9px;color:var(--text-dim);display:flex;align-items:center;justify-content:center;">Odds</div>
                        <div style="text-align:center;">
                            <div style="font-weight:700;color:var(--red);font-size:13px;">NO</div>
                            <div style="font-size:10px;color:var(--text-dim);" id="inlineNoAmm-${market.marketId}">--</div>
                        </div>
                    </div>
                    <div class="inline-orderbook-ladder" id="inlineLadder-${market.marketId}">
                        <div style="text-align:center;color:var(--text-dim);padding:2rem;font-size:11px;">Loading orderbook...</div>
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);font-size:9px;color:var(--text-dim);">
                        <span><span style="color:var(--green);">‚ñ†</span> Bids</span>
                        <span>Depth in ETH | Click to trade</span>
                        <span><span style="color:var(--red);">‚ñ†</span> Asks</span>
                    </div>
                </div>
                ` : '<div></div>'}
                </div>
            `;
        }

        // ======================== WALLET ========================
        const WALLET_CONFIG = {
            metamask: { name: 'MetaMask', icon: 'ü¶ä', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
            coinbase: { name: 'Coinbase', icon: 'üîµ', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
            rabby: { name: 'Rabby', icon: 'üê∞', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
            rainbow: { name: 'Rainbow', icon: 'üåà', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
            walletconnect: { name: 'WalletConnect', icon: 'üì±' }
        };

        function initEIP6963() {
            if (typeof window === 'undefined') return;
            window.addEventListener('eip6963:announceProvider', (event) => {
                const { info, provider } = event.detail;
                eip6963Providers.set(info.uuid, { info, provider });
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

        function detectWallets() {
            const detected = [];
            const seenNames = new Set();

            for (const [key, config] of Object.entries(WALLET_CONFIG)) {
                if (key === 'walletconnect') continue;
                if (config.detect && config.detect()) {
                    detected.push({ key, ...config });
                    seenNames.add(config.name.toLowerCase());
                }
            }

            for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
                if (!seenNames.has(info.name.toLowerCase())) {
                    const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
                    const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
                    // Escape URL to prevent XSS via attribute injection
                    const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
                    detected.push({
                        key: `eip6963_${uuid}`,
                        name: safeName,
                        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'üîå',
                        getProvider: () => provider
                    });
                    seenNames.add(info.name.toLowerCase());
                }
            }

            if (detected.length === 0 && window.ethereum) {
                detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'üîó', getProvider: () => window.ethereum });
            }

            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            if (wcModule?.EthereumProvider) {
                detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'üì±', isWalletConnect: true });
            }

            return detected;
        }

        function showWalletModal() {
            const wallets = detectWallets();
            const container = document.getElementById('walletOptions');

            if (connectedAddress) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: var(--gray); border-radius: var(--radius); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Connected</div>
                        <div style="font-size: 0.9rem; word-break: break-all; color: var(--pink);">${connectedAddress}</div>
                    </div>
                    <div class="wallet-option disconnect" onclick="disconnectWallet()">
                        <span class="wallet-option-name">Disconnect</span>
                    </div>
                `;
            } else {
                container.innerHTML = wallets.length > 0 ? wallets.map(w => `
                    <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
                        <span class="wallet-option-icon">${w.icon}</span>
                        <span class="wallet-option-name">${w.name}</span>
                    </div>
                `).join('') : '<div style="padding:1rem;text-align:center;color:var(--text-muted);">No wallets detected. Install MetaMask or use WalletConnect.</div>';
            }

            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        function updateCreateSectionVisibility() {
            const createSection = document.getElementById('createSection');
            const isAdmin = connectedAddress && connectedAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase();
            if (createSection) {
                createSection.style.display = isAdmin ? 'block' : 'none';
            }
        }

        function updateMarketTabsVisibility() {
            // Check if current user is admin
            const isAdmin = connectedAddress && connectedAddress.toLowerCase() === ADMIN_ADDRESS.toLowerCase();

            // If admin, show all create tabs
            if (isAdmin) {
                document.getElementById('tabFeeSwitch').style.display = 'block';
                document.getElementById('tabUniBalance').style.display = 'block';
                document.getElementById('tabUniVotes').style.display = 'block';
                document.getElementById('tabTotalSupply').style.display = 'block';
                document.getElementById('tabUniPrice').style.display = 'block';
                return;
            }

            // For non-admin users, show tabs only if markets exist (though create section is hidden for them)
            const marketTypeCounts = {
                V4_FEE_SWITCH: 0,
                UNI_BALANCE: 0,
                UNI_VOTES: 0,
                TOTAL_SUPPLY: 0,
                UNI_PRICE_USD: 0
            };

            if (univ4Markets && univ4Markets.length > 0) {
                univ4Markets.forEach(market => {
                    const type = market.marketType;
                    if (marketTypeCounts.hasOwnProperty(type)) {
                        marketTypeCounts[type]++;
                    }
                });
            }

            // Update tab visibility
            document.getElementById('tabFeeSwitch').style.display = marketTypeCounts.V4_FEE_SWITCH > 0 ? 'block' : 'none';
            document.getElementById('tabUniBalance').style.display = marketTypeCounts.UNI_BALANCE > 0 ? 'block' : 'none';
            document.getElementById('tabUniVotes').style.display = marketTypeCounts.UNI_VOTES > 0 ? 'block' : 'none';
            document.getElementById('tabTotalSupply').style.display = marketTypeCounts.TOTAL_SUPPLY > 0 ? 'block' : 'none';
            document.getElementById('tabUniPrice').style.display = marketTypeCounts.UNI_PRICE_USD > 0 ? 'block' : 'none';
        }

        async function updateWalletBalances() {
            if (!signer || !connectedAddress) {
                document.getElementById('walletBalances').style.display = 'none';
                updateCreateSectionVisibility();
                return;
            }

            try {
                // Fetch ETH balance
                const ethBal = await provider.getBalance(connectedAddress);
                const ethFormatted = parseFloat(ethers.formatEther(ethBal)).toFixed(4);
                document.getElementById('ethBalance').textContent = ethFormatted;

                // Fetch UNI balance and approval
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, signer);
                uniBalance = await uniToken.balanceOf(connectedAddress);
                const uniFormatted = parseFloat(ethers.formatUnits(uniBalance, 18)).toFixed(2);
                document.getElementById('uniBalance').textContent = uniFormatted;

                // Check UNI approval to Resolver
                uniApprovalAmount = await uniToken.allowance(connectedAddress, RESOLVER_ADDRESS);

                document.getElementById('walletBalances').style.display = 'block';

                // Update create section visibility based on admin status
                updateCreateSectionVisibility();
            } catch (error) {
                console.error('Failed to fetch balances:', error);
            }
        }

        async function connectWallet() {
            showWalletModal();
        }

        async function connectWithWallet(walletKey) {
            if (isConnecting) return;
            isConnecting = true;

            const connectBtn = document.getElementById('connectBtn');
            const originalText = connectBtn.textContent;
            connectBtn.textContent = 'Connecting...';
            connectBtn.disabled = true;

            try {
                closeWalletModal();
                let walletProvider;

                if (walletKey === 'walletconnect') {
                    const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
                    const WCProvider = wcModule?.EthereumProvider;
                    if (!WCProvider?.init) throw new Error('WalletConnect not available');

                    if (walletConnectProvider) {
                        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
                        walletConnectProvider = null;
                    }

                    walletConnectProvider = await WCProvider.init({
                        projectId: '1e8390ef1c1d8a185e035912a1409749',
                        chains: [1],
                        showQrModal: true,
                        rpcMap: { 1: 'https://1rpc.io/eth' },
                        metadata: {
                            name: 'pnkPM',
                            description: 'Uniswap V4 Fee Switch Prediction Markets',
                            url: window.location.origin,
                            icons: []
                        }
                    });

                    await walletConnectProvider.enable();
                    walletProvider = walletConnectProvider;
                } else if (walletKey.startsWith('eip6963_')) {
                    const uuid = walletKey.replace('eip6963_', '');
                    walletProvider = eip6963Providers.get(uuid)?.provider;
                } else {
                    walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
                }

                if (!walletProvider) throw new Error('Wallet not found');

                if (walletKey !== 'walletconnect') {
                    await walletProvider.request({ method: 'eth_requestAccounts' });
                }

                provider = new ethers.BrowserProvider(walletProvider);

                // Check network is Ethereum mainnet
                let network = await provider.getNetwork();
                if (network.chainId !== 1n) {
                    try {
                        await walletProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x1' }]
                        });
                        // Re-create provider after network switch and verify
                        provider = new ethers.BrowserProvider(walletProvider);
                        network = await provider.getNetwork();
                    } catch (e) {
                        // Switch failed or was rejected
                    }
                    if (network.chainId !== 1n) {
                        throw new Error('Please switch to Ethereum mainnet');
                    }
                }

                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                connectedWalletProvider = walletProvider;

                document.getElementById('connectBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                document.getElementById('connectBtn').classList.add('connected');

                // Show wallet balances
                await updateWalletBalances();

                // Remove old listeners if any
                if (walletEventHandlers) {
                    try {
                        walletEventHandlers.provider.removeListener('accountsChanged', walletEventHandlers.onAccountsChanged);
                        walletEventHandlers.provider.removeListener('chainChanged', walletEventHandlers.onChainChanged);
                    } catch (e) {}
                }

                // Store and add new listeners
                walletEventHandlers = {
                    provider: walletProvider,
                    onAccountsChanged: () => window.location.reload(),
                    onChainChanged: () => window.location.reload()
                };
                walletProvider.on('accountsChanged', walletEventHandlers.onAccountsChanged);
                walletProvider.on('chainChanged', walletEventHandlers.onChainChanged);

                localStorage.setItem('unipm_wallet', walletKey);

                // Reload data with new provider
                await loadData();

            } catch (error) {
                console.error('Connection failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Connection Failed', error.message || 'Could not connect wallet', 'error');
                }
                connectBtn.textContent = originalText;
                connectBtn.classList.remove('connected');
            } finally {
                connectBtn.disabled = false;
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            // Remove event listeners
            if (walletEventHandlers) {
                try {
                    walletEventHandlers.provider.removeListener('accountsChanged', walletEventHandlers.onAccountsChanged);
                    walletEventHandlers.provider.removeListener('chainChanged', walletEventHandlers.onChainChanged);
                } catch (e) {}
                walletEventHandlers = null;
            }
            if (walletConnectProvider) {
                try { walletConnectProvider.disconnect(); } catch (e) {}
                walletConnectProvider = null;
            }
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletProvider = null;
            uniBalance = 0n;
            uniApprovalAmount = 0n;
            document.getElementById('connectBtn').textContent = 'Connect';
            document.getElementById('connectBtn').classList.remove('connected');
            document.getElementById('walletBalances').style.display = 'none';
            updateCreateSectionVisibility();
            closeWalletModal();
            localStorage.removeItem('unipm_wallet');
        }

        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== TRADING ========================
        async function openTrade(marketId, isYes) {
            if (!connectedAddress) {
                showWalletModal();
                return;
            }

            const market = univ4Markets.find(m => m.id.toString() === marketId.toString());
            if (!market) return;

            const isResolved = market.resolved;

            // Batch getNoId + getPoolState via multicall
            const rpc = await getReadProvider();
            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
            const pammInterface = new ethers.Interface(PAMM_ABI);

            const results = await multicall.aggregate3([
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getNoId', [marketId]) },
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [marketId, FEE_TIER]) }
            ]);

            const noId = pammInterface.decodeFunctionResult('getNoId', results[0].returnData)[0];
            const poolState = pammInterface.decodeFunctionResult('getPoolState', results[1].returnData);

            currentTrade = {
                marketId: BigInt(marketId),
                collateral: market.collateral,
                isYes,
                yesId: BigInt(marketId),
                noId: BigInt(noId),
                rYes: poolState.rYes,
                rNo: poolState.rNo,
                resolved: isResolved,
                outcome: market.outcome
            };

            document.getElementById('tradeTitle').textContent = `${isYes ? 'YES' : 'NO'} Shares`;
            const opSymbol = ['<', '>', '<=', '>=', '==', '!='][market.op] || '?';
            document.getElementById('tradeMarketDesc').textContent = `Punks ${opSymbol} ${market.threshold} by ${formatDate(market.close)}`;

            // For resolved markets, allow LP withdrawal and swaps (for position exit)
            if (isResolved) {
                setTradeMode('lp');
                setLpMode('remove');
                // Disable trade and limit modes, but keep swap enabled for position exit
                ['tradeModeBtn', 'limitModeBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.style.opacity = '0.4';
                    btn.style.pointerEvents = 'none';
                });
                // Keep swap enabled
                const swapBtn = document.getElementById('swapModeBtn');
                swapBtn.style.opacity = '1';
                swapBtn.style.pointerEvents = 'auto';
                showToast('Market Resolved', `${market.outcome ? 'YES' : 'NO'} won. Swap to winning side, withdraw LP, or claim.`, 'info');
            } else {
                // Reset mode to trade
                setTradeMode('trade');
                setTradeDirection('buy');
                // Ensure mode buttons are enabled
                ['tradeModeBtn', 'swapModeBtn', 'limitModeBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                });
            }

            // Load user position, pool positions, and orderbook in parallel
            await Promise.all([
                loadUserPosition(),
                loadUserPoolPositions(),
                loadOrderbook()
            ]);

            // Update balances for all modes
            await loadBalance();

            document.getElementById('tradeModal').classList.add('active');

            // Trigger preview with default amount
            handleTradeInput();
        }

        function closeTradeModal() {
            document.getElementById('tradeModal').classList.remove('active');
        }

        // Open trade modal with limit tab pre-filled (for inline orderbook clicks)
        async function openTradeWithPrice(marketId, isYes, price) {
            await openTrade(marketId, isYes);
            // Switch to limit mode and pre-fill price
            setTradeMode('limit');
            document.getElementById('limitPrice').value = price.toFixed(2);
            updateLimitPreview();
        }

        // View market depth without opening trade modal
        async function viewMarketDepth(marketId) {
            const market = univ4Markets.find(m => m.id.toString() === marketId.toString());
            if (!market) return;

            // Load pool state for AMM prices
            const rpc = await getReadProvider();
            const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
            const pammInterface = new ethers.Interface(PAMM_ABI);

            const results = await multicall.aggregate3([
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getNoId', [marketId]) },
                { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [marketId, FEE_TIER]) }
            ]);

            const noId = pammInterface.decodeFunctionResult('getNoId', results[0].returnData)[0];
            const poolState = pammInterface.decodeFunctionResult('getPoolState', results[1].returnData);

            // Set currentTrade so orderbook loads correctly
            currentTrade = {
                marketId: BigInt(marketId),
                collateral: market.collateral,
                isYes: true,
                yesId: BigInt(marketId),
                noId: BigInt(noId),
                rYes: poolState.rYes,
                rNo: poolState.rNo
            };

            // Load orderbook and show modal
            await loadOrderbook();
            openOrderbookModal();
        }

        // ======================== MODE SWITCHING ========================
        function setTradeMode(mode) {
            currentTradeMode = mode;

            // Update mode buttons
            ['trade', 'swap', 'limit', 'lp'].forEach(m => {
                const btn = document.getElementById(`${m}ModeBtn`);
                if (m === mode) {
                    btn.style.background = m === 'trade' ? 'var(--green)' : m === 'swap' ? 'var(--pink)' : m === 'limit' ? '#8b5cf6' : 'var(--blue)';
                    btn.style.color = m === 'trade' ? 'var(--bg)' : 'white';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                }
            });

            // Show/hide sections
            document.getElementById('tradeSection').style.display = mode === 'trade' ? 'block' : 'none';
            document.getElementById('swapSection').style.display = mode === 'swap' ? 'block' : 'none';
            document.getElementById('lpSection').style.display = mode === 'lp' ? 'block' : 'none';
            document.getElementById('limitSection').style.display = mode === 'limit' ? 'block' : 'none';

            // Initialize limit mode defaults
            if (mode === 'limit') {
                // Update side indicator
                const sideIndicator = document.getElementById('limitSideIndicator');
                const isYes = currentTrade.isYes;
                sideIndicator.textContent = isYes ? 'YES' : 'NO';
                sideIndicator.style.background = isYes ? 'var(--green-dim)' : 'var(--red-dim)';
                sideIndicator.style.color = isYes ? 'var(--green)' : 'var(--red)';

                // Initialize with buy side (also sets button text with YES/NO)
                setLimitSide(limitIsBuy ? 'buy' : 'sell');

                // Refresh the compact orderbook display
                updateLimitBookPreview();
            }

            loadBalance();
        }

        function setTradeDirection(dir) {
            currentTradeDirection = dir;
            tradeMaxRaw = null; // Clear max when switching direction
            const buyBtn = document.getElementById('buyBtn');
            const sellBtn = document.getElementById('sellBtn');
            const maxBtn = document.getElementById('tradeMaxBtn');

            if (dir === 'buy') {
                buyBtn.style.background = 'var(--green-dim)';
                buyBtn.style.color = 'var(--green)';
                buyBtn.style.borderColor = 'var(--green)';
                sellBtn.style.background = 'transparent';
                sellBtn.style.color = 'var(--text-muted)';
                sellBtn.style.borderColor = 'var(--border)';
                document.getElementById('tradeAmountLabel').textContent = 'Amount (ETH)';
                document.getElementById('previewSharesLabel').textContent = 'Est. Shares';
                document.getElementById('previewPriceLabel').textContent = 'Avg. Price';
                document.getElementById('previewPayoutLabel').textContent = 'If you win';
                maxBtn.style.display = 'none';
            } else {
                sellBtn.style.background = 'var(--red-dim)';
                sellBtn.style.color = 'var(--red)';
                sellBtn.style.borderColor = 'var(--red)';
                buyBtn.style.background = 'transparent';
                buyBtn.style.color = 'var(--text-muted)';
                buyBtn.style.borderColor = 'var(--border)';
                document.getElementById('tradeAmountLabel').textContent = 'Shares to Sell';
                document.getElementById('previewSharesLabel').textContent = 'ETH Received';
                document.getElementById('previewPriceLabel').textContent = 'Price/Share';
                document.getElementById('previewPayoutLabel').textContent = 'Min Received';
                maxBtn.style.display = 'inline-block';
            }

            updateTradeButton();
            loadBalance();
            handleTradeInput();
        }

        function setSwapDirection(yesToNo) {
            currentSwapDirection = yesToNo;
            const yesBtn = document.getElementById('yesToNoBtn');
            const noBtn = document.getElementById('noToYesBtn');

            if (yesToNo) {
                yesBtn.style.background = 'var(--green-dim)';
                yesBtn.style.color = 'var(--green)';
                yesBtn.style.borderColor = 'var(--green)';
                noBtn.style.background = 'transparent';
                noBtn.style.color = 'var(--text-muted)';
                noBtn.style.borderColor = 'var(--border)';
                document.getElementById('swapInputLabel').textContent = 'YES Amount';
                document.getElementById('swapSubmit').textContent = 'Swap YES ‚Üí NO';
            } else {
                noBtn.style.background = 'var(--red-dim)';
                noBtn.style.color = 'var(--red)';
                noBtn.style.borderColor = 'var(--red)';
                yesBtn.style.background = 'transparent';
                yesBtn.style.color = 'var(--text-muted)';
                yesBtn.style.borderColor = 'var(--border)';
                document.getElementById('swapInputLabel').textContent = 'NO Amount';
                document.getElementById('swapSubmit').textContent = 'Swap NO ‚Üí YES';
            }

            loadBalance();
            updateSwapPreview();
        }

        function setSwapSlippage(pct) {
            swapSlippage = pct;
            [0.5, 1, 2].forEach(p => {
                const btn = document.getElementById(`swapSlip${p === 0.5 ? '05' : p}`);
                if (p === pct) {
                    btn.style.background = 'var(--pink-dim)';
                    btn.style.color = 'var(--pink)';
                    btn.style.borderColor = 'var(--pink)';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = 'var(--text-muted)';
                    btn.style.borderColor = 'var(--border)';
                }
            });
            updateSwapPreview();
        }

        function setTradeSlippage(pct) {
            slippageTolerance = pct;
            // Update both trade and LP buttons since they share slippageTolerance
            [5, 10, 20].forEach(p => {
                ['tradeSlip', 'lpSlip'].forEach(prefix => {
                    const btn = document.getElementById(`${prefix}${p}`);
                    if (!btn) return;
                    if (p === pct) {
                        btn.style.background = 'var(--pink-dim)';
                        btn.style.color = 'var(--pink)';
                        btn.style.borderColor = 'var(--pink)';
                    } else {
                        btn.style.background = 'transparent';
                        btn.style.color = 'var(--text-muted)';
                        btn.style.borderColor = 'var(--border)';
                    }
                });
            });
            // Clear custom inputs if a preset was clicked, or highlight if custom
            const isPreset = [5, 10, 20].includes(pct);
            ['tradeSlipCustom', 'lpSlipCustom'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    if (isPreset) {
                        input.value = '';
                        input.style.borderColor = 'var(--border)';
                    } else {
                        input.value = pct;
                        input.style.borderColor = 'var(--pink)';
                    }
                }
            });
        }

        function setLpSlippage(pct) {
            setTradeSlippage(pct); // LP and trade share slippageTolerance
        }

        let swapMaxRaw = null; // Store raw BigInt for exact max swaps
        let limitMaxRaw = null; // Store raw BigInt for exact max limit orders
        let tradeMaxRaw = null; // Store raw BigInt for exact max sells
        let lpMaxRaw = null; // Store raw BigInt for exact max LP operations

        function setTradeMax() {
            // Only works for sell mode - fills with user's share balance
            if (currentTradeDirection !== 'sell') return;

            const balance = currentTrade.isYes
                ? currentUserPosition.yesBalance
                : currentUserPosition.noBalance;

            if (balance && balance > 0n) {
                tradeMaxRaw = balance;
                document.getElementById('tradeAmount').value = ethers.formatEther(balance);
                updateTradePreview(); // Don't call handleTradeInput which clears tradeMaxRaw
            }
        }

        function setSwapMax() {
            // Get the balance of the source token (YES or NO based on swap direction)
            const sourceBalance = currentSwapDirection
                ? currentUserPosition.yesBalance
                : currentUserPosition.noBalance;

            if (sourceBalance && sourceBalance > 0n) {
                swapMaxRaw = sourceBalance; // Store exact value for execution
                const maxAmount = ethers.formatEther(sourceBalance);
                document.getElementById('swapAmount').value = maxAmount;
                updateSwapPreview();
            }
        }

        async function setLimitMax() {
            try {
                if (limitIsBuy) {
                    // For buys, max is collateral balance (ETH or UNI)
                    if (!connectedAddress) return;
                    const rpc = await getReadProvider();
                    const isEthCollateral = !currentTrade.collateral || currentTrade.collateral === ethers.ZeroAddress;

                    let bal;
                    if (isEthCollateral) {
                        bal = await rpc.getBalance(connectedAddress);
                        if (bal > 0n) {
                            // Leave a little for gas (0.001 ETH)
                            const maxBal = bal > ethers.parseEther('0.001') ? bal - ethers.parseEther('0.001') : bal;
                            limitMaxRaw = maxBal;
                            document.getElementById('limitAmount').value = ethers.formatEther(maxBal);
                            updateLimitPreview();
                        }
                    } else {
                        const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                        bal = await uniToken.balanceOf(connectedAddress);
                        if (bal > 0n) {
                            limitMaxRaw = bal;
                            document.getElementById('limitAmount').value = ethers.formatUnits(bal, 18);
                            updateLimitPreview();
                        }
                    }
                } else {
                    // For sells, max is share balance (YES or NO based on currentTrade.isYes)
                    const balance = currentTrade.isYes
                        ? currentUserPosition.yesBalance
                        : currentUserPosition.noBalance;
                    if (balance && balance > 0n) {
                        limitMaxRaw = balance;
                        document.getElementById('limitAmount').value = ethers.formatEther(balance);
                        updateLimitPreview();
                    }
                }
            } catch (e) {
                // Silently fail - max button just won't work
            }
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            lpMaxRaw = null; // Clear max when switching mode
            const addBtn = document.getElementById('lpAddBtn');
            const removeBtn = document.getElementById('lpRemoveBtn');

            if (mode === 'add') {
                addBtn.style.background = 'var(--blue)';
                addBtn.style.color = 'white';
                removeBtn.style.background = 'transparent';
                removeBtn.style.color = 'var(--text-muted)';
                const symbol = getCollateralSymbol(currentTrade.collateral);
                document.getElementById('lpAmountLabel').textContent = `${symbol} to Add`;
                document.getElementById('lpPreviewLabel').textContent = 'Est. LP Tokens';
                document.getElementById('lpSubmit').textContent = 'Deposit Liquidity';
            } else {
                removeBtn.style.background = 'var(--blue)';
                removeBtn.style.color = 'white';
                addBtn.style.background = 'transparent';
                addBtn.style.color = 'var(--text-muted)';
                const symbol = getCollateralSymbol(currentTrade.collateral);
                document.getElementById('lpAmountLabel').textContent = 'LP to Remove';
                document.getElementById('lpPreviewLabel').textContent = `Est. ${symbol} Out`;
                document.getElementById('lpSubmit').textContent = 'Withdraw Liquidity';
            }

            loadBalance();
            updateLpPreview();
        }

        async function setLpMax() {
            try {
                if (currentLpMode === 'add') {
                    // For add, max is collateral balance (ETH or UNI)
                    if (!connectedAddress) return;
                    const rpc = await getReadProvider();
                    const isEthCollateral = !currentTrade.collateral || currentTrade.collateral === ethers.ZeroAddress;

                    let bal;
                    if (isEthCollateral) {
                        bal = await rpc.getBalance(connectedAddress);
                        if (bal > 0n) {
                            const maxBal = bal > ethers.parseEther('0.001') ? bal - ethers.parseEther('0.001') : bal;
                            lpMaxRaw = maxBal;
                            document.getElementById('lpAmount').value = ethers.formatEther(maxBal);
                            updateLpPreview();
                        }
                    } else {
                        const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                        bal = await uniToken.balanceOf(connectedAddress);
                        if (bal > 0n) {
                            lpMaxRaw = bal;
                            document.getElementById('lpAmount').value = ethers.formatUnits(bal, 18);
                            updateLpPreview();
                        }
                    }
                } else {
                    // For remove, max is LP balance
                    const lpBal = currentUserPosition.lpBalance;
                    if (lpBal && lpBal > 0n) {
                        lpMaxRaw = lpBal;
                        document.getElementById('lpAmount').value = ethers.formatEther(lpBal);
                        updateLpPreview();
                    }
                }
            } catch (e) {
                // Silently fail - max button just won't work
            }
        }

        function setLimitSide(side) {
            limitIsBuy = side === 'buy';
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const sideName = currentTrade.isYes ? 'YES' : 'NO';

            if (limitIsBuy) {
                buyBtn.style.background = '#8b5cf6';
                buyBtn.style.color = 'white';
                sellBtn.style.background = 'transparent';
                sellBtn.style.color = 'var(--text-muted)';
                document.getElementById('limitExplainerText').textContent = `Bid below pool odds for better price. ETH locked until filled.`;
                document.getElementById('limitAmountLabel').textContent = 'Spend (ETH)';
                document.getElementById('limitResultLabel').textContent = `${sideName} shares you get`;
                document.getElementById('limitSavingsLabel').textContent = 'vs Pool';
                document.getElementById('limitSubmit').textContent = `Buy ${sideName} @ Limit`;
            } else {
                sellBtn.style.background = '#8b5cf6';
                sellBtn.style.color = 'white';
                buyBtn.style.background = 'transparent';
                buyBtn.style.color = 'var(--text-muted)';
                document.getElementById('limitExplainerText').textContent = `Ask above pool odds for better price. Shares locked until filled.`;
                document.getElementById('limitAmountLabel').textContent = `Sell (${sideName} shares)`;
                document.getElementById('limitResultLabel').textContent = 'ETH you receive';
                document.getElementById('limitSavingsLabel').textContent = 'vs Pool';
                document.getElementById('limitSubmit').textContent = `Sell ${sideName} @ Limit`;
            }

            // Set default price based on pool price
            setDefaultLimitPrice();
            loadBalance();
            updateLimitPreview();
        }

        function setDefaultLimitPrice() {
            if (currentTrade.rYes === 0n || currentTrade.rNo === 0n) return;

            const yesPrice = Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo);
            const poolPrice = currentTrade.isYes ? yesPrice : (1 - yesPrice);

            // For buy orders: suggest 2% below pool (better for buyer)
            // For sell orders: suggest 2% above pool (better for seller)
            const adjustment = limitIsBuy ? -0.02 : 0.02;
            const suggestedPrice = Math.max(0.01, Math.min(0.99, poolPrice + adjustment));

            document.getElementById('limitPrice').value = suggestedPrice.toFixed(2);
        }

        function adjustLimitPrice(delta) {
            const input = document.getElementById('limitPrice');
            const current = parseFloat(input.value) || 0.5;
            const newVal = Math.max(0.01, Math.min(0.99, current + delta));
            input.value = newVal.toFixed(2);
            updateLimitPreview();
        }

        function updateTradeButton() {
            const btn = document.getElementById('tradeSubmit');
            const side = currentTrade.isYes ? 'YES' : 'NO';
            if (currentTradeDirection === 'buy') {
                btn.textContent = `Buy ${side}`;
                btn.className = `trade-submit ${currentTrade.isYes ? 'buy-yes' : 'buy-no'}`;
            } else {
                btn.textContent = `Sell ${side}`;
                btn.className = 'trade-submit';
                btn.style.background = 'var(--red)';
            }
        }

        // ======================== USER POSITION ========================
        async function refreshPoolState() {
            if (!currentTrade.marketId) return;
            try {
                const rpc = await getReadProvider();
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const results = await multicall.aggregate3([
                    { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('getPoolState', [currentTrade.marketId, FEE_TIER]) }
                ]);
                const poolState = pammInterface.decodeFunctionResult('getPoolState', results[0].returnData);
                currentTrade.rYes = poolState.rYes;
                currentTrade.rNo = poolState.rNo;
            } catch (e) {
                console.error('Failed to refresh pool state:', e);
            }
        }

        // Position cache to reduce RPC calls
        const positionCache = new Map(); // key -> { data, timestamp }
        const POSITION_CACHE_TTL = 30000; // 30 seconds

        async function loadUserPosition(forceRefresh = false) {
            if (!connectedAddress || !currentTrade.marketId) return;

            const cacheKey = `${connectedAddress}-${currentTrade.marketId}`;
            const cached = positionCache.get(cacheKey);

            // Use cache if valid and not forcing refresh
            if (!forceRefresh && cached && Date.now() - cached.timestamp < POSITION_CACHE_TTL) {
                currentUserPosition = cached.data;
                updatePositionUI(cached.data);
                return;
            }

            try {
                const rpc = await getReadProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);
                const zammInterface = new ethers.Interface(ZAMM_ABI);

                const yesId = currentTrade.yesId;
                const noId = currentTrade.noId;

                // Compute pool ID
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;
                const poolId = computePoolId(id0, id1, PAMM_ADDRESS, PAMM_ADDRESS, FEE_TIER);

                // Batch all 4 calls: YES bal, NO bal, LP bal, pool data
                const results = await multicall.aggregate3([
                    { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, yesId]) },
                    { target: PAMM_ADDRESS, allowFailure: false, callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId]) },
                    { target: ZAMM_ADDRESS, allowFailure: false, callData: zammInterface.encodeFunctionData('balanceOf', [connectedAddress, poolId]) },
                    { target: ZAMM_ADDRESS, allowFailure: false, callData: zammInterface.encodeFunctionData('pools', [poolId]) }
                ]);

                const yesBal = pammInterface.decodeFunctionResult('balanceOf', results[0].returnData)[0];
                const noBal = pammInterface.decodeFunctionResult('balanceOf', results[1].returnData)[0];
                const lpBal = zammInterface.decodeFunctionResult('balanceOf', results[2].returnData)[0];
                const poolData = zammInterface.decodeFunctionResult('pools', results[3].returnData);
                // poolData: [reserve0, reserve1, blockTimestampLast, price0CumulativeLast, price1CumulativeLast, kLast, supply]
                const lpTotalSupply = poolData[6];

                currentUserPosition = {
                    yesBalance: yesBal,
                    noBalance: noBal,
                    lpBalance: lpBal,
                    lpTotalSupply: lpTotalSupply
                };

                // Cache the result
                positionCache.set(cacheKey, { data: currentUserPosition, timestamp: Date.now() });

                updatePositionUI(currentUserPosition);

            } catch (e) {
                console.error('Failed to load user position:', e);
            }
        }

        function updatePositionUI(pos) {
            document.getElementById('tradeModalYes').textContent = formatEth(pos.yesBalance);
            document.getElementById('tradeModalNo').textContent = formatEth(pos.noBalance);
            document.getElementById('tradeModalLP').textContent = formatEth(pos.lpBalance);
            document.getElementById('lpPosition').textContent = formatEth(pos.lpBalance) + ' LP';
        }

        // Invalidate position cache after transactions
        function invalidatePositionCache() {
            positionCache.clear();
        }

        async function loadUserPoolPositions() {
            if (!connectedAddress || !currentTrade.marketId) return;

            try {
                const rpc = await getReadProvider();
                const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, rpc);

                // Fetch user positions for both YES and NO
                const [yesPos, noPos] = await Promise.all([
                    quoter.getUserActivePositions(currentTrade.marketId, true, connectedAddress),
                    quoter.getUserActivePositions(currentTrade.marketId, false, connectedAddress)
                ]);

                // Parse YES positions
                const yesAsks = [];
                for (let i = 0; i < yesPos.askPrices.length; i++) {
                    if (yesPos.askShares[i] > 0n) {
                        yesAsks.push({
                            priceBps: Number(yesPos.askPrices[i]),
                            shares: yesPos.askShares[i],
                            pendingCollateral: yesPos.askPendingColl[i]
                        });
                    }
                }
                const yesBids = [];
                for (let i = 0; i < yesPos.bidPrices.length; i++) {
                    if (yesPos.bidCollateral[i] > 0n) {
                        yesBids.push({
                            priceBps: Number(yesPos.bidPrices[i]),
                            collateral: yesPos.bidCollateral[i],
                            pendingShares: yesPos.bidPendingShares[i]
                        });
                    }
                }

                // Parse NO positions
                const noAsks = [];
                for (let i = 0; i < noPos.askPrices.length; i++) {
                    if (noPos.askShares[i] > 0n) {
                        noAsks.push({
                            priceBps: Number(noPos.askPrices[i]),
                            shares: noPos.askShares[i],
                            pendingCollateral: noPos.askPendingColl[i]
                        });
                    }
                }
                const noBids = [];
                for (let i = 0; i < noPos.bidPrices.length; i++) {
                    if (noPos.bidCollateral[i] > 0n) {
                        noBids.push({
                            priceBps: Number(noPos.bidPrices[i]),
                            collateral: noPos.bidCollateral[i],
                            pendingShares: noPos.bidPendingShares[i]
                        });
                    }
                }

                userPoolPositions = {
                    yes: { asks: yesAsks, bids: yesBids },
                    no: { asks: noAsks, bids: noBids }
                };
            } catch (e) {
                console.error('Failed to load user pool positions:', e);
                userPoolPositions = { yes: { asks: [], bids: [] }, no: { asks: [], bids: [] } };
            }
        }

        async function loadBalance() {
            if (!connectedAddress) return;

            try {
                const rpc = await getReadProvider();
                const isEthCollateral = !currentTrade.collateral || currentTrade.collateral === ethers.ZeroAddress;
                const symbol = getCollateralSymbol(currentTrade.collateral);

                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        let bal;
                        if (isEthCollateral) {
                            bal = await rpc.getBalance(connectedAddress);
                        } else {
                            const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                            bal = await uniToken.balanceOf(connectedAddress);
                        }
                        document.getElementById('lpBalance').textContent = formatEth(bal) + ' ' + symbol;
                    } else {
                        document.getElementById('lpBalance').textContent = formatEth(currentUserPosition.lpBalance) + ' LP';
                    }
                } else if (currentTradeMode === 'swap') {
                    const bal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('swapBalance').textContent = formatEth(bal);
                } else if (currentTradeMode === 'trade') {
                    if (currentTradeDirection === 'buy') {
                        let bal;
                        if (isEthCollateral) {
                            bal = await rpc.getBalance(connectedAddress);
                        } else {
                            const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                            bal = await uniToken.balanceOf(connectedAddress);
                        }
                        document.getElementById('tradeBalance').textContent = formatEth(bal) + ' ' + symbol;
                    } else {
                        const bal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('tradeBalance').textContent = formatEth(bal);
                    }
                } else if (currentTradeMode === 'limit') {
                    if (limitIsBuy) {
                        let bal;
                        if (isEthCollateral) {
                            bal = await rpc.getBalance(connectedAddress);
                        } else {
                            const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                            bal = await uniToken.balanceOf(connectedAddress);
                        }
                        document.getElementById('limitBalance').textContent = formatEth(bal) + ' ' + symbol;
                    } else {
                        const bal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('limitBalance').textContent = formatEth(bal);
                    }
                }
            } catch (e) {
                console.error('Failed to load balance:', e);
            }
        }

        // ======================== ORDERBOOK ========================
        // Uses PMHookQuoter.getActiveLevels for orderbook data
        async function loadOrderbook() {
            if (!currentTrade.marketId) return;

            try {
                const rpc = await getReadProvider();
                const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, rpc);

                // Load orderbooks for both YES and NO sides in parallel via quoter
                const [yesLevels, noLevels] = await Promise.all([
                    quoter.getActiveLevels(currentTrade.marketId, true, 10),
                    quoter.getActiveLevels(currentTrade.marketId, false, 10)
                ]);

                // Parse levels from quoter format: (askPrices[], askDepths[], bidPrices[], bidDepths[])
                const parseLevels = (levels) => {
                    const [askPrices, askDepths, bidPrices, bidDepths] = levels;

                    // Convert to orderbook format
                    const asks = [];
                    for (let i = 0; i < askPrices.length; i++) {
                        if (askDepths[i] > 0n) {
                            const priceBps = Number(askPrices[i]);
                            asks.push({
                                price: priceBps / 10000, // Convert BPS to decimal
                                priceBps: priceBps,
                                depth: askDepths[i],
                                shares: askDepths[i], // Depth is in shares for asks
                                collateral: askDepths[i] * BigInt(priceBps) / 10000n
                            });
                        }
                    }

                    const bids = [];
                    for (let i = 0; i < bidPrices.length; i++) {
                        if (bidDepths[i] > 0n) {
                            const priceBps = Number(bidPrices[i]);
                            bids.push({
                                price: priceBps / 10000, // Convert BPS to decimal
                                priceBps: priceBps,
                                depth: bidDepths[i],
                                collateral: bidDepths[i], // Depth is in collateral for bids
                                shares: bidDepths[i] * 10000n / BigInt(priceBps)
                            });
                        }
                    }

                    // Sort asks ascending by price, bids descending
                    asks.sort((a, b) => a.price - b.price);
                    bids.sort((a, b) => b.price - a.price);

                    return { asks, bids };
                };

                const yesParsed = parseLevels(yesLevels);
                const noParsed = parseLevels(noLevels);

                // Calculate AMM prices
                const ammYesPrice = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                    ? Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo)
                    : null;
                const ammNoPrice = ammYesPrice !== null ? 1 - ammYesPrice : null;

                currentOrderbook = {
                    yes: {
                        bids: yesParsed.bids,
                        asks: yesParsed.asks,
                        ammPrice: ammYesPrice
                    },
                    no: {
                        bids: noParsed.bids,
                        asks: noParsed.asks,
                        ammPrice: ammNoPrice
                    }
                };

                // Batch all DOM updates in single animation frame
                requestAnimationFrame(() => {
                    updateOrderbookUI();
                    updateLimitBookPreview();
                    updateInlineOrderbook();
                    updateOrderbookTvl();
                });

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                currentOrderbook = {
                    yes: { bids: [], asks: [], ammPrice: null },
                    no: { bids: [], asks: [], ammPrice: null }
                };
            }
        }

        function updateLimitBookPreview() {
            const container = document.getElementById('limitBookPreview');
            if (!container) return;

            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            const { bids, asks, ammPrice } = book;
            const side = currentTrade.isYes ? 'YES' : 'NO';

            if (bids.length === 0 && asks.length === 0) {
                container.innerHTML = `<div style="color:var(--text-dim);text-align:center;padding:0.5rem;">No ${side} orders yet</div>`;
                return;
            }

            // Show top 3 bids and asks in a compact format
            const topAsks = asks.slice(0, 3).reverse();
            const topBids = bids.slice(0, 3);

            let html = '<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:2px 8px;font-family:var(--font-mono);">';

            // Header
            html += `<div style="color:var(--text-dim);font-size:10px;">Size</div>`;
            html += `<div style="color:var(--text-dim);font-size:10px;text-align:center;">Price</div>`;
            html += `<div style="color:var(--text-dim);font-size:10px;text-align:right;">Size</div>`;

            // Asks (sell orders) - show in red
            for (const ask of topAsks) {
                const size = (Number(ask.shares) / 1e18).toFixed(2) + ' sh';
                const price = (ask.price * 100).toFixed(1) + '%';
                html += `<div></div>`;
                html += `<div style="color:var(--red);text-align:center;">${price}</div>`;
                html += `<div style="color:var(--red);text-align:right;">${size}</div>`;
            }

            // AMM price line
            if (ammPrice) {
                html += `<div style="border-top:1px dashed var(--border);grid-column:span 3;margin:2px 0;"></div>`;
                html += `<div style="font-size:10px;color:var(--text-dim);">AMM</div>`;
                html += `<div style="color:var(--text);text-align:center;font-weight:600;">${(ammPrice * 100).toFixed(1)}%</div>`;
                html += `<div style="font-size:10px;color:var(--text-dim);text-align:right;">AMM</div>`;
                html += `<div style="border-bottom:1px dashed var(--border);grid-column:span 3;margin:2px 0;"></div>`;
            }

            // Bids (buy orders) - show in green
            for (const bid of topBids) {
                const size = (Number(bid.shares) / 1e18).toFixed(2) + ' sh';
                const price = (bid.price * 100).toFixed(1) + '%';
                html += `<div style="color:var(--green);">${size}</div>`;
                html += `<div style="color:var(--green);text-align:center;">${price}</div>`;
                html += `<div></div>`;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function updateInlineOrderbook() {
            if (!currentTrade.marketId) return;

            const ladder = document.getElementById(`inlineLadder-${currentTrade.marketId}`);
            const yesAmmEl = document.getElementById(`inlineYesAmm-${currentTrade.marketId}`);
            const noAmmEl = document.getElementById(`inlineNoAmm-${currentTrade.marketId}`);
            if (!ladder) return;

            const yesBook = currentOrderbook.yes;
            const noBook = currentOrderbook.no;
            if (!yesBook || !noBook) return;
            const yesAmm = yesBook.ammPrice || 0.5;
            const noAmm = noBook.ammPrice || 0.5;

            // Update AMM reference prices
            if (yesAmmEl) yesAmmEl.textContent = yesBook.ammPrice ? `AMM: ${(yesBook.ammPrice * 100).toFixed(1)}%` : '--';
            if (noAmmEl) noAmmEl.textContent = noBook.ammPrice ? `AMM: ${(noBook.ammPrice * 100).toFixed(1)}%` : '--';

            // Collect resting orders only:
            // - Bids below AMM (buyers want cheaper)
            // - Asks above AMM (sellers want more)
            const levels = new Map();

            const addOrders = (orders, side, isYes, ammPrice) => {
                orders.forEach(order => {
                    const price = Math.round(order.price * 1000) / 1000;
                    // Only show resting orders (bids below AMM, asks above AMM)
                    const isResting = side === 'bids' ? price < ammPrice : price > ammPrice;
                    if (!isResting) return;

                    const eth = Number(order.shares) / 1e18 * order.price;
                    if (!levels.has(price)) levels.set(price, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0 });
                    const key = isYes ? (side === 'bids' ? 'yesBids' : 'yesAsks') : (side === 'bids' ? 'noBids' : 'noAsks');
                    levels.get(price)[key] += eth; // Sum depth at each level
                });
            };

            addOrders(yesBook.bids, 'bids', true, yesAmm);
            addOrders(yesBook.asks, 'asks', true, yesAmm);
            addOrders(noBook.bids, 'bids', false, noAmm);
            addOrders(noBook.asks, 'asks', false, noAmm);

            // Add AMM price rows
            const yesAmmRounded = Math.round(yesAmm * 1000) / 1000;
            const noAmmRounded = Math.round(noAmm * 1000) / 1000;
            if (!levels.has(yesAmmRounded)) levels.set(yesAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, isYesAmm: true });
            else levels.get(yesAmmRounded).isYesAmm = true;
            if (!levels.has(noAmmRounded)) levels.set(noAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, isNoAmm: true });
            else levels.get(noAmmRounded).isNoAmm = true;

            const sortedLevels = [...levels.entries()].sort((a, b) => b[0] - a[0]);

            if (sortedLevels.length === 0) {
                ladder.innerHTML = `<div style="text-align:center;color:var(--text-dim);padding:1.5rem;font-size:11px;">No limit orders yet. Trade via AMM or place limit orders.</div>`;
                return;
            }

            let maxDepth = 0.001;
            sortedLevels.forEach(([, data]) => {
                maxDepth = Math.max(maxDepth, data.yesBids, data.yesAsks, data.noBids, data.noAsks);
            });

            ladder.innerHTML = sortedLevels.map(([price, data]) => {
                const pct = (price * 100).toFixed(1);
                // Asks above AMM (red), Bids below AMM (green)
                const yesDepth = data.yesAsks > 0 ? data.yesAsks : data.yesBids;
                const noDepth = data.noAsks > 0 ? data.noAsks : data.noBids;
                const yesBarWidth = (yesDepth / maxDepth * 100).toFixed(1);
                const noBarWidth = (noDepth / maxDepth * 100).toFixed(1);
                const yesIsAsk = data.yesAsks > 0;
                const noIsAsk = data.noAsks > 0;

                const isYesAmm = data.isYesAmm;
                const isNoAmm = data.isNoAmm;
                const isAmmRow = isYesAmm || isNoAmm;

                const yesDepthStr = yesDepth > 0 ? (yesDepth >= 1 ? yesDepth.toFixed(2) : yesDepth.toFixed(3)) + 'Œû' : '';
                const noDepthStr = noDepth > 0 ? (noDepth >= 1 ? noDepth.toFixed(2) : noDepth.toFixed(3)) + 'Œû' : '';

                return `
                    <div class="inline-ob-row" style="display:grid;grid-template-columns:1fr 50px 1fr;gap:0;align-items:center;height:24px;border-bottom:1px solid var(--border);${isAmmRow ? 'background:var(--surface-2);' : ''}">
                        <div class="inline-ob-cell inline-ob-yes" style="position:relative;height:100%;display:flex;align-items:center;justify-content:flex-end;padding-right:6px;overflow:hidden;cursor:pointer;"
                             onclick="openTradeWithPrice('${currentTrade.marketId}', true, ${price})">
                            ${yesDepth > 0 ? `<div style="position:absolute;right:0;top:0;bottom:0;width:${yesBarWidth}%;background:${yesIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            ${isYesAmm ? '<span style="font-size:8px;color:var(--blue);margin-right:4px;z-index:1;font-weight:600;">AMM</span>' : ''}
                            <span style="font-size:10px;color:${yesIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:500;">${yesDepthStr}</span>
                        </div>
                        <div style="text-align:center;font-size:10px;font-weight:600;color:var(--text);height:100%;display:flex;align-items:center;justify-content:center;border-left:1px solid var(--border);border-right:1px solid var(--border);">${pct}%</div>
                        <div class="inline-ob-cell inline-ob-no" style="position:relative;height:100%;display:flex;align-items:center;padding-left:6px;overflow:hidden;cursor:pointer;"
                             onclick="openTradeWithPrice('${currentTrade.marketId}', false, ${price})">
                            ${noDepth > 0 ? `<div style="position:absolute;left:0;top:0;bottom:0;width:${noBarWidth}%;background:${noIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            <span style="font-size:10px;color:${noIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:500;">${noDepthStr}</span>
                            ${isNoAmm ? '<span style="font-size:8px;color:var(--blue);margin-left:4px;z-index:1;font-weight:600;">AMM</span>' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateOrderbookTvl() {
            const el = document.getElementById('orderbookTvl');
            if (!el) return;
            if (!currentOrderbook.yes || !currentOrderbook.no) {
                el.textContent = '--';
                return;
            }

            // Calculate TVL from all orders
            // Bids: collateral (ETH) locked
            // Asks: shares locked, valued at ask price
            let totalEth = 0;

            // Sum bid collateral (ETH locked by buyers)
            [...currentOrderbook.yes.bids, ...currentOrderbook.no.bids].forEach(o => {
                totalEth += Number(o.collateral) / 1e18;
            });

            // Sum ask value (shares * price = ETH equivalent)
            [...currentOrderbook.yes.asks, ...currentOrderbook.no.asks].forEach(o => {
                totalEth += (Number(o.shares) / 1e18) * o.price;
            });

            el.textContent = totalEth >= 1
                ? totalEth.toFixed(2) + ' Œû'
                : totalEth > 0
                    ? totalEth.toFixed(4) + ' Œû'
                    : '0';
        }

        function updateOrderbookUI() {
            const container = document.getElementById('orderbookPreview');
            if (!container) return;

            // Get data for current trade side
            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            if (!book || !currentOrderbook.yes || !currentOrderbook.no) return;
            const { bids, asks, ammPrice } = book;
            const bestBidPrice = bids.length > 0 ? bids[0].price : null;
            const bestAskPrice = asks.length > 0 ? asks[0].price : null;
            const side = currentTrade.isYes ? 'YES' : 'NO';

            // Format best prices
            const ammStr = ammPrice ? (ammPrice * 100).toFixed(1) + '%' : '--';
            const bestBidStr = bestBidPrice ? (bestBidPrice * 100).toFixed(1) + '%' : '--';
            const bestAskStr = bestAskPrice ? (bestAskPrice * 100).toFixed(1) + '%' : '--';

            // Determine best price for buying (compare AMM vs best ask)
            let bestBuySource = 'AMM';
            if (bestAskPrice && (!ammPrice || bestAskPrice < ammPrice)) {
                bestBuySource = 'Limit';
            }

            // Determine best price for selling (compare AMM vs best bid)
            let bestSellSource = 'AMM';
            if (bestBidPrice && (!ammPrice || bestBidPrice > ammPrice)) {
                bestSellSource = 'Limit';
            }

            // Count total orders and liquidity across both books
            const totalOrders = currentOrderbook.yes.bids.length + currentOrderbook.yes.asks.length +
                               currentOrderbook.no.bids.length + currentOrderbook.no.asks.length;

            // Calculate orderbook liquidity (ETH in bids = buy orders escrowed)
            const bidLiquidity = [...currentOrderbook.yes.bids, ...currentOrderbook.no.bids]
                .reduce((sum, o) => sum + Number(o.collateral) / 1e18, 0);
            const bidLiqStr = bidLiquidity > 0 ? formatEth(BigInt(Math.floor(bidLiquidity * 1e18))) : '0';

            container.innerHTML = `
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:0.5rem;font-size:var(--font-xs);">
                    <div style="text-align:center;padding:0.5rem;background:var(--green-dim);border-radius:4px;">
                        <div style="color:var(--text-dim);font-size:10px;">${side} Best Bid</div>
                        <div style="color:var(--green);font-weight:600;">${bestBidStr}</div>
                        <div style="color:var(--text-dim);font-size:10px;">${bids.length} order${bids.length !== 1 ? 's' : ''}</div>
                    </div>
                    <div style="text-align:center;padding:0.5rem;background:var(--red-dim);border-radius:4px;">
                        <div style="color:var(--text-dim);font-size:10px;">${side} Best Ask</div>
                        <div style="color:var(--red);font-weight:600;">${bestAskStr}</div>
                        <div style="color:var(--text-dim);font-size:10px;">${asks.length} order${asks.length !== 1 ? 's' : ''}</div>
                    </div>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-top:0.5rem;flex-wrap:wrap;gap:0.25rem;">
                    <span style="font-size:10px;color:var(--text-dim);">AMM: ${ammStr}${bidLiquidity > 0 ? ` | Book: ${bidLiqStr} ETH` : ''}</span>
                    <button onclick="openOrderbookModal()" style="font-size:10px;padding:2px 8px;background:var(--surface-2);border:1px solid var(--border);border-radius:4px;color:var(--text-muted);cursor:pointer;">${totalOrders > 0 ? `Depth (${totalOrders})` : 'View Depth'}</button>
                </div>
            `;

            // Update My Orders section
            updateMyOrders();
        }

        function updateMyOrders() {
            const section = document.getElementById('myOrdersSection');
            const list = document.getElementById('myOrdersList');
            const countEl = document.getElementById('myOrdersCount');

            if (!section || !list) return;

            // Collect all user's pool positions
            const myPositions = [];

            // YES asks (user is selling YES)
            for (const pos of userPoolPositions.yes.asks) {
                myPositions.push({ ...pos, isYes: true, type: 'ASK' });
            }
            // YES bids (user wants to buy YES)
            for (const pos of userPoolPositions.yes.bids) {
                myPositions.push({ ...pos, isYes: true, type: 'BID' });
            }
            // NO asks (user is selling NO)
            for (const pos of userPoolPositions.no.asks) {
                myPositions.push({ ...pos, isYes: false, type: 'ASK' });
            }
            // NO bids (user wants to buy NO)
            for (const pos of userPoolPositions.no.bids) {
                myPositions.push({ ...pos, isYes: false, type: 'BID' });
            }

            if (myPositions.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            countEl.textContent = myPositions.length;

            // Sort by price descending
            myPositions.sort((a, b) => b.priceBps - a.priceBps);

            const symbol = getCollateralSymbol(currentTrade.collateral);
            let html = '';
            for (const pos of myPositions) {
                const priceStr = (pos.priceBps / 100).toFixed(1) + '%';
                const sideLabel = pos.isYes ? 'YES' : 'NO';
                const sideColor = pos.isYes ? 'var(--green)' : 'var(--red)';
                const typeColor = pos.type === 'BID' ? 'var(--green)' : 'var(--red)';

                // Amount display
                const amountStr = pos.type === 'ASK'
                    ? formatEth(pos.shares) + ' sh'
                    : formatEth(pos.collateral) + ' ' + symbol;

                // Pending fills
                const hasPending = pos.type === 'ASK'
                    ? (pos.pendingCollateral && pos.pendingCollateral > 0n)
                    : (pos.pendingShares && pos.pendingShares > 0n);
                const pendingStr = hasPending
                    ? (pos.type === 'ASK'
                        ? `${formatEth(pos.pendingCollateral)} ${symbol} pending`
                        : `${formatEth(pos.pendingShares)} sh pending`)
                    : '';

                // Withdraw function based on type
                const withdrawFn = pos.type === 'ASK'
                    ? `withdrawFromAskPool(${pos.isYes}, ${pos.priceBps})`
                    : `withdrawFromBidPool(${pos.isYes}, ${pos.priceBps})`;

                html += `
                    <div style="display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px solid rgba(245,158,11,0.2);">
                        <div>
                            <span style="color:${sideColor};font-weight:600;">${sideLabel}</span>
                            <span style="color:${typeColor};margin-left:4px;">${pos.type === 'BID' ? 'Buy' : 'Sell'}</span>
                            <span style="color:var(--text-muted);margin-left:4px;">@ ${priceStr}</span>
                            ${hasPending ? `<span style="color:var(--green);margin-left:4px;font-size:10px;">(${pendingStr})</span>` : ''}
                        </div>
                        <div style="display:flex;align-items:center;gap:6px;">
                            <span style="color:var(--text);">${amountStr}</span>
                            <button onclick="${withdrawFn}" style="padding:2px 6px;font-size:10px;background:var(--surface);border:1px solid var(--amber);border-radius:4px;color:var(--amber);cursor:pointer;">Withdraw</button>
                        </div>
                    </div>
                `;
            }

            list.innerHTML = html;
        }

        function openOrderbookModal() {
            renderDepthLadder();
            document.getElementById('orderbookModal').classList.add('active');
        }

        function renderDepthLadder() {
            const ladder = document.getElementById('depthLadder');
            const yesBook = currentOrderbook.yes;
            const noBook = currentOrderbook.no;
            if (!yesBook || !noBook) return;
            const yesAmm = yesBook.ammPrice || 0.5;
            const noAmm = noBook.ammPrice || 0.5;

            // Update header AMM prices
            document.getElementById('yesAmmRef').textContent = yesBook.ammPrice ? `AMM ${(yesBook.ammPrice * 100).toFixed(1)}%` : '--';
            document.getElementById('noAmmRef').textContent = noBook.ammPrice ? `AMM ${(noBook.ammPrice * 100).toFixed(1)}%` : '--';

            // Collect resting orders only (bids below AMM, asks above AMM)
            const levels = new Map(); // price -> { yesBids, yesAsks, noBids, noAsks, orders[] }

            // Helper to add resting orders with depth at each level
            const addOrders = (orders, side, isYes, ammPrice) => {
                orders.forEach(order => {
                    const price = Math.round(order.price * 1000) / 1000; // Round to 0.1% precision
                    // Only show resting orders (bids below AMM, asks above AMM)
                    const isResting = side === 'bids' ? price < ammPrice : price > ammPrice;
                    if (!isResting) return;

                    const eth = Number(order.shares) / 1e18 * order.price;
                    if (!levels.has(price)) levels.set(price, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [] });
                    const key = isYes ? (side === 'bids' ? 'yesBids' : 'yesAsks') : (side === 'bids' ? 'noBids' : 'noAsks');
                    levels.get(price)[key] += eth; // Sum depth at each level
                    levels.get(price).orders.push({ ...order, side, isYes, eth });
                });
            };

            addOrders(yesBook.bids, 'bids', true, yesAmm);
            addOrders(yesBook.asks, 'asks', true, yesAmm);
            addOrders(noBook.bids, 'bids', false, noAmm);
            addOrders(noBook.asks, 'asks', false, noAmm);

            // Add AMM price rows as reference points
            const yesAmmRounded = Math.round(yesAmm * 1000) / 1000;
            const noAmmRounded = Math.round(noAmm * 1000) / 1000;
            if (!levels.has(yesAmmRounded)) levels.set(yesAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [], isYesAmm: true });
            else levels.get(yesAmmRounded).isYesAmm = true;
            if (!levels.has(noAmmRounded)) levels.set(noAmmRounded, { yesBids: 0, yesAsks: 0, noBids: 0, noAsks: 0, orders: [], isNoAmm: true });
            else levels.get(noAmmRounded).isNoAmm = true;

            // Sort levels by price descending (high odds to low)
            const sortedLevels = [...levels.entries()].sort((a, b) => b[0] - a[0]);

            // Check if we have any actual orders
            const hasOrders = sortedLevels.some(([, data]) => data.orders.length > 0);

            if (!hasOrders) {
                // Show AMM prices as reference even without orders
                const yesAmm = yesBook.ammPrice ? (yesBook.ammPrice * 100).toFixed(1) : '--';
                const noAmm = noBook.ammPrice ? (noBook.ammPrice * 100).toFixed(1) : '--';
                ladder.innerHTML = `
                    <div style="text-align:center;padding:1.5rem;color:var(--text-dim);">
                        <div style="font-size:12px;margin-bottom:1rem;">No limit orders</div>
                        <div style="display:flex;justify-content:center;gap:2rem;font-size:11px;">
                            <span><span style="color:var(--green);">YES</span> AMM: ${yesAmm}%</span>
                            <span><span style="color:var(--red);">NO</span> AMM: ${noAmm}%</span>
                        </div>
                    </div>
                `;
                return;
            }

            // Find max cumulative for bar scaling
            let maxDepth = 0.001;
            sortedLevels.forEach(([, data]) => {
                maxDepth = Math.max(maxDepth, data.yesBids, data.yesAsks, data.noBids, data.noAsks);
            });

            // Render ladder rows - simplified for pooled orderbook (aggregate depth only)
            ladder.innerHTML = sortedLevels.map(([price, data]) => {
                const pct = (price * 100).toFixed(1);
                // Asks (above AMM) or Bids (below AMM) - only one should be non-zero per side
                const yesDepth = data.yesAsks > 0 ? data.yesAsks : data.yesBids;
                const noDepth = data.noAsks > 0 ? data.noAsks : data.noBids;
                const yesBarWidth = (yesDepth / maxDepth * 100).toFixed(1);
                const noBarWidth = (noDepth / maxDepth * 100).toFixed(1);
                const yesIsAsk = data.yesAsks > 0;
                const noIsAsk = data.noAsks > 0;

                // Check if this is AMM price row
                const isYesAmm = data.isYesAmm;
                const isNoAmm = data.isNoAmm;
                const isAmmRow = isYesAmm || isNoAmm;

                // Format depth display (ETH value)
                const yesDepthStr = yesDepth > 0 ? (yesDepth >= 1 ? yesDepth.toFixed(2) : yesDepth.toFixed(3)) + 'Œû' : '';
                const noDepthStr = noDepth > 0 ? (noDepth >= 1 ? noDepth.toFixed(2) : noDepth.toFixed(3)) + 'Œû' : '';

                return `
                    <div style="display:grid;grid-template-columns:1fr 56px 1fr;gap:0;align-items:center;height:26px;border-bottom:1px solid var(--border);${isAmmRow ? 'background:var(--surface-2);' : ''}">
                        <!-- YES side (bars grow right-to-left) -->
                        <div style="position:relative;height:100%;display:flex;align-items:center;justify-content:flex-end;padding-right:8px;overflow:hidden;">
                            ${yesDepth > 0 ? `<div style="position:absolute;right:0;top:0;bottom:0;width:${yesBarWidth}%;background:${yesIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            ${isYesAmm ? '<span style="font-size:8px;color:var(--blue);margin-right:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                            <span style="font-size:10px;color:${yesIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:600;">${yesDepthStr}</span>
                        </div>
                        <!-- Center odds -->
                        <div style="text-align:center;font-size:11px;font-weight:700;color:var(--text);background:${isAmmRow ? 'var(--surface-2)' : 'var(--surface)'};height:100%;display:flex;align-items:center;justify-content:center;border-left:1px solid var(--border);border-right:1px solid var(--border);">${pct}%</div>
                        <!-- NO side (bars grow left-to-right) -->
                        <div style="position:relative;height:100%;display:flex;align-items:center;padding-left:8px;overflow:hidden;">
                            ${noDepth > 0 ? `<div style="position:absolute;left:0;top:0;bottom:0;width:${noBarWidth}%;background:${noIsAsk ? 'var(--red)' : 'var(--green)'};opacity:0.3;"></div>` : ''}
                            <span style="font-size:10px;color:${noIsAsk ? 'var(--red)' : 'var(--green)'};z-index:1;font-weight:600;">${noDepthStr}</span>
                            ${isNoAmm ? '<span style="font-size:8px;color:var(--blue);margin-left:6px;z-index:1;font-weight:600;">AMM</span>' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function closeOrderbookModal() {
            document.getElementById('orderbookModal').classList.remove('active');
        }

        // Withdraw from a sell pool (ask order) - returns shares
        async function withdrawFromAskPool(isYes, priceBps) {
            if (!signer || !currentTrade.marketId) {
                showWalletModal();
                return;
            }

            const side = isYes ? 'YES' : 'NO';
            const priceDisplay = (priceBps / 100).toFixed(0) + '%';

            try {
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);

                await monitorTransaction(
                    masterRouter.withdrawFromPool(currentTrade.marketId, isYes, priceBps),
                    {
                        pending: { title: `Withdrawing ${side} Order`, body: `Cancelling ask at ${priceDisplay}...` },
                        submitted: { title: `Withdrawing ${side} Order`, body: 'Waiting for confirmation...' },
                        success: { title: 'Order Withdrawn', body: `Your ${side} shares have been returned` },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([loadUserPosition(), loadUserPoolPositions(), loadOrderbook()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Withdraw from pool error:', e);
                    showToast('Withdraw Failed', 'Could not withdraw from pool', 'error');
                }
            }
        }

        // Withdraw from a buy pool (bid order) - returns collateral
        async function withdrawFromBidPool(isYes, priceBps) {
            if (!signer || !currentTrade.marketId) {
                showWalletModal();
                return;
            }

            const side = isYes ? 'YES' : 'NO';
            const priceDisplay = (priceBps / 100).toFixed(0) + '%';
            const symbol = getCollateralSymbol(currentTrade.collateral);

            try {
                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);

                await monitorTransaction(
                    masterRouter.withdrawFromBidPool(currentTrade.marketId, isYes, priceBps),
                    {
                        pending: { title: `Withdrawing ${side} Bid`, body: `Cancelling bid at ${priceDisplay}...` },
                        submitted: { title: `Withdrawing ${side} Bid`, body: 'Waiting for confirmation...' },
                        success: { title: 'Bid Withdrawn', body: `Your ${symbol} has been returned` },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([loadUserPosition(), loadUserPoolPositions(), loadOrderbook()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Withdraw from bid pool error:', e);
                    showToast('Withdraw Failed', 'Could not withdraw from bid pool', 'error');
                }
            }
        }

        // ======================== PREVIEW FUNCTIONS ========================
        let tradeInputTimer = null;
        function handleTradeInput() {
            tradeMaxRaw = null; // Clear max when user manually edits input
            // Debounce expensive preview calculations
            clearTimeout(tradeInputTimer);
            tradeInputTimer = setTimeout(() => {
                if (currentTradeMode === 'trade') updateTradePreview();
            }, 80);
        }

        function updateTradePreview() {
            const amount = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const routeEl = document.getElementById('previewRoute');

            if (!currentTrade.marketId || amount <= 0 || currentTrade.rYes === 0n || currentTrade.rNo === 0n) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                document.getElementById('previewPayout').style.color = 'var(--text-muted)';
                routeEl.textContent = '--';
                return;
            }

            const amtWei = ethers.parseEther(amount.toString());
            const isBuy = currentTradeDirection === 'buy';

            // Calculate AMM execution price (with price impact) for routing
            const ammOutput = isBuy
                ? (currentTrade.isYes ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo))
                : (currentTrade.isYes ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo) : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo));
            const ammOutputNum = Number(ammOutput) / 1e18;
            // Guard against division by zero
            const ammExecutionPrice = (ammOutputNum > 0 && amount > 0)
                ? (isBuy ? amount / ammOutputNum : ammOutputNum / amount)
                : null;

            // Check orderbook for better prices (use current side's book)
            const book = currentTrade.isYes ? currentOrderbook.yes : currentOrderbook.no;
            if (!book) {
                // Orderbook not loaded yet, show AMM-only preview
                document.getElementById('previewShares').textContent = ammOutputNum.toFixed(4);
                document.getElementById('previewPrice').textContent = ammExecutionPrice ? ammExecutionPrice.toFixed(4) : '--';
                document.getElementById('previewPayout').textContent = isBuy ? ammOutputNum.toFixed(4) + ' ETH' : '--';
                routeEl.textContent = 'AMM';
                return;
            }
            const { bids, asks } = book;
            const relevantOrders = isBuy ? asks : bids;

            // Simulate routing through limit orders then AMM
            const MAX_ORDERS_TO_FILL = 10; // Match execution limit
            let betterOrders = [];
            let sharesFromOrders = 0;  // Shares received (buy) or ETH received (sell)
            let ethFromOrders = 0;     // ETH received from selling to bids
            let remainingAmount = amount;

            if (relevantOrders && relevantOrders.length > 0 && ammExecutionPrice !== null) {
                for (const order of relevantOrders) {
                    // Stop if we've filled enough or hit order limit
                    if (remainingAmount <= 0 || betterOrders.length >= MAX_ORDERS_TO_FILL) break;
                    // Skip own orders - can't fill your own orders
                    if (order.isOwn) continue;
                    // Compare against execution price (with impact), not spot
                    const isBetter = isBuy ? order.price <= ammExecutionPrice : order.price >= ammExecutionPrice;
                    if (!isBetter) continue;

                    const orderShares = Number(order.shares) / 1e18;
                    const orderPrice = order.price;

                    betterOrders.push(order);

                    if (isBuy) {
                        // Buy: we spend ETH to get shares from asks
                        const orderCost = orderShares * orderPrice;
                        if (remainingAmount >= orderCost) {
                            sharesFromOrders += orderShares;
                            remainingAmount -= orderCost;
                        } else {
                            // Partial fill
                            const partialShares = remainingAmount / orderPrice;
                            sharesFromOrders += partialShares;
                            remainingAmount = 0;
                        }
                    } else {
                        // Sell: we sell shares to bids to get ETH
                        if (remainingAmount >= orderShares) {
                            ethFromOrders += orderShares * orderPrice;
                            remainingAmount -= orderShares;
                        } else {
                            ethFromOrders += remainingAmount * orderPrice;
                            remainingAmount = 0;
                        }
                    }
                }
            }

            // Calculate final output including both orderbook and AMM portions
            let totalShares, avgPrice, profit;

            if (isBuy) {
                // Remaining ETH goes to AMM
                let ammShares = 0n;
                if (remainingAmount > 0) {
                    const remainingWei = ethers.parseEther(remainingAmount.toFixed(18));
                    ammShares = currentTrade.isYes
                        ? quoteBuyYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                }
                totalShares = sharesFromOrders + Number(ammShares) / 1e18;
                avgPrice = totalShares > 0 ? amount / totalShares : 0;
                profit = totalShares - amount;
            } else {
                // Remaining shares go to AMM
                let ammEth = 0n;
                if (remainingAmount > 0) {
                    const remainingWei = ethers.parseEther(remainingAmount.toFixed(18));
                    ammEth = currentTrade.isYes
                        ? quoteSellYes(remainingWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(remainingWei, currentTrade.rYes, currentTrade.rNo);
                }
                const totalEth = ethFromOrders + Number(ammEth) / 1e18;
                totalShares = amount; // shares sold
                avgPrice = totalEth / amount;
                profit = totalEth;
            }

            // Update route indicator with savings info
            if (betterOrders.length > 0) {
                // Calculate AMM-only output for comparison
                let ammOnlyOutput;
                if (isBuy) {
                    ammOnlyOutput = currentTrade.isYes
                        ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                } else {
                    ammOnlyOutput = currentTrade.isYes
                        ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                }
                const ammOnlyNum = Number(ammOnlyOutput) / 1e18;
                const savings = ammOnlyNum > 0
                    ? (isBuy ? ((totalShares / ammOnlyNum - 1) * 100).toFixed(1) : ((profit / ammOnlyNum - 1) * 100).toFixed(1))
                    : '0.0';
                const savingsStr = parseFloat(savings) > 0 ? ` (+${savings}%)` : '';
                const routeText = remainingAmount > 0
                    ? `${betterOrders.length} order${betterOrders.length > 1 ? 's' : ''} + AMM`
                    : `${betterOrders.length} order${betterOrders.length > 1 ? 's' : ''}`;
                routeEl.innerHTML = `<span style="color:var(--green);">${routeText}</span><span style="color:var(--green);font-size:10px;">${savingsStr}</span>`;
            } else {
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--text-muted)';
            }

            if (isBuy) {
                document.getElementById('previewShares').textContent = totalShares.toFixed(4);
                document.getElementById('previewPrice').textContent = avgPrice.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').textContent = (profit > 0 ? '+' : '') + profit.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').style.color = 'var(--green)';
            } else {
                // For sells: profit = totalEth received
                document.getElementById('previewShares').textContent = profit.toFixed(4) + ' ETH';
                document.getElementById('previewPrice').textContent = avgPrice.toFixed(4) + ' ETH';
                const minReceived = profit * (100 - slippageTolerance) / 100;
                document.getElementById('previewPayout').textContent = minReceived.toFixed(4) + ' ETH';
                document.getElementById('previewPayout').style.color = 'var(--text-muted)';
            }
        }

        function updateSwapPreview() {
            const amount = parseFloat(document.getElementById('swapAmount').value) || 0;

            if (!currentTrade.marketId || amount <= 0 || currentTrade.rYes === 0n || currentTrade.rNo === 0n) {
                document.getElementById('swapOutput').textContent = '--';
                document.getElementById('swapFee').textContent = '--';
                document.getElementById('swapMinOutput').textContent = '--';
                return;
            }

            const amtWei = ethers.parseEther(amount.toString());
            const output = currentSwapDirection
                ? getAmountOut(amtWei, currentTrade.rYes, currentTrade.rNo)
                : getAmountOut(amtWei, currentTrade.rNo, currentTrade.rYes);
            const outputNum = Number(output) / 1e18;
            const fee = amount * 0.003;
            const minOut = outputNum * (1 - swapSlippage / 100);
            const outputSide = currentSwapDirection ? 'NO' : 'YES';

            document.getElementById('swapOutput').textContent = outputNum.toFixed(4) + ' ' + outputSide;
            document.getElementById('swapFee').textContent = fee.toFixed(6) + ' (included)';
            document.getElementById('swapMinOutput').textContent = minOut.toFixed(4) + ' ' + outputSide;
        }

        function updateLpPreview() {
            const amount = parseFloat(document.getElementById('lpAmount').value) || 0;
            const rYes = currentTrade.rYes || 0n;
            const rNo = currentTrade.rNo || 0n;
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;

            // Get total LP supply and user LP balance
            const hasActualSupply = currentUserPosition.lpTotalSupply !== null && currentUserPosition.lpTotalSupply > 0n;
            const totalLpSupply = hasActualSupply
                ? Number(currentUserPosition.lpTotalSupply) / 1e18
                : Math.sqrt(rYesNum * rNoNum);
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;

            if (!currentTrade.marketId || amount <= 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                document.getElementById('lpShareChange').textContent = '';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP provider
                document.getElementById('lpPreview').textContent = '~' + amount.toFixed(4) + ' LP';
                document.getElementById('lpPoolShare').textContent = '100%';
                document.getElementById('lpShareChange').textContent = '(+100%)';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: estimate LP tokens
                // splitAndAddLiquidity adds equal YES+NO, so LP = min(amt/rYes, amt/rNo) * supply
                const maxReserve = Math.max(rYesNum, rNoNum);
                const estLp = maxReserve > 0 ? (amount / maxReserve) * totalLpSupply : amount;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = '~' + estLp.toFixed(4) + ' LP';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta > 0 ? `(+${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
            } else {
                // Removing liquidity: LP tokens -> ETH
                if (amount > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    document.getElementById('lpShareChange').textContent = '';
                    return;
                }

                // Calculate ETH out from burning LP
                const shareOfPool = totalLpSupply > 0 ? amount / totalLpSupply : 0;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;
                const ethOut = Math.min(yesOut, noOut);

                // Calculate new share after removal
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newUserLp = userLp - amount;
                const newTotalLp = totalLpSupply - amount;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = '~' + ethOut.toFixed(4) + ' ETH';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta !== 0 ? `(${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = shareDelta < 0 ? 'var(--red)' : 'var(--text-muted)';
            }
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const amount = parseFloat(document.getElementById('limitAmount').value) || 0;

            // Update odds display (price as percentage)
            const oddsDisplay = document.getElementById('limitOddsDisplay');
            if (price > 0 && price < 1) {
                oddsDisplay.textContent = (price * 100).toFixed(0) + '%';
            } else {
                oddsDisplay.textContent = '--';
            }

            // Calculate pool price
            let poolPrice = null;
            if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                const yesPrice = Number(currentTrade.rNo) / Number(currentTrade.rYes + currentTrade.rNo);
                poolPrice = currentTrade.isYes ? yesPrice : (1 - yesPrice);
                document.getElementById('limitPoolPrice').textContent = (poolPrice * 100).toFixed(1) + '%';
            } else {
                document.getElementById('limitPoolPrice').textContent = '--';
            }

            if (price <= 0 || amount <= 0) {
                document.getElementById('limitResult').textContent = '--';
                document.getElementById('limitSavings').textContent = '--';
                return;
            }

            if (limitIsBuy) {
                // BUY: User spends ETH, receives shares
                // shares = ETH / price
                const shares = amount / price;
                document.getElementById('limitResult').textContent = shares.toFixed(4) + ' shares';

                // Compare to pool: how many shares would pool ACTUALLY give (with slippage)?
                if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                    const amtWei = ethers.parseEther(amount.toString());
                    const poolSharesWei = currentTrade.isYes
                        ? quoteBuyYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteBuyNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                    const poolShares = Number(poolSharesWei) / 1e18;
                    const extraShares = shares - poolShares;
                    if (extraShares > 0) {
                        document.getElementById('limitSavings').textContent = '+' + extraShares.toFixed(4) + ' shares';
                        document.getElementById('limitSavings').style.color = 'var(--green)';
                    } else {
                        document.getElementById('limitSavings').textContent = extraShares.toFixed(4) + ' shares';
                        document.getElementById('limitSavings').style.color = 'var(--red)';
                    }
                } else {
                    document.getElementById('limitSavings').textContent = '--';
                }
            } else {
                // SELL: User sells shares, receives ETH
                // ETH = shares * price
                const ethReceived = amount * price;
                document.getElementById('limitResult').textContent = ethReceived.toFixed(4) + ' ETH';

                // Compare to pool: how much ETH would pool ACTUALLY give (with slippage)?
                if (currentTrade.rYes > 0n && currentTrade.rNo > 0n) {
                    const amtWei = ethers.parseEther(amount.toString());
                    const poolEthWei = currentTrade.isYes
                        ? quoteSellYes(amtWei, currentTrade.rYes, currentTrade.rNo)
                        : quoteSellNo(amtWei, currentTrade.rYes, currentTrade.rNo);
                    const poolEth = Number(poolEthWei) / 1e18;
                    const extraEth = ethReceived - poolEth;
                    if (extraEth > 0) {
                        document.getElementById('limitSavings').textContent = '+' + extraEth.toFixed(4) + ' ETH';
                        document.getElementById('limitSavings').style.color = 'var(--green)';
                    } else {
                        document.getElementById('limitSavings').textContent = extraEth.toFixed(4) + ' ETH';
                        document.getElementById('limitSavings').style.color = 'var(--red)';
                    }
                } else {
                    document.getElementById('limitSavings').textContent = '--';
                }
            }
        }

        // ======================== AMM MATH ========================
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            return collateralIn + yesFromSwap;
        }

        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            return collateralIn + noFromSwap;
        }

        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Binary search for optimal swap amount
            // Goal: find x where (yesIn - x) == getAmountOut(x, rYes, rNo)
            if (yesIn === 0n) return 0n;
            let lo = 0n, hi = yesIn;
            for (let i = 0; i < 64; i++) {
                const mid = (lo + hi) / 2n;
                const noFromSwap = getAmountOut(mid, rYes, rNo, feeBps);
                const yesRemaining = yesIn - mid;
                if (yesRemaining > noFromSwap) {
                    lo = mid + 1n;
                } else {
                    hi = mid;
                }
            }
            const noFromSwap = getAmountOut(lo, rYes, rNo, feeBps);
            const yesRemaining = yesIn - lo;
            return yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
        }

        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Binary search for optimal swap amount
            // Goal: find x where (noIn - x) == getAmountOut(x, rNo, rYes)
            if (noIn === 0n) return 0n;
            let lo = 0n, hi = noIn;
            for (let i = 0; i < 64; i++) {
                const mid = (lo + hi) / 2n;
                const yesFromSwap = getAmountOut(mid, rNo, rYes, feeBps);
                const noRemaining = noIn - mid;
                if (noRemaining > yesFromSwap) {
                    lo = mid + 1n;
                } else {
                    hi = mid;
                }
            }
            const yesFromSwap = getAmountOut(lo, rNo, rYes, feeBps);
            const noRemaining = noIn - lo;
            return noRemaining < yesFromSwap ? noRemaining : yesFromSwap;
        }

        // ======================== EXECUTE FUNCTIONS ========================
        // Uses MasterRouter.buyWithSweep/sellWithSweep for optimal routing
        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('tradeAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            const isBuy = currentTradeDirection === 'buy';
            const side = currentTrade.isYes ? 'YES' : 'NO';

            // For sells, validate balance first
            if (!isBuy) {
                const balance = currentTrade.isYes
                    ? currentUserPosition.yesBalance
                    : currentUserPosition.noBalance;
                const amtToSell = tradeMaxRaw || ethers.parseEther(amount.toString());
                if (!balance || amtToSell > balance) {
                    showToast('Insufficient Balance', `You don't have enough ${side} shares`, 'error');
                    return;
                }
            }

            // Refresh pool state before trade to ensure fresh prices
            await refreshPoolState();

            try {
                if (!isBuy) {
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);
                const quoter = new ethers.Contract(PMHOOKQUOTER_ADDRESS, PMHOOKQUOTER_ABI, await getReadProvider());

                // Use exact raw value if max was clicked, otherwise parse input
                const amtWei = (!isBuy && tradeMaxRaw) ? tradeMaxRaw : ethers.parseEther(amount.toString());
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);
                const isEthCollateral = !currentTrade.collateral || currentTrade.collateral === ethers.ZeroAddress;

                // Get quote from quoter for expected output
                let expectedOutput;
                let txPromise;

                if (isBuy) {
                    // maxPriceBps: apply slippage as max price willing to pay (spot + slippage)
                    const spotPriceBps = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                        ? (currentTrade.isYes
                            ? Number(currentTrade.rNo * 10000n / (currentTrade.rYes + currentTrade.rNo))
                            : Number(currentTrade.rYes * 10000n / (currentTrade.rYes + currentTrade.rNo)))
                        : 5000;
                    const maxPriceBps = Math.min(9900, Math.floor(spotPriceBps * (1 + slippageTolerance / 100)));

                    // Quote the buy
                    const quote = await quoter.quoteBuyWithSweep(currentTrade.marketId, currentTrade.isYes, amtWei, maxPriceBps);
                    expectedOutput = quote.totalSharesOut;
                    const minOutput = expectedOutput * BigInt(100 - slippageTolerance) / 100n;

                    // Handle UNI collateral approval for buys
                    if (!isEthCollateral) {
                        await approveUNI(amtWei, MASTERROUTER_ADDRESS);
                    }

                    const txOptions = isEthCollateral ? { value: amtWei } : {};
                    txPromise = masterRouter.buyWithSweep(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        amtWei,
                        minOutput,
                        maxPriceBps,
                        connectedAddress,
                        deadline,
                        txOptions
                    );
                } else {
                    // minPriceBps: apply slippage as min price willing to accept (spot - slippage)
                    const spotPriceBps = currentTrade.rYes > 0n && currentTrade.rNo > 0n
                        ? (currentTrade.isYes
                            ? Number(currentTrade.rNo * 10000n / (currentTrade.rYes + currentTrade.rNo))
                            : Number(currentTrade.rYes * 10000n / (currentTrade.rYes + currentTrade.rNo)))
                        : 5000;
                    const minPriceBps = Math.max(100, Math.floor(spotPriceBps * (1 - slippageTolerance / 100)));

                    // Quote the sell
                    const quote = await quoter.quoteSellWithSweep(currentTrade.marketId, currentTrade.isYes, amtWei, minPriceBps);
                    expectedOutput = quote.totalCollateralOut;
                    const minOutput = expectedOutput * BigInt(100 - slippageTolerance) / 100n;

                    txPromise = masterRouter.sellWithSweep(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        amtWei,
                        minOutput,
                        minPriceBps,
                        connectedAddress,
                        deadline
                    );
                }

                const expectedOutputNum = Number(expectedOutput) / 1e18;
                const collateralSymbol = isEthCollateral ? 'ETH' : 'UNI';
                await monitorTransaction(txPromise, {
                    pending: { title: `${isBuy ? 'Buying' : 'Selling'} ${side}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${isBuy ? 'Buying' : 'Selling'} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Complete!', body: isBuy ? `Bought ~${expectedOutputNum.toFixed(4)} ${side} shares for ${amount} ${collateralSymbol}` : `Sold ${amount} ${side} shares for ~${expectedOutputNum.toFixed(4)} ${collateralSymbol}` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        tradeMaxRaw = null; // Clear max flag
                        await Promise.all([refreshPoolState(), loadUserPosition(), loadUserPoolPositions(), loadOrderbook(), loadData()]);
                        loadBalance();
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) console.error('Trade error:', e);
            } finally {
                tradeMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function executeSwap() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('swapAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            // Check balance - use exact raw value if max was clicked, otherwise parse input
            const sourceBalance = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
            const amtWei = swapMaxRaw || ethers.parseEther(amount.toString());
            if (amtWei > sourceBalance) {
                showToast('Insufficient Balance', `You don't have enough ${currentSwapDirection ? 'YES' : 'NO'} shares`, 'error');
                return;
            }

            const fromLabel = currentSwapDirection ? 'YES' : 'NO';
            const toLabel = currentSwapDirection ? 'NO' : 'YES';

            // Refresh pool state before swap to ensure fresh prices
            await refreshPoolState();

            try {
                // Need ZAMM approved as operator on PAMM
                const approved = await checkAndRequestApprovals('swap');
                if (!approved) return;

                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const yesId = currentTrade.yesId;
                const noId = currentTrade.noId;
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;

                const poolKey = {
                    id0: id0,
                    id1: id1,
                    token0: PAMM_ADDRESS,
                    token1: PAMM_ADDRESS,
                    feeOrHook: FEE_TIER
                };

                const yesIsToken0 = yesId === id0;
                const zeroForOne = currentSwapDirection ? yesIsToken0 : !yesIsToken0;

                // Calculate min output with slippage
                const output = currentSwapDirection
                    ? getAmountOut(amtWei, currentTrade.rYes, currentTrade.rNo)
                    : getAmountOut(amtWei, currentTrade.rNo, currentTrade.rYes);
                const minOut = output * BigInt(Math.floor((1 - swapSlippage / 100) * 10000)) / 10000n;

                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                await monitorTransaction(
                    zamm.swapExactIn(poolKey, amtWei, minOut, zeroForOne, connectedAddress, deadline),
                    {
                        pending: { title: `Swap ${fromLabel} ‚Üí ${toLabel}`, body: 'Confirm in your wallet...' },
                        submitted: { title: `Swap ${fromLabel} ‚Üí ${toLabel}`, body: 'Waiting for confirmation...' },
                        success: { title: 'Swap Complete!', body: `Swapped ${amount} ${fromLabel} ‚Üí ${toLabel}` },
                        error: { title: 'Swap Failed', body: '' },
                        onSuccess: async () => {
                            swapMaxRaw = null; // Clear max flag
                            await Promise.all([refreshPoolState(), loadUserPosition(), loadData()]);
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) console.error('Swap error:', e);
            } finally {
                swapMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amount = parseFloat(document.getElementById('lpAmount').value);
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Please enter a valid amount', 'error');
                return;
            }

            // Use exact raw value if max was clicked, otherwise parse input
            const amtWei = lpMaxRaw || ethers.parseEther(amount.toString());

            // Validate balance for LP remove
            if (currentLpMode === 'remove') {
                const lpBal = currentUserPosition.lpBalance;
                if (!lpBal || amtWei > lpBal) {
                    showToast('Insufficient LP', 'You don\'t have enough LP tokens', 'error');
                    return;
                }
            }

            // Validate pool exists for adding liquidity
            if (currentLpMode === 'add' && (!currentTrade.rYes || currentTrade.rYes === 0n)) {
                showToast('Pool Not Seeded', 'This market has no liquidity pool yet', 'error');
                return;
            }

            // Refresh pool state before LP action to ensure fresh reserves
            await refreshPoolState();

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                // Calculate expected outputs for slippage protection
                const rYesNum = Number(currentTrade.rYes) / 1e18;
                const rNoNum = Number(currentTrade.rNo) / 1e18;
                // Use actual LP supply if available, otherwise estimate from reserves (only accurate for initial add)
                const hasActualSupply = currentUserPosition.lpTotalSupply !== null && currentUserPosition.lpTotalSupply > 0n;
                const totalLpSupply = hasActualSupply
                    ? Number(currentUserPosition.lpTotalSupply) / 1e18
                    : Math.sqrt(rYesNum * rNoNum);

                if (currentLpMode === 'add') {
                    // Use PMHookRouter.provideLiquidity for adding to vault + AMM
                    const pmHookRouter = new ethers.Contract(PMHOOKROUTER_ADDRESS, PMHOOKROUTER_ABI, signer);

                    // Split collateral between vault (for bootstrap) and AMM
                    // Default: 50% to vault (YES + NO), 50% to AMM
                    const vaultShare = amtWei / 4n; // 25% to YES vault, 25% to NO vault
                    const ammShare = amtWei / 2n;   // 50% to AMM

                    // Calculate minimum outputs with slippage
                    const maxReserve = Math.max(rYesNum, rNoNum);
                    const estLp = maxReserve > 0 && hasActualSupply
                        ? (amount / 2 / maxReserve) * totalLpSupply
                        : amount / 2;
                    const minAmmLiquidity = hasActualSupply && maxReserve > 0
                        ? ethers.parseEther((estLp * (100 - slippageTolerance) / 100).toFixed(18))
                        : 0n;

                    const isEthCollateral = !currentTrade.collateral || currentTrade.collateral === ethers.ZeroAddress;

                    // Handle UNI collateral approval
                    if (!isEthCollateral) {
                        await approveUNI(amtWei, PMHOOKROUTER_ADDRESS);
                    }

                    const txOptions = isEthCollateral ? { value: amtWei } : {};

                    await monitorTransaction(
                        pmHookRouter.provideLiquidity(
                            currentTrade.marketId,
                            amtWei,         // Total collateral
                            vaultShare,     // vaultYesShares
                            vaultShare,     // vaultNoShares
                            ammShare,       // ammLPShares
                            0n,             // minAmount0
                            0n,             // minAmount1
                            connectedAddress,
                            deadline,
                            txOptions
                        ),
                        {
                            pending: { title: 'Adding Liquidity', body: 'Providing to vault + AMM...' },
                            submitted: { title: 'Adding Liquidity', body: 'Waiting for confirmation...' },
                            success: { title: 'Liquidity Added!', body: `Added ${amount} to vault + AMM` },
                            error: { title: 'Add Liquidity Failed', body: '' },
                            onSuccess: async () => {
                                lpMaxRaw = null; // Clear max flag
                                await Promise.all([refreshPoolState(), loadUserPosition(), loadData()]);
                                loadBalance();
                            }
                        }
                    );
                } else {
                    // Need PAMM approved as operator on ZAMM for LP removal
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    // Calculate minimum collateral out with slippage protection
                    const shareOfPool = totalLpSupply > 0 ? amount / totalLpSupply : 0;
                    const yesOut = shareOfPool * rYesNum;
                    const noOut = shareOfPool * rNoNum;
                    const estEthOut = Math.min(yesOut, noOut);
                    const minCollateral = ethers.parseEther((estEthOut * (100 - slippageTolerance) / 100).toFixed(18));

                    // Check if market is resolved and user has direct winning tokens
                    const market = await pamm.getMarket(currentTrade.marketId);
                    const isResolved = market[2]; // resolved
                    const outcome = market[3]; // outcome (true = YES won)

                    // Check for direct winning token holdings (beyond LP)
                    let hasDirectWinnings = false;
                    if (isResolved) {
                        const winningBalance = outcome
                            ? currentUserPosition.yesBalance
                            : currentUserPosition.noBalance;
                        hasDirectWinnings = winningBalance > 0n;
                    }

                    let txPromise;
                    if (isResolved && hasDirectWinnings) {
                        // Use multicall to batch LP removal + claim
                        const pammInterface = new ethers.Interface(PAMM_ABI);
                        const calls = [
                            pammInterface.encodeFunctionData('removeLiquidityToCollateral', [
                                currentTrade.marketId,
                                FEE_TIER,
                                amtWei,
                                0n, 0n, minCollateral,
                                connectedAddress,
                                deadline
                            ]),
                            pammInterface.encodeFunctionData('claim', [
                                currentTrade.marketId,
                                connectedAddress
                            ])
                        ];
                        txPromise = pamm.multicall(calls);
                    } else {
                        txPromise = pamm.removeLiquidityToCollateral(
                            currentTrade.marketId,
                            FEE_TIER,
                            amtWei,
                            0n, 0n, minCollateral,
                            connectedAddress,
                            deadline
                        );
                    }

                    const actionTitle = hasDirectWinnings ? 'Withdrawing All' : 'Removing Liquidity';
                    const successBody = hasDirectWinnings
                        ? 'LP and winnings returned to your wallet'
                        : 'Withdrew liquidity from the pool';

                    await monitorTransaction(txPromise, {
                        pending: { title: actionTitle, body: 'Confirm in your wallet...' },
                        submitted: { title: actionTitle, body: 'Waiting for confirmation...' },
                        success: { title: 'Success!', body: successBody },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            lpMaxRaw = null; // Clear max flag
                            await Promise.all([refreshPoolState(), loadUserPosition(), loadData()]);
                            loadBalance();
                        }
                    });
                }
            } catch (e) {
                if (!isUserRejection(e)) console.error('LP error:', e);
            } finally {
                lpMaxRaw = null; // Clear max flag regardless of outcome
            }
        }

        async function claimWinnings(marketId) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const rpc = await getReadProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);

                // Check if user has any winning tokens to claim
                const market = await pamm.getMarket(marketId);
                const outcome = market[3]; // true = YES won
                const yesId = BigInt(marketId);
                const noId = await pamm.getNoId(marketId);
                const winningId = outcome ? yesId : noId;
                const balance = await pamm.balanceOf(connectedAddress, winningId);

                if (balance === 0n) {
                    showToast('Nothing to Claim', `You don't have any ${outcome ? 'YES' : 'NO'} shares to claim`, 'info');
                    return;
                }

                const pammSigner = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                await monitorTransaction(
                    pammSigner.claim(marketId, connectedAddress),
                    {
                        pending: { title: 'Claiming Winnings', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Claiming Winnings', body: 'Waiting for confirmation...' },
                        success: { title: 'Winnings Claimed!', body: 'Your winnings have been sent to your wallet' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            loadBalance();
                        }
                    }
                );
            } catch (e) {
                if (!isUserRejection(e)) console.error('Claim failed:', e);
            }
        }

        // Uses MasterRouter.mintAndPool for buy orders, depositSharesToPool for sell orders
        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) return;

            const price = parseFloat(document.getElementById('limitPrice').value);
            const amount = parseFloat(document.getElementById('limitAmount').value);

            if (!price || price <= 0 || price >= 1) {
                showToast('Invalid Price', 'Enter price between 0.01 and 0.99', 'error');
                return;
            }
            if (!amount || amount <= 0) {
                showToast('Invalid Amount', 'Enter a valid amount', 'error');
                return;
            }

            // Convert price to BPS for MasterRouter
            const priceBps = Math.floor(price * 10000);

            // Calculate shares and collateral based on order type
            const WAD = 10n ** 18n;
            let sharesWei, collateralWei;

            if (limitIsBuy) {
                // BUY: user provides collateral (amount), mints shares and pools opposite side
                collateralWei = limitMaxRaw || ethers.parseEther(amount.toString());
                sharesWei = collateralWei * 10000n / BigInt(priceBps);
            } else {
                // SELL: user provides shares (amount), deposits to pool at price
                sharesWei = limitMaxRaw || ethers.parseEther(amount.toString());
                collateralWei = sharesWei * BigInt(priceBps) / 10000n;

                // Check balance
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                if (sharesWei > userShares) {
                    showToast('Insufficient Shares', `You don't have enough shares`, 'error');
                    return;
                }
            }

            // Calculate display values for toast message
            const shares = Number(sharesWei) / 1e18;
            const collateral = Number(collateralWei) / 1e18;

            try {
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('limit');
                    if (!approved) return;
                }

                const masterRouter = new ethers.Contract(MASTERROUTER_ADDRESS, MASTERROUTER_ABI, signer);

                const orderType = limitIsBuy ? 'Buy' : 'Sell';
                const displayPrice = (price * 100).toFixed(0) + '%';
                const isEthCollateral = !currentTrade.collateral || currentTrade.collateral === ethers.ZeroAddress;

                let txPromise;

                if (limitIsBuy) {
                    // Handle UNI collateral approval for buy orders
                    if (!isEthCollateral) {
                        await approveUNI(collateralWei, MASTERROUTER_ADDRESS);
                    }

                    // mintAndPool: mints shares and pools the opposite side at the given price
                    const keepYes = currentTrade.isYes;
                    const poolPriceBps = keepYes ? (10000 - priceBps) : priceBps;
                    const txOptions = isEthCollateral ? { value: collateralWei } : {};

                    txPromise = masterRouter.mintAndPool(
                        currentTrade.marketId,
                        collateralWei,
                        keepYes,
                        poolPriceBps,
                        connectedAddress,
                        txOptions
                    );
                } else {
                    // depositSharesToPool: deposits existing shares to pool at price
                    txPromise = masterRouter.depositSharesToPool(
                        currentTrade.marketId,
                        currentTrade.isYes,
                        sharesWei,
                        priceBps,
                        connectedAddress
                    );
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `Placing ${orderType} Order`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Placing ${orderType} Order`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Placed!', body: `${orderType} ${shares.toFixed(2)} shares at ${displayPrice}` },
                    error: { title: 'Order Failed', body: '' },
                    onSuccess: async () => {
                        document.getElementById('limitAmount').value = '';
                        limitMaxRaw = null; // Clear max flag
                        setDefaultLimitPrice();
                        updateLimitPreview();
                        await Promise.all([loadUserPosition(), loadUserPoolPositions(), loadOrderbook()]);
                    }
                });
            } catch (e) {
                if (!isUserRejection(e)) console.error('Limit order error:', e);
            }
            limitMaxRaw = null; // Clear max flag regardless of outcome
        }

        // ======================== APPROVALS ========================
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                let success = false;
                await monitorTransaction(contract.setOperator(operatorAddress, true), {
                    pending: { title: `Approving ${operatorName}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Approving ${operatorName}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Approved!', body: `${operatorName} can now manage your shares` },
                    error: { title: 'Approval Failed', body: '' },
                    onSuccess: () => { success = true; }
                });

                return success;
            } catch (e) {
                if (!isUserRejection(e)) console.error('Approval error:', e);
                return false;
            }
        }

        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error');
                return false;
            }

            // MasterRouter needs operator on PAMM for: sell, limit orders (depositSharesToPool)
            if (operation === 'sell' || operation === 'limit') {
                return await ensureOperatorApproval('pamm', MASTERROUTER_ADDRESS, 'MasterRouter');
            }

            // PAMM needs operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                return await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
            }

            // ZAMM needs operator on PAMM for: swap
            if (operation === 'swap') {
                return await ensureOperatorApproval('pamm', ZAMM_ADDRESS, 'ZAMM');
            }

            // PMHookRouter needs operator on PAMM for: LP via vault
            if (operation === 'lp_vault') {
                return await ensureOperatorApproval('pamm', PMHOOKROUTER_ADDRESS, 'PMHookRouter');
            }

            return true;
        }

        // ======================== TX MONITORING ========================
        async function monitorTransaction(txPromise, options = {}) {
            const {
                pending = { title: 'Transaction Pending', body: 'Confirm in your wallet...' },
                submitted = { title: 'Transaction Submitted', body: 'Waiting for confirmation...' },
                success = { title: 'Transaction Confirmed', body: '' },
                error = { title: 'Transaction Failed', body: '' },
                onSuccess = null
            } = options;

            const toastId = showToast(pending.title, pending.body, 'pending');
            let txHash = null;

            try {
                const tx = await txPromise;
                txHash = tx.hash;
                const etherscanLink = `<a href="https://etherscan.io/tx/${txHash}" target="_blank" style="color:var(--blue);">View on Etherscan</a>`;
                updateToast(toastId, submitted.title, `${submitted.body}<br>${etherscanLink}`, 'pending');

                // Wait for confirmation using dedicated RPC
                const rpc = await getRpcProvider();
                const receipt = await Promise.race([
                    rpc.waitForTransaction(txHash, 1, 60000),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 65000))
                ]);

                if (receipt && Number(receipt.status) === 1) {
                    updateToast(toastId, success.title, `${success.body}${success.body ? '<br>' : ''}${etherscanLink}`, 'success', 5000);
                    invalidatePositionCache(); // Clear cached positions after successful tx
                    if (onSuccess) await onSuccess(receipt);
                    return receipt;
                } else if (receipt && Number(receipt.status) === 0) {
                    updateToast(toastId, error.title, `Transaction reverted<br>${etherscanLink}`, 'error', 8000);
                    throw new Error('Transaction reverted');
                } else {
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded<br>${etherscanLink}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                }
            } catch (e) {
                console.error('Transaction error:', e);
                if (isUserRejection(e)) {
                    updateToast(toastId, 'Transaction Cancelled', 'You rejected the transaction', 'error', 4000);
                } else if (e.message === 'timeout') {
                    const etherscanLink = txHash ? `<a href="https://etherscan.io/tx/${txHash}" target="_blank" style="color:var(--blue);">View on Etherscan</a>` : '';
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded${etherscanLink ? '<br>' + etherscanLink : ''}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                } else {
                    const errMsg = e.reason || e.message || 'Unknown error';
                    updateToast(toastId, error.title, errMsg.slice(0, 100), 'error', 8000);
                }
                throw e;
            }
        }

        // ======================== MARKET CREATION ========================
        function updateCreatePreview() {
            const threshold = document.getElementById('createThreshold').value || '40';
            const deadlineSelect = document.getElementById('createDeadline').value;
            const canClose = document.getElementById('createCanClose').value === 'true';

            document.getElementById('customDeadlineGroup').style.display = deadlineSelect === 'custom' ? 'block' : 'none';

            let deadlineStr = 'Dec 31, 2026';
            if (deadlineSelect === 'custom') {
                const customTs = document.getElementById('createCustomDeadline').value;
                if (customTs) {
                    deadlineStr = new Date(parseInt(customTs) * 1000).toUTCString();
                }
            }

            document.getElementById('createPreview').textContent =
                `Uniswap V4 protocolFeeController() != 0 by ${deadlineStr}` +
                (canClose ? ' (may close early)' : '');
        }

        // ======================== MARKET TAB SWITCHING ========================
        function switchMarketTab(tab) {
            const tabs = document.querySelectorAll('.market-tab');
            const creators = {
                feeSwitch: document.getElementById('creatorFeeSwitch'),
                uniBalance: document.getElementById('creatorUniBalance'),
                uniVotes: document.getElementById('creatorUniVotes'),
                totalSupply: document.getElementById('creatorTotalSupply'),
                uniPrice: document.getElementById('creatorUniPrice')
            };

            tabs.forEach(t => t.classList.remove('active'));
            Object.values(creators).forEach(c => c && (c.style.display = 'none'));

            if (tab === 'feeSwitch') {
                document.getElementById('tabFeeSwitch').classList.add('active');
                creators.feeSwitch.style.display = 'block';
            } else if (tab === 'uniBalance') {
                document.getElementById('tabUniBalance').classList.add('active');
                creators.uniBalance.style.display = 'block';
                updateUniBalancePreview();
            } else if (tab === 'uniVotes') {
                document.getElementById('tabUniVotes').classList.add('active');
                creators.uniVotes.style.display = 'block';
                updateUniVotesPreview();
            } else if (tab === 'totalSupply') {
                document.getElementById('tabTotalSupply').classList.add('active');
                creators.totalSupply.style.display = 'block';
                fetchAndDisplayTotalSupply();
                updateTotalSupplyPreview();
            } else if (tab === 'uniPrice') {
                document.getElementById('tabUniPrice').classList.add('active');
                creators.uniPrice.style.display = 'block';
                fetchAndDisplayCurrentUniPrice();
                updateUniPricePreview();
            }
        }

        // ======================== ENS RESOLUTION ========================
        let resolvedTargetAddress = null;

        async function resolveENS(input) {
            if (!input) return;

            const resolvedDiv = document.getElementById('resolvedAddress');
            const resolvedText = document.getElementById('resolvedAddressText');

            // If already a valid address
            if (input.startsWith('0x') && input.length === 42) {
                resolvedTargetAddress = input;
                resolvedDiv.style.display = 'none';
                updateUniBalancePreview();
                return;
            }

            // Try ENS resolution
            if (input.includes('.eth')) {
                try {
                    resolvedDiv.style.display = 'block';
                    resolvedText.textContent = 'Resolving ENS...';
                    resolvedText.style.color = 'var(--text-muted)';

                    const rpc = await getReadProvider();
                    const address = await rpc.resolveName(input);

                    if (address) {
                        resolvedTargetAddress = address;
                        resolvedText.textContent = `‚úì Resolved to ${address.slice(0, 6)}...${address.slice(-4)}`;
                        resolvedText.style.color = 'var(--green)';
                    } else {
                        resolvedTargetAddress = null;
                        resolvedText.textContent = '‚úó ENS name not found';
                        resolvedText.style.color = 'var(--red)';
                    }
                    updateUniBalancePreview();
                } catch (error) {
                    console.error('ENS resolution error:', error);
                    resolvedText.textContent = '‚úó Failed to resolve ENS';
                    resolvedText.style.color = 'var(--red)';
                    resolvedTargetAddress = null;
                }
            } else {
                resolvedDiv.style.display = 'none';
                resolvedTargetAddress = null;
            }
        }

        // ======================== PREVIEW UPDATES ========================
        function updateUniBalancePreview() {
            const address = document.getElementById('createTargetAddress').value;
            const operator = document.getElementById('createOperator').value;
            const threshold = document.getElementById('createUniThreshold').value;
            const deadlineSelect = document.getElementById('createDeadlineUniBalance').value;

            const opSymbols = { '1': '>', '2': '<', '3': '>=', '4': '<=' };
            const opSym = opSymbols[operator] || '>';

            let deadlineStr = 'Dec 31, 2026';
            if (deadlineSelect === 'custom') {
                const customTs = document.getElementById('createCustomDeadlineUniBalance').value;
                if (customTs) {
                    const date = new Date(parseInt(customTs) * 1000);
                    deadlineStr = date.toUTCString();
                }
            }

            const addrDisplay = resolvedTargetAddress
                ? `${resolvedTargetAddress.slice(0, 6)}...${resolvedTargetAddress.slice(-4)}`
                : (address || '[address]');

            const thresholdDisplay = threshold
                ? parseFloat(threshold).toLocaleString('en-US', { maximumFractionDigits: 2 })
                : '[amount]';

            document.getElementById('createPreviewUniBalance').textContent =
                `UNI balance of ${addrDisplay} ${opSym} ${thresholdDisplay} by ${deadlineStr}`;
        }

        // Attach preview updates
        setTimeout(() => {
            if (document.getElementById('createTargetAddress')) {
                document.getElementById('createTargetAddress').addEventListener('input', updateUniBalancePreview);
                document.getElementById('createOperator').addEventListener('change', updateUniBalancePreview);
                document.getElementById('createUniThreshold').addEventListener('input', updateUniBalancePreview);
                document.getElementById('createDeadlineUniBalance').addEventListener('change', updateUniBalancePreview);
                document.getElementById('createCustomDeadlineUniBalance').addEventListener('input', updateUniBalancePreview);
            }
        }, 100);

        // ======================== COLLATERAL HELPERS ========================
        function getCollateralSymbol(collateralAddress) {
            if (!collateralAddress || collateralAddress === ethers.ZeroAddress) {
                return 'ETH';
            }
            return 'UNI';
        }

        function getCollateralIcon(collateralAddress, size = '16') {
            const isETH = !collateralAddress || collateralAddress === ethers.ZeroAddress;

            if (isETH) {
                // ETH icon
                return `<svg width="${size}" height="${size}" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></svg>`;
            } else {
                // UNI icon
                return `<svg width="${size}" height="${size}" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;"><g fill="none" fill-rule="evenodd"><circle fill="#FF007A" fill-rule="nonzero" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M12.261 5.767c-.285-.044-.297-.05-.163-.07.046-.007.827.135 1.302.237.652.14 1.122.293 1.674.544.796.362 1.366.797 1.945 1.484.173.206.506.685.569.82.018.037-.01.054-.126.077-.438.087-.68.222-.938.523-.323.376-.471.76-.582 1.514-.071.48-.158.861-.307 1.342-.205.661-.432 1.093-.88 1.674-.561.729-.777.916-1.45 1.258-.696.354-1.35.507-2.261.529-.414.01-.52.023-.66.08-.23.094-.349.245-.398.504-.028.148-.028.445 0 .592.088.465.34.804.85 1.144.737.492.998.82 1.052 1.324.045.415-.036.746-.31 1.271-.421.808-.526 1.154-.597 1.968-.045.517-.108.756-.274.9-.172.149-.328.207-.755.276-.696.113-1.139.31-1.503.668-.316.31-.411.544-.414.98l-.002.294.177.19c.254.272 2.355 2.404 6.304 6.395l.106.107.212-.154c.116-.085.24-.177.274-.204.034-.027.096-.076.137-.11 3.708-4.327 5.624-6.555 5.746-6.682.2-.207.125-.484-.219-.805-.191-.178-.585-.301-.781-.244-.223.066-.474.21-.657.375-.129.117-.65.855-1.853 2.625-.903 1.33-1.672 2.444-1.712 2.476-.049.04-.048.038 1.618-2.634 1.046-1.68 1.4-2.27 1.4-2.332 0-.132-.05-.217-.272-.462-.37-.407-.535-.835-.655-1.697-.134-.963-.51-1.683-1.554-2.978-.61-.757-.71-.896-.865-1.204-.194-.386-.247-.603-.269-1.092-.023-.515.022-.849.18-1.342.138-.432.282-.717.65-1.288.318-.492.501-.858.501-1.002 0-.113.022-.113.515-.003 1.179-.265 2.136-.734 2.675-1.308.333-.356.411-.552.414-1.039.001-.318-.01-.384-.096-.568-.14-.297-.395-.546-.957-.93-.737-.504-1.051-.909-1.138-1.466-.072-.458.011-.78.419-1.634.421-.884.526-1.261.597-2.152.045-.576.108-.803.274-.985.172-.19.328-.255.755-.313.696-.095 1.139-.275 1.503-.61.316-.292.448-.573.468-.995l.016-.32-.177-.206c-.254-.296-2.355-2.614-6.304-6.956l-.106-.115-.212.165z"/><path d="M7.91 19.732c-.114-.145-.174-.331-.174-.546 0-.06.033-.104.108-.143.127-.065.136-.139.037-.288-.101-.152-.093-.286.023-.377.186-.146.45-.065.59.18.16.281-.015.65-.363.766-.157.052-.17.047-.22-.092zm5.524-7.176c-.327.1-.644.447-.743.81-.06.221-.026.61.064.73.145.194.286.245.666.242.744-.005 1.39-.324 1.466-.723.062-.327-.223-.78-.614-.98-.202-.102-.631-.143-.839-.079zm.87.68c.115-.163.064-.34-.13-.458-.372-.227-.934-.04-.934.312 0 .174.293.365.561.365.18 0 .424-.107.503-.219z"/></g></g></svg>`;
            }
        }

        // Custom collateral dropdown functions
        function createCollateralDropdown(id, marketType) {
            const ethIcon = getCollateralIcon(ethers.ZeroAddress, '18');
            const uniIcon = getCollateralIcon(UNI_TOKEN_ADDRESS, '18');

            return `
                <div class="collateral-dropdown" id="${id}Dropdown" data-value="eth" data-market-type="${marketType}">
                    <div class="collateral-dropdown-selected" onclick="toggleCollateralDropdown('${id}')">
                        <span class="collateral-dropdown-icon">${ethIcon}</span>
                        <span class="collateral-dropdown-text">ETH</span>
                        <span class="collateral-dropdown-arrow">‚ñº</span>
                    </div>
                    <div class="collateral-dropdown-options" id="${id}Options">
                        <div class="collateral-dropdown-option" onclick="selectCollateral('${id}', 'eth', '${marketType}')">
                            <span class="collateral-dropdown-icon">${ethIcon}</span>
                            <span>ETH</span>
                        </div>
                        <div class="collateral-dropdown-option" onclick="selectCollateral('${id}', 'uni', '${marketType}')">
                            <span class="collateral-dropdown-icon">${uniIcon}</span>
                            <span>UNI</span>
                        </div>
                    </div>
                </div>
            `;
        }

        function toggleCollateralDropdown(id) {
            const optionsEl = document.getElementById(`${id}Options`);
            const selectedEl = document.querySelector(`#${id}Dropdown .collateral-dropdown-selected`);

            // Close all other dropdowns first
            document.querySelectorAll('.collateral-dropdown-options').forEach(el => {
                if (el.id !== `${id}Options`) {
                    el.classList.remove('active');
                }
            });
            document.querySelectorAll('.collateral-dropdown-selected').forEach(el => {
                if (el !== selectedEl) {
                    el.classList.remove('active');
                }
            });

            // Toggle this dropdown
            optionsEl.classList.toggle('active');
            selectedEl.classList.toggle('active');
        }

        function selectCollateral(id, value, marketType) {
            const dropdown = document.getElementById(`${id}Dropdown`);
            const selectedEl = dropdown.querySelector('.collateral-dropdown-selected');
            const optionsEl = document.getElementById(`${id}Options`);

            const icon = value === 'eth'
                ? getCollateralIcon(ethers.ZeroAddress, '18')
                : getCollateralIcon(UNI_TOKEN_ADDRESS, '18');
            const text = value === 'eth' ? 'ETH' : 'UNI';

            // Update displayed value
            selectedEl.innerHTML = `
                <span class="collateral-dropdown-icon">${icon}</span>
                <span class="collateral-dropdown-text">${text}</span>
                <span class="collateral-dropdown-arrow">‚ñº</span>
            `;

            // Update stored value
            dropdown.dataset.value = value;

            // Close dropdown
            optionsEl.classList.remove('active');
            selectedEl.classList.remove('active');

            // Update seed label
            const seedLabel = document.getElementById(`seedLabel${marketType}`);
            if (seedLabel) {
                seedLabel.textContent = `Seed Liquidity (${text})`;
            }
        }

        // Get collateral value from custom dropdown
        function getCollateralValue(id) {
            const dropdown = document.getElementById(`${id}Dropdown`);
            return dropdown ? dropdown.dataset.value : 'eth';
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.collateral-dropdown')) {
                document.querySelectorAll('.collateral-dropdown-options').forEach(el => {
                    el.classList.remove('active');
                });
                document.querySelectorAll('.collateral-dropdown-selected').forEach(el => {
                    el.classList.remove('active');
                });
            }
        });

        function updateSeedLabel(marketType) {
            // This function is now handled by selectCollateral
            // Kept for backward compatibility
            const dropdown = document.getElementById(`createCollateral${marketType}Dropdown`);
            const seedLabel = document.getElementById(`seedLabel${marketType}`);

            if (dropdown && seedLabel) {
                const collateralType = dropdown.dataset.value === 'uni' ? 'UNI' : 'ETH';
                seedLabel.textContent = `Seed Liquidity (${collateralType})`;
            }
        }

        async function approveUNI(amount, spender = RESOLVER_ADDRESS) {
            if (!signer || !connectedAddress) {
                throw new Error('Wallet not connected');
            }

            try {
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, signer);

                // Check current allowance
                const currentAllowance = await uniToken.allowance(connectedAddress, spender);

                if (currentAllowance >= amount) {
                    return; // Already approved
                }

                showToast('Approval Required', 'Please approve UNI token spending...', 'pending');

                // Request approval for a large amount to avoid future approvals
                const approvalAmount = ethers.MaxUint256;
                const approveTx = await uniToken.approve(spender, approvalAmount);

                showToast('Approval Submitted', `<a href="https://etherscan.io/tx/${approveTx.hash}" target="_blank" style="color:var(--pink);">View on Etherscan ‚Üó</a>`, 'pending');

                await approveTx.wait();

                showToast('Approval Confirmed', 'UNI token approved. Proceeding...', 'success');

                // Update the approval amount in state if approving RESOLVER
                if (spender === RESOLVER_ADDRESS) {
                    uniApprovalAmount = approvalAmount;
                }

            } catch (error) {
                console.error('Approval failed:', error);
                throw new Error('UNI approval failed: ' + (error.message || 'Unknown error'));
            }
        }

        // ======================== PRICE FORMATTING UTILITIES ========================
        // Convert Chainlink oracle price (8 decimals) to USD display
        function formatOraclePrice(threshold) {
            return (Number(threshold) / 1e8).toFixed(2);
        }

        // Convert USD price to Chainlink oracle threshold (8 decimals)
        function usdToOracleThreshold(usdPrice) {
            return BigInt(Math.floor(parseFloat(usdPrice) * 1e8));
        }

        // Fetch current UNI price from Chainlink oracle
        async function fetchCurrentUniPrice() {
            try {
                const rpc = await getReadProvider();
                const oracleABI = ['function latestAnswer() external view returns (int256)'];
                const oracle = new ethers.Contract(CHAINLINK_UNI_USD_ORACLE, oracleABI, rpc);
                const price = await oracle.latestAnswer();
                return formatOraclePrice(price);
            } catch (error) {
                console.error('Failed to fetch UNI price:', error);
                return null;
            }
        }

        // Fetch and display current UNI price in UI
        async function fetchAndDisplayCurrentUniPrice() {
            const priceEl = document.getElementById('currentUniPrice');
            if (!priceEl) return;

            priceEl.value = 'Loading...';
            const price = await fetchCurrentUniPrice();

            if (price) {
                priceEl.value = `$${price}`;
            } else {
                priceEl.value = 'Failed to load';
            }
        }

        // Update UNI Price market preview
        function updateUniPricePreview() {
            const targetPrice = document.getElementById('createTargetPrice')?.value || '10.00';
            const operator = parseInt(document.getElementById('createPriceOperator')?.value || '3');
            const deadlineSelect = document.getElementById('createDeadlineUniPrice')?.value;
            const canClose = document.getElementById('createCanCloseUniPrice')?.value === 'true';

            const opSymbols = { 0: '<', 1: '>', 2: '<=', 3: '>=' };
            const opSym = opSymbols[operator] || '>=';

            let deadlineStr = 'Dec 31, 2026';
            if (deadlineSelect === 'custom') {
                const customTs = document.getElementById('createCustomDeadlineUniPrice')?.value;
                if (customTs) {
                    deadlineStr = new Date(parseInt(customTs) * 1000).toUTCString();
                }
            }

            const previewEl = document.getElementById('createPreviewUniPrice');
            if (previewEl) {
                previewEl.textContent = `UNI price ${opSym} $${targetPrice} by ${deadlineStr}` +
                    (canClose ? ' (may close early)' : '');
            }
        }

        // ======================== FEE SWITCH MARKET CREATION ========================
        async function createFeeSwitchMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            const collateralType = getCollateralValue('createCollateralFeeSwitch');
            const deadlineSelect = document.getElementById('createDeadlineFeeSwitch').value;
            const canClose = document.getElementById('createCanCloseFeeSwitch').value === 'true';
            const seedAmount = parseFloat(document.getElementById('createSeedFeeSwitch').value);

            if (!seedAmount || seedAmount < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eoy2026') {
                close = EOY_2026;
            } else {
                close = parseInt(document.getElementById('createCustomDeadlineFeeSwitch').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = collateralType === 'uni'
                    ? ethers.parseUnits(seedAmount.toString(), 18)
                    : ethers.parseEther(seedAmount.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // Handle UNI collateral approval
                if (collateralType === 'uni') {
                    if (uniBalance < seedWei) {
                        showToast('Insufficient Balance', `You only have ${ethers.formatUnits(uniBalance, 18)} UNI`, 'error');
                        btn.disabled = false;
                        btn.textContent = 'Create Fee Switch Market';
                        return;
                    }
                    await approveUNI(seedWei);
                }

                const callData = PROTOCOL_FEE_CONTROLLER_SELECTOR;
                const collateralAddress = collateralType === 'uni' ? UNI_TOKEN_ADDRESS : ethers.ZeroAddress;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                const observable = `Uniswap V4 protocolFeeController()`;

                const txOptions = collateralType === 'eth' ? { value: seedWei } : {};

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    collateralAddress,
                    UNIV4_ADDRESS,
                    callData,
                    4, // Op.NEQ (not equal to)
                    0n, // threshold: 0 (checking != 0)
                    BigInt(close),
                    canClose,
                    seedParams,
                    txOptions
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="color:var(--pink);">View on Etherscan ‚Üó</a>`, 'pending');

                const receipt = await tx.wait();

                showToast('Market Created', 'Your V4 fee switch market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                showToast('Error', error.message || 'Failed to create market', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Fee Switch Market';
            }
        }

        // ======================== UNI BALANCE MARKET CREATION ========================
        async function createUniBalanceMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            const collateralType = getCollateralValue('createCollateralUniBalance');
            const targetAddress = resolvedTargetAddress || document.getElementById('createTargetAddress').value;
            const operator = parseInt(document.getElementById('createOperator').value);
            const threshold = parseFloat(document.getElementById('createUniThreshold').value);
            const deadlineSelect = document.getElementById('createDeadlineUniBalance').value;
            const canClose = document.getElementById('createCanCloseUniBalance').value === 'true';
            const seedAmount = parseFloat(document.getElementById('createSeedUniBalance').value);

            if (!targetAddress || !ethers.isAddress(targetAddress)) {
                showToast('Invalid Address', 'Please enter a valid Ethereum address or ENS name', 'error');
                return;
            }

            if (!threshold || threshold <= 0) {
                showToast('Invalid Threshold', 'Please enter a valid UNI amount', 'error');
                return;
            }

            if (!seedAmount || seedAmount < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eoy2026') {
                close = EOY_2026;
            } else {
                close = parseInt(document.getElementById('createCustomDeadlineUniBalance').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = collateralType === 'uni'
                    ? ethers.parseUnits(seedAmount.toString(), 18)
                    : ethers.parseEther(seedAmount.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // Handle UNI collateral approval
                if (collateralType === 'uni') {
                    if (uniBalance < seedWei) {
                        showToast('Insufficient Balance', `You only have ${ethers.formatUnits(uniBalance, 18)} UNI`, 'error');
                        btn.disabled = false;
                        btn.textContent = 'Create UNI Balance Market';
                        return;
                    }
                    await approveUNI(seedWei);
                }

                // Convert threshold to wei (18 decimals)
                const thresholdWei = ethers.parseUnits(threshold.toString(), 18);

                // Encode callData: balanceOf(targetAddress)
                const callData = BALANCE_OF_SELECTOR + '000000000000000000000000' + targetAddress.slice(2).toLowerCase();

                const collateralAddress = collateralType === 'uni' ? UNI_TOKEN_ADDRESS : ethers.ZeroAddress;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                const opSymbols = { 1: '>', 2: '<', 3: '>=', 4: '<=' };
                const addrDisplay = `${targetAddress.slice(0, 6)}...${targetAddress.slice(-4)}`;
                const observable = `UNI balance of ${addrDisplay}`;

                const txOptions = collateralType === 'eth' ? { value: seedWei } : {};

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    collateralAddress,
                    UNI_TOKEN_ADDRESS,
                    callData,
                    operator, // Op enum value
                    thresholdWei,
                    BigInt(close),
                    canClose,
                    seedParams,
                    txOptions
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="color:var(--pink);">View on Etherscan ‚Üó</a>`, 'pending');

                const receipt = await tx.wait();

                showToast('Market Created', 'Your UNI balance market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                showToast('Error', error.message || 'Failed to create market', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create UNI Balance Market';
            }
        }

        // ======================== UNI VOTES ENS RESOLUTION ========================
        let resolvedTargetAddressVotes = null;

        async function resolveENSVotes(input) {
            if (!input) return;

            const resolvedDiv = document.getElementById('resolvedAddressVotes');
            const resolvedText = document.getElementById('resolvedAddressTextVotes');

            // If already a valid address
            if (input.startsWith('0x') && input.length === 42) {
                resolvedTargetAddressVotes = input;
                resolvedDiv.style.display = 'none';
                updateUniVotesPreview();
                return;
            }

            // Try ENS resolution
            if (input.includes('.eth')) {
                try {
                    resolvedDiv.style.display = 'block';
                    resolvedText.textContent = 'Resolving ENS...';
                    resolvedText.style.color = 'var(--text-muted)';

                    const rpc = await getReadProvider();
                    const address = await rpc.resolveName(input);

                    if (address) {
                        resolvedTargetAddressVotes = address;
                        resolvedText.textContent = `‚úì Resolved to ${address.slice(0, 6)}...${address.slice(-4)}`;
                        resolvedText.style.color = 'var(--green)';
                    } else {
                        resolvedTargetAddressVotes = null;
                        resolvedText.textContent = '‚úó ENS name not found';
                        resolvedText.style.color = 'var(--red)';
                    }
                    updateUniVotesPreview();
                } catch (error) {
                    console.error('ENS resolution error:', error);
                    resolvedText.textContent = '‚úó Failed to resolve ENS';
                    resolvedText.style.color = 'var(--red)';
                    resolvedTargetAddressVotes = null;
                }
            } else {
                resolvedDiv.style.display = 'none';
                resolvedTargetAddressVotes = null;
            }
        }

        // ======================== UNI VOTES PREVIEW ========================
        function updateUniVotesPreview() {
            const address = document.getElementById('createTargetAddressVotes')?.value;
            const operator = document.getElementById('createOperatorVotes')?.value;
            const threshold = document.getElementById('createUniVotesThreshold')?.value;
            const deadlineSelect = document.getElementById('createDeadlineUniVotes')?.value;

            const opSymbols = { '1': '>', '2': '<', '3': '>=', '4': '<=' };
            const opSym = opSymbols[operator] || '>';

            let deadlineStr = 'Dec 31, 2026';
            if (deadlineSelect === 'custom') {
                const customTs = document.getElementById('createCustomDeadlineUniVotes')?.value;
                if (customTs) {
                    const date = new Date(parseInt(customTs) * 1000);
                    deadlineStr = date.toUTCString();
                }
            }

            const addrDisplay = resolvedTargetAddressVotes
                ? `${resolvedTargetAddressVotes.slice(0, 6)}...${resolvedTargetAddressVotes.slice(-4)}`
                : (address || '[address]');

            const thresholdDisplay = threshold
                ? parseFloat(threshold).toLocaleString('en-US', { maximumFractionDigits: 2 })
                : '[amount]';

            const previewEl = document.getElementById('createPreviewUniVotes');
            if (previewEl) {
                previewEl.textContent =
                    `UNI voting power of ${addrDisplay} ${opSym} ${thresholdDisplay} by ${deadlineStr}`;
            }
        }

        // Attach preview updates for votes
        setTimeout(() => {
            const addressInput = document.getElementById('createTargetAddressVotes');
            const operatorSelect = document.getElementById('createOperatorVotes');
            const thresholdInput = document.getElementById('createUniVotesThreshold');
            const deadlineSelect = document.getElementById('createDeadlineUniVotes');
            const customDeadlineInput = document.getElementById('createCustomDeadlineUniVotes');

            if (addressInput) {
                addressInput.addEventListener('input', updateUniVotesPreview);
                operatorSelect.addEventListener('change', updateUniVotesPreview);
                thresholdInput.addEventListener('input', updateUniVotesPreview);
                deadlineSelect.addEventListener('change', updateUniVotesPreview);
                customDeadlineInput.addEventListener('input', updateUniVotesPreview);
            }
        }, 100);

        // ======================== UNI VOTES MARKET CREATION ========================
        async function createUniVotesMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            const collateralType = getCollateralValue('createCollateralUniVotes');
            const targetAddress = resolvedTargetAddressVotes || document.getElementById('createTargetAddressVotes').value;
            const operator = parseInt(document.getElementById('createOperatorVotes').value);
            const threshold = parseFloat(document.getElementById('createUniVotesThreshold').value);
            const deadlineSelect = document.getElementById('createDeadlineUniVotes').value;
            const canClose = document.getElementById('createCanCloseUniVotes').value === 'true';
            const seedAmount = parseFloat(document.getElementById('createSeedUniVotes').value);

            if (!targetAddress || !ethers.isAddress(targetAddress)) {
                showToast('Invalid Address', 'Please enter a valid Ethereum address or ENS name', 'error');
                return;
            }

            if (!threshold || threshold <= 0) {
                showToast('Invalid Threshold', 'Please enter a valid UNI voting power amount', 'error');
                return;
            }

            if (!seedAmount || seedAmount < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eoy2026') {
                close = EOY_2026;
            } else {
                close = parseInt(document.getElementById('createCustomDeadlineUniVotes').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = collateralType === 'uni'
                    ? ethers.parseUnits(seedAmount.toString(), 18)
                    : ethers.parseEther(seedAmount.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // Handle UNI collateral approval
                if (collateralType === 'uni') {
                    if (uniBalance < seedWei) {
                        showToast('Insufficient Balance', `You only have ${ethers.formatUnits(uniBalance, 18)} UNI`, 'error');
                        btn.disabled = false;
                        btn.textContent = 'Create Voting Power Market';
                        return;
                    }
                    await approveUNI(seedWei);
                }

                // Convert threshold to wei (18 decimals)
                const thresholdWei = ethers.parseUnits(threshold.toString(), 18);

                // Encode callData: getCurrentVotes(targetAddress)
                const callData = GET_CURRENT_VOTES_SELECTOR + '000000000000000000000000' + targetAddress.slice(2).toLowerCase();

                const collateralAddress = collateralType === 'uni' ? UNI_TOKEN_ADDRESS : ethers.ZeroAddress;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                const addrDisplay = `${targetAddress.slice(0, 6)}...${targetAddress.slice(-4)}`;
                const observable = `UNI votes of ${addrDisplay}`;

                const txOptions = collateralType === 'eth' ? { value: seedWei } : {};

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    collateralAddress,
                    UNI_TOKEN_ADDRESS,
                    callData,
                    operator, // Op enum value
                    thresholdWei,
                    BigInt(close),
                    canClose,
                    seedParams,
                    txOptions
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="color:var(--pink);">View on Etherscan ‚Üó</a>`, 'pending');

                const receipt = await tx.wait();

                showToast('Market Created', 'Your UNI voting power market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                showToast('Error', error.message || 'Failed to create market', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Voting Power Market';
            }
        }

        // ======================== TOTAL SUPPLY FETCHING ========================
        let cachedTotalSupply = null;

        async function fetchAndDisplayTotalSupply() {
            const supplyInput = document.getElementById('currentTotalSupply');
            if (!supplyInput) return;

            try {
                supplyInput.value = 'Loading...';
                const rpc = await getReadProvider();
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, rpc);
                const supply = await uniToken.totalSupply();
                cachedTotalSupply = supply;
                const formatted = ethers.formatUnits(supply, 18);
                supplyInput.value = parseFloat(formatted).toLocaleString('en-US', { maximumFractionDigits: 2 }) + ' UNI';
                updateTotalSupplyPreview();
            } catch (error) {
                console.error('Failed to fetch totalSupply:', error);
                supplyInput.value = 'Error fetching supply';
                cachedTotalSupply = null;
            }
        }

        // ======================== TOTAL SUPPLY PREVIEW ========================
        function updateTotalSupplyPreview() {
            const marketType = document.getElementById('createSupplyMarketType')?.value;
            const deadlineSelect = document.getElementById('createDeadlineTotalSupply')?.value;

            const opSym = marketType === 'eq' ? '==' : '!=';

            let deadlineStr = 'Dec 31, 2026';
            if (deadlineSelect === 'custom') {
                const customTs = document.getElementById('createCustomDeadlineTotalSupply')?.value;
                if (customTs) {
                    const date = new Date(parseInt(customTs) * 1000);
                    deadlineStr = date.toUTCString();
                }
            }

            let supplyDisplay = '[current]';
            if (cachedTotalSupply) {
                const formatted = ethers.formatUnits(cachedTotalSupply, 18);
                supplyDisplay = parseFloat(formatted).toLocaleString('en-US', { maximumFractionDigits: 2 });
            }

            const previewEl = document.getElementById('createPreviewTotalSupply');
            if (previewEl) {
                previewEl.textContent = `UNI totalSupply() ${opSym} ${supplyDisplay} by ${deadlineStr}`;
            }
        }

        // Attach preview updates for totalSupply
        setTimeout(() => {
            const marketTypeSelect = document.getElementById('createSupplyMarketType');
            const deadlineSelect = document.getElementById('createDeadlineTotalSupply');
            const customDeadlineInput = document.getElementById('createCustomDeadlineTotalSupply');

            if (marketTypeSelect) {
                marketTypeSelect.addEventListener('change', updateTotalSupplyPreview);
                deadlineSelect.addEventListener('change', updateTotalSupplyPreview);
                customDeadlineInput.addEventListener('input', updateTotalSupplyPreview);
            }
        }, 100);

        // ======================== TOTAL SUPPLY MARKET CREATION ========================
        async function createTotalSupplyMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            if (!cachedTotalSupply) {
                showToast('Supply Not Loaded', 'Please wait for current supply to load', 'error');
                return;
            }

            const collateralType = getCollateralValue('createCollateralTotalSupply');
            const marketType = document.getElementById('createSupplyMarketType').value;
            const operator = marketType === 'eq' ? 4 : 5; // EQ = 4, NEQ = 5
            const threshold = cachedTotalSupply;
            const deadlineSelect = document.getElementById('createDeadlineTotalSupply').value;
            const canClose = document.getElementById('createCanCloseTotalSupply').value === 'true';
            const seedAmount = parseFloat(document.getElementById('createSeedTotalSupply').value);

            if (!seedAmount || seedAmount < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eoy2026') {
                close = EOY_2026;
            } else {
                close = parseInt(document.getElementById('createCustomDeadlineTotalSupply').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = collateralType === 'uni'
                    ? ethers.parseUnits(seedAmount.toString(), 18)
                    : ethers.parseEther(seedAmount.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // Handle UNI collateral approval
                if (collateralType === 'uni') {
                    if (uniBalance < seedWei) {
                        showToast('Insufficient Balance', `You only have ${ethers.formatUnits(uniBalance, 18)} UNI`, 'error');
                        btn.disabled = false;
                        btn.textContent = 'Create Supply Market';
                        return;
                    }
                    await approveUNI(seedWei);
                }

                // callData for totalSupply() - no parameters needed
                const callData = TOTAL_SUPPLY_SELECTOR;

                const collateralAddress = collateralType === 'uni' ? UNI_TOKEN_ADDRESS : ethers.ZeroAddress;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                const formatted = ethers.formatUnits(threshold, 18);
                const opLabel = marketType === 'eq' ? 'stays at' : 'changes from';
                const observable = `UNI supply ${opLabel} ${parseFloat(formatted).toLocaleString('en-US', { maximumFractionDigits: 2 })}`;

                const txOptions = collateralType === 'eth' ? { value: seedWei } : {};

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    collateralAddress,
                    UNI_TOKEN_ADDRESS,
                    callData,
                    operator, // Op enum value (EQ=4 or NEQ=5)
                    threshold,
                    BigInt(close),
                    canClose,
                    seedParams,
                    txOptions
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="color:var(--pink);">View on Etherscan ‚Üó</a>`, 'pending');

                const receipt = await tx.wait();

                showToast('Market Created', 'Your total supply market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                showToast('Error', error.message || 'Failed to create market', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Supply Market';
            }
        }

        // ======================== UNI PRICE MARKET CREATION ========================
        async function createUniPriceMarket() {
            if (!signer) {
                showWalletModal();
                return;
            }

            const collateralType = getCollateralValue('createCollateralUniPrice');
            const targetPrice = parseFloat(document.getElementById('createTargetPrice').value);
            const operator = parseInt(document.getElementById('createPriceOperator').value);
            const deadlineSelect = document.getElementById('createDeadlineUniPrice').value;
            const canClose = document.getElementById('createCanCloseUniPrice').value === 'true';
            const seedAmount = parseFloat(document.getElementById('createSeedUniPrice').value);

            if (!targetPrice || targetPrice <= 0) {
                showToast('Invalid Target Price', 'Please enter a valid USD price', 'error');
                return;
            }

            if (!seedAmount || seedAmount < 0.001) {
                showToast('Invalid Seed', 'Please enter at least 0.001', 'error');
                return;
            }

            let close;
            if (deadlineSelect === 'eoy2026') {
                close = EOY_2026;
            } else {
                close = parseInt(document.getElementById('createCustomDeadlineUniPrice').value);
                if (!close || close <= Math.floor(Date.now() / 1000)) {
                    showToast('Invalid Deadline', 'Deadline must be in the future', 'error');
                    return;
                }
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Creating...';

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);
                const seedWei = collateralType === 'uni'
                    ? ethers.parseUnits(seedAmount.toString(), 18)
                    : ethers.parseEther(seedAmount.toString());
                const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour

                // Handle UNI collateral approval
                if (collateralType === 'uni') {
                    if (uniBalance < seedWei) {
                        showToast('Insufficient Balance', `You only have ${ethers.formatUnits(uniBalance, 18)} UNI`, 'error');
                        btn.disabled = false;
                        btn.textContent = 'Create Price Market';
                        return;
                    }
                    await approveUNI(seedWei);
                }

                // Convert USD price to 8-decimal threshold (Chainlink format)
                const threshold = usdToOracleThreshold(targetPrice);

                // callData for latestAnswer() - no parameters needed
                const callData = LATEST_ANSWER_SELECTOR;

                const collateralAddress = collateralType === 'uni' ? UNI_TOKEN_ADDRESS : ethers.ZeroAddress;

                const seedParams = {
                    collateralIn: seedWei,
                    feeOrHook: FEE_TIER,
                    amount0Min: 0n,
                    amount1Min: 0n,
                    minLiquidity: 0n,
                    lpRecipient: connectedAddress,
                    deadline: BigInt(deadline)
                };

                showToast('Transaction Pending', 'Please confirm in your wallet...', 'pending');

                const opSymbols = { 0: '<', 1: '>', 2: '<=', 3: '>=' };
                const opSym = opSymbols[operator] || '>=';
                const observable = `UNI price ${opSym} $${targetPrice.toFixed(2)}`;

                const txOptions = collateralType === 'eth' ? { value: seedWei } : {};

                const tx = await resolver.createNumericMarketAndSeed(
                    observable,
                    collateralAddress,
                    CHAINLINK_UNI_USD_ORACLE, // target = Chainlink oracle
                    callData,
                    operator, // Op enum value (LT=0, GT=1, LTE=2, GTE=3)
                    threshold,
                    BigInt(close),
                    canClose,
                    seedParams,
                    txOptions
                );

                showToast('Transaction Submitted', `<a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="color:var(--pink);">View on Etherscan ‚Üó</a>`, 'pending');

                const receipt = await tx.wait();

                showToast('Market Created', 'Your UNI price market is now live!', 'success');
                await loadData();

            } catch (error) {
                console.error('Create failed:', error);
                showToast('Error', error.message || 'Failed to create market', 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Create Price Market';
            }
        }

        // ======================== RESOLUTION ========================
        async function resolveMarket(marketId) {
            if (!signer) {
                showWalletModal();
                return;
            }

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);

                await monitorTransaction(
                    resolver.resolveMarket(marketId),
                    {
                        pending: { title: 'Resolving Market', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Resolving Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Resolved!', body: 'The market has been resolved' },
                        error: { title: 'Resolution Failed', body: '' },
                        onSuccess: () => loadData()
                    }
                );

            } catch (error) {
                console.error('Resolution failed:', error);
            }
        }

        // ======================== UTILITIES ========================
        function formatEth(wei) {
            if (typeof wei === 'bigint') {
                return (Number(wei) / 1e18).toFixed(4);
            }
            return '0.0000';
        }

        function formatSupplyShorthand(supply) {
            // Convert BigInt to number (in base units, e.g., 1B UNI = 1e27 wei)
            const num = Number(ethers.formatUnits(supply, 18));

            if (num >= 1e9) {
                // Billions
                return (num / 1e9).toFixed(2) + 'B';
            } else if (num >= 1e6) {
                // Millions
                return (num / 1e6).toFixed(2) + 'M';
            } else if (num >= 1e3) {
                // Thousands
                return (num / 1e3).toFixed(2) + 'K';
            } else {
                return num.toFixed(2);
            }
        }

        function formatCountdown(seconds) {
            if (seconds <= 0) return 'Ended';

            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            return `${mins}m`;
        }

        function formatDate(unixTimestamp) {
            const date = new Date(unixTimestamp * 1000);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        function escapeHtml(str) {
            return str.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
        }

        function truncateId(id) {
            if (id.length <= 12) return id;
            return id.slice(0, 6) + '...' + id.slice(-4);
        }

        function showToast(title, message, type = 'info', duration = 5000) {
            const id = ++toastIdCounter;
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.dataset.toastId = id;

            const icons = { pending: '‚è≥', success: '‚úì', error: '‚úï', info: '‚Ñπ' };

            toast.innerHTML = `
                <div class="toast-header">
                    <span class="icon">${icons[type] || icons.info}</span>
                    <span class="toast-title">${title}</span>
                </div>
                <div class="toast-body">${message}</div>
            `;

            container.appendChild(toast);
            pendingToasts.set(id, toast);

            if (type !== 'pending') {
                setTimeout(() => {
                    toast.classList.add('hiding');
                    setTimeout(() => {
                        toast.remove();
                        pendingToasts.delete(id);
                    }, 300);
                }, duration);
            } else {
                // Auto-cleanup pending toasts after 70s (just after tx monitor's 60s timeout)
                setTimeout(() => {
                    if (pendingToasts.has(id)) {
                        updateToast(id, 'Timeout', 'Transaction may still be pending. Check Etherscan.', 'info', 8000);
                    }
                }, 70000);
            }

            return id;
        }

        function updateToast(toastId, title, message, type = 'info', duration = 5000) {
            const toast = pendingToasts.get(toastId);
            if (!toast) return;

            const icons = { pending: '‚è≥', success: '‚úì', error: '‚úï', info: '‚Ñπ' };
            toast.className = `toast ${type}`;

            const titleEl = toast.querySelector('.toast-title');
            const bodyEl = toast.querySelector('.toast-body');
            const iconEl = toast.querySelector('.icon');

            if (titleEl) titleEl.textContent = title;
            if (bodyEl) bodyEl.innerHTML = message;
            if (iconEl) iconEl.textContent = icons[type] || icons.info;

            if (type !== 'pending' && duration > 0) {
                setTimeout(() => {
                    toast.classList.add('hiding');
                    setTimeout(() => {
                        toast.remove();
                        pendingToasts.delete(toastId);
                    }, 300);
                }, duration);
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
