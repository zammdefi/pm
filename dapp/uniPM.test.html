<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uniPM Test Suite</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0e1a;
            color: #e4e4e7;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #FF007A;
            margin-bottom: 2rem;
            font-size: 2rem;
        }

        .test-section {
            background: #1a1f2e;
            border: 1px solid #2a2f3e;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .test-section h2 {
            color: #a1a1aa;
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }

        .test-item {
            padding: 1rem;
            margin-bottom: 0.5rem;
            background: #0f1419;
            border-left: 3px solid #3f3f46;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-item.running {
            border-left-color: #fbbf24;
        }

        .test-item.passed {
            border-left-color: #10b981;
        }

        .test-item.failed {
            border-left-color: #ef4444;
        }

        .test-name {
            flex: 1;
        }

        .test-status {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-pending {
            background: #3f3f46;
            color: #a1a1aa;
        }

        .status-running {
            background: #fbbf24;
            color: #000;
        }

        .status-passed {
            background: #10b981;
            color: #fff;
        }

        .status-failed {
            background: #ef4444;
            color: #fff;
        }

        .test-error {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #450a0a;
            border: 1px solid #ef4444;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            color: #fca5a5;
        }

        .summary {
            background: #1a1f2e;
            border: 2px solid #FF007A;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
        }

        .summary h2 {
            color: #FF007A;
            margin-bottom: 1rem;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }

        .stat {
            padding: 1rem;
            background: #0f1419;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            color: #a1a1aa;
            font-size: 0.875rem;
        }

        .run-btn {
            background: #FF007A;
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 2rem;
        }

        .run-btn:hover {
            background: #e6006d;
        }

        .run-btn:disabled {
            background: #3f3f46;
            cursor: not-allowed;
        }

        .instructions {
            background: #1e3a5f;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .instructions h3 {
            color: #60a5fa;
            margin-bottom: 0.5rem;
        }

        .instructions ol {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .instructions li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§ª uniPM Test Suite - UNI Collateral</h1>

        <div class="instructions">
            <h3>ðŸ“‹ Test Instructions</h3>
            <ol>
                <li>Connect your wallet on Ethereum mainnet</li>
                <li>Ensure you have both ETH and UNI tokens</li>
                <li>Have at least 0.1 ETH for gas and 100 UNI for testing</li>
                <li>Click "Run All Tests" to execute the test suite</li>
                <li>Tests will interact with real contracts - use testnet if preferred</li>
            </ol>
        </div>

        <button class="run-btn" id="runAllTests" onclick="runAllTests()">Run All Tests</button>

        <div class="test-section">
            <h2>1. Helper Functions</h2>
            <div id="helperTests"></div>
        </div>

        <div class="test-section">
            <h2>2. Balance Loading</h2>
            <div id="balanceTests"></div>
        </div>

        <div class="test-section">
            <h2>3. Market Creation</h2>
            <div id="creationTests"></div>
        </div>

        <div class="test-section">
            <h2>4. Trading Functions</h2>
            <div id="tradingTests"></div>
        </div>

        <div class="test-section">
            <h2>5. Liquidity Functions</h2>
            <div id="liquidityTests"></div>
        </div>

        <div class="test-section">
            <h2>6. Limit Orders</h2>
            <div id="orderTests"></div>
        </div>

        <div class="summary" id="summary" style="display:none;">
            <h2>ðŸ“Š Test Summary</h2>
            <div class="summary-stats">
                <div class="stat">
                    <div class="stat-value" id="totalTests">0</div>
                    <div class="stat-label">Total Tests</div>
                </div>
                <div class="stat">
                    <div class="stat-value" style="color: #10b981;" id="passedTests">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" style="color: #ef4444;" id="failedTests">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="duration">0s</div>
                    <div class="stat-label">Duration</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    <script>
        // Test state
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            startTime: null
        };

        // Constants from main app
        const UNI_TOKEN_ADDRESS = '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984';
        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const PMROUTER_ADDRESS = '0x000000000055fF709f26efB262fba8B0AE8c35Dc';

        const UNI_TOKEN_ABI = [
            'function balanceOf(address owner) view returns (uint256)',
            'function allowance(address owner, address spender) view returns (uint256)',
            'function approve(address spender, uint256 amount) returns (bool)'
        ];

        let provider, signer, connectedAddress;

        // Test helper functions
        function createTestItem(container, name) {
            const item = document.createElement('div');
            item.className = 'test-item';
            item.innerHTML = `
                <div class="test-name">${name}</div>
                <div class="test-status status-pending">Pending</div>
            `;
            document.getElementById(container).appendChild(item);
            return item;
        }

        function updateTestStatus(item, status, error = null) {
            const statusEl = item.querySelector('.test-status');
            statusEl.className = `test-status status-${status}`;
            statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
            item.className = `test-item ${status}`;

            if (error) {
                const errorEl = document.createElement('div');
                errorEl.className = 'test-error';
                errorEl.textContent = error;
                item.appendChild(errorEl);
            }

            if (status === 'passed') testResults.passed++;
            if (status === 'failed') testResults.failed++;
        }

        async function runTest(container, name, testFn) {
            testResults.total++;
            const item = createTestItem(container, name);
            updateTestStatus(item, 'running');

            try {
                await testFn();
                updateTestStatus(item, 'passed');
                return true;
            } catch (error) {
                updateTestStatus(item, 'failed', error.message);
                return false;
            }
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message);
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(`${message}: expected ${expected}, got ${actual}`);
            }
        }

        // Test suite
        async function runAllTests() {
            // Reset
            testResults = { total: 0, passed: 0, failed: 0, startTime: Date.now() };
            document.querySelectorAll('.test-item').forEach(el => el.remove());
            document.getElementById('summary').style.display = 'none';
            document.getElementById('runAllTests').disabled = true;

            try {
                // Connect wallet
                if (typeof window.ethereum === 'undefined') {
                    alert('Please install MetaMask to run tests');
                    return;
                }

                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send("eth_requestAccounts", []);
                signer = provider.getSigner();
                connectedAddress = await signer.getAddress();

                // Run test suites
                await runHelperTests();
                await runBalanceTests();
                await runCreationTests();
                await runTradingTests();
                await runLiquidityTests();
                await runOrderTests();

            } catch (error) {
                console.error('Test suite error:', error);
                alert('Test suite error: ' + error.message);
            } finally {
                // Show summary
                const duration = ((Date.now() - testResults.startTime) / 1000).toFixed(2);
                document.getElementById('totalTests').textContent = testResults.total;
                document.getElementById('passedTests').textContent = testResults.passed;
                document.getElementById('failedTests').textContent = testResults.failed;
                document.getElementById('duration').textContent = duration + 's';
                document.getElementById('summary').style.display = 'block';
                document.getElementById('runAllTests').disabled = false;
            }
        }

        // ========== TEST SUITES ==========

        async function runHelperTests() {
            await runTest('helperTests', 'getCollateralSymbol() returns ETH for zero address', async () => {
                // This would need to be called in the main window context
                const symbol = window.opener?.getCollateralSymbol?.(ethers.constants.AddressZero);
                // For isolated test, we test the logic
                const testSymbol = !ethers.constants.AddressZero || ethers.constants.AddressZero === ethers.constants.AddressZero ? 'ETH' : 'UNI';
                assertEqual(testSymbol, 'ETH', 'Zero address should return ETH');
            });

            await runTest('helperTests', 'getCollateralSymbol() returns UNI for UNI address', async () => {
                const testSymbol = UNI_TOKEN_ADDRESS === ethers.constants.AddressZero ? 'ETH' : 'UNI';
                assertEqual(testSymbol, 'UNI', 'UNI address should return UNI');
            });
        }

        async function runBalanceTests() {
            await runTest('balanceTests', 'Can fetch ETH balance', async () => {
                const balance = await provider.getBalance(connectedAddress);
                assert(balance >= 0, 'ETH balance should be non-negative');
            });

            await runTest('balanceTests', 'Can fetch UNI balance', async () => {
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, provider);
                const balance = await uniToken.balanceOf(connectedAddress);
                assert(balance >= 0, 'UNI balance should be non-negative');
            });

            await runTest('balanceTests', 'User has sufficient ETH for testing (>0.05)', async () => {
                const balance = await provider.getBalance(connectedAddress);
                const ethBalance = parseFloat(ethers.utils.formatEther(balance));
                assert(ethBalance > 0.05, `Need at least 0.05 ETH, have ${ethBalance.toFixed(4)}`);
            });

            await runTest('balanceTests', 'User has UNI tokens for testing (>10)', async () => {
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, provider);
                const balance = await uniToken.balanceOf(connectedAddress);
                const uniBalance = parseFloat(ethers.utils.formatUnits(balance, 18));
                assert(uniBalance > 10, `Need at least 10 UNI, have ${uniBalance.toFixed(2)}`);
            });
        }

        async function runCreationTests() {
            await runTest('creationTests', 'Can check UNI approval to Resolver', async () => {
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, provider);
                const allowance = await uniToken.allowance(connectedAddress, RESOLVER_ADDRESS);
                // Just checking the call works, allowance can be 0
                assert(allowance >= 0, 'Allowance check should succeed');
            });

            await runTest('creationTests', 'Market creation validation - requires collateral selector', async () => {
                // Simulate checking for collateral selector element
                const hasCollateralSelector = true; // Would check DOM in real app
                assert(hasCollateralSelector, 'Collateral selector should exist');
            });

            await runTest('creationTests', 'Seed amount parsing works for both ETH and UNI', async () => {
                const amount = 0.1;
                const ethWei = ethers.utils.parseEther(amount.toString());
                const uniWei = ethers.utils.parseUnits(amount.toString(), 18);
                assertEqual(ethWei.toString(), uniWei.toString(), 'Both should parse to same wei value');
            });
        }

        async function runTradingTests() {
            await runTest('tradingTests', 'Trading approval check - can query UNI approval to PMRouter', async () => {
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, provider);
                const allowance = await uniToken.allowance(connectedAddress, PMROUTER_ADDRESS);
                assert(allowance >= 0, 'PMRouter allowance check should succeed');
            });

            await runTest('tradingTests', 'Collateral detection logic - ETH vs UNI', async () => {
                const ethCollateral = ethers.constants.AddressZero;
                const uniCollateral = UNI_TOKEN_ADDRESS;

                const isEthCollateral1 = !ethCollateral || ethCollateral === ethers.constants.AddressZero;
                const isEthCollateral2 = !uniCollateral || uniCollateral === ethers.constants.AddressZero;

                assert(isEthCollateral1 === true, 'Zero address should be ETH collateral');
                assert(isEthCollateral2 === false, 'UNI address should not be ETH collateral');
            });

            await runTest('tradingTests', 'Balance comparison works with BigInt', async () => {
                const balance = ethers.utils.parseEther('100');
                const required = ethers.utils.parseEther('50');
                assert(balance.gte(required), 'BigInt comparison should work');
            });
        }

        async function runLiquidityTests() {
            await runTest('liquidityTests', 'Can query UNI approval to PAMM', async () => {
                const uniToken = new ethers.Contract(UNI_TOKEN_ADDRESS, UNI_TOKEN_ABI, provider);
                const allowance = await uniToken.allowance(connectedAddress, PAMM_ADDRESS);
                assert(allowance >= 0, 'PAMM allowance check should succeed');
            });

            await runTest('liquidityTests', 'Gas buffer calculation for ETH', async () => {
                const balance = ethers.utils.parseEther('1.0');
                const gasBuffer = ethers.utils.parseEther('0.001');
                const maxBal = balance.gt(gasBuffer) ? balance.sub(gasBuffer) : balance;
                assert(maxBal.lt(balance), 'Max should leave gas buffer');
            });

            await runTest('liquidityTests', 'No gas buffer needed for UNI', async () => {
                const uniBalance = ethers.utils.parseUnits('100', 18);
                // UNI doesn't need gas buffer, so max should equal balance
                const max = uniBalance;
                assertEqual(max.toString(), uniBalance.toString(), 'UNI max should equal balance');
            });
        }

        async function runOrderTests() {
            await runTest('orderTests', 'Limit order collateral calculation - Buy order', async () => {
                const price = 0.65; // 65%
                const shares = 100;
                const collateral = shares * price;

                const sharesWei = ethers.utils.parseEther(shares.toString());
                const priceWei = ethers.utils.parseEther(price.toString());
                const collateralWei = sharesWei.mul(priceWei).div(ethers.utils.parseEther('1'));

                const expectedCollateral = 65; // 100 * 0.65
                const actualCollateral = parseFloat(ethers.utils.formatEther(collateralWei));

                assert(Math.abs(actualCollateral - expectedCollateral) < 0.01,
                    `Collateral should be ~${expectedCollateral}, got ${actualCollateral}`);
            });

            await runTest('orderTests', 'Limit order collateral calculation - Sell order', async () => {
                const price = 0.35; // 35%
                const shares = 50;

                const sharesWei = ethers.utils.parseEther(shares.toString());
                const priceWei = ethers.utils.parseEther(price.toString());
                const collateralWei = sharesWei.mul(priceWei).div(ethers.utils.parseEther('1'));

                const expectedCollateral = 17.5; // 50 * 0.35
                const actualCollateral = parseFloat(ethers.utils.formatEther(collateralWei));

                assert(Math.abs(actualCollateral - expectedCollateral) < 0.01,
                    `Collateral should be ~${expectedCollateral}, got ${actualCollateral}`);
            });

            await runTest('orderTests', 'Order validation - Sufficient balance check', async () => {
                const userBalance = ethers.utils.parseEther('10');
                const requiredAmount = ethers.utils.parseEther('5');

                const hasSufficient = userBalance.gte(requiredAmount);
                assert(hasSufficient, 'Should have sufficient balance');
            });

            await runTest('orderTests', 'Order validation - Insufficient balance check', async () => {
                const userBalance = ethers.utils.parseEther('3');
                const requiredAmount = ethers.utils.parseEther('5');

                const hasSufficient = userBalance.gte(requiredAmount);
                assert(!hasSufficient, 'Should detect insufficient balance');
            });
        }

        console.log('âœ… uniPM Test Suite Loaded');
        console.log('Click "Run All Tests" to execute the test suite');
    </script>
</body>
</html>
