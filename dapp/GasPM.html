<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GasPM</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='600' fill='%2322c55e' text-anchor='middle'>Gas</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='600' fill='%233b82f6' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --amber: #f59e0b;
            --yellow: #eab308;
            --orange: #f97316;
            --gray: #27272a;
            --light-gray: #3f3f46;
            --black: #09090b;

            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--green); }

        .tagline {
            font-size: var(--font-xs);
            color: var(--text-dim);
            margin-left: 0.75rem;
        }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.green { color: var(--green); }
        .live-stat-value.cyan { color: var(--blue); }
        .live-stat-value.amber { color: var(--amber); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--green);
            color: var(--bg);
            border-color: var(--green);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* CHART SECTION */
        .chart-section {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            overflow: visible; /* Allow tooltips to extend beyond */
        }

        .chart-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius);
            height: 260px;
            position: relative;
            overflow: visible; /* Allow tooltips to extend beyond container */
        }

        .chart-canvas { width: 100%; height: 100%; }

        .chart-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
        }

        .chart-tooltip.visible { opacity: 1; }
        .chart-tooltip-time {
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .chart-tooltip-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .chart-tooltip-row:last-child { margin-bottom: 0; }
        .chart-tooltip-dot { width: 6px; height: 6px; border-radius: 50%; }
        .chart-tooltip-dot.spot { background: var(--green); }
        .chart-tooltip-dot.twap { background: var(--blue); }
        .chart-tooltip-key { color: var(--text-muted); flex: 1; }
        .chart-tooltip-val { font-weight: 600; font-variant-numeric: tabular-nums; }

        /* Prediction tooltip */
        .pred-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s, transform 0.15s;
            z-index: 110;
            min-width: 190px;
            transform: translateY(5px);
        }
        .pred-tooltip.visible { opacity: 1; transform: translateY(0); }
        .pred-tooltip-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .pred-tooltip-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 10px;
        }
        .pred-tooltip-title {
            font-weight: 500;
            color: var(--text);
        }
        .pred-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.35rem;
        }
        .pred-tooltip-row:last-child { margin-bottom: 0; }
        .pred-tooltip-label { color: var(--text-muted); }
        .pred-tooltip-value { font-weight: 600; font-variant-numeric: tabular-nums; }
        .pred-tooltip-direction {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 11px;
        }
        .pred-tooltip-direction.up { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
        .pred-tooltip-direction.down { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
        .pred-tooltip-direction.neutral { background: rgba(161, 161, 170, 0.15); color: #a1a1aa; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 1100px) { .bets-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .bets-grid { grid-template-columns: 1fr; } }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--green);
        }

        .bet-card.no-market { opacity: 0.5; }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
        }

        .bet-type.hourly { color: var(--amber); }
        .bet-type.daily { color: var(--green); }
        .bet-type.weekly { color: var(--blue); }
        .bet-type.extreme { color: var(--red); }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        /* Gas Comparison Display */
        .gas-compare {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .gas-compare-point { text-align: center; }

        .gas-compare-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .gas-compare-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .gas-compare-arrow { font-size: 1.25rem; }
        .gas-compare-arrow.up { color: var(--green); }
        .gas-compare-arrow.down { color: var(--red); }

        /* Progress Bar */
        .progress-container { margin-bottom: 1rem; }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .progress-bar {
            height: 8px;
            background: var(--surface-2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--amber), var(--red));
            border-radius: 4px;
            transition: width 0.5s;
        }

        .target-display {
            font-size: var(--font-2xl);
            font-weight: 700;
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--red);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { background: var(--surface-2); }

        .bet-btn.up { border-color: var(--green); }
        .bet-btn.up:hover { background: var(--green-dim); }
        .bet-btn.down { border-color: var(--red); }
        .bet-btn.down:hover { background: var(--red-dim); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.up .bet-btn-label { color: var(--green); }
        .bet-btn.down .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* Position Display */
        .position-display {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            font-size: var(--font-xs);
        }

        .position-row { display: flex; justify-content: space-between; }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .create-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1.25rem;
        }

        @media (max-width: 1100px) { .create-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .create-grid { grid-template-columns: 1fr; } }

        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--green);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        /* Orderbook - CEX/Polymarket Style */
        .orderbook {
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            overflow: hidden;
            border: 1px solid var(--border);
        }
        .orderbook-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--surface-2);
            border-bottom: 1px solid var(--border);
        }
        .orderbook-title-text {
            font-size: var(--font-xs);
            font-weight: 600;
            color: var(--text);
        }
        .orderbook-depth-info {
            font-size: 9px;
            color: var(--text-muted);
        }
        .orderbook-body {
            max-height: 220px;
            overflow-y: auto;
        }
        .orderbook-side {
            display: flex;
            flex-direction: column;
        }
        .orderbook-side.asks {
            flex-direction: column-reverse;
        }
        .orderbook-header {
            display: grid;
            grid-template-columns: 2fr 1.2fr 1.2fr;
            padding: 0.4rem 0.75rem;
            background: var(--surface);
            font-size: 9px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .orderbook-header span:last-child { text-align: right; }
        .orderbook-row {
            display: grid;
            grid-template-columns: 2fr 1.2fr 1.2fr;
            padding: 0.35rem 0.75rem;
            font-size: 11px;
            font-variant-numeric: tabular-nums;
            cursor: pointer;
            transition: background 0.1s;
            position: relative;
        }
        .orderbook-row::before {
            content: '';
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: var(--depth, 0%);
            opacity: 0.15;
            pointer-events: none;
            transition: width 0.2s;
        }
        .orderbook-row.ask::before { background: var(--red); }
        .orderbook-row.bid::before { background: var(--green); }
        .orderbook-row:hover { background: var(--surface-2); }
        .orderbook-row:hover::before { opacity: 0.25; }
        .orderbook-row.ask { color: var(--red); }
        .orderbook-row.bid { color: var(--green); }
        .orderbook-row .price { font-weight: 600; z-index: 1; }
        .orderbook-row .size { color: var(--text); z-index: 1; }
        .orderbook-row .total { color: var(--text-muted); text-align: right; z-index: 1; }
        .orderbook-row.mine { background: rgba(59, 130, 246, 0.1); }
        .orderbook-row.mine::after {
            content: 'YOU';
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            background: var(--blue);
            color: white;
            padding: 1px 4px;
            border-radius: 2px;
            font-weight: 600;
        }
        .orderbook-empty {
            padding: 1.5rem 1rem;
            text-align: center;
            color: var(--text-dim);
            font-size: var(--font-xs);
        }
        .orderbook-spread {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 0.75rem;
            background: var(--surface-2);
            font-size: 11px;
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        .orderbook-spread-left {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .orderbook-spread-price {
            font-weight: 700;
            font-size: 14px;
            color: var(--text);
        }
        .orderbook-spread-label {
            font-size: 9px;
            color: var(--text-dim);
        }
        .orderbook-spread-right {
            text-align: right;
            font-size: 10px;
        }
        .orderbook-spread-pct {
            color: var(--text-muted);
        }
        .orderbook-row.better-deal { background: rgba(34, 197, 94, 0.1); }
        .orderbook-row.better-deal:hover { background: rgba(34, 197, 94, 0.2); }
        .orderbook-row.better-deal .price { color: var(--green); }
        .orderbook-row.better-deal::before { background: var(--green); opacity: 0.2; }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-up { background: var(--green); color: var(--bg); }
        .trade-submit.buy-down { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* STATUS */
        .status-message {
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
            border-radius: var(--radius);
            display: none;
        }

        .status-message.show { display: block; }
        .status-message.pending { background: rgba(59, 130, 246, 0.15); color: var(--blue); }
        .status-message.success { background: var(--green-dim); color: var(--green); }
        .status-message.error { background: var(--red-dim); color: var(--red); }
        .status-message.info { background: rgba(255, 136, 0, 0.15); color: var(--orange); }

        /* Wallet Options */
        .wallet-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--gray);
            border: 1px solid var(--light-gray);
            border-radius: var(--radius);
            cursor: pointer;
            margin-bottom: var(--spacing-xs);
            transition: all 0.15s ease;
        }
        .wallet-option:hover { border-color: var(--green); }
        .wallet-option-icon { font-size: 1.5rem; }
        .wallet-option-name { font-weight: 600; }
        .wallet-option.disconnect {
            border-color: var(--red);
            color: var(--red);
            justify-content: center;
        }
        .wallet-option.disconnect:hover {
            background: var(--red);
            color: var(--black);
        }

        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 380px;
            pointer-events: none;
        }
        .toast {
            padding: 1rem 1.25rem;
            border-radius: var(--radius);
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: var(--font-sm);
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-in forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toast-out {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); }
        }
        .toast-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        .toast-header .icon {
            font-size: 1.1em;
        }
        .toast.pending .toast-header { color: var(--blue); }
        .toast.success .toast-header { color: var(--green); }
        .toast.error .toast-header { color: var(--red); }
        .toast.info .toast-header { color: var(--yellow); }
        .toast-body {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }
        .toast-body a {
            color: var(--blue);
            text-decoration: underline;
        }
        .toast-progress {
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.25rem;
        }
        .toast-progress-bar {
            height: 100%;
            background: var(--blue);
            animation: progress-shrink linear forwards;
        }
        @keyframes progress-shrink {
            from { width: 100%; }
            to { width: 0%; }
        }
        .toast.pending .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border);
            border-top-color: var(--blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; }
            .header-center { gap: 1rem; }
            .chart-container { height: 220px; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .bet-card, .create-card { padding: 1rem; }
            .modal {
                margin: 0.5rem;
                padding: 1rem;
                max-width: calc(100vw - 1rem);
                max-height: calc(100vh - 1rem);
            }
            .orderbook-body { max-height: 140px; }
            .trade-submit, .create-btn { min-height: 44px; }
            .bet-btn { min-height: 56px; }
        }

        @media (max-width: 480px) {
            .header {
                flex-wrap: wrap;
                justify-content: space-between;
                gap: 0.5rem;
            }
            .header-center {
                order: 3;
                width: 100%;
                justify-content: space-between;
                gap: 0.25rem;
                padding: 0.5rem 0 0;
                border-top: 1px solid var(--border);
                margin-top: 0.25rem;
            }
            .live-stat {
                flex: 1;
                min-width: 0;
            }
            .live-stat-label {
                font-size: 9px;
            }
            .live-stat-value {
                font-size: 11px;
            }
            /* Hide outlook on very small screens, keep essentials */
            .live-stat:nth-child(4) {
                display: none;
            }
            .tagline { display: none; }
            .section-title { font-size: var(--font-base); }
            .logo { font-size: var(--font-base); }

            /* Chart mobile optimizations */
            .chart-section { padding: 0.75rem; }
            .chart-container { height: 200px; border-radius: 8px; }
            .chart-tooltip, .pred-tooltip {
                font-size: 10px;
                padding: 0.4rem;
            }
            .pred-tooltip {
                min-width: 150px;
                max-width: 170px;
                pointer-events: auto; /* Allow tapping on mobile */
            }
            .pred-tooltip-header { gap: 0.25rem; margin-bottom: 0.25rem; padding-bottom: 0.25rem; }
            .pred-tooltip-badge { padding: 0.1rem 0.35rem; font-size: 8px; }
            .pred-tooltip-title { font-size: 10px; }
            .pred-tooltip-direction { padding: 0.15rem 0.35rem; font-size: 9px; }
            .pred-tooltip-row { margin-bottom: 0.15rem; font-size: 9px; }
            .pred-tooltip-label { font-size: 9px; }
            .pred-tooltip-value { font-size: 9px; }
        }

        @media (max-width: 360px) {
            .header-center {
                flex-wrap: wrap;
                gap: 0.25rem 0.5rem;
            }
            .live-stat {
                flex: 0 0 auto;
            }
            .chart-container { height: 180px; }
        }

        @media (max-width: 768px) {
            .tagline { display: none; }
        }

        /* Stats summary responsive */
        .stats-summary { flex-wrap: wrap; }
        @media (max-width: 600px) {
            .stats-summary { gap: 0.75rem !important; }
            .stats-summary > div { flex: 1 1 40%; }
        }

        /* Touch-friendly interactions */
        @media (hover: none) {
            .bet-btn:active, .btn:active { transform: scale(0.98); }
            .orderbook-row:active { background: var(--surface-2); }
        }

        /* Modal mode toggle buttons */
        .mode-toggle {
            display: flex;
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            padding: 3px;
        }
        .mode-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            color: var(--text-muted);
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .mode-toggle-btn.active-buy {
            background: var(--green);
            color: var(--bg);
        }
        .mode-toggle-btn.active-sell {
            background: var(--red);
            color: var(--text);
        }
        .mode-toggle-btn.active-lp {
            background: var(--blue);
            color: var(--text);
        }
        .mode-toggle-btn.active-mint {
            background: var(--amber);
            color: var(--bg);
        }
        .mode-toggle-btn.active-limit {
            background: #8b5cf6;
            color: var(--text);
        }
        .mode-toggle-btn.active-swap {
            background: #06b6d4;
            color: var(--bg);
        }

        /* LP mode toggle */
        .lp-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .lp-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .lp-toggle-btn.active-add {
            background: var(--blue);
            color: var(--text);
            border-color: var(--blue);
        }
        .lp-toggle-btn.active-remove {
            background: var(--red);
            color: var(--text);
            border-color: var(--red);
        }
        .slip-btn {
            padding: 4px 8px;
            font-size: var(--font-xs);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.15s;
        }
        .slip-btn:hover {
            border-color: var(--blue);
            color: var(--text);
        }
        .slip-btn.slip-active {
            background: var(--blue);
            border-color: var(--blue);
            color: var(--text);
        }

        @media (max-width: 768px) {
            .mode-toggle-btn, .lp-toggle-btn { min-height: 40px; }
        }
    </style>
</head>
<body>
    <!-- Toast Notifications Container -->
    <div id="toastContainer" class="toast-container"></div>

    <header class="header">
        <div class="logo">Gas<span>PM</span></div>
        <span class="tagline">Bet Gas on Gas Price</span>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">Live</div>
                <div class="live-stat-value green" id="liveGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">TWAP</div>
                <div class="live-stat-value cyan" id="twapGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Min</div>
                <div class="live-stat-value" id="minGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Outlook</div>
                <div class="live-stat-value" id="predictionArrows" style="display:flex;gap:0.5rem;font-size:var(--font-sm);">
                    <span id="pred1H" title="Hourly prediction">1H --</span>
                    <span id="pred1D" title="Daily prediction">1D --</span>
                    <span id="pred1W" title="Weekly prediction">1W --</span>
                </div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Max</div>
                <div class="live-stat-value" id="maxGas">--</div>
            </div>
        </div>
        <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
    </header>

    <main class="main">
        <!-- Chart Section -->
        <section class="chart-section">
            <div class="chart-container">
                <canvas id="gasChart" class="chart-canvas"></canvas>
                <div class="chart-tooltip" id="chartTooltip">
                    <div class="chart-tooltip-time" id="tooltipTime">--</div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot spot"></span>
                        <span class="chart-tooltip-key">Spot</span>
                        <span class="chart-tooltip-val" id="tooltipSpot">--</span>
                    </div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot twap"></span>
                        <span class="chart-tooltip-key">TWAP</span>
                        <span class="chart-tooltip-val" id="tooltipTwap">--</span>
                    </div>
                </div>
                <div class="pred-tooltip" id="predTooltip">
                    <div class="pred-tooltip-header">
                        <span class="pred-tooltip-badge" id="predBadge">1H</span>
                        <span class="pred-tooltip-title" id="predTitle">Hourly Market</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Odds</span>
                        <span class="pred-tooltip-direction up" id="predDirection">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Threshold</span>
                        <span class="pred-tooltip-value" id="predThreshold">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Predicted</span>
                        <span class="pred-tooltip-value" id="predTwap">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Closes in</span>
                        <span class="pred-tooltip-value" id="predCloses">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">TVL</span>
                        <span class="pred-tooltip-value" id="predTvl">--</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Bets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Bets</h2>
            <div class="stats-summary" style="display:flex;justify-content:center;gap:2rem;padding:0.875rem;margin-bottom:1rem;background:var(--surface);border-radius:var(--radius);">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">TVL</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--blue);" id="totalPoolTvl">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Orderbook</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="totalOrderbookLiq">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Markets</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeMarketsCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Resolved</div>
                    <a href="#" onclick="toggleResolved();return false;" id="resolvedMarketsCount" title="Click to view resolved markets" style="font-size:var(--font-lg);font-weight:600;color:var(--text-muted);text-decoration:none;cursor:pointer;transition:color 0.15s;" onmouseover="this.style.color='var(--green)'" onmouseout="this.style.color='var(--text-muted)'">0 â–¾</a>
                </div>
            </div>
            <div class="bets-grid">
                <!-- Hourly Card -->
                <div class="bet-card" id="hourlyCard">
                    <div class="bet-header">
                        <span class="bet-type hourly">Hourly</span>
                    </div>
                    <div class="bet-title">This Hour's Gas</div>
                    <div class="bet-question">Will gas go up or down this hour?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="hourlyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="hourlyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">TWAP</div>
                            <div class="gas-compare-value" id="hourlyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('hourly', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="hourlyUpOdds">--</div>
                            <div class="bet-btn-price" id="hourlyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('hourly', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="hourlyDownOdds">--</div>
                            <div class="bet-btn-price" id="hourlyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends top of hour UTC</span>
                        <span class="countdown-value" id="hourlyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="hourlyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="hourlyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="hourlyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="hourlyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="hourlyDownBal">0</span></div>
                    </div>
                    <button id="hourlyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('hourly')">Resolve Market</button>
                </div>

                <!-- Daily Card -->
                <div class="bet-card" id="dailyCard">
                    <div class="bet-header">
                        <span class="bet-type daily">Daily</span>
                    </div>
                    <div class="bet-title">Today's Gas</div>
                    <div class="bet-question">Will gas go up or down today?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="dailyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="dailyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">TWAP</div>
                            <div class="gas-compare-value" id="dailyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('daily', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="dailyUpOdds">--</div>
                            <div class="bet-btn-price" id="dailyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('daily', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="dailyDownOdds">--</div>
                            <div class="bet-btn-price" id="dailyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends midnight UTC</span>
                        <span class="countdown-value" id="dailyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="dailyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="dailyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="dailyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="dailyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="dailyDownBal">0</span></div>
                    </div>
                    <button id="dailyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('daily')">Resolve Market</button>
                </div>

                <!-- Weekly Card -->
                <div class="bet-card" id="weeklyCard">
                    <div class="bet-header">
                        <span class="bet-type weekly">Weekly</span>
                    </div>
                    <div class="bet-title">This Week's Gas</div>
                    <div class="bet-question">Will gas go up or down this week?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="weeklyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="weeklyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">TWAP</div>
                            <div class="gas-compare-value" id="weeklyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('weekly', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="weeklyUpOdds">--</div>
                            <div class="bet-btn-price" id="weeklyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('weekly', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="weeklyDownOdds">--</div>
                            <div class="bet-btn-price" id="weeklyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends Sunday UTC</span>
                        <span class="countdown-value" id="weeklyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="weeklyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="weeklyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="weeklyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="weeklyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="weeklyDownBal">0</span></div>
                    </div>
                    <button id="weeklyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('weekly')">Resolve Market</button>
                </div>

                <!-- Extreme Card -->
                <div class="bet-card" id="extremeCard">
                    <div class="bet-header">
                        <span class="bet-type extreme">Extreme</span>
                    </div>
                    <div class="bet-title">100 Gwei Challenge</div>
                    <div class="bet-question">Will gas hit 100 gwei?</div>
                    <div class="target-display">100 gwei</div>
                    <div class="progress-container">
                        <div class="progress-labels">
                            <span>Max seen: <strong id="extremeMax">--</strong></span>
                            <span id="extremePercent">--%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="extremeProgress" style="width:0%"></div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('extreme', true)">
                            <div class="bet-btn-label">Yes</div>
                            <div class="bet-btn-odds" id="extremeYesOdds">--</div>
                            <div class="bet-btn-price" id="extremeYesPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('extreme', false)">
                            <div class="bet-btn-label">No</div>
                            <div class="bet-btn-odds" id="extremeNoOdds">--</div>
                            <div class="bet-btn-price" id="extremeNoPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Resolves early if touched!</span>
                        <span class="countdown-value" id="extremeCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="extremePoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="extremeOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="extremePosition" style="display:none;">
                        <div class="position-row"><span>Your YES</span><span id="extremeYesBal">0</span></div>
                        <div class="position-row"><span>Your NO</span><span id="extremeNoBal">0</span></div>
                    </div>
                    <button id="extremeResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('extreme')">Resolve Market</button>
                </div>
            </div>
        </section>

        <!-- Create Section (Owner Only) -->
        <section class="create-section" id="createSection" style="display:none;">
            <h2 class="section-title">Create Markets</h2>
            <p style="color:var(--text-muted);font-size:var(--font-xs);margin-bottom:1rem;">
                Create new betting markets. Requires initial liquidity.
            </p>
            <div class="create-grid">
                <!-- Hourly -->
                <div class="create-card" id="createHourlyCard">
                    <div class="create-card-title">Hourly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this hour? Resolves at top of hour UTC.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="hourlySeed" value="0.01" step="0.001" min="0.001">
                    </div>
                    <button class="create-btn" onclick="createHourly()">Create Hourly</button>
                </div>

                <!-- Daily -->
                <div class="create-card" id="createDailyCard">
                    <div class="create-card-title">Daily Comparison</div>
                    <div class="create-card-desc">Will gas go up or down today? Resolves at midnight UTC.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="dailySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createDaily()">Create Daily</button>
                </div>

                <!-- Weekly -->
                <div class="create-card" id="createWeeklyCard">
                    <div class="create-card-title">Weekly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this week? Resolves Sunday midnight.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="weeklySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createWeekly()">Create Weekly</button>
                </div>

                <!-- Extreme -->
                <div class="create-card" id="createExtremeCard">
                    <div class="create-card-title">100 Gwei Challenge</div>
                    <div class="create-card-desc">Will gas hit 100 gwei before end of 2025? Resolves early if hit.</div>
                    <div class="create-input-group">
                        <label class="create-label">Deadline</label>
                        <div style="color:var(--green);font-weight:600;">Dec 31, 2025 23:59:59 UTC</div>
                    </div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="extremeSeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createExtreme()">Create Challenge</button>
                </div>
            </div>
            <p id="allMarketsActive" style="display:none;color:var(--green);text-align:center;margin-top:1.5rem;">
                âœ“ All market types are currently active
            </p>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>Hourly, Daily &amp; Weekly:</strong> Bet on whether the gas TWAP (time-weighted average) will be higher when the market closes compared to when it was created. UP wins if TWAP increased, DOWN wins if it stayed the same or decreased.<br><br>
                <strong>100 Gwei Challenge:</strong> Bet on whether gas will spike to 100 gwei before the deadline. If it touches 100 gwei at any point, YES wins and the market can resolve early. If the deadline passes without reaching 100 gwei, NO wins.<br><br>
                <strong>Trading:</strong> Price = Probability. If UP shows 30%, one share costs ~0.30 ETH and pays 1 ETH if UP wins (3.3x return). Losing shares pay nothing. Trade anytime or hold to resolution. Use limit orders to set your own odds.
            </div>
        </section>

        <!-- Resolved Markets (hidden by default) -->
        <section class="bets-section" id="resolvedSection" style="display:none;">
            <h2 class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
                Resolved Markets
                <a href="#" onclick="toggleResolved();return false;" style="font-size:var(--font-xs);color:var(--text-muted);text-decoration:none;">Hide</a>
            </h2>
            <div class="bets-grid" id="resolvedGrid"></div>
        </section>

        <!-- Footer -->
        <footer style="text-align:center;padding:2rem 0;margin-top:1rem;border-top:1px solid var(--border);color:var(--text-dim);font-size:var(--font-xs);">
            <div style="display:flex;justify-content:center;align-items:center;gap:1.5rem;">
                <a href="https://zamm.finance/" target="_blank" style="display:flex;align-items:center;gap:0.5rem;color:var(--text-muted);text-decoration:none;">
                    <img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:20px;height:20px;border-radius:4px;">
                    Built on zAMM
                </a>
                <a href="https://github.com/zammdefi/pm" target="_blank" style="color:var(--text-muted);text-decoration:none;">Code</a>
            </div>
        </footer>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal" style="max-width:360px;">
            <div class="modal-header">
                <div class="modal-title">Connect Wallet</div>
                <button class="modal-close" onclick="closeWalletModal()">&times;</button>
            </div>
            <div class="modal-body" id="walletOptions"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <!-- YES/NO Side Toggle -->
            <div style="display:flex;gap:4px;margin-bottom:0.75rem;">
                <button id="sideYesBtn" class="mode-toggle-btn" onclick="switchTradeSide(true)" style="flex:1;padding:0.5rem;">
                    <span id="sideYesLabel">YES</span>
                    <span id="sideYesOdds" style="opacity:0.7;margin-left:4px;font-size:11px;">--</span>
                </button>
                <button id="sideNoBtn" class="mode-toggle-btn" onclick="switchTradeSide(false)" style="flex:1;padding:0.5rem;">
                    <span id="sideNoLabel">NO</span>
                    <span id="sideNoOdds" style="opacity:0.7;margin-left:4px;font-size:11px;">--</span>
                </button>
            </div>
            <div class="status-message" id="tradeStatus"></div>
            <!-- Mode Toggle: Trade, Swap, Limit, LP -->
            <div class="mode-toggle">
                <button id="tradeModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('trade')">Trade</button>
                <button id="swapModeBtn" class="mode-toggle-btn" onclick="setTradeMode('swap')">Swap</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')">LP</button>
            </div>
            <!-- Trade Direction Toggle (Buy/Sell) - shown only in Trade mode -->
            <div id="tradeDirectionToggle" class="mode-toggle" style="margin-top:4px;">
                <button id="buyDirBtn" class="mode-toggle-btn active-buy" onclick="setTradeDirection('buy')" style="flex:1;">Buy with ETH</button>
                <button id="sellDirBtn" class="mode-toggle-btn" onclick="setTradeDirection('sell')" style="flex:1;">Sell for ETH</button>
            </div>
            <!-- Swap Direction Toggle (YESâ†”NO) - shown only in Swap mode -->
            <div id="swapDirectionToggle" class="mode-toggle" style="margin-top:4px;display:none;">
                <button id="yesToNoBtn" class="mode-toggle-btn active-buy" onclick="setSwapDirection(true)" style="flex:1;">YES â†’ NO</button>
                <button id="noToYesBtn" class="mode-toggle-btn" onclick="setSwapDirection(false)" style="flex:1;">NO â†’ YES</button>
            </div>
            <!-- Position Display -->
            <div id="tradePositionDisplay" style="background:var(--surface-2);padding:0.75rem;margin-bottom:1rem;font-size:var(--font-xs);border-radius:var(--radius);">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
                    <span style="color:var(--text-dim);">Your Position</span>
                    <span id="positionValue" style="color:var(--text);font-weight:600;">--</span>
                </div>
                <div style="display:flex;gap:1.5rem;margin-bottom:6px;">
                    <span style="color:var(--green);">YES: <span id="tradeModalYes">0</span></span>
                    <span style="color:var(--red);">NO: <span id="tradeModalNo">0</span></span>
                    <span style="color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                </div>
                <div id="positionPnL" style="display:none;padding-top:6px;border-top:1px solid var(--border);">
                    <div style="display:flex;justify-content:space-between;">
                        <span style="color:var(--text-dim);">If <span id="positionOutcome">YES</span> wins</span>
                        <span id="positionPayout" style="color:var(--green);">+0 ETH</span>
                    </div>
                </div>
            </div>
            <!-- Orderbook -->
            <div class="orderbook" id="orderbookContainer">
                <div class="orderbook-title">
                    <span class="orderbook-title-text"><span id="orderbookShareType">YES</span> Order Book</span>
                    <span class="orderbook-depth-info">Depth: <span id="orderbookTotalDepth">--</span> ETH</span>
                </div>
                <div class="orderbook-header">
                    <span>Price <span style="font-weight:400;opacity:0.7">(= Odds)</span></span>
                    <span>Size</span>
                    <span>Total</span>
                </div>
                <div class="orderbook-body">
                    <div id="asksLabel" class="orderbook-section-label" style="display:flex;justify-content:space-between;padding:2px 8px;background:rgba(239,68,68,0.1);font-size:9px;color:var(--red);">
                        <span>ASKS (Sellers)</span>
                        <span style="opacity:0.7;">Click to buy from</span>
                    </div>
                    <div class="orderbook-side asks" id="orderbookAsks">
                        <!-- Asks (sell orders) - sorted high to low, displayed reversed -->
                    </div>
                    <div class="orderbook-spread" id="orderbookSpread">
                        <div class="orderbook-spread-left">
                            <div class="orderbook-spread-price" id="spreadMidPrice">--</div>
                            <div class="orderbook-spread-label">Pool Price (<span id="spreadOddsPct">--%</span> <span id="spreadOutcome">YES</span>)</div>
                        </div>
                        <div class="orderbook-spread-right">
                            <div id="spreadBidAsk" style="color:var(--text);">-- / --</div>
                            <div class="orderbook-spread-pct">Spread: <span id="spreadPct">--%</span></div>
                        </div>
                    </div>
                    <div id="bidsLabel" class="orderbook-section-label" style="display:flex;justify-content:space-between;padding:2px 8px;background:rgba(34,197,94,0.1);font-size:9px;color:var(--green);">
                        <span>BIDS (Buyers)</span>
                        <span style="opacity:0.7;">Click to sell to</span>
                    </div>
                    <div class="orderbook-side bids" id="orderbookBids">
                        <!-- Bids (buy orders) - sorted high to low -->
                    </div>
                </div>
                <div class="orderbook-empty" id="orderbookEmpty" style="display:none;">
                    <div style="margin-bottom:8px;">No limit orders yet</div>
                    <div style="font-size:10px;color:var(--text-muted);">Place a limit order or trade against the pool</div>
                </div>
            </div>
            <div class="trade-input-group" id="tradeInputGroup">
                <div class="trade-label">
                    <span id="tradeInputLabel">Amount (ETH)</span>
                    <span>Balance: <span id="tradeBalance">--</span> <span id="tradeBalanceUnit">ETH</span></span>
                </div>
                <div style="display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                    <input type="number" class="trade-input" id="tradeAmount" placeholder="0.01" step="0.001" min="0" oninput="handleTradeInput()" style="flex:1;background:transparent;border:none;border-radius:0;">
                    <button onclick="setMaxTrade()" style="padding:0.5rem 1rem;background:var(--surface-2);border:none;border-left:1px solid var(--border);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-xs);">MAX</button>
                </div>
            </div>
            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <div id="tradeExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Buy or sell shares for ETH. Orders route through the orderbook and AMM for the best price.
                </div>
                <!-- Slippage Settings -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button onclick="setSlippage(0.5)" id="slip05" class="slip-btn slip-active">0.5%</button>
                        <button onclick="setSlippage(1)" id="slip1" class="slip-btn">1%</button>
                        <button onclick="setSlippage(2)" id="slip2" class="slip-btn">2%</button>
                        <input type="number" id="slipCustom" placeholder="Custom" step="0.1" min="0.1" max="50" style="width:60px;padding:4px 6px;font-size:var(--font-xs);background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);" onchange="setSlippage(parseFloat(this.value))">
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Avg. price <span style="opacity:0.6">(= odds)</span></span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row" id="previewOddsRow" style="display:none;">
                        <span style="color:var(--text-dim);">Implied probability</span>
                        <span id="previewOdds" style="font-weight:600;">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">Potential payout</span>
                        <span id="previewPayout">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="color:var(--blue);">AMM</span>
                    </div>
                    <div id="previewBreakdown" class="trade-preview-row" style="display:none;flex-direction:column;align-items:flex-start;gap:2px;padding-top:0.5rem;border-top:1px solid var(--border);margin-top:0.5rem;">
                        <span style="font-size:var(--font-xs);color:var(--text-dim);width:100%;">Execution breakdown:</span>
                        <div id="breakdownDetails" style="font-size:var(--font-xs);color:var(--text-muted);width:100%;"></div>
                    </div>
                    <div id="previewSavings" class="trade-preview-row" style="display:none;">
                        <span style="color:var(--text-dim);">vs pure AMM</span>
                        <span id="savingsAmount" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="tradeSubmit" onclick="executeTrade()">Buy</button>
            </div>
            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div class="lp-toggle">
                    <button id="addLpBtn" class="lp-toggle-btn active-add" onclick="setLpMode('add')">Deposit</button>
                    <button id="removeLpBtn" class="lp-toggle-btn" onclick="setLpMode('remove')">Withdraw</button>
                </div>
                <div id="lpExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.
                </div>
                <!-- Your Position Summary -->
                <div id="lpPositionSummary" style="background:var(--surface-2);padding:0.75rem;margin-bottom:0.75rem;border-radius:var(--radius);font-size:var(--font-xs);">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span id="lpPositionValue" style="color:var(--text);">-- ETH</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;">
                        <span style="color:var(--text-dim);">Pool Share</span>
                        <span id="lpCurrentShare" style="color:var(--text-muted);">--%</span>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>Pool TVL</span>
                        <span id="lpPoolReserves">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="lpPoolPrice">-- (--% YES)</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">You receive</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Your share after</span>
                        <span><span id="lpPoolShare">--%</span> <span id="lpShareChange" style="font-size:10px;color:var(--text-muted);"></span></span>
                    </div>
                </div>
                <div id="lpWarning" style="display:none;font-size:var(--font-xs);color:var(--amber);padding:0.5rem;background:rgba(245,158,11,0.1);border-radius:var(--radius);margin-bottom:0.75rem;">
                </div>
                <button class="trade-submit" id="lpSubmit" style="background:var(--blue);" onclick="executeLp()">Deposit Liquidity</button>
            </div>
            <!-- Swap Section (YESâ†”NO) -->
            <div id="swapSection" style="display:none;">
                <div id="swapExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Swap shares directly via the pool. No ETH needed - trade one outcome for the other.
                </div>
                <!-- Slippage for Swap -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-muted);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button id="swapSlip05" class="slip-btn slip-active" onclick="setSwapSlippage(0.5)">0.5%</button>
                        <button id="swapSlip1" class="slip-btn" onclick="setSwapSlippage(1)">1%</button>
                        <button id="swapSlip2" class="slip-btn" onclick="setSwapSlippage(2)">2%</button>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="swapGiveLabel">You give (YES)</span>
                        <span id="swapGive">-- shares</span>
                    </div>
                    <div class="trade-preview-row" style="border-bottom:1px solid var(--border);padding-bottom:8px;margin-bottom:4px;">
                        <span>Pool Rate</span>
                        <span id="swapPoolRate">1 YES = -- NO</span>
                    </div>
                    <div class="trade-preview-row" style="font-weight:600;font-size:1.05em;">
                        <span id="swapReceiveLabel">You receive (NO)</span>
                        <span id="swapReceive" style="color:var(--green);">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Swap Fee (0.3%)</span>
                        <span id="swapFee">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Price Impact</span>
                        <span id="swapImpact">--%</span>
                    </div>
                    <div class="trade-preview-row" style="border-top:1px solid var(--border);padding-top:8px;margin-top:4px;">
                        <span>Min. Receive (<span id="swapSlipDisplay">0.5%</span> slip)</span>
                        <span id="swapMinReceive">-- shares</span>
                    </div>
                </div>
                <button class="trade-submit buy-down" id="swapSubmit" onclick="executeSwap()">Swap YES â†’ NO</button>
            </div>
            <!-- Mint & List Section -->
            <div id="mintSection" style="display:none;">
                <div id="mintExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Mint YES + NO shares from ETH, keep one side and list the other at your price. Useful for low liquidity markets.
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="keepYesBtn" class="lp-toggle-btn active-add" onclick="setMintKeep(true)">Keep YES</button>
                    <button id="keepNoBtn" class="lp-toggle-btn" onclick="setMintKeep(false)">Keep NO</button>
                </div>
                <div style="margin-bottom:1rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Sell price (ETH per share)</label>
                    <input type="number" id="mintLimitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateMintPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You deposit</span>
                        <span id="mintDeposit">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="mintReceive">-- YES + -- NO</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You keep</span>
                        <span id="mintKeep">-- YES</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You list for sale</span>
                        <span id="mintList">-- NO @ -- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>If order fills</span>
                        <span id="mintProfit" style="color:var(--green);">Net cost: -- ETH</span>
                    </div>
                </div>
                <button class="trade-submit" id="mintSubmit" style="background:var(--amber);color:var(--bg);" onclick="executeMintAndList()">Mint & List</button>
            </div>
            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <div id="limitExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    <span id="limitExplainerText"><strong>Buy Limit:</strong> Bid below pool price to get better odds. Your ETH is escrowed until filled or cancelled.</span>
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="limitBuyBtn" class="lp-toggle-btn active-add" onclick="setLimitSide('buy')">Buy Order</button>
                    <button id="limitSellBtn" class="lp-toggle-btn" onclick="setLimitSide('sell')">Sell Order</button>
                </div>
                <div style="margin-bottom:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <label style="font-size:var(--font-xs);color:var(--text-muted);">Limit Price (ETH = Odds %)</label>
                        <span style="font-size:var(--font-xs);color:var(--text-dim);">Pool: <span id="limitPoolPrice">--</span></span>
                    </div>
                    <div style="display:flex;gap:4px;">
                        <div style="flex:1;display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                            <input type="number" id="limitPrice" placeholder="0.50" step="0.01" min="0.01" max="0.99"
                                style="flex:1;padding:0.75rem;background:transparent;border:none;color:var(--text);font-size:var(--font-base);"
                                oninput="updateLimitPreview()">
                        </div>
                        <button onclick="adjustLimitPrice(-0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--red);font-weight:600;cursor:pointer;font-size:var(--font-sm);">-1%</button>
                        <button onclick="adjustLimitPrice(0.01)" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-sm);">+1%</button>
                        <button onclick="setLimitPriceToPool()" style="padding:0.5rem 0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--blue);font-weight:600;cursor:pointer;font-size:10px;">POOL</button>
                    </div>
                    <div id="limitOddsHelper" style="margin-top:6px;font-size:var(--font-xs);padding:0.5rem;background:var(--surface);border-radius:var(--radius);display:none;">
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <span style="color:var(--text);">= <strong id="limitOddsValue">50%</strong> implied odds</span>
                            <span id="limitOddsVsPool" style="color:var(--text-muted);">--</span>
                        </div>
                        <div id="limitReturnInfo" style="margin-top:4px;color:var(--green);"></div>
                    </div>
                </div>
                <div style="margin-bottom:0.75rem;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
                        <label style="font-size:var(--font-xs);color:var(--text-muted);">Shares</label>
                        <span style="font-size:var(--font-xs);color:var(--text-muted);">Balance: <span id="limitBalance">--</span> <span id="limitBalanceUnit">ETH</span></span>
                    </div>
                    <div style="display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                        <input type="number" id="limitShares" placeholder="1.0" step="0.1" min="0.01"
                            style="flex:1;padding:0.75rem;background:transparent;border:none;color:var(--text);font-size:var(--font-base);"
                            oninput="updateLimitPreview()">
                        <button onclick="setMaxLimitShares()" style="padding:0.5rem 1rem;background:var(--surface-2);border:none;border-left:1px solid var(--border);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-xs);">MAX</button>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitCostLabel">You escrow</span>
                        <span id="limitCost">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="limitReceiveLabel">If filled, you get</span>
                        <span id="limitReceive">-- shares</span>
                    </div>
                    <div class="trade-preview-row" id="limitProfitRow">
                        <span id="limitProfitLabel">If you win</span>
                        <span id="limitProfit" style="color:var(--green);">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Expires</span>
                        <span id="limitExpires">Market close</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" style="background:#8b5cf6;" onclick="executeLimitOrder()">Place Buy Order</button>
            </div>
            <!-- Your Orders Section -->
            <div id="yourOrdersSection" style="margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border);display:none;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);font-weight:600;">YOUR OPEN ORDERS</span>
                    <button onclick="refreshUserOrders()" style="font-size:var(--font-xs);padding:2px 8px;background:transparent;border:1px solid var(--border);border-radius:var(--radius);color:var(--text-muted);cursor:pointer;">â†»</button>
                </div>
                <div id="yourOrdersList" style="font-size:var(--font-xs);">
                    <!-- Orders populate here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const GASPM_ADDRESS = '0x0000000000ee3d4294438093EaA34308f47Bc0b4';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const PMROUTER_ADDRESS = '0x000000000055ff709f26efb262fba8b0ae8c35dc';
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        const FEE_TIER = 30n; // 30 bps = 0.30% fee

        // Public RPC fallbacks
        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc);
                    await p.getBlockNumber(); // test connection
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const RESOLVER_ABI = [
            'function resolveMarket(uint256 marketId) public'
        ];

        const GASPM_ABI = [
            'function baseFeeAverage() public view returns (uint256)',
            'function baseFeeMax() public view returns (uint256)',
            'function baseFeeMin() public view returns (uint256)',
            'function startTime() public view returns (uint64)',
            'function baseFeeMaxSince(uint256 marketId) public view returns (uint256)',
            'function comparisonStartValue(uint256 marketId) public view returns (uint256)',
            'function marketCount() public view returns (uint256)',
            'function getMarkets(uint256 start, uint256 count) public view returns (uint256[])',
            'function getMarketInfos(uint256 start, uint256 count) public view returns (tuple(uint256 marketId, uint64 close, bool resolved, bool outcome, uint256 currentValue, bool conditionMet, bool ready)[])',
            'function observationCount() public view returns (uint256)',
            'function getObservations(uint256 start, uint256 count) public view returns (tuple(uint64 timestamp, uint64 baseFee, uint128 cumulativeBaseFee)[])',
            'function createComparisonMarket(address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function createWindowPeakMarket(uint256 threshold, address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function owner() public view returns (address)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) public view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) public view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function poolKey(uint256 marketId, uint256 feeOrHook) public view returns (tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook))',
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function getNoId(uint256 marketId) public pure returns (uint256)',
            'function claim(uint256 marketId, address to) public returns (uint256 shares, uint256 payout)',
            'function claimMany(uint256[] marketIds, address to) public returns (uint256 totalPayout)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) public payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) public returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
            'function multicall(bytes[] data) public returns (bytes[])'
        ];

        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const ZAMM_ABI = [
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)',
            'function pools(uint256 poolId) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)',
            'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountIn, uint256 amountOutMin, bool zeroForOne, address to, uint256 deadline) returns (uint256 amountOut)'
        ];

        const PMROUTER_ABI = [
            'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
            'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)',
            'function claim(uint256 marketId, address to) returns (uint256 payout)',
            'function getOrderbook(uint256 marketId, bool isYes, uint256 depth) view returns (bytes32[] bidHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] bidOrders, bytes32[] askHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] askOrders)',
            'function fillOrder(bytes32 orderHash, uint96 sharesToFill, address to) payable returns (uint96 sharesFilled, uint96 collateralFilled)',
            'function fillOrdersThenSwap(uint256 marketId, bool isYes, bool isBuy, uint256 totalAmount, uint256 minOutput, bytes32[] orderHashes, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256 totalOutput)',
            'function split(uint256 marketId, uint256 amount, address to) payable',
            'function placeOrder(uint256 marketId, bool isYes, bool isBuy, uint96 shares, uint96 collateral, uint56 deadline, bool partialFill) payable returns (bytes32)',
            'function multicall(bytes[] data) payable returns (bytes[])',
            'function cancelOrder(bytes32 orderHash)',
            'function getUserOrderCount(address user) view returns (uint256)',
            'function getUserOrderHashes(address user, uint256 offset, uint256 limit) view returns (bytes32[])',
            'function orders(bytes32 orderHash) view returns (address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let isOwner = false;
        let connectedWalletProvider = null;
        let walletConnectProvider = null;
        let isConnecting = false;
        const eip6963Providers = new Map();

        let markets = { hourly: null, daily: null, weekly: null, extreme: null };
        let resolvedMarkets = [];
        let currentTrade = { type: null, isYes: true, marketId: null };
        let currentTradeMode = 'buy'; // 'buy' or 'sell'
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
        let slippageTolerance = 0.5; // 0.5% default slippage tolerance

        // Chart data (like GasPM.html)
        let chartDataPoints = [];   // Historical baseFee in gwei
        let chartTimestamps = [];   // Timestamps for each observation
        let chartCumulatives = [];  // Cumulative base fee for rolling TWAP
        let chartState = {};
        let cachedGasData = { twap: 0, current: 0, startTime: 0 };
        let lastLoadedObsCount = 0; // Track for incremental loading
        let lastCanvasSize = { width: 0, height: 0 }; // Track canvas size to avoid unnecessary resizes
        let predictionMarkerPositions = []; // Store prediction marker hit areas for hover detection
        let hoveredPrediction = null; // Currently hovered prediction market type
        let priceChangeBadgeArea = null; // Store price change badge hit area for hover

        // ======================== DOM CACHE ========================
        // Cache frequently accessed DOM elements to avoid repeated lookups
        const DOM = {};
        function initDOMCache() {
            DOM.liveGas = document.getElementById('liveGas');
            DOM.twapGas = document.getElementById('twapGas');
            DOM.minGas = document.getElementById('minGas');
            DOM.maxGas = document.getElementById('maxGas');
            DOM.extremeMax = document.getElementById('extremeMax');
            DOM.extremeProgress = document.getElementById('extremeProgress');
            DOM.extremePercent = document.getElementById('extremePercent');
            DOM.hourlyCountdown = document.getElementById('hourlyCountdown');
            DOM.dailyCountdown = document.getElementById('dailyCountdown');
            DOM.weeklyCountdown = document.getElementById('weeklyCountdown');
            DOM.extremeCountdown = document.getElementById('extremeCountdown');
            DOM.totalPoolTvl = document.getElementById('totalPoolTvl');
            DOM.totalOrderbookLiq = document.getElementById('totalOrderbookLiq');
            DOM.activeMarketsCount = document.getElementById('activeMarketsCount');
            DOM.gasChart = document.getElementById('gasChart');
            DOM.chartTooltip = document.getElementById('chartTooltip');
            DOM.predTooltip = document.getElementById('predTooltip');
            DOM.connectBtn = document.getElementById('connectBtn');
            DOM.createSection = document.getElementById('createSection');
        }

        // ======================== INIT ========================
        async function init() {
            initDOMCache();
            initEIP6963();

            // Auto-reconnect wallet if previously connected
            const savedWallet = localStorage.getItem('gaspm_wallet');
            if (savedWallet) {
                // Small delay to let EIP-6963 providers announce themselves
                setTimeout(async () => {
                    try {
                        await connectWithWallet(savedWallet);
                    } catch (e) {
                        console.warn('Auto-reconnect failed:', e);
                        localStorage.removeItem('gaspm_wallet');
                    }
                }, 100);
            }

            await loadData();
            updateCountdowns();
            setInterval(updateCountdowns, 1000);
            setInterval(loadData, 60000);
            setupChart();
            startPulseAnimation();
        }

        function startPulseAnimation() {
            // Only animate pulse for small datasets; skip for large ones (too expensive)
            let lastPulseTime = 0;
            const pulseInterval = 66; // ~15fps for pulse animation

            function animatePulse(timestamp) {
                if (timestamp - lastPulseTime >= pulseInterval) {
                    if (chartDataPoints.length > 0 && chartDataPoints.length <= 200 && cachedGasData.current && hoverIndex < 0) {
                        drawChart(cachedGasData);
                    }
                    lastPulseTime = timestamp;
                }
                requestAnimationFrame(animatePulse);
            }
            requestAnimationFrame(animatePulse);
        }

        // ======================== WALLET ========================
        const WALLET_CONFIG = {
            metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
            coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
            rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
            rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
            walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
        };

        function initEIP6963() {
            if (typeof window === 'undefined') return;
            window.addEventListener('eip6963:announceProvider', (event) => {
                const { info, provider } = event.detail;
                eip6963Providers.set(info.uuid, { info, provider });
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

        function detectWallets() {
            const detected = [];
            const seenNames = new Set();

            for (const [key, config] of Object.entries(WALLET_CONFIG)) {
                if (key === 'walletconnect') continue;
                if (config.detect && config.detect()) {
                    detected.push({ key, ...config });
                    seenNames.add(config.name.toLowerCase());
                }
            }

            for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
                if (!seenNames.has(info.name.toLowerCase())) {
                    // Sanitize wallet name to prevent XSS
                    const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
                    // Only allow data: or https: URLs for icons
                    const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
                    detected.push({
                        key: `eip6963_${uuid}`,
                        name: safeName,
                        icon: iconUrl ? `<img src="${iconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'ðŸ”Œ',
                        getProvider: () => provider
                    });
                    seenNames.add(info.name.toLowerCase());
                }
            }

            if (detected.length === 0 && window.ethereum) {
                detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'ðŸ”—', getProvider: () => window.ethereum });
            }

            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            if (wcModule?.EthereumProvider) {
                detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'ðŸ“±', isWalletConnect: true });
            }

            return detected;
        }

        function showWalletModal() {
            const wallets = detectWallets();
            const container = document.getElementById('walletOptions');

            if (connectedAddress) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: var(--gray); border-radius: var(--radius); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Connected</div>
                        <div style="font-size: 0.9rem; word-break: break-all; color: var(--green);">${connectedAddress}</div>
                    </div>
                    <div class="wallet-option disconnect" onclick="disconnectWallet()">
                        <span class="wallet-option-name">Disconnect</span>
                    </div>
                `;
            } else {
                container.innerHTML = wallets.length > 0 ? wallets.map(w => `
                    <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
                        <span class="wallet-option-icon">${w.icon}</span>
                        <span class="wallet-option-name">${w.name}</span>
                    </div>
                `).join('') : '<div style="padding:1rem;text-align:center;color:var(--text-muted);">No wallets detected. Install MetaMask or use WalletConnect.</div>';
            }

            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        async function connectWallet() {
            showWalletModal();
        }

        async function connectWithWallet(walletKey) {
            if (isConnecting) return;
            isConnecting = true;

            try {
                closeWalletModal();
                let walletProvider;

                if (walletKey === 'walletconnect') {
                    const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
                    const WCProvider = wcModule?.EthereumProvider;

                    if (!WCProvider?.init) throw new Error('WalletConnect not available');

                    if (walletConnectProvider) {
                        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
                        walletConnectProvider = null;
                    }

                    walletConnectProvider = await WCProvider.init({
                        projectId: '1e8390ef1c1d8a185e035912a1409749',
                        chains: [1],
                        showQrModal: true,
                        rpcMap: { 1: 'https://1rpc.io/eth' },
                        metadata: {
                            name: 'GasPM',
                            description: 'Ethereum Gas Prediction Markets',
                            url: window.location.origin,
                            icons: []
                        }
                    });

                    await walletConnectProvider.enable();
                    walletProvider = walletConnectProvider;
                } else if (walletKey.startsWith('eip6963_')) {
                    const uuid = walletKey.replace('eip6963_', '');
                    walletProvider = eip6963Providers.get(uuid)?.provider;
                } else {
                    walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
                }

                if (!walletProvider) throw new Error('Wallet not found');

                if (walletKey !== 'walletconnect') {
                    await walletProvider.request({ method: 'eth_requestAccounts' });
                }

                provider = new ethers.BrowserProvider(walletProvider);
                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                connectedWalletProvider = walletProvider;

                DOM.connectBtn.textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                DOM.connectBtn.classList.add('connected');

                walletProvider.on('accountsChanged', () => window.location.reload());
                walletProvider.on('chainChanged', () => window.location.reload());

                // Check if owner (for reference, but creation is now public)
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, provider);
                const owner = await gasPm.owner();
                isOwner = owner.toLowerCase() === connectedAddress.toLowerCase();
                // Show create section to all connected users (creation is public)
                DOM.createSection.style.display = 'block';

                await loadPositions();

                // Save wallet preference for auto-reconnect on page refresh
                localStorage.setItem('gaspm_wallet', walletKey);

            } catch (error) {
                console.error('Connection failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Connection Failed', error.message || 'Could not connect wallet', 'error', 4000);
                }
            } finally {
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            if (walletConnectProvider) {
                try { walletConnectProvider.disconnect(); } catch (e) {}
                walletConnectProvider = null;
            }
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletProvider = null;
            isOwner = false;
            DOM.connectBtn.textContent = 'Connect';
            DOM.connectBtn.classList.remove('connected');
            DOM.createSection.style.display = 'none';
            hidePositions();
            closeWalletModal();

            // Clear saved wallet preference
            localStorage.removeItem('gaspm_wallet');
        }

        // Check if error is a user rejection (wallet popup cancelled)
        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== DATA LOADING ========================
        const MAX_MARKETS = 1000;

        async function loadData() {
            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const gasPmInterface = new ethers.Interface(GASPM_ABI);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Batch gas data + market infos with block fetch (like GasPM.html)
                const [results, block] = await Promise.all([
                    multicall.aggregate3([
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeAverage') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMax') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMin') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('startTime') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('observationCount') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('getMarketInfos', [0, MAX_MARKETS]) }
                    ]),
                    rpc.getBlock('latest')
                ]);

                // Live gas from block (baseFeePerGas is in wei)
                const liveWei = block.baseFeePerGas || 0n;
                const liveGwei = Number(liveWei) / 1e9;
                DOM.liveGas.textContent = formatGwei(liveWei) + ' gwei';

                // Decode oracle data (returns wei, convert to gwei)
                let twapWei = 0n, maxWei = 0n, minWei = 0n, startTime = 0, obsCount = 0;

                if (results[0].success) {
                    twapWei = gasPmInterface.decodeFunctionResult('baseFeeAverage', results[0].returnData)[0];
                } else {
                    console.warn('baseFeeAverage call failed');
                }

                if (results[1].success) {
                    maxWei = gasPmInterface.decodeFunctionResult('baseFeeMax', results[1].returnData)[0];
                } else {
                    console.warn('baseFeeMax call failed');
                }

                if (results[2].success) {
                    minWei = gasPmInterface.decodeFunctionResult('baseFeeMin', results[2].returnData)[0];
                } else {
                    console.warn('baseFeeMin call failed');
                }

                if (results[3].success) {
                    startTime = Number(gasPmInterface.decodeFunctionResult('startTime', results[3].returnData)[0]);
                } else {
                    console.warn('startTime call failed');
                }

                if (results[4].success) {
                    obsCount = Number(gasPmInterface.decodeFunctionResult('observationCount', results[4].returnData)[0]);
                } else {
                    console.warn('observationCount call failed');
                }

                const twapGwei = Number(twapWei) / 1e9;
                const maxGwei = Number(maxWei) / 1e9;

                DOM.twapGas.textContent = formatGwei(twapWei) + ' gwei';
                DOM.minGas.textContent = formatGwei(minWei) + ' gwei';
                DOM.maxGas.textContent = formatGwei(maxWei) + ' gwei';

                // Update extreme progress
                DOM.extremeMax.textContent = formatGwei(maxWei) + ' gwei';
                const pct = Math.min(100, (maxGwei / 100) * 100);
                DOM.extremeProgress.style.width = pct + '%';
                DOM.extremePercent.textContent = pct.toFixed(0) + '%';

                // Note: Start/Now values are set in updateCard() when markets are loaded

                // Cache gas data for chart
                cachedGasData = { twap: twapGwei, current: liveGwei, startTime };

                // Fetch observations for chart (incremental loading for efficiency)
                if (obsCount > 0) {
                    const batchSize = 500;
                    let fetchStart = 0;
                    let newObservations = [];

                    if (lastLoadedObsCount === 0) {
                        // First load: only fetch last 500 observations (don't need ancient history)
                        fetchStart = Math.max(0, obsCount - batchSize);
                    } else if (obsCount > lastLoadedObsCount) {
                        // Incremental load: only fetch new observations
                        fetchStart = lastLoadedObsCount;
                    } else {
                        // No new observations, skip fetch
                        fetchStart = obsCount; // Will skip the loop
                    }

                    if (fetchStart < obsCount) {
                        const obsCalls = [];
                        for (let start = fetchStart; start < obsCount; start += batchSize) {
                            obsCalls.push({
                                target: GASPM_ADDRESS,
                                allowFailure: true,
                                callData: gasPmInterface.encodeFunctionData('getObservations', [start, Math.min(batchSize, obsCount - start)])
                            });
                        }
                        const obsResults = await multicall.aggregate3(obsCalls);
                        for (const res of obsResults) {
                            if (res.success) {
                                const batch = gasPmInterface.decodeFunctionResult('getObservations', res.returnData)[0];
                                newObservations.push(...batch);
                            }
                        }

                        // Append new observations to existing arrays (or replace on first load)
                        const newPoints = newObservations.map(o => Number(o.baseFee) / 1e9);
                        const newTimestamps = newObservations.map(o => Number(o.timestamp));
                        const newCumulatives = newObservations.map(o => Number(o.cumulativeBaseFee));

                        if (lastLoadedObsCount === 0) {
                            // First load - replace
                            chartDataPoints = newPoints;
                            chartTimestamps = newTimestamps;
                            chartCumulatives = newCumulatives;
                        } else {
                            // Incremental - append
                            chartDataPoints.push(...newPoints);
                            chartTimestamps.push(...newTimestamps);
                            chartCumulatives.push(...newCumulatives);
                        }
                        lastLoadedObsCount = obsCount;
                    }
                }

                // Decode market infos
                let marketInfos = [];
                if (results[5].success) {
                    try {
                        marketInfos = gasPmInterface.decodeFunctionResult('getMarketInfos', results[5].returnData)[0];
                    } catch (e) {
                        console.warn('No markets or failed to decode:', e);
                    }
                }

                // Load markets using marketInfos (this also calls updatePredictions)
                await loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei, liveGwei);

                // Draw chart AFTER markets loaded so predictions are available
                drawChart(cachedGasData);

            } catch (e) {
                console.error('Load failed:', e);
            }
        }

        async function loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei, liveGwei) {
            // Reset markets on each load to handle expiry
            markets = { hourly: null, daily: null, weekly: null, extreme: null };
            resolvedMarkets = [];

            try {
                if (marketInfos.length === 0) return;

                const now = Math.floor(Date.now() / 1000);

                // Batch all PAMM.getMarket calls for descriptions
                const marketCalls = marketInfos.map(info => ({
                    target: PAMM_ADDRESS,
                    allowFailure: true,
                    callData: pammInterface.encodeFunctionData('getMarket', [info.marketId])
                }));
                const marketResults = await multicall.aggregate3(marketCalls);

                // Find comparison markets (including expired-but-unresolved) and batch their startValue calls
                const comparisonIds = [];
                const comparisonMarketIndices = []; // Maps back to marketInfos index
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    // Skip only resolved markets - include expired-but-unresolved
                    if (info.resolved) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const desc = data.description || data[10];
                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        comparisonIds.push(info.marketId);
                        comparisonMarketIndices.push(i);
                    }
                }

                // Batch comparisonStartValue calls AND getPoolState calls for unresolved markets
                let startValuesMap = new Map(); // marketId -> startValue
                let poolStateMap = new Map(); // marketId -> { rYes, rNo }

                // Collect all unresolved market IDs for pool state (including expired)
                const activeMarketIds = [];
                const activeMarketIndices = [];
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    // Include expired-but-unresolved markets
                    if (info.resolved) continue;
                    activeMarketIds.push(info.marketId);
                    activeMarketIndices.push(i);
                }

                if (activeMarketIds.length > 0) {
                    // Batch: startValue for comparison markets + poolState for all active markets
                    const batchCalls = [];

                    // Add startValue calls for comparison markets
                    for (const id of comparisonIds) {
                        batchCalls.push({
                            target: GASPM_ADDRESS,
                            allowFailure: true,
                            callData: gasPmInterface.encodeFunctionData('comparisonStartValue', [id])
                        });
                    }

                    // Add getPoolState calls for all active markets
                    for (const id of activeMarketIds) {
                        batchCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('getPoolState', [id, FEE_TIER])
                        });
                    }

                    const batchResults = await multicall.aggregate3(batchCalls);

                    // Parse startValue results
                    for (let i = 0; i < comparisonIds.length; i++) {
                        const val = batchResults[i].success ? gasPmInterface.decodeFunctionResult('comparisonStartValue', batchResults[i].returnData)[0] : 0n;
                        startValuesMap.set(comparisonIds[i].toString(), val);
                    }

                    // Parse poolState results
                    const poolStateOffset = comparisonIds.length;
                    for (let i = 0; i < activeMarketIds.length; i++) {
                        const res = batchResults[poolStateOffset + i];
                        if (res.success) {
                            const [rYes, rNo] = pammInterface.decodeFunctionResult('getPoolState', res.returnData);
                            poolStateMap.set(activeMarketIds[i].toString(), { rYes, rNo });
                        }
                    }
                }

                // Process markets
                let collateralMap = new Map(); // marketId -> collateralLocked
                for (let i = 0; i < marketInfos.length; i++) {
                    const info = marketInfos[i];
                    if (!marketResults[i].success) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const resolved = info.resolved;
                    const close = Number(info.close);
                    const desc = data.description || data[10];
                    const collateralLocked = data.collateralLocked || data[6] || 0n;

                    // Collect resolved markets for history display
                    if (resolved) {
                        const outcome = info.outcome; // 0 = no, 1 = yes
                        // Only distinguish extreme (spike) vs comparison (TWAP) markets
                        const isExtreme = desc.includes('spikes to') || desc.includes('Gas spikes');
                        resolvedMarkets.push({
                            id: info.marketId,
                            isExtreme,
                            close,
                            outcome,
                            desc,
                            collateralLocked
                        });
                        continue;
                    }

                    const isExpired = close <= now;
                    // info.ready accounts for canClose markets (true if condition met early OR expired)
                    const needsResolve = info.ready;

                    // Store collateralLocked for TVL display (total ETH backing all tokens)
                    collateralMap.set(info.marketId.toString(), collateralLocked);

                    // Use pool reserves for price (reflects AMM state, not just supply)
                    const poolState = poolStateMap.get(info.marketId.toString());
                    let yesPrice = 0.5, noPrice = 0.5;

                    if (poolState && poolState.rYes > 0n && poolState.rNo > 0n) {
                        // AMM price: yesPrice = rNo / (rYes + rNo)
                        const rYesNum = Number(poolState.rYes);
                        const rNoNum = Number(poolState.rNo);
                        const total = rYesNum + rNoNum;
                        yesPrice = rNoNum / total;
                        noPrice = rYesNum / total;
                    } else {
                        // Fallback to supply-based calculation if no pool
                        const yesSupply = data.yesSupply || data[8];
                        const noSupply = data.noSupply || data[9];
                        const total = Number(yesSupply) + Number(noSupply);
                        if (total > 0) {
                            yesPrice = Number(noSupply) / total;
                            noPrice = Number(yesSupply) / total;
                        }
                    }

                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        const startValue = startValuesMap.get(info.marketId.toString()) || 0n;
                        const startGwei = Number(startValue) / 1e9;
                        const timeToClose = close - now;

                        // For expired markets, use negative timeToClose to determine original category
                        // Hourly: expired within last hour or closes within next hour
                        // Daily: expired within last day or closes within next day
                        // Weekly: expired within last week or closes within next week
                        if (timeToClose <= 3600 && timeToClose > -3600 && !markets.hourly) {
                            markets.hourly = { id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve, tvl: Number(collateralLocked) / 1e18 };
                            updateCard('hourly', startGwei, twapGwei, yesPrice, noPrice, needsResolve);
                        } else if (timeToClose <= 86400 && timeToClose > -86400 && !markets.daily) {
                            markets.daily = { id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve, tvl: Number(collateralLocked) / 1e18 };
                            updateCard('daily', startGwei, twapGwei, yesPrice, noPrice, needsResolve);
                        } else if (timeToClose <= 604800 && timeToClose > -604800 && !markets.weekly) {
                            markets.weekly = { id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve, tvl: Number(collateralLocked) / 1e18 };
                            updateCard('weekly', startGwei, twapGwei, yesPrice, noPrice, needsResolve);
                        }
                    } else if (desc.includes('spikes to') || desc.includes('Gas spikes')) {
                        if (!markets.extreme) {
                            markets.extreme = { id: info.marketId, close, yesPrice, noPrice, needsResolve, conditionMet: info.conditionMet, tvl: Number(collateralLocked) / 1e18 };
                            document.getElementById('extremeYesOdds').textContent = formatOdds(yesPrice);
                            document.getElementById('extremeNoOdds').textContent = formatOdds(noPrice);
                            document.getElementById('extremeYesPrice').textContent = formatEth(yesPrice, '');
                            document.getElementById('extremeNoPrice').textContent = formatEth(noPrice, '');
                            // Show resolve button for extreme if ready (condition met OR expired)
                            const resolveBtn = document.getElementById('extremeResolveBtn');
                            if (resolveBtn) {
                                resolveBtn.style.display = needsResolve ? 'block' : 'none';
                                // Update button text if condition met early
                                if (info.conditionMet && !isExpired) {
                                    resolveBtn.textContent = '100 GWEI HIT! Resolve Now';
                                    resolveBtn.style.background = 'var(--green)';
                                }
                            }
                        }
                    }
                }

                // Update create cards visibility
                updateCreateCardsVisibility();
                // Load liquidity stats after markets are loaded (pass collateralMap for TVL)
                loadLiquidityStats(collateralMap);
                // Update predictions based on market odds
                updatePredictions();
                // Update resolved markets count and render if visible
                const isExpanded = document.getElementById('resolvedSection').style.display !== 'none';
                document.getElementById('resolvedMarketsCount').textContent = resolvedMarkets.length + (isExpanded ? ' â–´' : ' â–¾');
                renderResolvedMarkets();
            } catch (e) {
                console.error('Load markets failed:', e);
            }
        }

        async function loadLiquidityStats(collateralMap = null) {
            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                let totalTvl = 0;
                let totalOrderbookLiq = 0;
                let activeCount = 0;

                // Load stats for each active market
                const marketTypes = ['hourly', 'daily', 'weekly', 'extreme'];
                for (const type of marketTypes) {
                    const market = markets[type];
                    if (!market || !market.id) continue;

                    activeCount++;

                    try {
                        // Use collateralMap if available (from loadMarkets), otherwise fetch
                        let collateralLocked;
                        const cachedCollateral = collateralMap?.get(market.id.toString());
                        if (cachedCollateral !== undefined) {
                            collateralLocked = cachedCollateral;
                        } else {
                            const marketData = await pamm.getMarket(market.id);
                            collateralLocked = marketData.collateralLocked || marketData[6] || 0n;
                        }

                        // Market TVL = total collateral locked (ETH backing all tokens)
                        const marketTvl = Number(collateralLocked) / 1e18;
                        totalTvl += marketTvl;

                        // Update individual card
                        const poolEl = document.getElementById(`${type}PoolTvl`);
                        if (poolEl) poolEl.textContent = formatEth(marketTvl);

                        // Get orderbook depth
                        try {
                            const [bidHashes, bidOrders, askHashes, askOrders] = await pmRouter.getOrderbook(market.id, true, 20);
                            const orderCount = bidHashes.length + askHashes.length;

                            // Sum orderbook liquidity (collateral in orders)
                            let orderbookLiq = 0;
                            for (const o of bidOrders) orderbookLiq += Number(o.collateral) / 1e18;
                            for (const o of askOrders) orderbookLiq += Number(o.collateral) / 1e18;
                            totalOrderbookLiq += orderbookLiq;

                            const orderbookEl = document.getElementById(`${type}Orderbook`);
                            if (orderbookEl) {
                                if (orderCount > 0) {
                                    orderbookEl.textContent = formatEth(orderbookLiq);
                                } else {
                                    orderbookEl.textContent = 'none';
                                }
                            }
                        } catch (e) {
                            // PMRouter may not be deployed yet
                            const orderbookEl = document.getElementById(`${type}Orderbook`);
                            if (orderbookEl) orderbookEl.textContent = '--';
                        }

                    } catch (e) {
                        console.warn(`Failed to load liquidity for ${type}:`, e);
                    }
                }

                // Update global stats
                DOM.totalPoolTvl.textContent = formatEth(totalTvl);
                DOM.totalOrderbookLiq.textContent = totalOrderbookLiq > 0 ? formatEth(totalOrderbookLiq) : '--';
                DOM.activeMarketsCount.textContent = activeCount.toString();

            } catch (e) {
                console.error('Failed to load liquidity stats:', e);
            }
        }

        // Hide create cards for market types that already have active markets
        function updateCreateCardsVisibility() {
            const cards = {
                hourly: document.getElementById('createHourlyCard'),
                daily: document.getElementById('createDailyCard'),
                weekly: document.getElementById('createWeeklyCard'),
                extreme: document.getElementById('createExtremeCard')
            };

            let allActive = true;
            for (const [type, card] of Object.entries(cards)) {
                if (card) {
                    if (markets[type]) {
                        card.style.display = 'none';
                    } else {
                        card.style.display = '';
                        allActive = false;
                    }
                }
            }

            // Show message if all markets are active
            const allActiveMsg = document.getElementById('allMarketsActive');
            if (allActiveMsg) {
                allActiveMsg.style.display = allActive ? 'block' : 'none';
            }
        }

        // ======================== RESOLVED MARKETS ========================
        async function toggleResolved() {
            const section = document.getElementById('resolvedSection');
            const countEl = document.getElementById('resolvedMarketsCount');
            if (section) {
                const willShow = section.style.display === 'none';
                section.style.display = willShow ? 'block' : 'none';
                // Update arrow direction
                if (countEl) {
                    countEl.textContent = resolvedMarkets.length + (willShow ? ' â–´' : ' â–¾');
                }
                // Re-render when opening to fetch fresh balances (e.g., if wallet connected after initial load)
                if (willShow) {
                    await renderResolvedMarkets();
                }
            }
        }

        async function renderResolvedMarkets() {
            const grid = document.getElementById('resolvedGrid');
            if (!grid) return;

            if (resolvedMarkets.length === 0) {
                grid.innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:2rem;">No resolved markets yet</div>';
                return;
            }

            // Sort by close time (most recent first)
            const sorted = [...resolvedMarkets].sort((a, b) => b.close - a.close);

            // Load user's winning shares AND LP balances if connected
            let userWinnings = new Map(); // marketId -> winning token balance
            let userLpBalances = new Map(); // marketId -> { lpBalance, poolId }
            if (connectedAddress) {
                try {
                    const rpc = provider || await getRpcProvider();
                    const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                    const pammInterface = new ethers.Interface(PAMM_ABI);
                    const zammInterface = new ethers.Interface(ZAMM_ABI);

                    // First batch: get poolKeys for all markets
                    const poolKeyCalls = sorted.map(m => ({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('poolKey', [m.id, FEE_TIER])
                    }));
                    const poolKeyResults = await multicall.aggregate3(poolKeyCalls);

                    // Compute pool IDs and build balance calls
                    // Query BOTH YES and NO token balances for each market
                    const poolIds = new Map();
                    const noTokenIds = new Map();
                    const balanceCalls = [];
                    for (let i = 0; i < sorted.length; i++) {
                        const m = sorted[i];
                        const noId = ethers.solidityPackedKeccak256(['string', 'uint256'], ['PMARKET:NO', m.id]);
                        noTokenIds.set(m.id.toString(), noId);

                        // YES token balance (marketId)
                        balanceCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                        });
                        // NO token balance (derived)
                        balanceCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                        });

                        // LP token balance
                        if (poolKeyResults[i].success) {
                            const poolKey = pammInterface.decodeFunctionResult('poolKey', poolKeyResults[i].returnData)[0];
                            const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                                [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                            ));
                            poolIds.set(m.id.toString(), poolId);
                            balanceCalls.push({
                                target: ZAMM_ADDRESS,
                                allowFailure: true,
                                callData: zammInterface.encodeFunctionData('balanceOf', [connectedAddress, poolId])
                            });
                        } else {
                            // Placeholder for failed poolKey
                            balanceCalls.push({ target: ZAMM_ADDRESS, allowFailure: true, callData: '0x' });
                        }
                    }

                    if (balanceCalls.length > 0) {
                        const balanceResults = await multicall.aggregate3(balanceCalls);
                        for (let i = 0; i < sorted.length; i++) {
                            const m = sorted[i];
                            // Each market has 3 calls: YES, NO, LP
                            const yesRes = balanceResults[i * 3];
                            const noRes = balanceResults[i * 3 + 1];
                            const lpRes = balanceResults[i * 3 + 2];

                            const yesBal = yesRes.success ? BigInt(pammInterface.decodeFunctionResult('balanceOf', yesRes.returnData)[0]) : 0n;
                            const noBal = noRes.success ? BigInt(pammInterface.decodeFunctionResult('balanceOf', noRes.returnData)[0]) : 0n;

                            // Determine winning balance based on outcome
                            // outcome truthy = YES won, outcome falsy = NO won
                            const winBal = m.outcome ? yesBal : noBal;
                            const loseBal = m.outcome ? noBal : yesBal;
                            userWinnings.set(m.id.toString(), { winBal, loseBal, yesBal, noBal });

                            const poolId = poolIds.get(m.id.toString());
                            if (lpRes.success && poolId) {
                                const lpBal = BigInt(zammInterface.decodeFunctionResult('balanceOf', lpRes.returnData)[0]);
                                userLpBalances.set(m.id.toString(), { lpBalance: lpBal, poolId });
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load resolved market balances:', e);
                }
            }

            // Helper to truncate market ID
            const truncateId = (id) => {
                const s = id.toString();
                if (s.length <= 12) return s;
                return s.slice(0, 6) + '...' + s.slice(-4);
            };

            grid.innerHTML = sorted.map(m => {
                const typeLabel = m.isExtreme ? 'Challenge' : 'TWAP';
                const typeClass = m.isExtreme ? 'extreme' : 'daily';
                const outcomeLabel = m.isExtreme ? (m.outcome ? 'YES' : 'NO') : (m.outcome ? 'UP' : 'DOWN');
                const outcomeColor = m.outcome ? 'var(--green)' : 'var(--red)';
                const closeDate = new Date(m.close * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                const tvl = Number(m.collateralLocked) / 1e18;

                // User positions
                const posData = userWinnings.get(m.id.toString()) || { winBal: 0n, loseBal: 0n };
                const winBal = posData.winBal || 0n;
                const loseBal = posData.loseBal || 0n;
                const winBalNum = Number(winBal) / 1e18;
                const loseBalNum = Number(loseBal) / 1e18;
                const hasWinnings = winBal > 0n;
                const hasLosing = loseBal > 0n;

                const lpData = userLpBalances.get(m.id.toString());
                const lpBal = lpData?.lpBalance || 0n;
                const lpBalNum = Number(lpBal) / 1e18;
                const hasLp = lpBal > 0n;

                const hasPosition = hasWinnings || hasLp || hasLosing;

                return `
                    <div class="bet-card resolved" style="opacity:0.9;">
                        <div class="bet-header">
                            <span class="bet-type ${typeClass}">${typeLabel}</span>
                            <span style="font-size:var(--font-xs);color:var(--text-dim);">${closeDate}</span>
                        </div>
                        <div class="bet-title" style="font-size:var(--font-sm);" title="Market #${m.id}">Market #${truncateId(m.id)}</div>
                        <div style="text-align:center;padding:0.75rem 0;">
                            <div style="font-size:var(--font-xs);color:var(--text-dim);">Outcome</div>
                            <div style="font-size:var(--font-lg);font-weight:700;color:${outcomeColor};">${outcomeLabel} Won</div>
                        </div>
                        ${hasPosition ? `
                            <div style="background:var(--gray);border-radius:var(--radius);padding:0.75rem;margin:0.5rem 0;">
                                ${hasWinnings ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);${hasLp || hasLosing ? 'margin-bottom:0.5rem;' : ''}">
                                        <span style="color:var(--text-muted);">Winnings</span>
                                        <span style="color:var(--green);font-weight:600;">${winBalNum.toFixed(4)} ETH</span>
                                    </div>
                                ` : ''}
                                ${hasLosing && !hasWinnings && !hasLp ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);">
                                        <span style="color:var(--text-muted);">Position</span>
                                        <span style="color:var(--text-dim);font-weight:600;">Claimed âœ“</span>
                                    </div>
                                ` : ''}
                                ${hasLp ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);">
                                        <span style="color:var(--text-muted);">LP Position</span>
                                        <span style="color:var(--blue);font-weight:600;">${lpBalNum.toFixed(4)}</span>
                                    </div>
                                ` : ''}
                            </div>
                            ${hasWinnings && !hasLp ? `
                                <button class="bet-btn up" style="width:100%;margin-top:0.5rem;" onclick="claimWinnings('${m.id}')">
                                    <div class="bet-btn-label">Claim ${winBalNum.toFixed(4)} ETH</div>
                                </button>
                            ` : ''}
                            ${hasLp ? `
                                <button class="bet-btn up" style="width:100%;margin-top:0.5rem;" onclick="withdrawLP('${m.id}', ${hasWinnings})">
                                    <div class="bet-btn-label">Withdraw All</div>
                                </button>
                            ` : ''}
                        ` : `
                            <div style="font-size:var(--font-xs);color:var(--text-dim);text-align:center;padding-top:0.5rem;">TVL: ${formatEth(tvl)}</div>
                        `}
                    </div>
                `;
            }).join('');
        }

        async function claimWinnings(marketId) {
            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                await monitorTransaction(
                    pamm.claim(marketId, connectedAddress),
                    {
                        pending: { title: 'Claiming Winnings', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Claiming Winnings', body: 'Waiting for confirmation...' },
                        success: { title: 'Winnings Claimed!', body: 'Your winnings have been sent to your wallet' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            renderResolvedMarkets();
                        }
                    }
                );
            } catch (e) {
                // monitorTransaction already shows toast for errors, so just log
                console.error('Claim failed:', e);
            }
        }

        async function withdrawLP(marketId, hasDirectWinnings = false) {
            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                // Get LP balance
                const poolKey = await pamm.poolKey(marketId, FEE_TIER);
                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                    [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                ));
                const lpBalance = await zamm.balanceOf(connectedAddress, poolId);

                if (lpBalance === 0n) {
                    showToast('No LP', 'No LP position to withdraw', 'error', 3000);
                    return;
                }

                // Ensure PAMM is approved as operator for ZAMM
                const isApproved = await zamm.isOperator(connectedAddress, PAMM_ADDRESS);
                if (!isApproved) {
                    let approved = false;
                    await monitorTransaction(zamm.setOperator(PAMM_ADDRESS, true), {
                        pending: { title: 'Approval Required', body: 'Approve PAMM as operator...' },
                        submitted: { title: 'Approval Required', body: 'Waiting for confirmation...' },
                        success: { title: 'Approved!', body: 'PAMM can now manage your LP tokens' },
                        error: { title: 'Approval Failed', body: '' },
                        onSuccess: () => { approved = true; }
                    });
                    if (!approved) return;
                }

                const deadline = Math.floor(Date.now() / 1000) + 600;
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Build calls array - removeLiquidityToCollateral already handles winning tokens from LP
                // Only add claim if user has direct winning token holdings (from trades)
                const calls = [
                    pammInterface.encodeFunctionData('removeLiquidityToCollateral', [
                        marketId,
                        FEE_TIER,
                        lpBalance,
                        0, // amount0Min
                        0, // amount1Min
                        0, // minCollateralOut
                        connectedAddress,
                        deadline
                    ])
                ];

                // Only claim if user has direct winning tokens (not from LP)
                if (hasDirectWinnings) {
                    calls.push(pammInterface.encodeFunctionData('claim', [marketId, connectedAddress]));
                }

                await monitorTransaction(
                    pamm.multicall(calls),
                    {
                        pending: { title: 'Withdrawing All', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Withdrawing All', body: 'Waiting for confirmation...' },
                        success: { title: 'Withdrawn!', body: 'LP and winnings returned to your wallet' },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            renderResolvedMarkets();
                        }
                    }
                );
            } catch (e) {
                console.error('Withdraw LP failed:', e);
            }
        }

        function updateCard(type, startGwei, nowGwei, yesPrice, noPrice, needsResolve = false) {
            // Format gwei values with appropriate precision
            const formatGweiValue = (gwei) => {
                if (gwei >= 10) return gwei.toFixed(1);
                if (gwei >= 1) return gwei.toFixed(2);
                return gwei.toFixed(3);
            };

            document.getElementById(`${type}Start`).textContent = formatGweiValue(startGwei);
            document.getElementById(`${type}Now`).textContent = formatGweiValue(nowGwei);

            const arrow = document.getElementById(`${type}Arrow`);
            const diff = nowGwei - startGwei;
            const pctChange = startGwei > 0 ? (diff / startGwei * 100) : 0;

            if (nowGwei > startGwei * 1.001) { // > 0.1% higher
                arrow.textContent = 'â–²';
                arrow.className = 'gas-compare-arrow up';
                arrow.title = `+${pctChange.toFixed(1)}% from start`;
            } else if (nowGwei < startGwei * 0.999) { // > 0.1% lower
                arrow.textContent = 'â–¼';
                arrow.className = 'gas-compare-arrow down';
                arrow.title = `${pctChange.toFixed(1)}% from start`;
            } else {
                arrow.textContent = '=';
                arrow.className = 'gas-compare-arrow';
                arrow.title = 'No significant change';
            }

            document.getElementById(`${type}UpOdds`).textContent = formatOdds(yesPrice);
            document.getElementById(`${type}DownOdds`).textContent = formatOdds(noPrice);
            document.getElementById(`${type}UpPrice`).textContent = formatEth(yesPrice, '');
            document.getElementById(`${type}DownPrice`).textContent = formatEth(noPrice, '');

            // Show/hide resolve button and update card state for expired markets
            const resolveBtn = document.getElementById(`${type}ResolveBtn`);
            const buttonsDiv = document.querySelector(`#${type}Card .bet-buttons`);
            const countdownEl = document.getElementById(`${type}Countdown`);

            if (needsResolve) {
                // Market expired - show resolve button, hide trade buttons
                if (resolveBtn) resolveBtn.style.display = 'block';
                if (buttonsDiv) buttonsDiv.style.opacity = '0.5';
                if (countdownEl) {
                    countdownEl.textContent = 'Ready to resolve';
                    countdownEl.style.color = 'var(--amber)';
                }
            } else {
                if (resolveBtn) resolveBtn.style.display = 'none';
                if (buttonsDiv) buttonsDiv.style.opacity = '1';
            }
        }

        async function loadPositions() {
            if (!connectedAddress) return;

            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                const marketList = [];
                const types = [];
                if (markets.hourly) { marketList.push(markets.hourly); types.push('hourly'); }
                if (markets.daily) { marketList.push(markets.daily); types.push('daily'); }
                if (markets.weekly) { marketList.push(markets.weekly); types.push('weekly'); }
                if (markets.extreme) { marketList.push(markets.extreme); types.push('extreme'); }

                if (marketList.length === 0) return;

                // Build multicall for YES and NO balances
                const calls = [];
                for (const m of marketList) {
                    // YES balance (marketId is the YES token id)
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                    });
                    // NO balance (need to compute noId = keccak256(abi.encodePacked("PMARKET:NO", marketId)))
                    const noId = ethers.solidityPackedKeccak256(
                        ['string', 'uint256'],
                        ['PMARKET:NO', m.id]
                    );
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                    });
                }

                const results = await multicall.aggregate3(calls);

                for (let i = 0; i < types.length; i++) {
                    const t = types[i];
                    const yesResult = results[i * 2];
                    const noResult = results[i * 2 + 1];

                    const yes = yesResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', yesResult.returnData)[0]) / 1e18 : 0;
                    const no = noResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', noResult.returnData)[0]) / 1e18 : 0;

                    if (yes > 0 || no > 0) {
                        document.getElementById(`${t}Position`).style.display = 'block';
                        document.getElementById(`${t}${t === 'extreme' ? 'Yes' : 'Up'}Bal`).textContent = yes.toFixed(4);
                        document.getElementById(`${t}${t === 'extreme' ? 'No' : 'Down'}Bal`).textContent = no.toFixed(4);
                    } else {
                        document.getElementById(`${t}Position`).style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Load positions failed:', e);
            }
        }

        function hidePositions() {
            ['hourly', 'daily', 'weekly', 'extreme'].forEach(t => {
                document.getElementById(`${t}Position`).style.display = 'none';
            });
        }

        // ======================== CHART ========================
        let hoverIndex = -1; // Track hovered data point for crosshair
        let resizeTimer = null; // For debouncing resize
        let tooltipSpotEl, tooltipTwapEl, tooltipTimeEl; // Cache tooltip elements

        function setupChart() {
            const canvas = DOM.gasChart;
            const tooltip = DOM.chartTooltip;
            const predTooltip = DOM.predTooltip;

            if (!canvas || !tooltip) {
                console.error('Chart elements not found');
                return;
            }

            // Cache tooltip sub-elements
            tooltipSpotEl = document.getElementById('tooltipSpot');
            tooltipTwapEl = document.getElementById('tooltipTwap');
            tooltipTimeEl = document.getElementById('tooltipTime');

            // Cache prediction tooltip elements
            const predBadge = document.getElementById('predBadge');
            const predTitle = document.getElementById('predTitle');
            const predTwap = document.getElementById('predTwap');
            const predDirection = document.getElementById('predDirection');
            const predThreshold = document.getElementById('predThreshold');
            const predTvl = document.getElementById('predTvl');
            const predCloses = document.getElementById('predCloses');

            canvas.addEventListener('mousemove', (e) => {
                if (!chartState.data || !chartState.data.length) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const { data, rollingTwap, padding, chartWidth, width, height } = chartState;

                // Check if hovering over price change badge first
                if (priceChangeBadgeArea) {
                    const b = priceChangeBadgeArea;
                    if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                        // Show price change tooltip using the chart tooltip
                        tooltip.classList.remove('visible');
                        if (predTooltip) predTooltip.classList.remove('visible');
                        hoverIndex = -1;
                        hoveredPrediction = null;

                        // Format time span for display
                        let timeDesc = '';
                        if (b.timeSpan < 3600) {
                            timeDesc = 'Last ' + Math.round(b.timeSpan / 60) + ' minutes';
                        } else if (b.timeSpan < 86400) {
                            const hrs = Math.round(b.timeSpan / 3600);
                            timeDesc = 'Last ' + hrs + ' hour' + (hrs > 1 ? 's' : '');
                        } else {
                            const days = Math.round(b.timeSpan / 86400);
                            timeDesc = 'Last ' + days + ' day' + (days > 1 ? 's' : '');
                        }

                        // Update tooltip content for price change
                        tooltipTimeEl.textContent = timeDesc;
                        tooltipSpotEl.textContent = b.firstVal.toFixed(2) + ' â†’ ' + b.lastVal.toFixed(2) + ' gwei';
                        const changeSign = b.change >= 0 ? '+' : '';
                        tooltipTwapEl.textContent = changeSign + b.change.toFixed(2) + '% change';

                        // Position tooltip near badge
                        tooltip.style.left = (b.x + b.width + 10) + 'px';
                        tooltip.style.top = (b.y) + 'px';
                        tooltip.classList.add('visible');

                        canvas.style.cursor = 'help';
                        return;
                    }
                }

                // Check if hovering over a prediction marker
                let foundPrediction = null;
                for (const marker of predictionMarkerPositions) {
                    const dx = x - marker.x;
                    const dy = y - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        foundPrediction = marker;
                        break;
                    }
                }

                if (foundPrediction && predTooltip) {
                    // Hide chart tooltip, show prediction tooltip
                    tooltip.classList.remove('visible');
                    hoverIndex = -1;

                    // Update prediction tooltip content
                    const marketNames = { hourly: 'Hourly', daily: 'Daily', weekly: 'Weekly' };
                    const isUp = foundPrediction.yesPrice > 0.5;
                    const prob = Math.round(foundPrediction.yesPrice * 100);

                    if (predBadge) {
                        predBadge.textContent = foundPrediction.label;
                        predBadge.style.background = foundPrediction.color;
                        predBadge.style.color = '#18181b';
                    }
                    if (predTitle) predTitle.textContent = marketNames[foundPrediction.type] + ' Prediction';
                    predTooltip.style.borderColor = foundPrediction.color;

                    // Get market data for threshold
                    const marketData = markets[foundPrediction.type];
                    const threshold = marketData?.startGwei || 0;
                    const predicted = foundPrediction.predicted;
                    const aboveThreshold = predicted > threshold;

                    // Direction/Odds indicator - shows market sentiment
                    const isNeutral = prob >= 45 && prob <= 55;
                    if (predDirection) {
                        if (isNeutral) {
                            predDirection.className = 'pred-tooltip-direction neutral';
                            predDirection.innerHTML = `~50% EVEN`;
                        } else {
                            predDirection.className = 'pred-tooltip-direction ' + (isUp ? 'up' : 'down');
                            predDirection.innerHTML = `${isUp ? prob : 100 - prob}% ${isUp ? 'UP' : 'DOWN'}`;
                        }
                    }

                    // Threshold - what the market is betting against
                    if (predThreshold) {
                        predThreshold.textContent = threshold.toFixed(3) + ' gwei';
                    }

                    // Predicted value with above/below indicator
                    if (predTwap) {
                        const arrow = aboveThreshold ? 'â†‘' : 'â†“';
                        const color = aboveThreshold ? '#22c55e' : '#ef4444';
                        predTwap.innerHTML = `<span style="color:${color}">${arrow}</span> ${predicted.toFixed(3)} gwei`;
                    }

                    // Time to close
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = foundPrediction.closeTime - now;
                    if (predCloses) predCloses.textContent = formatTime(remaining);

                    // TVL
                    if (predTvl) predTvl.textContent = marketData?.tvl ? formatEth(marketData.tvl) : '--';

                    // Position prediction tooltip - responsive
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    const isMobileTooltip = canvasWidth < 400;
                    const predTooltipWidth = isMobileTooltip ? 150 : 180;
                    const predTooltipHeight = isMobileTooltip ? 130 : 150;
                    let tooltipX, tooltipY;

                    if (isMobileTooltip) {
                        // On mobile, position to left of marker (prediction zone is on right)
                        tooltipX = Math.max(5, x - predTooltipWidth - 10);
                        // Center vertically on marker, but clamp to canvas
                        tooltipY = Math.max(5, Math.min(y - predTooltipHeight / 2, canvasHeight - predTooltipHeight - 5));
                    } else {
                        // Desktop: position to left of marker to avoid going off right edge
                        tooltipX = x - predTooltipWidth - 15;
                        tooltipY = y - predTooltipHeight / 2;

                        // If not enough room on left, try right
                        if (tooltipX < 10) {
                            tooltipX = x + 15;
                        }
                        // Clamp to canvas edges
                        if (tooltipY + predTooltipHeight > canvasHeight) {
                            tooltipY = canvasHeight - predTooltipHeight - 5;
                        }
                        if (tooltipY < 5) {
                            tooltipY = 5;
                        }
                    }

                    predTooltip.style.left = tooltipX + 'px';
                    predTooltip.style.top = tooltipY + 'px';
                    predTooltip.classList.add('visible');

                    // Update hovered prediction state
                    if (hoveredPrediction !== foundPrediction.type) {
                        hoveredPrediction = foundPrediction.type;
                        drawChart(cachedGasData); // Redraw with highlight
                    }

                    canvas.style.cursor = 'pointer';
                    return;
                }

                // Not hovering over prediction - hide prediction tooltip
                if (hoveredPrediction) {
                    hoveredPrediction = null;
                    drawChart(cachedGasData);
                }
                if (predTooltip) predTooltip.classList.remove('visible');
                canvas.style.cursor = 'crosshair';

                // Regular chart hover logic
                const idx = Math.round((x - padding) / chartWidth * (data.length - 1));
                const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                // Update hover index and redraw for crosshair
                if (hoverIndex !== clampedIdx) {
                    hoverIndex = clampedIdx;
                    drawChart(cachedGasData);
                }

                if (clampedIdx >= 0 && clampedIdx < data.length) {
                    const spotVal = data[clampedIdx];
                    const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                    // Update tooltip content
                    tooltipSpotEl.textContent = spotVal.toFixed(2) + ' gwei';
                    tooltipTwapEl.textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                    // Time display
                    let timeText = '';
                    if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                        const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                        timeText = date.toLocaleString();
                    } else if (clampedIdx === data.length - 1) {
                        timeText = 'Now';
                    }
                    tooltipTimeEl.textContent = timeText;

                    // Position tooltip with edge clamping
                    const tooltipWidth = 160;
                    const tooltipHeight = 80;
                    let tooltipX = e.clientX - rect.left + 15;
                    let tooltipY = e.clientY - rect.top - 10;

                    // Clamp to right edge
                    if (tooltipX + tooltipWidth > width) {
                        tooltipX = e.clientX - rect.left - tooltipWidth - 15;
                    }
                    // Clamp to bottom edge
                    if (tooltipY + tooltipHeight > height) {
                        tooltipY = height - tooltipHeight - 10;
                    }
                    // Clamp to top edge
                    if (tooltipY < 10) {
                        tooltipY = 10;
                    }

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.classList.add('visible');
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
                if (predTooltip) predTooltip.classList.remove('visible');
                hoverIndex = -1;
                hoveredPrediction = null;
                canvas.style.cursor = 'default';
                drawChart(cachedGasData); // Clear crosshair
            });

            // Click handler for prediction markers - opens trade modal
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if clicking on a prediction marker
                for (const marker of predictionMarkerPositions) {
                    const dx = x - marker.x;
                    const dy = y - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        // Open trade for this market (default to UP/YES)
                        const isUp = marker.yesPrice > 0.5;
                        openTrade(marker.type, isUp);
                        return;
                    }
                }
            });

            // Touch support for mobile - full chart interaction
            let touchTimeout = null;
            let isTouchingChart = false;

            function handleChartTouch(touchX, touchY, clientX, clientY) {
                if (!chartState.data || !chartState.data.length) return false;

                const { data, rollingTwap, padding, chartWidth, width, height } = chartState;

                // Check if touching a prediction marker first
                for (const marker of predictionMarkerPositions) {
                    const dx = touchX - marker.x;
                    const dy = touchY - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        hoveredPrediction = marker.type;
                        if (cachedGasData) drawChart(cachedGasData);
                        // Trigger mousemove to show prediction tooltip
                        canvas.dispatchEvent(new MouseEvent('mousemove', { clientX, clientY }));
                        return true;
                    }
                }

                // Check if touching within chart area (not prediction zone)
                if (touchX >= padding && touchX <= padding + chartWidth) {
                    // Calculate data index from touch position
                    const idx = Math.round((touchX - padding) / chartWidth * (data.length - 1));
                    const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                    if (clampedIdx >= 0 && clampedIdx < data.length) {
                        hoverIndex = clampedIdx;
                        if (cachedGasData) drawChart(cachedGasData);

                        const spotVal = data[clampedIdx];
                        const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                        // Update tooltip content
                        tooltipSpotEl.textContent = spotVal.toFixed(2) + ' gwei';
                        tooltipTwapEl.textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                        // Time display
                        let timeText = '';
                        if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                            const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                            timeText = date.toLocaleString();
                        } else if (clampedIdx === data.length - 1) {
                            timeText = 'Now';
                        }
                        tooltipTimeEl.textContent = timeText;

                        // Position tooltip - centered above touch point on mobile
                        const tooltipWidth = 140;
                        let tooltipX = Math.max(5, Math.min(touchX - tooltipWidth / 2, width - tooltipWidth - 5));
                        let tooltipY = Math.max(5, touchY - 70);

                        tooltip.style.left = tooltipX + 'px';
                        tooltip.style.top = tooltipY + 'px';
                        tooltip.classList.add('visible');
                        return true;
                    }
                }

                return false;
            }

            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Clear any pending timeout
                if (touchTimeout) clearTimeout(touchTimeout);

                isTouchingChart = handleChartTouch(x, y, touch.clientX, touch.clientY);

                if (isTouchingChart) {
                    e.preventDefault(); // Prevent scroll while interacting
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (!isTouchingChart) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                handleChartTouch(x, y, touch.clientX, touch.clientY);
                e.preventDefault();
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                // Clear tooltip after a delay on touch release
                if (touchTimeout) clearTimeout(touchTimeout);
                touchTimeout = setTimeout(() => {
                    tooltip.classList.remove('visible');
                    if (predTooltip) predTooltip.classList.remove('visible');
                    hoverIndex = -1;
                    hoveredPrediction = null;
                    isTouchingChart = false;
                    if (cachedGasData) drawChart(cachedGasData);
                }, 2500); // Keep tooltip visible for 2.5s after touch ends
            });

            // Debounced resize handler
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (chartDataPoints.length) drawChart(cachedGasData);
                }, 150);
            });
        }

        // Cache canvas context
        let chartCtx = null;

        function drawChart(gasData) {
            const { twap, current, startTime } = gasData;

            const canvas = DOM.gasChart;
            if (!chartCtx) chartCtx = canvas.getContext('2d');
            const ctx = chartCtx;
            const container = canvas.parentElement;

            // Only resize canvas if dimensions actually changed (avoids clearing on every frame)
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            if (lastCanvasSize.width !== newWidth || lastCanvasSize.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                lastCanvasSize.width = newWidth;
                lastCanvasSize.height = newHeight;
            }

            const width = canvas.width;
            const height = canvas.height;

            // Responsive padding based on screen width
            const isMobile = width < 400;
            const isSmall = width < 600;
            const padding = isMobile ? 25 : (isSmall ? 32 : 40);
            const paddingRight = isMobile ? 60 : (isSmall ? 80 : 100); // Extra space for prediction zone
            const chartWidth = width - padding - paddingRight; // Chart area width

            // Clear
            ctx.fillStyle = '#18181b';
            ctx.fillRect(0, 0, width, height);

            // Use actual data points, or just current if no history
            // Note: We reference arrays directly for pulse animation, only copy when data changes
            let data = chartDataPoints.length > 0 ? chartDataPoints : [current];
            let timestamps = chartTimestamps;
            let cumulatives = chartCumulatives;

            // Ensure current is last point (only modify if needed)
            if (data.length === 0 || data[data.length - 1] !== current) {
                data = [...data, current];
                timestamps = [...timestamps, Math.floor(Date.now() / 1000)];
            }

            // Downsample for large datasets (keep max ~300 points for smooth rendering)
            const maxDisplayPoints = 300;
            let downsampleFactor = 1;
            if (data.length > maxDisplayPoints) {
                downsampleFactor = Math.ceil(data.length / maxDisplayPoints);
                const sampledData = [];
                const sampledTimestamps = [];
                const sampledCumulatives = [];
                for (let i = 0; i < data.length; i += downsampleFactor) {
                    sampledData.push(data[i]);
                    if (timestamps[i] !== undefined) sampledTimestamps.push(timestamps[i]);
                    if (cumulatives[i] !== undefined) sampledCumulatives.push(cumulatives[i]);
                }
                // Always include the last point
                if (sampledData[sampledData.length - 1] !== data[data.length - 1]) {
                    sampledData.push(data[data.length - 1]);
                    if (timestamps.length > 0) sampledTimestamps.push(timestamps[timestamps.length - 1]);
                    if (cumulatives.length > 0) sampledCumulatives.push(cumulatives[cumulatives.length - 1]);
                }
                data = sampledData;
                timestamps = sampledTimestamps;
                cumulatives = sampledCumulatives;
            }

            // Compute rolling TWAP from cumulative observations
            let rollingTwap = [];
            if (cumulatives.length >= 2 && startTime) {
                for (let i = 0; i < cumulatives.length; i++) {
                    const elapsed = timestamps[i] - startTime;
                    if (elapsed > 0) {
                        rollingTwap.push(cumulatives[i] / elapsed / 1e9);
                    } else {
                        rollingTwap.push(data[i]);
                    }
                }
            }
            // Add current TWAP as final point if needed
            if (rollingTwap.length > 0 && rollingTwap.length < data.length) {
                rollingTwap.push(twap);
            }

            // Calculate Y range (include rolling TWAP but only reasonable predictions)
            const allValues = [...data, twap];
            if (rollingTwap.length > 0) allValues.push(...rollingTwap);

            // Calculate base range from actual data first
            const dataMin = Math.min(...data);
            const dataMax = Math.max(...data);
            const dataRange = dataMax - dataMin;

            // Only include predictions if they're within 3x of the data range
            // This prevents extreme outliers from distorting the chart
            const addPredictionIfReasonable = (pred) => {
                if (!pred || pred <= 0) return;
                // Check if prediction is within reasonable bounds (within 3x range of data)
                const upperBound = dataMax + dataRange * 2;
                const lowerBound = Math.max(0, dataMin - dataRange * 2);
                if (pred >= lowerBound && pred <= upperBound) {
                    allValues.push(pred);
                }
            };
            addPredictionIfReasonable(markets.hourly?.predictedTwap);
            addPredictionIfReasonable(markets.daily?.predictedTwap);
            addPredictionIfReasonable(markets.weekly?.predictedTwap);

            let max = Math.max(...allValues) * 1.1;
            let min = Math.min(...allValues) * 0.9;

            // Ensure non-zero range to prevent division by zero
            const range = Math.max(max - min, 0.001);
            const gweiToY = (gwei) => padding + (height - padding * 2) * (1 - (gwei - min) / range);

            // Determine decimal places based on range
            const getDecimals = (r) => {
                if (r >= 10) return 0;
                if (r >= 1) return 1;
                if (r >= 0.1) return 2;
                if (r >= 0.01) return 3;
                return 4;
            };
            const decimals = getDecimals(range);

            // Draw grid - responsive Y-axis labels
            const axisFontSize = isMobile ? 8 : (isSmall ? 9 : 10);
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (height - padding * 2) * i / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'right';
                ctx.fillText((max - range * i / 4).toFixed(decimals), padding - (isMobile ? 3 : 5), y + 4);
            }

            // Draw time axis labels (X-axis)
            if (timestamps.length > 1) {
                const firstTime = timestamps[0];
                const lastTime = timestamps[timestamps.length - 1];
                const timeSpan = lastTime - firstTime;

                // Determine time format based on span
                const formatTime = (ts) => {
                    const d = new Date(ts * 1000);
                    if (timeSpan < 86400) { // < 1 day: show hours
                        return d.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                    } else if (timeSpan < 604800) { // < 1 week: show day + hour
                        return d.toLocaleDateString(undefined, { weekday: 'short', hour: '2-digit' });
                    } else { // >= 1 week: show date
                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    }
                };

                // Draw 3-5 time labels evenly spaced - responsive
                const numLabels = isMobile ? Math.min(3, data.length) : Math.min(5, data.length);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'center';
                for (let i = 0; i < numLabels; i++) {
                    const idx = Math.floor(i * (timestamps.length - 1) / (numLabels - 1));
                    const x = padding + chartWidth * idx / Math.max(1, data.length - 1);
                    const label = formatTime(timestamps[idx]);
                    ctx.fillText(label, x, height - padding + (isMobile ? 18 : 28));
                }
            }

            // Draw rolling TWAP line (cyan, behind spot line)
            if (rollingTwap.length > 1) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                for (let i = 0; i < rollingTwap.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(rollingTwap[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw current TWAP reference (final value as horizontal dashed line) - responsive
            const twapY = gweiToY(twap);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, twapY);
            ctx.lineTo(padding + chartWidth, twapY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#3b82f6';
            ctx.font = `${axisFontSize}px Helvetica`;
            ctx.textAlign = 'right';
            // Position TWAP label BEFORE prediction zone to avoid overlap with diamonds
            const twapLabel = isMobile ? twap.toFixed(decimals) : ('TWAP ' + twap.toFixed(decimals));
            ctx.fillText(twapLabel, padding + chartWidth - (isMobile ? 3 : 5), twapY + 4);

            // Draw line chart connecting data points (spot prices)
            if (data.length > 0) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw gradient fill under spot line
                const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
                gradient.addColorStop(0, 'rgba(34, 197, 94, 0.15)');
                gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                for (let i = 0; i < data.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(padding + chartWidth, height - padding);
                ctx.closePath();
                ctx.fill();

                // Find min/max values and indices
                let minVal = Infinity, maxVal = -Infinity, minIdx = 0, maxIdx = 0;
                for (let i = 0; i < data.length; i++) {
                    if (data[i] < minVal) { minVal = data[i]; minIdx = i; }
                    if (data[i] > maxVal) { maxVal = data[i]; maxIdx = i; }
                }

                // Draw data points (skip for large datasets - line is enough)
                if (data.length <= 100) {
                    const pointSize = data.length > 50 ? 2 : (data.length > 20 ? 3 : 4);
                    ctx.fillStyle = '#22c55e';
                    for (let i = 0; i < data.length; i++) {
                        const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                        const y = gweiToY(data[i]);
                        ctx.beginPath();
                        ctx.arc(x, y, i === data.length - 1 ? 6 : pointSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw min/max markers (subtle, just small indicators)
                if (data.length > 3) {
                    // Max marker - small diamond
                    const maxX = padding + chartWidth * maxIdx / Math.max(1, data.length - 1);
                    const maxY = gweiToY(maxVal);
                    if (maxIdx !== data.length - 1) { // Don't mark if it's the current point
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(maxX, maxY - 6);
                        ctx.lineTo(maxX + 4, maxY);
                        ctx.lineTo(maxX, maxY + 6);
                        ctx.lineTo(maxX - 4, maxY);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Min marker - small diamond (only if significantly different position)
                    if (Math.abs(minIdx - maxIdx) > 2 && minIdx !== data.length - 1) {
                        const minX = padding + chartWidth * minIdx / Math.max(1, data.length - 1);
                        const minY = gweiToY(minVal);
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(minX, minY - 5);
                        ctx.lineTo(minX + 3, minY);
                        ctx.lineTo(minX, minY + 5);
                        ctx.lineTo(minX - 3, minY);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw crosshair on hover
                if (hoverIndex >= 0 && hoverIndex < data.length) {
                    const hoverX = padding + chartWidth * hoverIndex / Math.max(1, data.length - 1);
                    const hoverY = gweiToY(data[hoverIndex]);

                    // Vertical line
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(hoverX, padding);
                    ctx.lineTo(hoverX, height - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Highlight circle on spot line
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hoverX, hoverY, 8, 0, Math.PI * 2);
                    ctx.stroke();

                    // Also highlight TWAP point if available
                    if (rollingTwap && rollingTwap[hoverIndex]) {
                        const twapHoverY = gweiToY(rollingTwap[hoverIndex]);
                        ctx.strokeStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(hoverX, twapHoverY, 6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Pulsing live point (outer glow) - responsive
                const lastX = padding + chartWidth;
                const lastY = gweiToY(data[data.length - 1]);
                const pulseTime = Date.now() / 1000;
                const pulseScale = 1 + 0.3 * Math.sin(pulseTime * 3);
                const pulseRadius = isMobile ? 8 : 12;
                ctx.fillStyle = 'rgba(34, 197, 94, 0.25)';
                ctx.beginPath();
                ctx.arc(lastX, lastY, pulseRadius * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                // White center on current point
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(lastX, lastY, isMobile ? 1.5 : 2, 0, Math.PI * 2);
                ctx.fill();

                // Current value label (next to live point) - responsive
                const currentLabel = data[data.length - 1].toFixed(decimals);
                ctx.font = `bold ${axisFontSize}px Helvetica`;
                ctx.textAlign = 'left';
                ctx.fillStyle = '#22c55e';
                const labelOffset = isMobile ? 12 : 18;
                const labelY = lastY < padding + 30 ? lastY + labelOffset : lastY - (isMobile ? 8 : 12);
                ctx.fillText(currentLabel, lastX + (isMobile ? 6 : 10), labelY);
            }

            // Price change badge (top-left, inside chart with subtle background)
            if (data.length > 1 && timestamps.length > 1) {
                const firstVal = data[0];
                const lastVal = data[data.length - 1];
                const change = firstVal > 0 ? ((lastVal - firstVal) / firstVal) * 100 : 0;
                const changeColor = change >= 0 ? '#22c55e' : '#ef4444';
                const changeSign = change >= 0 ? '+' : '';
                const changeText = changeSign + change.toFixed(1) + '%';

                // Calculate time period for context
                const timeSpan = timestamps[timestamps.length - 1] - timestamps[0];
                let periodLabel = '';
                if (timeSpan < 3600) {
                    periodLabel = Math.round(timeSpan / 60) + 'm';
                } else if (timeSpan < 86400) {
                    periodLabel = Math.round(timeSpan / 3600) + 'h';
                } else {
                    periodLabel = Math.round(timeSpan / 86400) + 'd';
                }

                // Responsive badge sizing
                const badgeFontBold = isMobile ? 8 : (isSmall ? 9 : 10);
                const badgeFontSmall = isMobile ? 7 : (isSmall ? 8 : 9);
                ctx.font = `bold ${badgeFontBold}px Helvetica`;
                const changeWidth = ctx.measureText(changeText).width;
                ctx.font = `${badgeFontSmall}px Helvetica`;
                const periodWidth = ctx.measureText(periodLabel).width;
                const totalWidth = changeWidth + periodWidth + (isMobile ? 4 : 6);

                // Draw subtle pill background - top left, above chart area - responsive
                const pillX = isMobile ? 4 : 8;
                const pillY = isMobile ? 10 : 12;
                const pillPadX = isMobile ? 4 : 6;
                const pillPadY = isMobile ? 3 : 4;
                const pillHeight = isMobile ? 13 : 16;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.roundRect(pillX - pillPadX, pillY - pillPadY - (isMobile ? 6 : 8), totalWidth + pillPadX * 2, pillHeight, 4);
                ctx.fill();

                // Draw change percentage
                ctx.textAlign = 'left';
                ctx.font = `bold ${badgeFontBold}px Helvetica`;
                ctx.fillStyle = changeColor;
                ctx.fillText(changeText, pillX, pillY);

                // Draw period label
                ctx.font = `${badgeFontSmall}px Helvetica`;
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText(periodLabel, pillX + changeWidth + (isMobile ? 3 : 4), pillY);

                // Store hit area for hover detection
                priceChangeBadgeArea = {
                    x: pillX - pillPadX,
                    y: pillY - pillPadY - (isMobile ? 6 : 8),
                    width: totalWidth + pillPadX * 2,
                    height: pillHeight,
                    change,
                    firstVal,
                    lastVal,
                    timeSpan,
                    periodLabel
                };
            } else {
                priceChangeBadgeArea = null;
            }

            // Legend - top-right corner, above chart area - responsive
            const legendFontSize = isMobile ? 7 : (isSmall ? 8 : 9);
            ctx.font = `${legendFontSize}px Helvetica`;
            ctx.textAlign = 'right';
            const legendY = isMobile ? 10 : 12;
            const legendSpacing = isMobile ? 30 : 40;
            ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
            ctx.fillText('â— Spot', width - legendSpacing * 2 - 5, legendY);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
            ctx.fillText('â€• TWAP', width - legendSpacing - 5, legendY);
            ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';
            ctx.fillText('â—† Pred', width - 5, legendY);

            // Draw prediction markers for each market
            drawPredictionMarkers(ctx, width, height, padding, chartWidth, gweiToY, timestamps, decimals);

            // Observation count (bottom-left) - show original count, not downsampled - responsive
            const originalCount = chartDataPoints.length || 1;
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = `${legendFontSize}px Helvetica`;
            ctx.fillText(`${originalCount} obs`, padding, height - padding + (isMobile ? 8 : 12));

            // Store state for tooltips (include rolling TWAP for tooltip display)
            chartState = { data, rollingTwap, padding, chartWidth, min, max, width, height, twap, current, timestamps, downsampleFactor };
        }

        /**
         * Draw prediction markers on the chart for each market's close time
         */
        function drawPredictionMarkers(ctx, width, height, padding, chartWidth, gweiToY, timestamps, decimals) {
            // Clear previous marker positions for hover detection
            predictionMarkerPositions = [];

            if (!timestamps || timestamps.length < 2) return;

            const firstTime = timestamps[0];
            const lastTime = timestamps[timestamps.length - 1];
            const timeRange = lastTime - firstTime;
            if (timeRange <= 0) return;

            // Responsive sizing based on canvas width
            const isMobile = width < 400;
            const isSmall = width < 600;

            const chartRightEdge = padding + chartWidth;

            // Draw "NOW" separator line - vertical dashed line at chart edge
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(chartRightEdge, padding);
            ctx.lineTo(chartRightEdge, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);

            // "NOW" label at top
            ctx.font = isMobile ? 'bold 7px Helvetica' : 'bold 9px Helvetica';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.textAlign = 'center';
            ctx.fillText('NOW', chartRightEdge, padding - (isMobile ? 4 : 6));

            // Subtle gradient overlay for prediction zone
            const predZoneGradient = ctx.createLinearGradient(chartRightEdge, 0, width, 0);
            predZoneGradient.addColorStop(0, 'rgba(255, 255, 255, 0.02)');
            predZoneGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
            ctx.fillStyle = predZoneGradient;
            ctx.fillRect(chartRightEdge, padding, width - chartRightEdge - 5, height - padding * 2);

            // Colors for each market type
            const marketColors = {
                hourly: '#f59e0b',  // amber
                daily: '#8b5cf6',   // purple
                weekly: '#06b6d4'   // cyan
            };

            const marketLabels = {
                hourly: '1H',
                daily: '1D',
                weekly: '1W'
            };

            // Animation time for pulse effect
            const pulseTime = Date.now() / 1000;

            // Draw predictions for each market (reverse order so hourly renders on top)
            ['weekly', 'daily', 'hourly'].forEach(type => {
                const market = markets[type];
                if (!market || !market.predictedTwap || !market.close) return;

                const closeTime = market.close;
                const predicted = market.predictedTwap;
                const yesPrice = market.yesPrice;
                const isHourly = type === 'hourly';

                // Calculate X position: extend chart to show future predictions
                const timeOffset = closeTime - lastTime;
                const futureExtend = Math.min(timeOffset / timeRange, 0.35);

                // Position: right edge + proportional future offset
                const xPos = padding + chartWidth + futureExtend * chartWidth;

                // Only draw if within canvas bounds (allow close to edge for predictions)
                if (xPos > width - 5) return;

                // Calculate Y position - use raw position for accurate placement
                const rawYPos = gweiToY(predicted);
                // Only clamp to prevent going off canvas, not for label fitting
                const minY = padding + 5;
                const maxY = height - padding - 5;
                const markerYPos = Math.max(minY, Math.min(rawYPos, maxY));

                const color = marketColors[type];
                const label = marketLabels[type];

                // Draw connecting line from current TWAP to ACTUAL prediction position (not clamped)
                // Gradient line that fades toward prediction
                const lineGradient = ctx.createLinearGradient(chartRightEdge, 0, xPos, 0);
                lineGradient.addColorStop(0, color);
                lineGradient.addColorStop(1, color + '80'); // 50% opacity at end
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = isHourly ? 2 : 1;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(chartRightEdge, gweiToY(cachedGasData.twap));
                ctx.lineTo(xPos, rawYPos); // Use raw position for accurate line direction
                ctx.stroke();
                ctx.setLineDash([]);

                // Marker size - larger on mobile for visibility, smaller on desktop for precision
                const markerSize = isMobile
                    ? (isHourly ? 10 : 7)
                    : (isSmall ? (isHourly ? 7 : 5) : (isHourly ? 8 : 5));

                // Draw glow effect for markers - more prominent on mobile
                const glowSize = isMobile
                    ? (isHourly ? (markerSize + 8 + Math.sin(pulseTime * 3) * 3) : (markerSize + 6))
                    : (isHourly ? (markerSize + 6 + Math.sin(pulseTime * 3) * 2) : (markerSize + 3));
                const glowGradient = ctx.createRadialGradient(xPos, markerYPos, 0, xPos, markerYPos, glowSize);
                glowGradient.addColorStop(0, color + '40');
                glowGradient.addColorStop(1, color + '00');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(xPos, markerYPos, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Draw prediction diamond marker
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(xPos, markerYPos - markerSize);
                ctx.lineTo(xPos + markerSize * 0.7, markerYPos);
                ctx.lineTo(xPos, markerYPos + markerSize);
                ctx.lineTo(xPos - markerSize * 0.7, markerYPos);
                ctx.closePath();
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#18181b';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Inner highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(xPos, markerYPos - markerSize + 2);
                ctx.lineTo(xPos + markerSize * 0.5, markerYPos);
                ctx.stroke();

                // Hover highlight ring
                if (hoveredPrediction === type) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(xPos, markerYPos, markerSize + 6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Extra glow on hover
                    const hoverGlow = ctx.createRadialGradient(xPos, markerYPos, markerSize, xPos, markerYPos, markerSize + 20);
                    hoverGlow.addColorStop(0, color + '60');
                    hoverGlow.addColorStop(1, color + '00');
                    ctx.fillStyle = hoverGlow;
                    ctx.beginPath();
                    ctx.arc(xPos, markerYPos, markerSize + 20, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw pill-style label badge - only on desktop to reduce mobile clutter
                const valueDecimals = predicted < 1 ? Math.max(2, decimals) : (decimals > 1 ? 1 : decimals);
                const valueText = predicted.toFixed(valueDecimals);
                const timeText = formatCloseTime(closeTime);

                if (!isMobile) {
                    const pillFontSize = isSmall ? 9 : 10;
                    ctx.font = `bold ${pillFontSize}px Helvetica`;
                    const labelWidth = ctx.measureText(label).width;
                    const pillWidth = Math.max(labelWidth + 12, 28);
                    const pillHeight = isSmall ? 16 : 18;
                    const pillX = xPos - pillWidth / 2;
                    const pillY = markerYPos - markerSize - pillHeight - 6;

                    // Pill background
                    ctx.fillStyle = color + 'E0';
                    ctx.beginPath();
                    ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 4);
                    ctx.fill();

                    // Pill border
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Label text
                    ctx.fillStyle = '#18181b';
                    ctx.font = `bold ${pillFontSize}px Helvetica`;
                    ctx.textAlign = 'center';
                    ctx.fillText(label, xPos, pillY + 13);

                    // Close time label (below pill)
                    ctx.font = isSmall ? '8px Helvetica' : '9px Helvetica';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(timeText, xPos, pillY + pillHeight + 10);
                }

                // Predicted value (below marker) - skip on mobile since value is in pill
                if (!isMobile) {
                    const valueFontSize = isSmall ? (isHourly ? 10 : 9) : (isHourly ? 11 : 10);
                    ctx.font = isHourly ? `bold ${valueFontSize}px Helvetica` : `${valueFontSize}px Helvetica`;
                    ctx.fillStyle = isHourly ? '#fff' : 'rgba(255,255,255,0.8)';
                    ctx.fillText(valueText + ' gwei', xPos, markerYPos + markerSize + 16);
                }

                // Draw odds indicator bar - only for hourly on mobile to reduce clutter
                if (!isMobile || isHourly) {
                    const barWidth = isMobile
                        ? 24
                        : (isSmall ? (isHourly ? 26 : 20) : (isHourly ? 32 : 24));
                    const barHeight = isMobile ? 4 : (isHourly ? 5 : 4);
                    const barX = xPos - barWidth / 2;
                    const barY = markerYPos + markerSize + (isMobile ? 6 : 22);

                    // Bar background with rounded ends
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth, barHeight, 2);
                    ctx.fill();

                    // Fill based on YES odds - neutral gray if near 50/50
                    const yesPct = Math.round(yesPrice * 100);
                    const isNeutralOdds = yesPct >= 45 && yesPct <= 55;
                    const oddsColor = isNeutralOdds ? '#71717a' : (yesPrice > 0.5 ? '#22c55e' : '#ef4444');
                    ctx.fillStyle = oddsColor;
                    ctx.beginPath();
                    ctx.roundRect(barX, barY, barWidth * yesPrice, barHeight, 2);
                    ctx.fill();

                    // Odds percentage label for hourly - hide on mobile to reduce clutter
                    if (isHourly && !isMobile) {
                        ctx.font = isSmall ? '7px Helvetica' : '8px Helvetica';
                        ctx.fillStyle = 'rgba(255,255,255,0.5)';
                        if (isNeutralOdds) {
                            ctx.fillText('~50% EVEN', xPos, barY + barHeight + 10);
                        } else {
                            ctx.fillText(yesPct + '% UP', xPos, barY + barHeight + 10);
                        }
                    }
                }

                // Store marker position for hover detection
                // Larger hit radius on mobile for easier touch targets
                const hitRadius = isMobile
                    ? (isHourly ? 40 : 30)
                    : (isHourly ? 25 : 18);
                predictionMarkerPositions.push({
                    type,
                    x: xPos,
                    y: markerYPos,
                    radius: hitRadius,
                    predicted,
                    yesPrice,
                    noPrice: market.noPrice,
                    closeTime,
                    color,
                    label
                });
            });
        }

        // Format close time for display
        function formatCloseTime(timestamp) {
            const date = new Date(timestamp * 1000);
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const h = hours % 12 || 12;
            const m = minutes.toString().padStart(2, '0');
            return h + ':' + m + ' ' + ampm;
        }

        // ======================== COUNTDOWNS ========================
        // Cache next period timestamps to avoid creating Date objects every second
        let cachedPeriods = { nextHour: 0, nextDay: 0, nextWeek: 0 };

        function updateCountdowns() {
            const now = Math.floor(Date.now() / 1000);

            // Hourly
            if (markets.hourly) {
                DOM.hourlyCountdown.textContent = formatTime(markets.hourly.close - now);
            } else {
                if (cachedPeriods.nextHour <= now) {
                    const nextHour = new Date();
                    nextHour.setUTCMinutes(60, 0, 0);
                    cachedPeriods.nextHour = Math.floor(nextHour.getTime() / 1000);
                }
                DOM.hourlyCountdown.textContent = formatTime(cachedPeriods.nextHour - now);
            }

            // Daily
            if (markets.daily) {
                DOM.dailyCountdown.textContent = formatTime(markets.daily.close - now);
            } else {
                if (cachedPeriods.nextDay <= now) {
                    const tomorrow = new Date();
                    tomorrow.setUTCHours(24, 0, 0, 0);
                    cachedPeriods.nextDay = Math.floor(tomorrow.getTime() / 1000);
                }
                DOM.dailyCountdown.textContent = formatTime(cachedPeriods.nextDay - now);
            }

            // Weekly
            if (markets.weekly) {
                DOM.weeklyCountdown.textContent = formatTime(markets.weekly.close - now);
            } else {
                if (cachedPeriods.nextWeek <= now) {
                    const sun = new Date();
                    sun.setUTCDate(sun.getUTCDate() + (7 - sun.getUTCDay()));
                    sun.setUTCHours(0, 0, 0, 0);
                    cachedPeriods.nextWeek = Math.floor(sun.getTime() / 1000);
                }
                DOM.weeklyCountdown.textContent = formatTime(cachedPeriods.nextWeek - now);
            }

            // Extreme
            if (markets.extreme) {
                const remaining = markets.extreme.close - now;
                if (remaining <= 0) {
                    DOM.extremeCountdown.textContent = 'Ended';
                } else {
                    const days = Math.floor(remaining / 86400);
                    DOM.extremeCountdown.textContent = days + ' days';
                }
            }
        }

        function formatTime(s) {
            if (s <= 0) return 'Ended';
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h >= 24) return Math.floor(h / 24) + 'd ' + (h % 24) + 'h';
            if (h > 0) return h + 'h ' + m + 'm';
            if (m > 0) return m + 'm ' + sec + 's';
            return sec + 's';
        }

        // ======================== TRADING ========================
        async function openTrade(type, isYes) {
            const market = markets[type];
            if (!market) { showStatus('No active market', 'error'); return; }
            if (!connectedAddress) { showStatus('Connect wallet first', 'error'); return; }

            currentTrade = { type, isYes, marketId: market.id, tvl: market.tvl || 0 };
            currentTradeMode = 'trade';
            currentTradeDirection = 'buy';

            // Load user position and orderbook in parallel
            await Promise.all([
                loadUserPosition(market.id),
                loadOrderbook(market.id, isYes)
            ]);

            // Update side toggle labels based on market type
            const yesLabel = type === 'extreme' ? 'YES' : 'UP';
            const noLabel = type === 'extreme' ? 'NO' : 'DOWN';
            document.getElementById('sideYesLabel').textContent = yesLabel;
            document.getElementById('sideNoLabel').textContent = noLabel;

            // Update odds on both buttons
            updateSideOdds(market);

            // Update active side button
            updateSideButtons(isYes);

            document.getElementById('tradeTitle').textContent = market.name || type;

            // Reset to trade mode with buy direction
            setTradeMode('trade');

            document.getElementById('tradeAmount').value = '';
            updatePreview();
            document.getElementById('tradeModal').classList.add('active');
        }

        function updateSideOdds(market) {
            // Show both YES and NO odds on the side buttons
            const yesOdds = market.yesPrice ? (market.yesPrice * 100).toFixed(0) + '%' : '--';
            const noOdds = market.noPrice ? (market.noPrice * 100).toFixed(0) + '%' : '--';
            document.getElementById('sideYesOdds').textContent = yesOdds;
            document.getElementById('sideNoOdds').textContent = noOdds;
        }

        function updateSideButtons(isYes) {
            const yesBtn = document.getElementById('sideYesBtn');
            const noBtn = document.getElementById('sideNoBtn');

            if (isYes) {
                yesBtn.className = 'mode-toggle-btn active-buy';
                noBtn.className = 'mode-toggle-btn';
            } else {
                yesBtn.className = 'mode-toggle-btn';
                noBtn.className = 'mode-toggle-btn active-sell';
            }
        }

        async function switchTradeSide(isYes) {
            if (currentTrade.isYes === isYes) return; // Already on this side

            currentTrade.isYes = isYes;
            updateSideButtons(isYes);

            // Reload orderbook for new side
            await loadOrderbook(currentTrade.marketId, isYes);

            // Update position value display
            const yesShares = parseFloat(ethers.formatEther(currentUserPosition.yesBalance || 0n));
            const noShares = parseFloat(ethers.formatEther(currentUserPosition.noBalance || 0n));
            updatePositionValue(yesShares, noShares);

            // Update trade mode labels and preview
            setTradeMode(currentTradeMode);

            // Update limit balance if in limit mode
            if (currentTradeMode === 'limit') {
                updateLimitBalance();
            }
        }

        async function loadUserPosition(marketId) {
            if (!connectedAddress) {
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, rpc);

                // Get noId and poolKey for LP balance
                const [noId, poolKey] = await Promise.all([
                    pamm.getNoId(marketId),
                    pamm.poolKey(marketId, FEE_TIER)
                ]);

                // Store yesId and noId in currentTrade for swap functionality
                // YES shares have ID = marketId, NO shares have ID from getNoId
                currentTrade.yesId = marketId;
                currentTrade.noId = noId;

                // Compute pool ID (LP token ID) = keccak256(abi.encode(id0, id1, token0, token1, feeOrHook))
                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                    [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                ));

                const [yesBal, noBal, lpBal, poolData] = await Promise.all([
                    pamm.balanceOf(connectedAddress, marketId),
                    pamm.balanceOf(connectedAddress, noId),
                    zamm.balanceOf(connectedAddress, poolId),
                    zamm.pools(poolId)
                ]);
                // poolData: [reserve0, reserve1, blockTimestampLast, price0CumulativeLast, price1CumulativeLast, kLast, supply]
                currentUserPosition = { yesBalance: yesBal, noBalance: noBal, lpBalance: lpBal, poolId, lpTotalSupply: poolData[6] };
            } catch (e) {
                console.error('Failed to load position:', e);
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
            }

            // Update modal display
            const yesShares = parseFloat(ethers.formatEther(currentUserPosition.yesBalance));
            const noShares = parseFloat(ethers.formatEther(currentUserPosition.noBalance));
            document.getElementById('tradeModalYes').textContent = yesShares.toFixed(4);
            document.getElementById('tradeModalNo').textContent = noShares.toFixed(4);
            document.getElementById('tradeModalLP').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);

            // Update position value and P&L display
            updatePositionValue(yesShares, noShares);
        }

        function updatePositionValue(yesShares, noShares) {
            const positionValueEl = document.getElementById('positionValue');
            const positionPnLEl = document.getElementById('positionPnL');
            const positionOutcomeEl = document.getElementById('positionOutcome');
            const positionPayoutEl = document.getElementById('positionPayout');

            // Get pool price from orderbook state
            const ammPrice = currentOrderbook.ammPrice || 0;

            if (yesShares === 0 && noShares === 0) {
                positionValueEl.textContent = 'No position';
                positionPnLEl.style.display = 'none';
                return;
            }

            // Current value based on pool price
            // For the side we're trading (currentTrade.isYes), ammPrice is the price
            // YES value = yesShares * yesPrice, NO value = noShares * (1 - yesPrice)
            const yesPrice = currentTrade.isYes ? ammPrice : (1 - ammPrice);
            const noPrice = currentTrade.isYes ? (1 - ammPrice) : ammPrice;
            const currentValue = (yesShares * yesPrice) + (noShares * noPrice);

            if (ammPrice > 0 && currentValue > 0) {
                positionValueEl.textContent = `â‰ˆ ${currentValue.toFixed(4)} ETH`;
            } else {
                positionValueEl.textContent = '--';
            }

            // Show P&L section
            if (yesShares > 0 || noShares > 0) {
                positionPnLEl.style.display = 'block';

                // Determine the larger position
                if (yesShares >= noShares) {
                    positionOutcomeEl.textContent = currentTrade.isYes ? 'YES' : 'UP';
                    positionOutcomeEl.style.color = 'var(--green)';
                    const payout = yesShares;
                    const profit = payout - currentValue;
                    positionPayoutEl.textContent = `${payout.toFixed(4)} ETH`;
                    positionPayoutEl.style.color = profit >= 0 ? 'var(--green)' : 'var(--red)';
                } else {
                    positionOutcomeEl.textContent = currentTrade.isYes ? 'NO' : 'DOWN';
                    positionOutcomeEl.style.color = 'var(--red)';
                    const payout = noShares;
                    const profit = payout - currentValue;
                    positionPayoutEl.textContent = `${payout.toFixed(4)} ETH`;
                    positionPayoutEl.style.color = profit >= 0 ? 'var(--green)' : 'var(--red)';
                }
            } else {
                positionPnLEl.style.display = 'none';
            }
        }

        let currentOrderbook = { bids: [], asks: [], bidHashes: [], askHashes: [], ammPrice: 0, rYes: 0n, rNo: 0n };

        async function loadOrderbook(marketId, isYes) {
            const asksContainer = document.getElementById('orderbookAsks');
            const bidsContainer = document.getElementById('orderbookBids');
            const spreadEl = document.getElementById('orderbookSpread');
            const emptyEl = document.getElementById('orderbookEmpty');
            const bodyEl = document.querySelector('.orderbook-body');

            // Clear and show loading state
            asksContainer.innerHTML = '<div class="orderbook-empty">Loading...</div>';
            bidsContainer.innerHTML = '';
            document.getElementById('spreadMidPrice').textContent = '--';
            document.getElementById('spreadOddsPct').textContent = '--';
            document.getElementById('spreadBidAsk').textContent = '-- / --';
            document.getElementById('spreadPct').textContent = '--%';
            document.getElementById('orderbookShareType').textContent = isYes ? 'YES' : 'NO';
            document.getElementById('spreadOutcome').textContent = isYes ? 'YES' : 'NO';
            document.getElementById('orderbookTotalDepth').textContent = '--';

            try {
                const rpc = provider || await getRpcProvider();

                // Always fetch AMM pool price first (available even without PMRouter)
                let ammPrice = 0;
                let rYesBigInt = 0n, rNoBigInt = 0n;
                try {
                    const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                    const [rYes, rNo, pYesNum, pYesDen] = await pamm.getPoolState(marketId, FEE_TIER);
                    rYesBigInt = rYes;
                    rNoBigInt = rNo;
                    // AMM price for YES = rNo / (rYes + rNo), for NO = rYes / (rYes + rNo)
                    ammPrice = isYes ?
                        Number(pYesNum) / Number(pYesDen) :
                        (Number(pYesDen) - Number(pYesNum)) / Number(pYesDen);
                } catch (e) {
                    console.warn('Could not get AMM price:', e);
                }

                currentOrderbook.ammPrice = ammPrice;
                currentOrderbook.rYes = rYesBigInt;
                currentOrderbook.rNo = rNoBigInt;

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                const depth = 10; // Max orders per side
                const [bidHashes, bidOrders, askHashes, askOrders] = await pmRouter.getOrderbook(marketId, isYes, depth);

                // Preserve rYes/rNo when updating orderbook
                currentOrderbook = {
                    bids: bidOrders.map((o, i) => ({ ...o, hash: bidHashes[i] })),
                    asks: askOrders.map((o, i) => ({ ...o, hash: askHashes[i] })),
                    bidHashes,
                    askHashes,
                    ammPrice,
                    rYes: rYesBigInt,
                    rNo: rNoBigInt
                };

                // Process and display orders
                const formatOrder = (order) => {
                    // Price = collateral / shares (guard against zero/invalid values)
                    const shares = Number(order.shares || 0);
                    const collateral = Number(order.collateral || 0);
                    if (shares <= 0 || isNaN(shares) || isNaN(collateral)) {
                        return null; // Invalid order
                    }
                    const price = collateral / shares;
                    const size = shares / 1e18;
                    return { price, size, order };
                };

                // Smart decimal formatting for small values
                const formatSize = (size) => {
                    if (size >= 1) return size.toFixed(2);
                    if (size >= 0.01) return size.toFixed(4);
                    if (size >= 0.0001) return size.toFixed(6);
                    return size.toExponential(2);
                };

                // Filter out invalid orders (null) before sorting
                const bids = currentOrderbook.bids.map(o => formatOrder(o)).filter(o => o !== null).sort((a, b) => b.price - a.price);
                const asks = currentOrderbook.asks.map(o => formatOrder(o)).filter(o => o !== null).sort((a, b) => a.price - b.price);

                // Clear containers
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';

                bodyEl.style.display = 'block';
                emptyEl.style.display = 'none';

                // Get section labels for showing/hiding
                const asksLabel = document.getElementById('asksLabel');
                const bidsLabel = document.getElementById('bidsLabel');
                const orderbookHeader = document.querySelector('.orderbook-header');
                const hasOrders = bids.length > 0 || asks.length > 0;

                // Show/hide orderbook structure based on whether orders exist
                if (hasOrders) {
                    asksLabel.style.display = 'flex';
                    bidsLabel.style.display = 'flex';
                    orderbookHeader.style.display = 'grid';
                } else {
                    // No orders - hide the asks/bids structure, show clean pool-only view
                    asksLabel.style.display = 'none';
                    bidsLabel.style.display = 'none';
                    orderbookHeader.style.display = 'none';
                }

                // Calculate max cumulative for depth bar scaling
                const totalAskDepth = asks.reduce((sum, a) => sum + a.size, 0);
                const totalBidDepth = bids.reduce((sum, b) => sum + b.size, 0);
                const maxDepth = Math.max(totalAskDepth, totalBidDepth, 0.01);

                // Update total depth display and title based on order availability
                const totalDepthEth = (totalAskDepth * ammPrice) + (totalBidDepth * ammPrice);
                const depthInfo = document.querySelector('.orderbook-depth-info');
                const titleText = document.querySelector('.orderbook-title-text');

                if (hasOrders) {
                    document.getElementById('orderbookTotalDepth').textContent = totalDepthEth > 0 ? formatSize(totalDepthEth) : '--';
                    depthInfo.style.display = 'block';
                    titleText.innerHTML = `<span id="orderbookShareType">${isYes ? 'YES' : 'NO'}</span> Order Book`;
                } else {
                    // No orders - show simpler title
                    depthInfo.style.display = 'none';
                    titleText.innerHTML = `<span id="orderbookShareType">${isYes ? 'YES' : 'NO'}</span> Pool`;
                }

                // Get user's address for highlighting their orders
                const userAddr = connectedAddress ? connectedAddress.toLowerCase() : '';

                // Calculate cumulative depth for asks (from lowest price up)
                let askCumulative = 0;
                const asksWithCumulative = asks.map(a => {
                    askCumulative += a.size;
                    return { ...a, cumulative: askCumulative };
                });

                // Render asks (sell orders) - displayed in reverse order (lowest at bottom near spread)
                asksWithCumulative.forEach((a, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && a.price < ammPrice;
                    const isUserOrder = userAddr && a.order.owner && a.order.owner.toLowerCase() === userAddr;
                    row.className = 'orderbook-row ask' + (isBetterDeal ? ' better-deal' : '') + (isUserOrder ? ' mine' : '');

                    // Depth bar width based on cumulative size
                    const depthPct = Math.min((a.cumulative / maxDepth) * 100, 100);
                    row.style.setProperty('--depth-width', depthPct + '%');
                    row.style.cssText += `; --depth-width: ${depthPct}%`;

                    const oddsStr = (a.price * 100).toFixed(0) + '%';
                    const priceStr = a.price.toFixed(3);
                    row.innerHTML = `
                        <span class="price">${priceStr} <span style="opacity:0.6">(${oddsStr})</span>${isBetterDeal ? ' <span style="color:var(--green)">â˜…</span>' : ''}</span>
                        <span class="size">${formatSize(a.size)}</span>
                        <span class="total">${formatSize(a.cumulative)}</span>
                    `;
                    row.title = `${oddsStr} implied odds | ${formatSize(a.size)} shares @ ${priceStr} ETH${isBetterDeal ? ' | Better than pool!' : ''}`;
                    row.onclick = () => fillOrderFromBook(a.order, false, idx);

                    // Set depth bar width via inline style on pseudo-element
                    row.style.setProperty('--depth', depthPct + '%');
                    asksContainer.appendChild(row);
                });

                // Calculate cumulative depth for bids (from highest price down)
                let bidCumulative = 0;
                const bidsWithCumulative = bids.map(b => {
                    bidCumulative += b.size;
                    return { ...b, cumulative: bidCumulative };
                });

                // Render bids (buy orders)
                bidsWithCumulative.forEach((b, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && b.price > ammPrice;
                    const isUserOrder = userAddr && b.order.owner && b.order.owner.toLowerCase() === userAddr;
                    row.className = 'orderbook-row bid' + (isBetterDeal ? ' better-deal' : '') + (isUserOrder ? ' mine' : '');

                    // Depth bar width
                    const depthPct = Math.min((b.cumulative / maxDepth) * 100, 100);

                    const oddsStr = (b.price * 100).toFixed(0) + '%';
                    const priceStr = b.price.toFixed(3);
                    row.innerHTML = `
                        <span class="price">${priceStr} <span style="opacity:0.6">(${oddsStr})</span>${isBetterDeal ? ' <span style="color:var(--green)">â˜…</span>' : ''}</span>
                        <span class="size">${formatSize(b.size)}</span>
                        <span class="total">${formatSize(b.cumulative)}</span>
                    `;
                    row.title = `${oddsStr} implied odds | ${formatSize(b.size)} shares @ ${priceStr} ETH${isBetterDeal ? ' | Better than pool!' : ''}`;
                    row.onclick = () => fillOrderFromBook(b.order, true, idx);

                    // Set depth bar width
                    row.style.setProperty('--depth', depthPct + '%');
                    bidsContainer.appendChild(row);
                });

                // Update spread area with new element structure
                const spreadMidPrice = document.getElementById('spreadMidPrice');
                const spreadOddsPct = document.getElementById('spreadOddsPct');
                const spreadOutcome = document.getElementById('spreadOutcome');
                const spreadBidAsk = document.getElementById('spreadBidAsk');
                const spreadPct = document.getElementById('spreadPct');

                // Calculate best bid/ask
                const bestAsk = asks.length > 0 ? asks[0].price : null;
                const bestBid = bids.length > 0 ? bids[0].price : null;

                // Update pool price display (mid-market or AMM price)
                if (ammPrice > 0) {
                    spreadMidPrice.textContent = ammPrice.toFixed(3) + ' ETH';
                    spreadOddsPct.textContent = (ammPrice * 100).toFixed(0) + '%';
                    spreadOutcome.textContent = isYes ? 'YES' : 'NO';
                    spreadOutcome.style.color = isYes ? 'var(--green)' : 'var(--red)';
                } else if (bestAsk && bestBid) {
                    const midPrice = (bestAsk + bestBid) / 2;
                    spreadMidPrice.textContent = midPrice.toFixed(3) + ' ETH';
                    spreadOddsPct.textContent = (midPrice * 100).toFixed(0) + '%';
                } else {
                    spreadMidPrice.textContent = '--';
                    spreadOddsPct.textContent = '--';
                }

                // Update bid/ask display
                if (bestBid && bestAsk) {
                    spreadBidAsk.innerHTML = `<span style="color:var(--green)">${bestBid.toFixed(3)}</span> / <span style="color:var(--red)">${bestAsk.toFixed(3)}</span>`;
                    const spread = ((bestAsk - bestBid) / bestAsk * 100).toFixed(1);
                    spreadPct.textContent = spread + '%';
                } else if (bestBid) {
                    spreadBidAsk.innerHTML = `<span style="color:var(--green)">${bestBid.toFixed(3)}</span> / --`;
                    spreadPct.textContent = '--';
                } else if (bestAsk) {
                    spreadBidAsk.innerHTML = `-- / <span style="color:var(--red)">${bestAsk.toFixed(3)}</span>`;
                    spreadPct.textContent = '--';
                } else if (ammPrice > 0) {
                    // No orders, just pool
                    spreadBidAsk.textContent = 'Pool only';
                    spreadPct.textContent = '0%';
                } else {
                    bodyEl.style.display = 'none';
                    emptyEl.style.display = 'block';
                    return;
                }

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';
                bodyEl.style.display = 'none';
                emptyEl.style.display = 'block';
                emptyEl.innerHTML = '<div>Failed to load orderbook</div><div style="font-size:10px;color:var(--text-muted);margin-top:4px;">Check console for details</div>';
            }
        }

        async function fillOrderFromBook(order, isBid, idx) {
            if (!signer) {
                showStatus('Connect wallet to fill orders', 'error');
                return;
            }

            // Calculate order details
            const shares = Number(order.shares) / 1e18;
            const collateral = Number(order.collateral) / 1e18;
            if (shares <= 0) {
                showStatus('Invalid order (zero shares)', 'error');
                return;
            }
            const price = collateral / shares;

            // isBid means it's a BID order in the orderbook (maker wants to buy)
            // If user clicks a BID, they are selling shares to the maker
            // If user clicks an ASK, they are buying shares from the maker
            const userIsBuying = !isBid;

            // Validate user has sufficient balance
            if (userIsBuying) {
                // Check ETH balance
                const ethBal = await provider.getBalance(connectedAddress);
                if (order.collateral > ethBal) {
                    const needed = collateral.toFixed(4);
                    const have = parseFloat(ethers.formatEther(ethBal)).toFixed(4);
                    showStatus(`Insufficient ETH. Need ${needed}, have ${have}`, 'error');
                    return;
                }
            } else {
                // Check shares balance
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                if (order.shares > userShares) {
                    const needed = shares.toFixed(4);
                    const have = parseFloat(ethers.formatEther(userShares)).toFixed(4);
                    showStatus(`Insufficient shares. Need ${needed}, have ${have}`, 'error');
                    return;
                }
            }

            const actionText = userIsBuying ?
                `Buy ${shares.toFixed(4)} shares for ${collateral.toFixed(4)} ETH (${price.toFixed(4)} ETH/share)?` :
                `Sell ${shares.toFixed(4)} shares for ${collateral.toFixed(4)} ETH (${price.toFixed(4)} ETH/share)?`;

            if (!confirm(actionText)) return;

            try {
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const orderHash = order.hash;
                const sharesToFill = 0; // 0 = fill all available

                let txPromise;
                if (userIsBuying) {
                    // User buying shares: send collateral as msg.value (for ETH markets)
                    txPromise = pmRouter.fillOrder(
                        orderHash,
                        sharesToFill,
                        connectedAddress,
                        { value: order.collateral }
                    );
                } else {
                    // User selling shares: need PMRouter approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    txPromise = pmRouter.fillOrder(
                        orderHash,
                        sharesToFill,
                        connectedAddress
                    );
                }

                const actionLabel = userIsBuying ? 'Buying' : 'Selling';
                await monitorTransaction(txPromise, {
                    pending: { title: `${actionLabel} Shares`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${actionLabel} Shares`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Filled!', body: `${actionLabel} ${shares.toFixed(4)} shares` },
                    error: { title: 'Fill Failed', body: '' },
                    onSuccess: async () => {
                        await Promise.all([
                            loadOrderbook(currentTrade.marketId, currentTrade.isYes),
                            loadUserPosition(currentTrade.marketId),
                            loadBalance()
                        ]);
                    }
                });

            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Fill order failed:', e);
                }
            }
        }

        let currentLpMode = 'add'; // 'add' or 'remove'
        let mintKeepYes = true; // true = keep YES, false = keep NO
        let limitIsBuy = true; // true = buy order, false = sell order
        let userOrders = []; // User's active orders for this market

        function setSlippage(pct) {
            if (!pct || pct <= 0) pct = 0.5;
            if (pct > 50) pct = 50; // Cap at 50% for safety
            slippageTolerance = pct;

            // Update button states
            document.getElementById('slip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';

            // Clear custom if using preset
            if (pct === 0.5 || pct === 1 || pct === 2) {
                document.getElementById('slipCustom').value = '';
            }

            updatePreview();
        }

        function setSwapSlippage(pct) {
            if (!pct || pct <= 0) pct = 0.5;
            if (pct > 50) pct = 50; // Cap at 50% for safety
            slippageTolerance = pct;

            // Update swap slippage button states
            document.getElementById('swapSlip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('swapSlip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('swapSlip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';

            // Update display
            document.getElementById('swapSlipDisplay').textContent = pct + '%';

            updateSwapPreview();
        }

        // Track current trade direction (buy/sell) and swap direction (yesToNo)
        let currentTradeDirection = 'buy';
        let currentSwapDirection = true; // true = YESâ†’NO, false = NOâ†’YES

        function setTradeMode(mode) {
            currentTradeMode = mode;

            const tradeBtn = document.getElementById('tradeModeBtn');
            const swapBtn = document.getElementById('swapModeBtn');
            const limitBtn = document.getElementById('limitModeBtn');
            const lpBtn = document.getElementById('lpModeBtn');
            const submitBtn = document.getElementById('tradeSubmit');
            const tradeSection = document.getElementById('tradeSection');
            const lpSection = document.getElementById('lpSection');
            const swapSection = document.getElementById('swapSection');
            const limitSection = document.getElementById('limitSection');
            const yourOrdersSection = document.getElementById('yourOrdersSection');
            const orderbookContainer = document.getElementById('orderbookContainer');
            const tradeDirectionToggle = document.getElementById('tradeDirectionToggle');
            const swapDirectionToggle = document.getElementById('swapDirectionToggle');
            const tradeInputGroup = document.getElementById('tradeInputGroup');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            // Reset all mode buttons
            tradeBtn.className = 'mode-toggle-btn';
            swapBtn.className = 'mode-toggle-btn';
            limitBtn.className = 'mode-toggle-btn';
            lpBtn.className = 'mode-toggle-btn';

            // Hide direction toggles by default
            tradeDirectionToggle.style.display = 'none';
            swapDirectionToggle.style.display = 'none';

            // Hide your orders section by default
            yourOrdersSection.style.display = 'none';

            if (mode === 'trade') {
                tradeBtn.className = 'mode-toggle-btn ' + (currentTradeDirection === 'buy' ? 'active-buy' : 'active-sell');
                tradeDirectionToggle.style.display = 'flex';
                tradeSection.style.display = 'block';
                lpSection.style.display = 'none';
                if (swapSection) swapSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'block';
                tradeInputGroup.style.display = 'block';
                // Apply direction-specific settings
                setTradeDirection(currentTradeDirection, true);
            } else if (mode === 'swap') {
                swapBtn.className = 'mode-toggle-btn active-swap';
                swapDirectionToggle.style.display = 'flex';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                if (swapSection) swapSection.style.display = 'block';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                tradeInputGroup.style.display = 'block';
                // Sync swap slippage buttons with current slippage
                document.getElementById('swapSlip05').className = slippageTolerance === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
                document.getElementById('swapSlip1').className = slippageTolerance === 1 ? 'slip-btn slip-active' : 'slip-btn';
                document.getElementById('swapSlip2').className = slippageTolerance === 2 ? 'slip-btn slip-active' : 'slip-btn';
                document.getElementById('swapSlipDisplay').textContent = slippageTolerance + '%';
                // Apply swap direction settings
                setSwapDirection(currentSwapDirection, true);
            } else if (mode === 'limit') {
                limitBtn.className = 'mode-toggle-btn active-limit';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                if (swapSection) swapSection.style.display = 'none';
                limitSection.style.display = 'block';
                orderbookContainer.style.display = 'block';
                yourOrdersSection.style.display = 'block';
                tradeInputGroup.style.display = 'none';
                // Set smart default price and shares
                setSmartDefaultPrice();
                if (!document.getElementById('limitShares').value) {
                    document.getElementById('limitShares').value = '1.0';
                }
                updateLimitBalance();
                updateLimitPreview();
                refreshUserOrders();
            } else if (mode === 'lp') {
                lpBtn.className = 'mode-toggle-btn active-lp';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'block';
                if (swapSection) swapSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                tradeInputGroup.style.display = 'block';
                document.getElementById('tradeInputLabel').textContent = currentLpMode === 'add' ? 'ETH to deposit' : 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = currentLpMode === 'add' ? 'ETH' : 'LP';
                updateLpPreview();
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            if (mode === 'trade') updatePreview();
            if (mode === 'swap') updateSwapPreview();
        }

        function setTradeDirection(direction, skipModeUpdate = false) {
            currentTradeDirection = direction;
            const buyDirBtn = document.getElementById('buyDirBtn');
            const sellDirBtn = document.getElementById('sellDirBtn');
            const tradeBtn = document.getElementById('tradeModeBtn');
            const submitBtn = document.getElementById('tradeSubmit');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            buyDirBtn.className = 'mode-toggle-btn' + (direction === 'buy' ? ' active-buy' : '');
            sellDirBtn.className = 'mode-toggle-btn' + (direction === 'sell' ? ' active-sell' : '');
            tradeBtn.className = 'mode-toggle-btn ' + (direction === 'buy' ? 'active-buy' : 'active-sell');

            if (direction === 'buy') {
                document.getElementById('tradeInputLabel').textContent = 'Amount (ETH)';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Payout if win';
                submitBtn.textContent = 'Buy ' + label;
                submitBtn.className = 'trade-submit ' + (currentTrade.isYes ? 'buy-up' : 'buy-down');
            } else {
                document.getElementById('tradeInputLabel').textContent = 'Shares to sell';
                document.getElementById('tradeBalanceUnit').textContent = 'shares';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Min receive';
                submitBtn.textContent = 'Sell ' + label;
                submitBtn.className = 'trade-submit buy-down';
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            updatePreview();
        }

        function setSwapDirection(yesToNo, skipUpdate = false) {
            currentSwapDirection = yesToNo;
            const yesToNoBtn = document.getElementById('yesToNoBtn');
            const noToYesBtn = document.getElementById('noToYesBtn');

            // Use market-appropriate labels (YES/NO for extreme, UP/DOWN for hourly)
            const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const fromShare = yesToNo ? yesLabel : noLabel;
            const toShare = yesToNo ? noLabel : yesLabel;

            yesToNoBtn.className = 'mode-toggle-btn' + (yesToNo ? ' active-buy' : '');
            noToYesBtn.className = 'mode-toggle-btn' + (!yesToNo ? ' active-sell' : '');
            yesToNoBtn.textContent = yesLabel + ' â†’ ' + noLabel;
            noToYesBtn.textContent = noLabel + ' â†’ ' + yesLabel;

            // Update input labels
            document.getElementById('tradeInputLabel').textContent = fromShare + ' shares to swap';
            document.getElementById('tradeBalanceUnit').textContent = fromShare;

            // Update swap preview labels
            const swapGiveLabel = document.getElementById('swapGiveLabel');
            const swapReceiveLabel = document.getElementById('swapReceiveLabel');
            const swapSubmit = document.getElementById('swapSubmit');
            const swapPoolRate = document.getElementById('swapPoolRate');
            if (swapGiveLabel) swapGiveLabel.textContent = 'You give (' + fromShare + ')';
            if (swapReceiveLabel) swapReceiveLabel.textContent = 'You receive (' + toShare + ')';
            if (swapPoolRate) swapPoolRate.textContent = '1 ' + fromShare + ' = -- ' + toShare;
            if (swapSubmit) {
                swapSubmit.textContent = 'Swap ' + fromShare + ' â†’ ' + toShare;
                swapSubmit.className = 'trade-submit ' + (yesToNo ? 'buy-down' : 'buy-up');
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            if (!skipUpdate) updateSwapPreview();
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            const addBtn = document.getElementById('addLpBtn');
            const removeBtn = document.getElementById('removeLpBtn');
            const lpSubmit = document.getElementById('lpSubmit');
            const explainer = document.getElementById('lpExplainer');

            if (mode === 'add') {
                addBtn.className = 'lp-toggle-btn active-add';
                removeBtn.className = 'lp-toggle-btn';
                document.getElementById('tradeInputLabel').textContent = 'ETH to deposit';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.';
                lpSubmit.textContent = 'Deposit Liquidity';
                lpSubmit.style.background = 'var(--blue)';
            } else {
                addBtn.className = 'lp-toggle-btn';
                removeBtn.className = 'lp-toggle-btn active-remove';
                document.getElementById('tradeInputLabel').textContent = 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = 'LP';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Withdraw your liquidity. Your LP tokens are burned and you receive ETH back.';
                lpSubmit.textContent = 'Withdraw Liquidity';
                lpSubmit.style.background = 'var(--red)';
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            updateLpPreview();
        }

        function updateLpPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;
            const warningEl = document.getElementById('lpWarning');

            // Calculate pool metrics
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;
            // Use actual TVL from market data if available, otherwise approximate
            const poolTvl = currentTrade.tvl > 0 ? currentTrade.tvl : (rYesNum + rNoNum) / 2;
            // Use actual LP supply from ZAMM pools() if available, otherwise estimate
            const totalLpSupply = currentUserPosition.lpTotalSupply
                ? Number(currentUserPosition.lpTotalSupply) / 1e18
                : Math.sqrt(rYesNum * rNoNum);

            // Pool price (YES probability)
            const yesPrice = rYesNum > 0 && rNoNum > 0 ? rNoNum / (rYesNum + rNoNum) : 0.5;

            // Display pool TVL and price
            if (rYes > 0n && rNo > 0n) {
                document.getElementById('lpPoolReserves').textContent = formatEth(poolTvl);
                document.getElementById('lpPoolPrice').textContent = yesPrice.toFixed(3) + ' (' + formatOdds(yesPrice) + ' YES)';
            } else {
                document.getElementById('lpPoolReserves').textContent = '--';
                document.getElementById('lpPoolPrice').textContent = '-- (--% YES)';
            }

            // Current user position value and share
            if (userLp > 0 && totalLpSupply > 0) {
                const userShare = userLp / totalLpSupply;
                const positionValue = userShare * poolTvl; // Value in ETH terms (collateral backing their LP)
                document.getElementById('lpPositionValue').textContent = formatEth(positionValue);
                document.getElementById('lpCurrentShare').textContent = (userShare * 100).toFixed(2) + '%';
            } else {
                document.getElementById('lpPositionValue').textContent = userLp > 0 ? formatEth(userLp, ' LP') : '0 ETH';
                document.getElementById('lpCurrentShare').textContent = '0%';
            }

            // Hide warning by default
            warningEl.style.display = 'none';

            if (amt === 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                document.getElementById('lpShareChange').textContent = '';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP
                document.getElementById('lpPreview').textContent = amt.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = '100%';
                document.getElementById('lpShareChange').textContent = '(+100%)';
                document.getElementById('lpShareChange').style.color = 'var(--green)';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: ETH -> split -> add to pool
                // User gets LP tokens proportional to their contribution
                // New LP = (amt / poolTvl) * totalLpSupply (simplified)
                const estLp = (amt / poolTvl) * totalLpSupply;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newShare = (newUserLp / newTotalLp) * 100;
                const shareDelta = newShare - currentShare;

                document.getElementById('lpPreview').textContent = estLp.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta > 0 ? `(+${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = 'var(--green)';

                // Show IL warning for imbalanced pools
                if (yesPrice < 0.2 || yesPrice > 0.8) {
                    warningEl.textContent = 'âš ï¸ Pool is imbalanced (' + formatOdds(yesPrice) + ' YES). Higher impermanent loss risk if price moves toward 50%.';
                    warningEl.style.display = 'block';
                }
            } else {
                // Removing liquidity: LP tokens -> YES + NO -> merge -> ETH
                if (amt > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    document.getElementById('lpShareChange').textContent = '';
                    return;
                }

                // Calculate how much YES + NO user gets from burning LP
                const shareOfPool = amt / totalLpSupply;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;

                // Merge gives min(yesOut, noOut) ETH back, leftover shares remain
                const ethOut = Math.min(yesOut, noOut);
                const leftoverYes = yesOut - ethOut;
                const leftoverNo = noOut - ethOut;

                // Display estimated ETH back
                document.getElementById('lpPreview').textContent = ethOut.toFixed(4) + ' ETH';

                // Calculate new share
                const currentShare = totalLpSupply > 0 ? (userLp / totalLpSupply) * 100 : 0;
                const newUserLp = userLp - amt;
                const newTotalLp = totalLpSupply - amt;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                const shareDelta = newShare - currentShare;
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';
                document.getElementById('lpShareChange').textContent = shareDelta !== 0 ? `(${shareDelta.toFixed(2)}%)` : '';
                document.getElementById('lpShareChange').style.color = shareDelta < 0 ? 'var(--red)' : 'var(--text-muted)';

                // Show leftover warning if pool is imbalanced
                if (leftoverYes > 0.0001 || leftoverNo > 0.0001) {
                    const leftover = leftoverYes > leftoverNo ?
                        leftoverYes.toFixed(4) + ' YES' :
                        leftoverNo.toFixed(4) + ' NO';
                    warningEl.textContent = 'âš ï¸ Pool imbalanced. You\'ll also receive ~' + leftover + ' shares (can\'t merge).';
                    warningEl.style.display = 'block';
                }
            }
        }

        // ======================== SWAP (YES â†” NO) ========================
        function updateSwapPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            // Use market-appropriate labels for defaults (default to YES/NO if type unknown)
            const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const fromLabel = currentSwapDirection ? yesLabel : noLabel;
            const toLabel = currentSwapDirection ? noLabel : yesLabel;

            // Update labels
            document.getElementById('swapGiveLabel').textContent = `You give (${fromLabel})`;
            document.getElementById('swapReceiveLabel').textContent = `You receive (${toLabel})`;

            if (rYes === 0n || rNo === 0n || amt === 0) {
                document.getElementById('swapGive').textContent = amt > 0 ? `${amt.toFixed(4)} shares` : '-- shares';
                document.getElementById('swapPoolRate').textContent = `1 ${fromLabel} = -- ${toLabel}`;
                document.getElementById('swapReceive').textContent = '-- shares';
                document.getElementById('swapFee').textContent = '-- shares';
                document.getElementById('swapImpact').textContent = '--%';
                document.getElementById('swapMinReceive').textContent = '-- shares';
                return;
            }

            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;

            // Current rate from pool (constant product)
            // YES â†’ NO: rate = rNo / rYes
            // NO â†’ YES: rate = rYes / rNo
            const spotRate = currentSwapDirection ? (rNoNum / rYesNum) : (rYesNum / rNoNum);

            // Calculate swap output using constant product formula
            // ZAMM applies fee BEFORE swap: amtInAfterFee = amtIn * (1 - fee)
            // Then: amtOut = (amtInAfterFee * reserveOut) / (reserveIn + amtInAfterFee)
            const fee = 0.003; // 0.3% fee (30 bps)
            const amtIn = amt;
            const feeAmount = amtIn * fee;
            let reserveIn, reserveOut;

            if (currentSwapDirection) {
                // YES â†’ NO
                reserveIn = rYesNum;
                reserveOut = rNoNum;
            } else {
                // NO â†’ YES
                reserveIn = rNoNum;
                reserveOut = rYesNum;
            }

            const amtInWithFee = amtIn * (1 - fee);
            const amtOut = (amtInWithFee * reserveOut) / (reserveIn + amtInWithFee);

            // Price impact (difference between spot rate and effective rate)
            const effectiveRate = amtOut / amtIn;
            const priceImpact = ((spotRate - effectiveRate) / spotRate) * 100;

            // Min receive with slippage
            const slippage = slippageTolerance / 100;
            const minReceive = amtOut * (1 - slippage);

            // Update all display elements
            document.getElementById('swapGive').textContent = `${amtIn.toFixed(4)} shares`;
            document.getElementById('swapPoolRate').textContent = `1 ${fromLabel} = ${spotRate.toFixed(4)} ${toLabel}`;
            document.getElementById('swapReceive').textContent = `${amtOut.toFixed(4)} ${toLabel}`;
            document.getElementById('swapFee').textContent = `${feeAmount.toFixed(4)} ${fromLabel}`;
            document.getElementById('swapImpact').textContent = priceImpact.toFixed(2) + '%';
            document.getElementById('swapMinReceive').textContent = `${minReceive.toFixed(4)} ${toLabel}`;

            // Color impact based on severity
            const impactEl = document.getElementById('swapImpact');
            if (priceImpact > 5) {
                impactEl.style.color = 'var(--red)';
            } else if (priceImpact > 1) {
                impactEl.style.color = 'var(--amber)';
            } else {
                impactEl.style.color = 'var(--text)';
            }
        }

        async function executeSwap() {
            if (!signer || !connectedAddress) {
                await connectWallet();
                if (!signer || !connectedAddress) return;
            }

            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            if (amt <= 0) {
                showStatus('Enter amount to swap', 'error');
                return;
            }

            // Validate market is selected
            if (!currentTrade.marketId || !currentTrade.yesId || !currentTrade.noId) {
                showStatus('Please select a market first', 'error');
                return;
            }

            // Validate pool has liquidity
            if (!currentOrderbook.rYes || !currentOrderbook.rNo ||
                currentOrderbook.rYes === 0n || currentOrderbook.rNo === 0n) {
                showStatus('Pool has no liquidity', 'error');
                return;
            }

            // Validate user has enough shares to swap
            const amtWei = ethers.parseEther(amt.toString());
            const sourceBalance = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
            if (!sourceBalance || amtWei > sourceBalance) {
                const available = sourceBalance ? parseFloat(ethers.formatEther(sourceBalance)).toFixed(4) : '0';
                const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
                const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
                const fromLabel = currentSwapDirection ? yesLabel : noLabel;
                showStatus(`Insufficient ${fromLabel}. You have ${available}`, 'error');
                return;
            }

            const submitBtn = document.getElementById('swapSubmit');
            const yesLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'YES' : 'UP';
            const noLabel = !currentTrade.type || currentTrade.type === 'extreme' ? 'NO' : 'DOWN';
            const fromLabel = currentSwapDirection ? yesLabel : noLabel;
            const toLabel = currentSwapDirection ? noLabel : yesLabel;

            try {
                submitBtn.disabled = true;

                // Check approval using proper system
                const approved = await checkAndRequestApprovals('swap');
                if (!approved) {
                    submitBtn.disabled = false;
                    return;
                }

                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                // Get market IDs from current trade
                const yesId = BigInt(currentTrade.yesId);
                const noId = BigInt(currentTrade.noId);

                // Build pool key - YES/NO shares both use PAMM as token address
                // Pool is ordered with smaller ID first
                const id0 = yesId < noId ? yesId : noId;
                const id1 = yesId < noId ? noId : yesId;
                const poolKey = {
                    id0: id0,
                    id1: id1,
                    token0: PAMM_ADDRESS,
                    token1: PAMM_ADDRESS,
                    feeOrHook: FEE_TIER  // 30 bps = 0.3% fee tier
                };

                // zeroForOne: true if swapping token0 for token1
                // If YES is token0 (id0) and we're swapping YESâ†’NO, then zeroForOne = true
                // If NO is token0 (id0) and we're swapping NOâ†’YES, then zeroForOne = true
                const yesIsToken0 = yesId === id0;
                const zeroForOne = currentSwapDirection ? yesIsToken0 : !yesIsToken0;

                // Calculate minimum output with slippage
                const slippage = slippageTolerance / 100;
                const rYesNum = Number(currentOrderbook.rYes) / 1e18;
                const rNoNum = Number(currentOrderbook.rNo) / 1e18;
                const reserveIn = currentSwapDirection ? rYesNum : rNoNum;
                const reserveOut = currentSwapDirection ? rNoNum : rYesNum;
                const amtInWithFee = amt * 0.997;
                const expectedOut = (reserveIn + amtInWithFee) > 0
                    ? (amtInWithFee * reserveOut) / (reserveIn + amtInWithFee)
                    : 0;
                const minOut = Math.max(0, expectedOut * (1 - slippage));
                const minOutWei = ethers.parseEther(minOut.toFixed(18));

                // Deadline: 20 minutes from now
                const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

                await monitorTransaction(
                    zamm.swapExactIn(poolKey, amtWei, minOutWei, zeroForOne, connectedAddress, deadline),
                    {
                        pending: { title: `Swap ${fromLabel} â†’ ${toLabel}`, body: 'Confirm in your wallet...' },
                        submitted: { title: `Swap ${fromLabel} â†’ ${toLabel}`, body: 'Waiting for confirmation...' },
                        success: { title: 'Swap Complete!', body: `Swapped ${amt.toFixed(4)} ${fromLabel} â†’ ${expectedOut.toFixed(4)} ${toLabel}` },
                        error: { title: 'Swap Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('tradeAmount').value = '';
                            updateSwapPreview();
                            await loadUserPosition(currentTrade.marketId);
                            await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                        }
                    }
                );

            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Swap failed:', err);
                }
            } finally {
                submitBtn.disabled = false;
            }
        }

        // ======================== MINT & LIST ========================
        function setMintKeep(keepYes) {
            mintKeepYes = keepYes;
            const keepYesBtn = document.getElementById('keepYesBtn');
            const keepNoBtn = document.getElementById('keepNoBtn');

            if (keepYes) {
                keepYesBtn.className = 'lp-toggle-btn active-add';
                keepNoBtn.className = 'lp-toggle-btn';
            } else {
                keepYesBtn.className = 'lp-toggle-btn';
                keepNoBtn.className = 'lp-toggle-btn active-remove';
            }
            updateMintPreview();
        }

        function updateMintPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value) || 0;

            const keepLabel = mintKeepYes ? 'YES' : 'NO';
            const sellLabel = mintKeepYes ? 'NO' : 'YES';

            document.getElementById('mintDeposit').textContent = amt > 0 ? amt.toFixed(4) + ' ETH' : '-- ETH';
            document.getElementById('mintReceive').textContent = amt > 0 ? amt.toFixed(4) + ' YES + ' + amt.toFixed(4) + ' NO' : '-- YES + -- NO';
            document.getElementById('mintKeep').textContent = amt > 0 ? amt.toFixed(4) + ' ' + keepLabel : '-- ' + keepLabel;

            if (amt > 0 && limitPrice > 0) {
                const sellShares = amt;
                const expectedReturn = sellShares * limitPrice;
                const netCost = amt - expectedReturn;

                document.getElementById('mintList').textContent = sellShares.toFixed(4) + ' ' + sellLabel + ' @ ' + limitPrice.toFixed(2) + ' ETH';

                if (netCost > 0) {
                    document.getElementById('mintProfit').textContent = 'Net cost: ' + netCost.toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--text-muted)';
                } else {
                    document.getElementById('mintProfit').textContent = 'Net profit: ' + Math.abs(netCost).toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--green)';
                }
            } else {
                document.getElementById('mintList').textContent = '-- ' + sellLabel + ' @ -- ETH';
                document.getElementById('mintProfit').textContent = 'Net cost: -- ETH';
                document.getElementById('mintProfit').style.color = 'var(--text-muted)';
            }
        }

        async function executeMintAndList() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value);

            if (!amt || amt <= 0) {
                showStatus('Please enter an amount', 'error');
                return;
            }
            if (!limitPrice || limitPrice <= 0 || limitPrice >= 1) {
                showStatus('Please enter a valid limit price (0.01 - 0.99)', 'error');
                return;
            }

            try {
                // Check approvals first
                const approved = await checkAndRequestApprovals('mint');
                if (!approved) return;

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                const marketId = currentTrade.marketId;
                const amountWei = ethers.parseEther(amt.toString());
                const sharesWei = amountWei; // 1 ETH = 1 YES + 1 NO
                const collateralWei = ethers.parseEther((amt * limitPrice).toString());

                // Get market close time for deadline
                const market = await pamm.getMarket(marketId);
                const closeTime = market[5]; // close timestamp
                const deadline = closeTime;

                // Encode multicall data:
                // 1. split(marketId, amount, address(0)) - sends to msg.sender
                // 2. placeOrder(marketId, isYes, isBuy=false, shares, collateral, deadline, partialFill=true)
                const splitData = pmRouter.interface.encodeFunctionData('split', [
                    marketId,
                    amountWei,
                    ethers.ZeroAddress // defaults to msg.sender
                ]);

                const placeOrderData = pmRouter.interface.encodeFunctionData('placeOrder', [
                    marketId,
                    !mintKeepYes, // isYes = opposite of what we keep (sell the other side)
                    false, // isBuy = false (sell order)
                    sharesWei, // shares to sell
                    collateralWei, // price in ETH
                    deadline,
                    true // partialFill
                ]);

                const keepSide = mintKeepYes ? 'YES' : 'NO';
                await monitorTransaction(
                    pmRouter.multicall([splitData, placeOrderData], { value: amountWei }),
                    {
                        pending: { title: 'Mint & List', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Mint & List', body: 'Minting shares and placing order...' },
                        success: { title: 'Mint & List Success!', body: `Keeping ${amt} ${keepSide} shares, listed ${amt} at ${limitPrice.toFixed(2)}` },
                        error: { title: 'Mint & List Failed', body: '' },
                        onSuccess: async () => {
                            await loadUserPosition(currentTrade.marketId);
                            await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                            document.getElementById('tradeAmount').value = '';
                            document.getElementById('mintLimitPrice').value = '';
                            updateMintPreview();
                        }
                    }
                );
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Mint & List error:', err);
                }
            }
        }

        // ======================== LIMIT ORDERS ========================

        async function updateLimitBalance() {
            const balEl = document.getElementById('limitBalance');
            const unitEl = document.getElementById('limitBalanceUnit');

            if (!provider || !connectedAddress) {
                balEl.textContent = '--';
                return;
            }

            try {
                if (limitIsBuy) {
                    // Buy order: need ETH
                    const bal = await provider.getBalance(connectedAddress);
                    balEl.textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    unitEl.textContent = 'ETH';
                } else {
                    // Sell order: need shares
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    balEl.textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                    unitEl.textContent = currentTrade.isYes ? 'YES' : 'NO';
                }
            } catch (e) {
                balEl.textContent = '--';
            }
        }

        function adjustLimitPrice(delta) {
            const input = document.getElementById('limitPrice');
            const current = parseFloat(input.value) || currentOrderbook.ammPrice || 0.5;
            const newPrice = Math.max(0.01, Math.min(0.99, current + delta));
            input.value = newPrice.toFixed(2);
            updateLimitPreview();
        }

        function setLimitPriceToPool() {
            const ammPrice = currentOrderbook.ammPrice;
            if (ammPrice > 0) {
                document.getElementById('limitPrice').value = ammPrice.toFixed(2);
                updateLimitPreview();
            }
        }

        function setSmartDefaultPrice() {
            const ammPrice = currentOrderbook.ammPrice;
            if (ammPrice > 0) {
                // Buy: bid 2% below pool, Sell: ask 2% above pool
                const spread = 0.02;
                const defaultPrice = limitIsBuy
                    ? Math.max(0.01, ammPrice - spread)
                    : Math.min(0.99, ammPrice + spread);
                document.getElementById('limitPrice').value = defaultPrice.toFixed(2);

                // Update pool price display
                document.getElementById('limitPoolPrice').textContent = ammPrice.toFixed(2) + ' (' + (ammPrice * 100).toFixed(0) + '%)';
            }
        }

        function setMaxLimitShares() {
            if (limitIsBuy) {
                // For buy orders, max is based on ETH balance and price
                const price = parseFloat(document.getElementById('limitPrice').value) || 0;
                if (price > 0 && provider && connectedAddress) {
                    provider.getBalance(connectedAddress).then(bal => {
                        const ethBal = parseFloat(ethers.formatEther(bal));
                        const maxShares = ethBal / price;
                        document.getElementById('limitShares').value = Math.floor(maxShares * 100) / 100;
                        updateLimitPreview();
                    });
                }
            } else {
                // For sell orders, max is share balance
                const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                const shares = parseFloat(ethers.formatEther(sharesBal || 0n));
                document.getElementById('limitShares').value = Math.floor(shares * 10000) / 10000;
                updateLimitPreview();
            }
        }

        function setLimitSide(side) {
            limitIsBuy = (side === 'buy');
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const submitBtn = document.getElementById('limitSubmit');
            const costLabel = document.getElementById('limitCostLabel');
            const receiveLabel = document.getElementById('limitReceiveLabel');
            const profitLabel = document.getElementById('limitProfitLabel');
            const explainerText = document.getElementById('limitExplainerText');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            if (limitIsBuy) {
                buyBtn.className = 'lp-toggle-btn active-add';
                sellBtn.className = 'lp-toggle-btn';
                costLabel.textContent = 'You escrow';
                receiveLabel.textContent = 'If filled, you get';
                profitLabel.textContent = 'If you win';
                submitBtn.textContent = 'Place Buy Order';
                submitBtn.style.background = 'var(--green)';
                explainerText.innerHTML = `<strong>Buy Limit:</strong> Bid below pool to get better odds. Your ETH is escrowed until filled.`;
            } else {
                buyBtn.className = 'lp-toggle-btn';
                sellBtn.className = 'lp-toggle-btn active-remove';
                costLabel.textContent = 'You escrow';
                receiveLabel.textContent = 'If filled, you get';
                profitLabel.textContent = 'Guaranteed receive';
                submitBtn.textContent = 'Place Sell Order';
                submitBtn.style.background = 'var(--red)';
                explainerText.innerHTML = `<strong>Sell Limit:</strong> Ask above pool to get a better price. Your ${label} shares are escrowed until filled.`;
            }

            // Set smart default price
            setSmartDefaultPrice();

            updateLimitBalance();
            updateLimitPreview();
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const shares = parseFloat(document.getElementById('limitShares').value) || 0;
            const ammPrice = currentOrderbook.ammPrice || 0;

            const label = currentTrade.isYes ? 'YES' : 'NO';
            const oddsHelper = document.getElementById('limitOddsHelper');
            const oddsValue = document.getElementById('limitOddsValue');
            const oddsVsPool = document.getElementById('limitOddsVsPool');
            const returnInfo = document.getElementById('limitReturnInfo');

            // Update pool price display
            if (ammPrice > 0) {
                document.getElementById('limitPoolPrice').textContent = ammPrice.toFixed(2) + ' (' + (ammPrice * 100).toFixed(0) + '%)';
            }

            // Show/update odds helper when price is entered
            if (price > 0 && price < 1) {
                oddsHelper.style.display = 'block';
                const oddsPct = (price * 100).toFixed(0);
                oddsValue.textContent = oddsPct + '%';

                // Calculate potential return
                const returnMultiple = (1 / price).toFixed(2);
                const returnPct = ((1 / price - 1) * 100).toFixed(0);
                returnInfo.textContent = limitIsBuy
                    ? `If you win: ${returnMultiple}x return (+${returnPct}%)`
                    : '';

                // Compare to pool odds
                if (ammPrice > 0) {
                    const poolOddsPct = (ammPrice * 100).toFixed(0);
                    const diff = ((price - ammPrice) / ammPrice * 100).toFixed(0);
                    const isBetter = limitIsBuy ? price < ammPrice : price > ammPrice;
                    const sign = diff > 0 ? '+' : '';
                    oddsVsPool.innerHTML = isBetter
                        ? `<span style="color:var(--green)">${sign}${diff}% vs pool</span>`
                        : `<span style="color:var(--text-muted)">${sign}${diff}% vs pool</span>`;
                } else {
                    oddsVsPool.textContent = '';
                }
            } else {
                oddsHelper.style.display = 'none';
            }

            if (price <= 0 || shares <= 0) {
                document.getElementById('limitCost').textContent = '-- ETH';
                document.getElementById('limitReceive').textContent = '-- ' + label;
                document.getElementById('limitProfit').textContent = '--';
                return;
            }

            const totalCost = price * shares;

            if (limitIsBuy) {
                // Buy order: escrow ETH, receive shares when filled
                document.getElementById('limitCost').textContent = totalCost.toFixed(4) + ' ETH';
                document.getElementById('limitReceive').textContent = shares.toFixed(4) + ' ' + label;

                // If you win, shares pay 1 ETH each
                const payout = shares;
                const profit = payout - totalCost;
                const roi = (profit / totalCost * 100).toFixed(0);
                document.getElementById('limitProfit').textContent = `${payout.toFixed(4)} ETH (+${roi}%)`;
                document.getElementById('limitProfit').style.color = 'var(--green)';
            } else {
                // Sell order: escrow shares, receive ETH when filled
                document.getElementById('limitCost').textContent = shares.toFixed(4) + ' ' + label;
                document.getElementById('limitReceive').textContent = totalCost.toFixed(4) + ' ETH';

                // Guaranteed ETH from sale
                document.getElementById('limitProfit').textContent = totalCost.toFixed(4) + ' ETH';
                document.getElementById('limitProfit').style.color = 'var(--text)';
            }
        }

        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const price = parseFloat(document.getElementById('limitPrice').value);
            const shares = parseFloat(document.getElementById('limitShares').value);

            if (!price || price <= 0 || price >= 1) {
                showStatus('Enter valid price (0.01 - 0.99)', 'error');
                return;
            }
            if (!shares || shares <= 0) {
                showStatus('Enter valid shares amount', 'error');
                return;
            }

            // For sell orders, validate user has enough shares
            if (!limitIsBuy) {
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                const sharesNeeded = ethers.parseEther(shares.toString());
                if (sharesNeeded > userShares) {
                    const available = parseFloat(ethers.formatEther(userShares)).toFixed(4);
                    showStatus(`Insufficient shares. You have ${available}`, 'error');
                    return;
                }
            }

            try {
                // For sell orders, need approval
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('limit');
                    if (!approved) return;
                }

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                const marketId = currentTrade.marketId;
                const sharesWei = ethers.parseEther(shares.toString());
                const collateralWei = ethers.parseEther((price * shares).toString());

                // Get market close time for deadline
                const market = await pamm.getMarket(marketId);
                const closeTime = market[5];

                let txPromise;
                if (limitIsBuy) {
                    // Buy order: send ETH as value
                    txPromise = pmRouter.placeOrder(
                        marketId,
                        currentTrade.isYes,
                        true, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true, // partialFill
                        { value: collateralWei }
                    );
                } else {
                    // Sell order: no ETH value
                    txPromise = pmRouter.placeOrder(
                        marketId,
                        currentTrade.isYes,
                        false, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true // partialFill
                    );
                }

                const orderType = limitIsBuy ? 'Buy' : 'Sell';
                await monitorTransaction(txPromise, {
                    pending: { title: `Placing ${orderType} Order`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Placing ${orderType} Order`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Placed!', body: `${orderType} ${shares} shares at ${price.toFixed(2)}` },
                    error: { title: 'Order Failed', body: '' },
                    onSuccess: async () => {
                        document.getElementById('limitPrice').value = '';
                        document.getElementById('limitShares').value = '';
                        updateLimitPreview();
                        await loadOrderbook(marketId, currentTrade.isYes);
                        await refreshUserOrders();
                    }
                });
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Limit order error:', err);
                }
            }
        }

        async function refreshUserOrders() {
            const listEl = document.getElementById('yourOrdersList');

            if (!connectedAddress || !currentTrade.marketId) {
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Connect wallet to see orders</div>';
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                // Get user's order hashes
                const orderCount = await pmRouter.getUserOrderCount(connectedAddress);
                if (orderCount === 0n) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No open orders</div>';
                    userOrders = [];
                    return;
                }

                const orderHashes = await pmRouter.getUserOrderHashes(connectedAddress, 0, 50);

                // Fetch order details and filter for current market
                const orders = [];
                for (const hash of orderHashes) {
                    try {
                        const order = await pmRouter.orders(hash);
                        // Filter: same market AND (order not fully filled, i.e., owner still set)
                        if (order.owner !== ethers.ZeroAddress &&
                            order.marketId.toString() === currentTrade.marketId.toString()) {
                            // Convert ethers Result to plain object
                            orders.push({
                                hash,
                                owner: order.owner,
                                deadline: order.deadline,
                                isYes: order.isYes,
                                isBuy: order.isBuy,
                                partialFill: order.partialFill,
                                shares: order.shares,
                                collateral: order.collateral,
                                marketId: order.marketId
                            });
                        }
                    } catch (e) {
                        // Order might be cancelled/filled
                    }
                }

                userOrders = orders;

                if (orders.length === 0) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No open orders for this market</div>';
                    return;
                }

                // Render orders
                listEl.innerHTML = orders.map(o => {
                    const shares = Number(o.shares) / 1e18;
                    const collateral = Number(o.collateral) / 1e18;
                    const price = shares > 0 ? collateral / shares : 0;
                    const side = o.isBuy ? 'BUY' : 'SELL';
                    const sideColor = o.isBuy ? 'var(--green)' : 'var(--red)';
                    const shareType = o.isYes ? 'YES' : 'NO';
                    const isCurrentSide = o.isYes === currentTrade.isYes;

                    // Smart formatting for shares - show more decimals for small values
                    const sharesStr = shares >= 1 ? shares.toFixed(2) :
                                     shares >= 0.01 ? shares.toFixed(4) :
                                     shares.toFixed(6);
                    const oddsStr = (price * 100).toFixed(0) + '%';

                    return `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-bottom:1px solid var(--border);${!isCurrentSide ? 'opacity:0.6;' : ''}">
                            <div>
                                <span style="color:${sideColor};font-weight:600;">${side}</span>
                                <span style="color:var(--text);">${sharesStr} ${shareType}</span>
                                <span style="color:var(--text-muted);">@ ${price.toFixed(3)} (${oddsStr})</span>
                                ${!isCurrentSide ? '<span style="font-size:9px;color:var(--text-dim);margin-left:4px;">(other side)</span>' : ''}
                            </div>
                            <button onclick="cancelUserOrder('${o.hash}')"
                                style="padding:2px 8px;font-size:var(--font-xs);background:transparent;border:1px solid var(--red);color:var(--red);border-radius:var(--radius);cursor:pointer;">
                                Cancel
                            </button>
                        </div>
                    `;
                }).join('');

            } catch (e) {
                console.error('Failed to load user orders:', e);
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Failed to load orders</div>';
            }
        }

        async function cancelUserOrder(orderHash) {
            if (!signer) {
                showStatus('Connect wallet first', 'error');
                return;
            }

            if (!confirm('Cancel this order?')) return;

            try {
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);

                await monitorTransaction(pmRouter.cancelOrder(orderHash), {
                    pending: { title: 'Cancelling Order', body: 'Confirm in your wallet...' },
                    submitted: { title: 'Cancelling Order', body: 'Waiting for confirmation...' },
                    success: { title: 'Order Cancelled!', body: 'Your order has been cancelled' },
                    error: { title: 'Cancel Failed', body: '' },
                    onSuccess: async () => {
                        await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                        await refreshUserOrders();
                        await loadUserPosition(currentTrade.marketId);
                    }
                });

            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Cancel order error:', err);
                }
            }
        }

        async function setMaxTrade() {
            if (currentTradeMode === 'lp') {
                if (currentLpMode === 'add') {
                    // Set max ETH for adding LP
                    if (provider && connectedAddress) {
                        try {
                            const bal = await provider.getBalance(connectedAddress);
                            const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                            document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                            updateLpPreview();
                        } catch (e) {
                            console.warn('Failed to fetch balance for max:', e.message);
                        }
                    }
                } else {
                    // Set max LP tokens for removing
                    document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    updateLpPreview();
                }
            } else if (currentTradeMode === 'swap') {
                // Set max shares for swap (YES if YESâ†’NO, NO if NOâ†’YES)
                const sharesBal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                updateSwapPreview();
            } else if (currentTradeMode === 'trade') {
                if (currentTradeDirection === 'buy') {
                    // Set max ETH balance (leave some for gas)
                    if (provider && connectedAddress) {
                        try {
                            const bal = await provider.getBalance(connectedAddress);
                            const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                            document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                            updatePreview();
                        } catch (e) {
                            console.warn('Failed to fetch balance for max:', e.message);
                        }
                    }
                } else {
                    // Set max shares for sell
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                    updatePreview();
                }
            } else if (currentTradeMode === 'mint') {
                // Set max ETH balance (leave some for gas)
                if (provider && connectedAddress) {
                    try {
                        const bal = await provider.getBalance(connectedAddress);
                        const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                        document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                        updateMintPreview();
                    } catch (e) {
                        console.warn('Failed to fetch balance for max:', e.message);
                    }
                }
            } else {
                // Legacy fallback
                const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                updatePreview();
            }
        }

        function closeModal() {
            document.getElementById('tradeModal').classList.remove('active');
            document.getElementById('tradeStatus').className = 'status-message';
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                // 1% slippage protection for LP operations
                const lpSlippage = 0.01;
                const minAmount = amtWei * BigInt(Math.floor((1 - lpSlippage) * 10000)) / 10000n;

                let txPromise;
                if (currentLpMode === 'add') {
                    // Add liquidity: splitAndAddLiquidity
                    txPromise = pamm.splitAndAddLiquidity(
                        currentTrade.marketId,
                        amtWei,
                        FEE_TIER,
                        0, // amount0Min - tokens go to pool, less critical
                        0, // amount1Min
                        minAmount / 2n, // minLiquidity - protect against sandwich
                        connectedAddress,
                        0, // deadline
                        { value: amtWei }
                    );

                    await monitorTransaction(txPromise, {
                        pending: { title: 'Adding Liquidity', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Adding Liquidity', body: 'Waiting for confirmation...' },
                        success: { title: 'Liquidity Added!', body: `Added ${amt} ETH to the pool` },
                        error: { title: 'Add Liquidity Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([
                                loadUserPosition(currentTrade.marketId),
                                loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                            ]);
                            loadBalance();
                            updateLpPreview();
                        }
                    });
                } else {
                    // Remove liquidity: need PAMM approved as operator on ZAMM
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    txPromise = pamm.removeLiquidityToCollateral(
                        currentTrade.marketId,
                        FEE_TIER,
                        amtWei,
                        0, // amount0Min
                        0, // amount1Min
                        minAmount, // minCollateralOut - protect against sandwich
                        connectedAddress,
                        0 // deadline
                    );

                    await monitorTransaction(txPromise, {
                        pending: { title: 'Removing Liquidity', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Removing Liquidity', body: 'Waiting for confirmation...' },
                        success: { title: 'Liquidity Removed!', body: `Withdrew liquidity from the pool` },
                        error: { title: 'Remove Liquidity Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([
                                loadUserPosition(currentTrade.marketId),
                                loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                            ]);
                            loadBalance();
                            updateLpPreview();
                        }
                    });
                }

            } catch (e) {
                // monitorTransaction handles errors, but catch user rejection before tx submission
                if (!isUserRejection(e)) {
                    console.error('LP operation failed:', e);
                }
            }
        }

        function handleTradeInput() {
            if (currentTradeMode === 'lp') {
                updateLpPreview();
            } else if (currentTradeMode === 'swap') {
                updateSwapPreview();
            } else if (currentTradeMode === 'mint') {
                updateMintPreview();
            } else {
                updatePreview();
            }
        }

        async function loadBalance() {
            if (!provider || !connectedAddress) return;
            try {
                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        const bal = await provider.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    } else {
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    }
                } else if (currentTradeMode === 'swap') {
                    // For swap, show balance of the share being swapped (YES if YESâ†’NO, NO if NOâ†’YES)
                    const sharesBal = currentSwapDirection ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                } else if (currentTradeMode === 'trade') {
                    if (currentTradeDirection === 'buy') {
                        const bal = await provider.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    } else {
                        const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                    }
                } else if (currentTradeMode === 'mint') {
                    const bal = await provider.getBalance(connectedAddress);
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                } else {
                    // Legacy fallback for buy/sell modes
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal || 0n)).toFixed(4);
                }
            } catch (e) {
                document.getElementById('tradeBalance').textContent = '--';
            }
        }

        function updatePreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const m = markets[currentTrade.type];
            const routeEl = document.getElementById('previewRoute');
            const breakdownEl = document.getElementById('previewBreakdown');
            const savingsEl = document.getElementById('previewSavings');
            const breakdownDetails = document.getElementById('breakdownDetails');

            // Determine if buying based on currentTradeDirection (for 'trade' mode) or legacy mode
            const isBuy = currentTradeMode === 'trade' ? currentTradeDirection === 'buy' : currentTradeMode === 'buy';

            if (!m || amt === 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                document.getElementById('previewOddsRow').style.display = 'none';
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--blue)';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            const price = currentTrade.isYes ? m.yesPrice : m.noPrice;
            const ammPrice = currentOrderbook.ammPrice || price;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            // Simulate mixed fill execution
            const execution = simulateMixedFill(amt, isBuy, rYes, rNo, ammPrice);

            // Update route indicator
            if (execution.orderbookFills.length > 0) {
                routeEl.innerHTML = `Orderbook + AMM <span style="color:var(--green);">â˜…</span>`;
                routeEl.style.color = 'var(--green)';
            } else {
                routeEl.textContent = 'AMM only';
                routeEl.style.color = 'var(--blue)';
            }

            // Update main preview
            if (execution.totalOutput <= 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = 'No liquidity';
                document.getElementById('previewOddsRow').style.display = 'none';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            if (isBuy) {
                // Buy: spend ETH, receive shares (1 share = 1 ETH if win)
                const effectivePrice = amt / execution.totalOutput;
                const payout = execution.totalOutput; // Shares redeem at 1 ETH each
                const profit = payout - amt;
                const roi = (profit / amt) * 100;
                const impliedOdds = effectivePrice * 100;

                document.getElementById('previewShares').textContent = formatEth(execution.totalOutput, ' shares');
                document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH');
                document.getElementById('previewPayout').textContent = `${formatEth(payout, '')} ETH (+${roi.toFixed(0)}%)`;

                // Show implied odds
                document.getElementById('previewOddsRow').style.display = 'flex';
                document.getElementById('previewOdds').textContent = impliedOdds.toFixed(1) + '% ' + (currentTrade.isYes ? 'YES' : 'NO');
            } else {
                // Sell: spend shares, receive ETH
                const effectivePrice = execution.totalOutput / amt;
                const minReceive = execution.totalOutput * (1 - slippageTolerance / 100);
                const impliedOdds = effectivePrice * 100;

                document.getElementById('previewShares').textContent = formatEth(execution.totalOutput);
                document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH');
                document.getElementById('previewPayout').textContent = formatEth(minReceive);

                // Show implied odds
                document.getElementById('previewOddsRow').style.display = 'flex';
                document.getElementById('previewOdds').textContent = impliedOdds.toFixed(1) + '%';
            }

            // Show execution breakdown if using orderbook
            if (execution.orderbookFills.length > 0) {
                breakdownEl.style.display = 'flex';
                let breakdownHtml = '';
                execution.orderbookFills.forEach(fill => {
                    if (isBuy) {
                        breakdownHtml += `<div>â€¢ ${formatEth(fill.sharesOut, '')} @ ${formatEth(fill.price, '')} (OB)</div>`;
                    } else {
                        breakdownHtml += `<div>â€¢ ${formatEth(fill.sharesIn, '')} @ ${formatEth(fill.price, '')} (OB)</div>`;
                    }
                });
                if (execution.ammOutput > 0) {
                    if (isBuy) {
                        breakdownHtml += `<div>â€¢ ${formatEth(execution.ammOutput, '')} @ ~${formatEth(execution.ammEffectivePrice, '')} (AMM)</div>`;
                    } else {
                        breakdownHtml += `<div>â€¢ ${formatEth(execution.ammSharesIn, '')} â†’ ${formatEth(execution.ammOutput)} (AMM)</div>`;
                    }
                }
                breakdownDetails.innerHTML = breakdownHtml;
            } else {
                breakdownEl.style.display = 'none';
            }

            // Show savings vs pure AMM
            if (execution.savings > 0.0001 && execution.pureAmmOutput > 0) {
                savingsEl.style.display = 'flex';
                const savingsPct = (execution.savings / execution.pureAmmOutput * 100).toFixed(1);
                document.getElementById('savingsAmount').textContent = `+${execution.savings.toFixed(4)} (+${savingsPct}%)`;
                document.getElementById('savingsAmount').style.color = 'var(--green)';
            } else {
                savingsEl.style.display = 'none';
            }
        }

        // Simulate execution with slippage-aware routing
        // Compares limit orders against AMM effective price (with slippage), not just spot
        function simulateMixedFill(inputAmt, isBuy, rYes, rNo, ammPrice) {
            const result = {
                orderbookFills: [],
                ammInput: 0,
                ammOutput: 0,
                ammSharesIn: 0,
                ammEffectivePrice: 0,
                totalOutput: 0,
                pureAmmOutput: 0,
                savings: 0
            };

            let remaining = inputAmt;
            const amtWei = BigInt(Math.floor(inputAmt * 1e18));

            // Calculate pure AMM output for comparison
            if (rYes > 0n && rNo > 0n) {
                if (isBuy) {
                    const pureAmm = currentTrade.isYes ?
                        quoteBuyYes(amtWei, rYes, rNo, FEE_TIER) :
                        quoteBuyNo(amtWei, rYes, rNo, FEE_TIER);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                } else {
                    const pureAmm = currentTrade.isYes ?
                        quoteSellYes(amtWei, rYes, rNo, FEE_TIER) :
                        quoteSellNo(amtWei, rYes, rNo, FEE_TIER);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                }
            }

            // Get ALL limit orders (we'll compare against AMM with slippage)
            let allOrders = [];
            if (isBuy) {
                // For buying: we look at asks (sell orders), sorted by price ascending (cheapest first)
                allOrders = (currentOrderbook.asks || [])
                    .map(o => ({
                        price: Number(o.collateral) / Number(o.shares),
                        shares: Number(o.shares) / 1e18,
                        collateral: Number(o.collateral) / 1e18,
                        hash: o.hash,
                        remaining: Number(o.collateral) / 1e18 // ETH needed to fill
                    }))
                    .filter(o => o.price > 0 && o.shares > 0)
                    .sort((a, b) => a.price - b.price);
            } else {
                // For selling: we look at bids (buy orders), sorted by price descending (best first)
                allOrders = (currentOrderbook.bids || [])
                    .map(o => ({
                        price: Number(o.collateral) / Number(o.shares),
                        shares: Number(o.shares) / 1e18,
                        collateral: Number(o.collateral) / 1e18,
                        hash: o.hash,
                        remaining: Number(o.shares) / 1e18 // Shares they want to buy
                    }))
                    .filter(o => o.price > 0 && o.shares > 0)
                    .sort((a, b) => b.price - a.price);
            }

            // Track AMM state as we simulate fills
            let simRYes = rYes;
            let simRNo = rNo;
            let orderIdx = 0;

            // Slippage-aware routing: compare each order against AMM marginal price
            while (remaining > 0.000001 && (orderIdx < allOrders.length || (simRYes > 0n && simRNo > 0n))) {
                const currentOrder = orderIdx < allOrders.length ? allOrders[orderIdx] : null;

                // Calculate AMM marginal price for a small test amount
                let ammMarginalPrice = ammPrice;
                if (simRYes > 0n && simRNo > 0n) {
                    const testAmt = BigInt(Math.floor(Math.min(remaining, 0.001) * 1e18));
                    if (testAmt > 0n) {
                        if (isBuy) {
                            const testOut = currentTrade.isYes ?
                                quoteBuyYes(testAmt, simRYes, simRNo, FEE_TIER) :
                                quoteBuyNo(testAmt, simRYes, simRNo, FEE_TIER);
                            ammMarginalPrice = Number(testAmt) / Number(testOut);
                        } else {
                            const testOut = currentTrade.isYes ?
                                quoteSellYes(testAmt, simRYes, simRNo, FEE_TIER) :
                                quoteSellNo(testAmt, simRYes, simRNo, FEE_TIER);
                            ammMarginalPrice = Number(testOut) / Number(testAmt);
                        }
                    }
                }

                // Decide: fill order or use AMM?
                let useOrder = false;
                if (currentOrder && currentOrder.remaining > 0) {
                    if (isBuy) {
                        // Buying: order is better if its price < AMM marginal price
                        useOrder = currentOrder.price < ammMarginalPrice;
                    } else {
                        // Selling: order is better if its price > AMM marginal price
                        useOrder = currentOrder.price > ammMarginalPrice;
                    }
                }

                if (useOrder && currentOrder) {
                    // Fill limit order
                    if (isBuy) {
                        const maxEthForOrder = currentOrder.remaining;
                        const ethToSpend = Math.min(remaining, maxEthForOrder);
                        const sharesOut = ethToSpend / currentOrder.price;

                        result.orderbookFills.push({
                            price: currentOrder.price,
                            ethSpent: ethToSpend,
                            sharesOut: sharesOut,
                            hash: currentOrder.hash
                        });
                        result.totalOutput += sharesOut;
                        remaining -= ethToSpend;
                        currentOrder.remaining -= ethToSpend;
                    } else {
                        const maxSharesForOrder = currentOrder.remaining;
                        const sharesToSell = Math.min(remaining, maxSharesForOrder);
                        const ethOut = sharesToSell * currentOrder.price;

                        result.orderbookFills.push({
                            price: currentOrder.price,
                            sharesIn: sharesToSell,
                            ethOut: ethOut,
                            hash: currentOrder.hash
                        });
                        result.totalOutput += ethOut;
                        remaining -= sharesToSell;
                        currentOrder.remaining -= sharesToSell;
                    }

                    // Move to next order if this one is exhausted
                    if (currentOrder.remaining <= 0.000001) {
                        orderIdx++;
                    }
                } else if (simRYes > 0n && simRNo > 0n) {
                    // Route to AMM - use chunk or all remaining
                    // If there are more orders, route just enough to make next order competitive
                    let amtToAmm = remaining;

                    // Check if routing partial to AMM would make next order better
                    if (currentOrder && currentOrder.remaining > 0) {
                        // Route smaller chunks to check when order becomes competitive
                        amtToAmm = Math.min(remaining, remaining * 0.1 + 0.0001);
                    }

                    const ammAmtWei = BigInt(Math.floor(amtToAmm * 1e18));
                    if (ammAmtWei > 0n) {
                        if (isBuy) {
                            const ammOut = currentTrade.isYes ?
                                quoteBuyYes(ammAmtWei, simRYes, simRNo, FEE_TIER) :
                                quoteBuyNo(ammAmtWei, simRYes, simRNo, FEE_TIER);
                            const sharesOut = Number(ammOut) / 1e18;
                            result.ammOutput += sharesOut;
                            result.ammInput += amtToAmm;
                            result.totalOutput += sharesOut;
                            remaining -= amtToAmm;

                            // Update simulated reserves (approximate)
                            if (currentTrade.isYes) {
                                simRNo += ammAmtWei;
                                simRYes -= ammOut > simRYes ? simRYes : ammOut;
                            } else {
                                simRYes += ammAmtWei;
                                simRNo -= ammOut > simRNo ? simRNo : ammOut;
                            }
                        } else {
                            const ammOut = currentTrade.isYes ?
                                quoteSellYes(ammAmtWei, simRYes, simRNo, FEE_TIER) :
                                quoteSellNo(ammAmtWei, simRYes, simRNo, FEE_TIER);
                            const ethOut = Number(ammOut) / 1e18;
                            result.ammOutput += ethOut;
                            result.ammSharesIn += amtToAmm;
                            result.totalOutput += ethOut;
                            remaining -= amtToAmm;

                            // Update simulated reserves (approximate)
                            if (currentTrade.isYes) {
                                simRYes += ammAmtWei;
                                simRNo -= ammOut > simRNo ? simRNo : ammOut;
                            } else {
                                simRNo += ammAmtWei;
                                simRYes -= ammOut > simRYes ? simRYes : ammOut;
                            }
                        }
                    } else {
                        break; // Can't route anymore
                    }
                } else {
                    // No AMM and no competitive orders
                    if (currentOrder) {
                        orderIdx++; // Skip to next order
                    } else {
                        break; // Nothing left to route
                    }
                }
            }

            // Calculate effective AMM price
            if (result.ammInput > 0) {
                result.ammEffectivePrice = result.ammInput / result.ammOutput;
            }

            // Calculate savings vs pure AMM
            if (result.pureAmmOutput > 0) {
                result.savings = result.totalOutput - result.pureAmmOutput;
            }

            return result;
        }

        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            // Determine if buying based on currentTradeDirection (for 'trade' mode) or legacy mode
            const isBuy = currentTradeMode === 'trade' ? currentTradeDirection === 'buy' : currentTradeMode === 'buy';

            try {
                showStatus('Preparing...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                const ammPrice = currentOrderbook.ammPrice || 0;
                const rYes = currentOrderbook.rYes || 0n;
                const rNo = currentOrderbook.rNo || 0n;

                // Simulate execution to get expected output and order hashes
                const execution = simulateMixedFill(amt, isBuy, rYes, rNo, ammPrice);

                if (execution.totalOutput <= 0) {
                    showStatus('No liquidity available', 'error');
                    return;
                }

                // Calculate minOutput with slippage tolerance
                const minOutput = Math.max(0, execution.totalOutput * (1 - slippageTolerance / 100));
                const minOutputWei = ethers.parseEther(minOutput.toFixed(18));

                // Get order hashes from simulation
                const betterOrderHashes = execution.orderbookFills.map(f => f.hash);

                const tradeLabel = isBuy ? 'Buying' : 'Selling';
                const side = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

                let txPromise;
                if (isBuy) {
                    // Use fillOrdersThenSwap if we have better limit orders
                    if (betterOrderHashes.length > 0) {
                        txPromise = pmRouter.fillOrdersThenSwap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            true, // isBuy
                            amtWei,
                            minOutputWei, // slippage protected
                            betterOrderHashes,
                            FEE_TIER,
                            connectedAddress,
                            0, // deadline (0 = no deadline)
                            { value: amtWei }
                        );
                    } else {
                        txPromise = pmRouter.buy(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei, // slippage protected
                            FEE_TIER,
                            connectedAddress,
                            0,
                            { value: amtWei }
                        );
                    }
                } else {
                    // Sell - need PMRouter approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    // Use fillOrdersThenSwap if we have better limit orders
                    if (betterOrderHashes.length > 0) {
                        txPromise = pmRouter.fillOrdersThenSwap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            false, // isBuy
                            amtWei,
                            minOutputWei, // slippage protected
                            betterOrderHashes,
                            FEE_TIER,
                            connectedAddress,
                            0 // deadline
                        );
                    } else {
                        txPromise = pmRouter.sell(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei, // slippage protected
                            FEE_TIER,
                            connectedAddress,
                            0
                        );
                    }
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `${tradeLabel} ${side}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${tradeLabel} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Successful!', body: `${tradeLabel} ${amt} ${isBuy ? 'ETH worth of' : ''} ${side} shares` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        await loadData();
                        await loadPositions();
                        setTimeout(closeModal, 1500);
                    }
                });

            } catch (e) {
                // monitorTransaction handles errors, but catch user rejection before tx submission
                if (!isUserRejection(e)) {
                    console.error('Trade failed:', e);
                }
            }
        }

        function showStatus(msg, type, isHtml = false) {
            const el = document.getElementById('tradeStatus');
            if (isHtml) {
                el.innerHTML = msg;
            } else {
                el.textContent = msg;
            }
            el.className = 'status-message show ' + type;
        }

        function txLink(hash, text = 'View tx') {
            return `<a href="https://etherscan.io/tx/${hash}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: underline;">${text}</a>`;
        }

        // ======================== TOAST NOTIFICATIONS ========================

        let activeToasts = new Map(); // Track active toasts by ID

        /**
         * Show a toast notification
         * @param {string} title - Toast title
         * @param {string} body - Toast body text (can include HTML)
         * @param {string} type - 'pending', 'success', or 'error'
         * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
         * @param {string} id - Optional unique ID for updating existing toast
         * @returns {string} - Toast ID
         */
        function showToast(title, body = '', type = 'pending', duration = 0, id = null) {
            const container = document.getElementById('toastContainer');
            const toastId = id || `toast-${Date.now()}`;

            // If updating existing toast, remove old one first
            if (id && activeToasts.has(id)) {
                const existing = activeToasts.get(id);
                existing.element.remove();
                if (existing.timeout) clearTimeout(existing.timeout);
            }

            const icons = {
                pending: '<div class="spinner"></div>',
                success: '<span class="icon">âœ“</span>',
                error: '<span class="icon">âœ—</span>',
                info: '<span class="icon">â„¹</span>'
            };

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-header">
                    ${icons[type] || ''}
                    <span>${title}</span>
                </div>
                ${body ? `<div class="toast-body">${body}</div>` : ''}
                ${duration > 0 ? `<div class="toast-progress"><div class="toast-progress-bar" style="animation-duration: ${duration}ms;"></div></div>` : ''}
            `;

            container.appendChild(toast);

            let timeout = null;
            if (duration > 0) {
                timeout = setTimeout(() => {
                    dismissToast(toastId);
                }, duration);
            }

            activeToasts.set(toastId, { element: toast, timeout });
            return toastId;
        }

        function dismissToast(toastId) {
            if (!activeToasts.has(toastId)) return;

            const { element, timeout } = activeToasts.get(toastId);
            if (timeout) clearTimeout(timeout);

            element.classList.add('hiding');
            setTimeout(() => {
                element.remove();
                activeToasts.delete(toastId);
            }, 300);
        }

        function updateToast(toastId, title, body, type, duration = 0) {
            return showToast(title, body, type, duration, toastId);
        }

        /**
         * Helper for transaction monitoring with toast updates
         * @param {Promise} txPromise - The transaction promise
         * @param {object} options - { pending, success, error } message configs
         * @returns {Promise} - The transaction receipt
         */
        async function monitorTransaction(txPromise, options = {}) {
            const {
                pending = { title: 'Transaction Pending', body: 'Confirm in your wallet...' },
                submitted = { title: 'Transaction Submitted', body: 'Waiting for confirmation...' },
                success = { title: 'Transaction Confirmed', body: '' },
                error = { title: 'Transaction Failed', body: '' },
                onSuccess = null
            } = options;

            const toastId = showToast(pending.title, pending.body, 'pending');
            let txHash = null;

            try {
                const tx = await txPromise;

                // Transaction submitted to network
                txHash = tx.hash;
                const etherscanLink = `<a href="https://etherscan.io/tx/${txHash}" target="_blank">View on Etherscan</a>`;
                updateToast(toastId, submitted.title, `${submitted.body}<br>${etherscanLink}`, 'pending');

                // Wait for confirmation using dedicated RPC provider (more reliable than wallet's provider)
                const rpc = await getRpcProvider();
                const receipt = await Promise.race([
                    rpc.waitForTransaction(txHash, 1, 60000), // 1 confirmation, 60s timeout
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 65000))
                ]);

                // Use Number() to handle BigInt or string status values
                if (receipt && Number(receipt.status) === 1) {
                    updateToast(toastId, success.title, `${success.body}${success.body ? '<br>' : ''}${etherscanLink}`, 'success', 5000);
                    if (onSuccess) await onSuccess(receipt);
                    return receipt;
                } else if (receipt && Number(receipt.status) === 0) {
                    updateToast(toastId, error.title, `Transaction reverted<br>${etherscanLink}`, 'error', 8000);
                    throw new Error('Transaction reverted');
                } else {
                    // Timeout or null receipt - tx may still be pending or succeeded
                    console.warn('Unexpected receipt state:', receipt);
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded<br>${etherscanLink}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                }
            } catch (e) {
                console.error('Transaction error:', e);
                if (isUserRejection(e)) {
                    updateToast(toastId, 'Transaction Cancelled', 'You rejected the transaction', 'error', 4000);
                } else if (e.message === 'timeout') {
                    const etherscanLink = txHash ? `<a href="https://etherscan.io/tx/${txHash}" target="_blank">View on Etherscan</a>` : '';
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded${etherscanLink ? '<br>' + etherscanLink : ''}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                } else {
                    const errMsg = e.reason || e.message || 'Unknown error';
                    updateToast(toastId, error.title, errMsg, 'error', 8000);
                }
                throw e;
            }
        }

        // ======================== APPROVALS ========================

        /**
         * Ensure operator approval for a contract.
         * @param {string} tokenContract - 'pamm' or 'zamm'
         * @param {string} operatorAddress - Address to approve as operator
         * @param {string} operatorName - Human-readable name for status messages
         * @returns {Promise<boolean>} - true if approved (or already approved), false if rejected
         */
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                let success = false;
                await monitorTransaction(contract.setOperator(operatorAddress, true), {
                    pending: { title: 'Approval Required', body: `Approve ${operatorName} as operator...` },
                    submitted: { title: 'Approval Required', body: 'Waiting for confirmation...' },
                    success: { title: 'Approved!', body: `${operatorName} can now manage your tokens` },
                    error: { title: 'Approval Failed', body: '' },
                    onSuccess: () => { success = true; }
                });
                return success;
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Approval error:', err);
                }
                return false;
            }
        }

        /**
         * Check all required approvals for the current operation
         * @param {string} operation - 'sell', 'lp', 'mint', 'limit'
         * @returns {Promise<boolean>} - true if all approvals granted
         */
        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showStatus('Please connect wallet first', 'error');
                return false;
            }

            // PMRouter needs to be operator on PAMM for: sell, mint & list, limit orders
            if (operation === 'sell' || operation === 'mint' || operation === 'limit') {
                const approved = await ensureOperatorApproval('pamm', PMROUTER_ADDRESS, 'PMRouter');
                if (!approved) return false;
            }

            // PAMM needs to be operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                const approved = await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
                if (!approved) return false;
            }

            // ZAMM needs to be operator on PAMM for: swap (YESâ†”NO)
            if (operation === 'swap') {
                const approved = await ensureOperatorApproval('pamm', ZAMM_ADDRESS, 'ZAMM');
                if (!approved) return false;
            }

            return true;
        }

        // ======================== HELPERS ========================

        // AMM constant product formula (matches ZAMM._getAmountOut)
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        // AMM reverse calculation (matches ZAMM._getAmountIn)
        function getAmountIn(amountOut, reserveIn, reserveOut, feeBps = 30n) {
            if (amountOut === 0n || reserveIn === 0n || amountOut >= reserveOut) return 0n;
            const numerator = reserveIn * amountOut * 10000n;
            const denominator = (reserveOut - amountOut) * (10000n - feeBps);
            return (numerator / denominator) + 1n;
        }

        // Quote buying YES shares with collateral
        // PAMM buyYes: split collateral â†’ YES + NO, then swap NO â†’ YES
        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn â†’ collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn NO â†’ yesFromSwap YES (pool: NO in, YES out)
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            // Total YES = from split + from swap
            return collateralIn + yesFromSwap;
        }

        // Quote buying NO shares with collateral
        // PAMM buyNo: split collateral â†’ YES + NO, then swap YES â†’ NO
        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn â†’ collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn YES â†’ noFromSwap NO (pool: YES in, NO out)
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            // Total NO = from split + from swap
            return collateralIn + noFromSwap;
        }

        // Quote selling YES shares for collateral
        // PAMM sellYes: swap some YES â†’ NO, then merge YES + NO â†’ collateral
        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of YES â†’ NO, then merge
            // Actual: swap yesIn/2 â†’ NO, merge min(yesIn/2, noFromSwap)
            const yesToSwap = yesIn / 2n;
            const noFromSwap = getAmountOut(yesToSwap, rYes, rNo, feeBps);
            const yesRemaining = yesIn - yesToSwap;
            // Merge: min(yesRemaining, noFromSwap) â†’ collateral
            const merged = yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
            return merged;
        }

        // Quote selling NO shares for collateral
        // PAMM sellNo: swap some NO â†’ YES, then merge YES + NO â†’ collateral
        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of NO â†’ YES, then merge
            const noToSwap = noIn / 2n;
            const yesFromSwap = getAmountOut(noToSwap, rNo, rYes, feeBps);
            const noRemaining = noIn - noToSwap;
            // Merge: min(yesFromSwap, noRemaining) â†’ collateral
            const merged = yesFromSwap < noRemaining ? yesFromSwap : noRemaining;
            return merged;
        }

        function formatGwei(wei) {
            const gwei = Number(wei) / 1e9;
            if (gwei >= 100) return Math.round(gwei).toString();
            if (gwei >= 10) return gwei.toFixed(1);
            return gwei.toFixed(2);
        }

        // Smart ETH formatting - shows appropriate precision for amount size
        function formatEth(eth, suffix = ' ETH') {
            if (eth === 0) return '0' + suffix;
            if (eth >= 100) return eth.toFixed(1) + suffix;
            if (eth >= 10) return eth.toFixed(2) + suffix;
            if (eth >= 1) return eth.toFixed(3) + suffix;
            if (eth >= 0.1) return eth.toFixed(4) + suffix;
            if (eth >= 0.01) return eth.toFixed(4) + suffix;
            if (eth >= 0.001) return eth.toFixed(5) + suffix;
            return eth.toFixed(6) + suffix; // For very small amounts
        }

        // Format odds/probability with appropriate precision
        function formatOdds(price, asPercent = true) {
            if (asPercent) {
                const pct = price * 100;
                if (pct >= 99 || pct <= 1) return pct.toFixed(1) + '%';
                if (pct >= 90 || pct <= 10) return pct.toFixed(1) + '%';
                return pct.toFixed(1) + '%';
            }
            return price.toFixed(4);
        }

        /**
         * Calculate predicted TWAP at market close based on:
         * - Current TWAP (partially locked in based on elapsed time)
         * - Market odds indicating expected direction for remaining time
         * - Time remaining until market close
         */
        function calculatePredictedTwap(currentTwap, startTwap, yesPrice, marketClose, marketStart) {
            // Safety check - if no valid TWAP data, return 0 (will skip drawing)
            if (!currentTwap || currentTwap <= 0) return 0;

            const now = Math.floor(Date.now() / 1000);
            const totalDuration = marketClose - marketStart;
            if (totalDuration <= 0) return currentTwap; // Invalid duration, use current

            const elapsed = Math.max(0, now - marketStart);
            const remaining = Math.max(0, totalDuration - elapsed);

            // If market closed or about to close, return current TWAP
            if (remaining < 60) return currentTwap;

            // TWAP formula: finalTwap = (accumulatedGweiSeconds) / totalDuration
            // accumulatedGweiSeconds = currentTwap * elapsed + futureAvg * remaining

            // What future average would result in finalTwap = startTwap (the threshold)?
            // startTwap * totalDuration = currentTwap * elapsed + neutralFuture * remaining
            // neutralFuture = (startTwap * totalDuration - currentTwap * elapsed) / remaining
            const neutralFutureAvg = (startTwap * totalDuration - currentTwap * elapsed) / remaining;

            // Market odds indicate how much above/below threshold we expect
            // yesPrice = 0.5 â†’ expect exactly startTwap (threshold)
            // yesPrice > 0.5 â†’ expect above startTwap
            // yesPrice < 0.5 â†’ expect below startTwap
            const rawDeviation = yesPrice - 0.5; // -0.5 to +0.5

            // Use power curve: small deviations (near 50%) have reduced effect,
            // larger deviations (toward extremes) have proportionally more effect
            // This reflects that 55% is slightly bullish but 80% is very bullish
            const sign = rawDeviation >= 0 ? 1 : -1;
            const magnitude = Math.abs(rawDeviation) * 2; // 0 to 1
            const scaledMagnitude = Math.pow(magnitude, 1.5); // Power curve reduces small values
            const oddsDeviation = sign * scaledMagnitude * 0.5; // Back to -0.5 to +0.5 range

            // Scale factor: how much to shift future avg per odds deviation
            const shiftFactor = 0.7;

            // Calculate expected future average
            // Use blend of neutral (threshold-hitting) and current TWAP, weighted by odds
            let expectedFutureAvg;
            if (neutralFutureAvg > 0) {
                // Shift from neutral based on odds direction
                expectedFutureAvg = neutralFutureAvg * (1 + oddsDeviation * shiftFactor * 2);
            } else {
                // If neutral would be negative (current already way above threshold),
                // use current TWAP with odds-based adjustment
                expectedFutureAvg = currentTwap * (1 + oddsDeviation * 0.3);
            }

            // Clamp to reasonable range (avoid negative or extreme values)
            // Use relative bounds based on current TWAP, not absolute values
            expectedFutureAvg = Math.max(currentTwap * 0.2, Math.min(expectedFutureAvg, currentTwap * 3));

            // Calculate predicted final TWAP
            const predicted = (currentTwap * elapsed + expectedFutureAvg * remaining) / totalDuration;

            return predicted;
        }

        /**
         * Update market predictions and the header stats
         */
        function updatePredictions() {
            const predictions = [];
            const now = Math.floor(Date.now() / 1000);

            // Helper to estimate market start time (close minus typical duration)
            const estimateStart = (close, type) => {
                if (type === 'hourly') return close - 3600;
                if (type === 'daily') return close - 86400;
                if (type === 'weekly') return close - 604800;
                return close - 3600;
            };

            // Hourly market prediction
            if (markets.hourly && markets.hourly.yesPrice !== undefined) {
                const m = markets.hourly;
                const start = estimateStart(m.close, 'hourly');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.hourly.predictedTwap = predicted;
                predictions.push({ type: 'hourly', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Daily market prediction
            if (markets.daily && markets.daily.yesPrice !== undefined) {
                const m = markets.daily;
                const start = estimateStart(m.close, 'daily');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.daily.predictedTwap = predicted;
                predictions.push({ type: 'daily', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Weekly market prediction
            if (markets.weekly && markets.weekly.yesPrice !== undefined) {
                const m = markets.weekly;
                const start = estimateStart(m.close, 'weekly');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.weekly.predictedTwap = predicted;
                predictions.push({ type: 'weekly', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Update prediction arrows for each timeframe
            const updateArrow = (elId, market, label) => {
                const el = document.getElementById(elId);
                if (!el) return;

                if (market && market.yesPrice !== undefined) {
                    const yesOdds = market.yesPrice;
                    const arrow = yesOdds > 0.5 ? 'â†‘' : yesOdds < 0.5 ? 'â†“' : 'â†’';
                    const color = yesOdds > 0.5 ? 'var(--green)' : yesOdds < 0.5 ? 'var(--red)' : 'var(--text-muted)';
                    const pct = Math.round(Math.max(yesOdds, 1 - yesOdds) * 100);
                    const direction = yesOdds > 0.5 ? 'UP' : 'DOWN';
                    el.innerHTML = `${label}<span style="color:${color};font-weight:700;">${arrow}</span>`;
                    el.title = `${pct}% ${direction} (from ${market.startGwei?.toFixed(2) || '--'} gwei)`;
                } else {
                    el.innerHTML = `${label}<span style="color:var(--text-dim);">--</span>`;
                    el.title = 'No active market';
                }
            };

            updateArrow('pred1H', markets.hourly, '1H ');
            updateArrow('pred1D', markets.daily, '1D ');
            updateArrow('pred1W', markets.weekly, '1W ');

            return predictions;
        }

        // ======================== MARKET RESOLUTION ========================
        async function resolveMarket(type) {
            const market = markets[type];
            if (!market || !market.id) {
                showToast('No Market', 'No market to resolve', 'error', 3000);
                return;
            }

            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);

                await monitorTransaction(
                    resolver.resolveMarket(market.id),
                    {
                        pending: { title: 'Resolving Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Resolving Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Resolved!', body: `${type.charAt(0).toUpperCase() + type.slice(1)} market has been resolved` },
                        error: { title: 'Resolution Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            await loadPositions();
                        }
                    }
                );
            } catch (e) {
                // monitorTransaction already shows toast for errors, so just log
                console.error('Resolve failed:', e);
            }
        }

        // ======================== MARKET CREATION ========================
        async function createHourly() {
            if (!signer) return;

            const seed = parseFloat(document.getElementById('hourlySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close at next top of hour UTC
                const close = new Date();
                close.setUTCMinutes(60, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000', // ETH
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Hourly Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Hourly Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Hourly market seeded with ${seed} ETH` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('hourlySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createDaily() {
            if (!signer) return;

            const seed = parseFloat(document.getElementById('dailySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close at next midnight UTC
                const close = new Date();
                close.setUTCHours(24, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000', // ETH
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Daily Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Daily Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Daily market seeded with ${seed} ETH` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('dailySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createWeekly() {
            if (!signer) return;

            const seed = parseFloat(document.getElementById('weeklySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close next Sunday midnight UTC
                const close = new Date();
                close.setUTCDate(close.getUTCDate() + (7 - close.getUTCDay()));
                close.setUTCHours(0, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000',
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Weekly Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Weekly Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Weekly market seeded with ${seed} ETH` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('weeklySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createExtreme() {
            if (!signer) return;

            const seed = parseFloat(document.getElementById('extremeSeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Fixed deadline: Dec 31, 2025 23:59:59 UTC
                const closeTs = 1767225599;
                const threshold = ethers.parseUnits('100', 'gwei'); // 100 gwei

                await monitorTransaction(
                    gasPm.createWindowPeakMarket(
                        threshold,
                        '0x0000000000000000000000000000000000000000',
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating 100 Gwei Challenge', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating 100 Gwei Challenge', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: '100 Gwei Challenge - Deadline: Dec 31, 2025' },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('extremeSeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
