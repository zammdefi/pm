<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GasPM</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%2309090b' width='100' height='100' rx='12'/><text x='50' y='55' font-family='system-ui,sans-serif' font-size='16' font-weight='600' fill='%2322c55e' text-anchor='middle'>Gas</text><text x='50' y='72' font-family='system-ui,sans-serif' font-size='14' font-weight='600' fill='%233b82f6' text-anchor='middle'>PM</text></svg>" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.15.0/ethers.umd.min.js" integrity="sha512-UXYETj+vXKSURF1UlgVRLzWRS9ZiQTv3lcL4rbeLyqTXCPNZC6PTLF/Ik3uxm2Zo+E109cUpJPZfLxJsCgKSng==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/ethereum-provider@2.10.0/dist/index.umd.js" integrity="sha384-ACTo60vL1/AfeYkCCXRvB1G0ugjHF0/SHU9YN7e4/KH/mitAIYpLcw5PKXW/+ekM" crossorigin="anonymous"></script>
    <style>
        :root {
            --bg: #09090b;
            --surface: #18181b;
            --surface-2: #27272a;
            --border: #3f3f46;
            --text: #fafafa;
            --text-muted: #a1a1aa;
            --text-dim: #71717a;
            --green: #22c55e;
            --green-dim: rgba(34, 197, 94, 0.15);
            --red: #ef4444;
            --red-dim: rgba(239, 68, 68, 0.15);
            --blue: #3b82f6;
            --amber: #f59e0b;
            --yellow: #eab308;
            --orange: #f97316;
            --gray: #27272a;
            --light-gray: #3f3f46;
            --black: #09090b;

            --spacing-xs: 0.25rem;
            --spacing-sm: 0.5rem;

            --font-xs: 0.75rem;
            --font-sm: 0.875rem;
            --font-base: 1rem;
            --font-lg: 1.125rem;
            --font-xl: 1.25rem;
            --font-2xl: 1.5rem;

            --radius: 6px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
            font-size: var(--font-sm);
            -webkit-font-smoothing: antialiased;
        }

        /* HEADER */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.5rem;
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            z-index: 1000;
        }

        .logo {
            font-size: var(--font-lg);
            font-weight: 700;
            letter-spacing: -0.025em;
        }

        .logo span { color: var(--green); }

        .tagline {
            font-size: var(--font-xs);
            color: var(--text-dim);
            margin-left: 0.75rem;
        }

        .header-center {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .live-stat { text-align: center; }

        .live-stat-label {
            font-size: var(--font-xs);
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 2px;
        }

        .live-stat-value {
            font-size: var(--font-base);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .live-stat-value.green { color: var(--green); }
        .live-stat-value.cyan { color: var(--blue); }
        .live-stat-value.amber { color: var(--amber); }

        .btn {
            font-family: inherit;
            font-size: var(--font-xs);
            font-weight: 600;
            padding: 0.5rem 1rem;
            background: transparent;
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--surface);
            border-color: var(--text-muted);
        }

        .btn.connected {
            background: var(--green);
            color: var(--bg);
            border-color: var(--green);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* MAIN */
        .main { padding-top: 64px; }

        /* CHART SECTION */
        .chart-section {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            overflow: visible; /* Allow tooltips to extend beyond */
        }

        .chart-container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: var(--radius);
            height: 260px;
            position: relative;
            overflow: visible; /* Allow tooltips to extend beyond container */
        }

        .chart-canvas { width: 100%; height: 100%; }

        .chart-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
        }

        .chart-tooltip.visible { opacity: 1; }
        .chart-tooltip-time {
            color: var(--text-dim);
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .chart-tooltip-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        .chart-tooltip-row:last-child { margin-bottom: 0; }
        .chart-tooltip-dot { width: 6px; height: 6px; border-radius: 50%; }
        .chart-tooltip-dot.spot { background: var(--green); }
        .chart-tooltip-dot.twap { background: var(--blue); }
        .chart-tooltip-key { color: var(--text-muted); flex: 1; }
        .chart-tooltip-val { font-weight: 600; font-variant-numeric: tabular-nums; }

        /* Prediction tooltip */
        .pred-tooltip {
            position: absolute;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0.75rem;
            font-size: var(--font-xs);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s, transform 0.15s;
            z-index: 110;
            min-width: 190px;
            transform: translateY(5px);
        }
        .pred-tooltip.visible { opacity: 1; transform: translateY(0); }
        .pred-tooltip-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        .pred-tooltip-badge {
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 10px;
        }
        .pred-tooltip-title {
            font-weight: 500;
            color: var(--text);
        }
        .pred-tooltip-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.35rem;
        }
        .pred-tooltip-row:last-child { margin-bottom: 0; }
        .pred-tooltip-label { color: var(--text-muted); }
        .pred-tooltip-value { font-weight: 600; font-variant-numeric: tabular-nums; }
        .pred-tooltip-direction {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-weight: 600;
            font-size: 11px;
        }
        .pred-tooltip-direction.up { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
        .pred-tooltip-direction.down { background: rgba(239, 68, 68, 0.15); color: #ef4444; }
        .pred-tooltip-direction.neutral { background: rgba(161, 161, 170, 0.15); color: #a1a1aa; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.5; }
        }

        /* BETS SECTION */
        .bets-section {
            padding: 1.5rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-title {
            font-size: var(--font-lg);
            font-weight: 600;
            margin-bottom: 1.25rem;
            color: var(--text);
        }

        .bets-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 1100px) { .bets-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .bets-grid { grid-template-columns: 1fr; } }

        .bet-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
            transition: box-shadow 0.2s;
        }

        .bet-card:hover {
            box-shadow: 0 0 0 1px var(--green);
        }

        .bet-card.no-market { opacity: 0.5; }

        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
        }

        .bet-type {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 6px;
            border-radius: 3px;
            background: var(--surface-2);
        }

        .bet-type.hourly { color: var(--amber); }
        .bet-type.daily { color: var(--green); }
        .bet-type.weekly { color: var(--blue); }
        .bet-type.extreme { color: var(--red); }

        .bet-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .bet-question {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        /* Gas Comparison Display */
        .gas-compare {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            margin-bottom: 1rem;
        }

        .gas-compare-point { text-align: center; }

        .gas-compare-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .gas-compare-value {
            font-size: var(--font-lg);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }

        .gas-compare-arrow { font-size: 1.25rem; }
        .gas-compare-arrow.up { color: var(--green); }
        .gas-compare-arrow.down { color: var(--red); }

        /* Progress Bar */
        .progress-container { margin-bottom: 1rem; }

        .progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .progress-bar {
            height: 8px;
            background: var(--surface-2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--green), var(--amber), var(--red));
            border-radius: 4px;
            transition: width 0.5s;
        }

        .target-display {
            font-size: var(--font-2xl);
            font-weight: 700;
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--red);
        }

        /* Bet Buttons */
        .bet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .bet-btn {
            padding: 0.75rem 0.5rem;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .bet-btn:hover { background: var(--surface-2); }

        .bet-btn.up { border-color: var(--green); }
        .bet-btn.up:hover { background: var(--green-dim); }
        .bet-btn.down { border-color: var(--red); }
        .bet-btn.down:hover { background: var(--red-dim); }

        .bet-btn-label {
            font-size: var(--font-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            margin-bottom: 0.25rem;
        }

        .bet-btn.up .bet-btn-label { color: var(--green); }
        .bet-btn.down .bet-btn-label { color: var(--red); }

        .bet-btn-odds {
            font-size: var(--font-xl);
            font-weight: 700;
            color: var(--text);
        }

        .bet-btn-price {
            font-size: 10px;
            color: var(--text-dim);
        }

        /* Countdown */
        .bet-countdown {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: var(--font-xs);
            color: var(--text-dim);
            padding-top: 0.75rem;
            border-top: 1px solid var(--border);
        }

        .countdown-value {
            color: var(--text);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        /* Position Display */
        .position-display {
            margin-top: 0.75rem;
            padding: 0.75rem;
            background: var(--surface-2);
            border-radius: var(--radius);
            font-size: var(--font-xs);
        }

        .position-row { display: flex; justify-content: space-between; }

        /* CREATE SECTION */
        .create-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .create-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-top: 1.25rem;
        }

        @media (max-width: 1100px) { .create-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .create-grid { grid-template-columns: 1fr; } }

        .create-card {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.25rem;
        }

        .create-card-title {
            font-size: var(--font-sm);
            font-weight: 600;
            margin-bottom: 0.375rem;
        }

        .create-card-desc {
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .create-input-group { margin-bottom: 1rem; }

        .create-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
            margin-bottom: 0.375rem;
            display: block;
        }

        .create-input {
            width: 100%;
            padding: 0.625rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-sm);
            font-family: inherit;
        }

        .create-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .create-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--green);
            color: var(--bg);
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-xs);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .create-btn:hover { opacity: 0.9; }
        .create-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* TRADE MODAL */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--surface);
            border-radius: var(--radius);
            padding: 1.5rem;
            width: 100%;
            max-width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }

        .modal-title {
            font-size: var(--font-base);
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .modal-close:hover { color: var(--text); }

        /* Orderbook */
        .orderbook {
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            overflow: hidden;
        }
        .orderbook-body {
            max-height: 180px;
            overflow-y: auto;
        }
        .orderbook-side {
            display: flex;
            flex-direction: column;
        }
        .orderbook-side.asks {
            flex-direction: column-reverse;
            border-bottom: 1px solid var(--border);
        }
        .orderbook-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 0.375rem 0.75rem;
            font-size: var(--font-xs);
            font-variant-numeric: tabular-nums;
            cursor: pointer;
            transition: background 0.1s;
        }
        .orderbook-header {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 0.5rem 0.75rem;
            background: var(--surface-2);
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .orderbook-row:hover { background: var(--surface-2); }
        .orderbook-row.ask { color: var(--red); }
        .orderbook-row.bid { color: var(--green); }
        .orderbook-row .price { font-weight: 600; }
        .orderbook-row .size { color: var(--text-muted); }
        .orderbook-row .total { color: var(--text-dim); text-align: right; }
        .orderbook-empty {
            padding: 1rem;
            text-align: center;
            color: var(--text-dim);
            font-size: var(--font-xs);
        }
        .orderbook-spread {
            display: flex;
            justify-content: center;
            padding: 0.375rem;
            background: var(--surface);
            font-size: 10px;
            color: var(--text-dim);
            border-top: 1px solid var(--border);
            border-bottom: 1px solid var(--border);
        }
        .orderbook-row.better-deal { background: var(--green-dim); }
        .orderbook-row.better-deal:hover { background: rgba(34, 197, 94, 0.25); }
        .orderbook-row.better-deal .price { color: var(--blue); }

        .trade-input-group { margin-bottom: 1rem; }

        .trade-label {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: var(--text-muted);
            margin-bottom: 0.375rem;
        }

        .trade-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text);
            font-size: var(--font-base);
            font-family: inherit;
            font-variant-numeric: tabular-nums;
        }

        .trade-input:focus {
            outline: none;
            border-color: var(--green);
        }

        .trade-preview {
            background: var(--surface-2);
            border-radius: var(--radius);
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
        }

        .trade-preview-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.375rem;
        }

        .trade-preview-row:last-child { margin-bottom: 0; }
        .trade-preview-row span:first-child { color: var(--text-muted); }

        .trade-submit {
            width: 100%;
            padding: 0.875rem;
            border: none;
            border-radius: var(--radius);
            font-size: var(--font-sm);
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.15s;
        }

        .trade-submit:hover { opacity: 0.9; }
        .trade-submit.buy-up { background: var(--green); color: var(--bg); }
        .trade-submit.buy-down { background: var(--red); color: var(--text); }
        .trade-submit:disabled { opacity: 0.5; cursor: not-allowed; }

        /* STATUS */
        .status-message {
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: var(--font-xs);
            border-radius: var(--radius);
            display: none;
        }

        .status-message.show { display: block; }
        .status-message.pending { background: rgba(59, 130, 246, 0.15); color: var(--blue); }
        .status-message.success { background: var(--green-dim); color: var(--green); }
        .status-message.error { background: var(--red-dim); color: var(--red); }
        .status-message.info { background: rgba(255, 136, 0, 0.15); color: var(--orange); }

        /* Wallet Options */
        .wallet-option {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            padding: var(--spacing-sm);
            background: var(--gray);
            border: 1px solid var(--light-gray);
            border-radius: var(--radius);
            cursor: pointer;
            margin-bottom: var(--spacing-xs);
            transition: all 0.15s ease;
        }
        .wallet-option:hover { border-color: var(--green); }
        .wallet-option-icon { font-size: 1.5rem; }
        .wallet-option-name { font-weight: 600; }
        .wallet-option.disconnect {
            border-color: var(--red);
            color: var(--red);
            justify-content: center;
        }
        .wallet-option.disconnect:hover {
            background: var(--red);
            color: var(--black);
        }

        /* TOAST NOTIFICATIONS */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 380px;
            pointer-events: none;
        }
        .toast {
            padding: 1rem 1.25rem;
            border-radius: var(--radius);
            background: var(--surface);
            border: 1px solid var(--border);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            font-size: var(--font-sm);
            animation: toast-in 0.3s ease-out;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast.hiding {
            animation: toast-out 0.3s ease-in forwards;
        }
        @keyframes toast-in {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes toast-out {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100%); }
        }
        .toast-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }
        .toast-header .icon {
            font-size: 1.1em;
        }
        .toast.pending .toast-header { color: var(--blue); }
        .toast.success .toast-header { color: var(--green); }
        .toast.error .toast-header { color: var(--red); }
        .toast.info .toast-header { color: var(--yellow); }
        .toast-body {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.4;
        }
        .toast-body a {
            color: var(--blue);
            text-decoration: underline;
        }
        .toast-progress {
            height: 3px;
            background: var(--border);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 0.25rem;
        }
        .toast-progress-bar {
            height: 100%;
            background: var(--blue);
            animation: progress-shrink linear forwards;
        }
        @keyframes progress-shrink {
            from { width: 100%; }
            to { width: 0%; }
        }
        .toast.pending .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border);
            border-top-color: var(--blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* INFO */
        .info-section {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            max-width: 1200px;
            margin: 0 auto;
        }

        .info-text {
            font-size: var(--font-xs);
            color: var(--text-muted);
            line-height: 1.7;
        }

        .info-text strong { color: var(--text); }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            .header { padding: 0.5rem 1rem; }
            .header-center { gap: 1rem; }
            .chart-container { height: 220px; }
            .bets-section, .create-section, .info-section { padding: 1rem; }
            .bet-card, .create-card { padding: 1rem; }
            .modal {
                margin: 0.5rem;
                padding: 1rem;
                max-width: calc(100vw - 1rem);
                max-height: calc(100vh - 1rem);
            }
            .orderbook-body { max-height: 140px; }
            .trade-submit, .create-btn { min-height: 44px; }
            .bet-btn { min-height: 56px; }
        }

        @media (max-width: 480px) {
            .header {
                flex-wrap: wrap;
                justify-content: space-between;
                gap: 0.5rem;
            }
            .header-center {
                order: 3;
                width: 100%;
                justify-content: space-between;
                gap: 0.25rem;
                padding: 0.5rem 0 0;
                border-top: 1px solid var(--border);
                margin-top: 0.25rem;
            }
            .live-stat {
                flex: 1;
                min-width: 0;
            }
            .live-stat-label {
                font-size: 9px;
            }
            .live-stat-value {
                font-size: 11px;
            }
            /* Hide outlook on very small screens, keep essentials */
            .live-stat:nth-child(4) {
                display: none;
            }
            .tagline { display: none; }
            .section-title { font-size: var(--font-base); }
            .logo { font-size: var(--font-base); }

            /* Chart mobile optimizations */
            .chart-section { padding: 0.75rem; }
            .chart-container { height: 200px; border-radius: 8px; }
            .chart-tooltip, .pred-tooltip {
                font-size: 10px;
                padding: 0.4rem;
            }
            .pred-tooltip {
                min-width: 150px;
                max-width: 170px;
                pointer-events: auto; /* Allow tapping on mobile */
            }
            .pred-tooltip-header { gap: 0.25rem; margin-bottom: 0.25rem; padding-bottom: 0.25rem; }
            .pred-tooltip-badge { padding: 0.1rem 0.35rem; font-size: 8px; }
            .pred-tooltip-title { font-size: 10px; }
            .pred-tooltip-direction { padding: 0.15rem 0.35rem; font-size: 9px; }
            .pred-tooltip-row { margin-bottom: 0.15rem; font-size: 9px; }
            .pred-tooltip-label { font-size: 9px; }
            .pred-tooltip-value { font-size: 9px; }
            /* Hide less critical rows on mobile */
            .pred-tooltip-row:nth-child(5),
            .pred-tooltip-row:nth-child(6) { display: none; }
        }

        @media (max-width: 360px) {
            .header-center {
                flex-wrap: wrap;
                gap: 0.25rem 0.5rem;
            }
            .live-stat {
                flex: 0 0 auto;
            }
            .chart-container { height: 180px; }
        }

        @media (max-width: 768px) {
            .tagline { display: none; }
        }

        /* Stats summary responsive */
        .stats-summary { flex-wrap: wrap; }
        @media (max-width: 600px) {
            .stats-summary { gap: 0.75rem !important; }
            .stats-summary > div { flex: 1 1 40%; }
        }

        /* Touch-friendly interactions */
        @media (hover: none) {
            .bet-btn:active, .btn:active { transform: scale(0.98); }
            .orderbook-row:active { background: var(--surface-2); }
        }

        /* Modal mode toggle buttons */
        .mode-toggle {
            display: flex;
            margin-bottom: 1rem;
            background: var(--bg);
            border-radius: var(--radius);
            padding: 3px;
        }
        .mode-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            color: var(--text-muted);
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .mode-toggle-btn.active-buy {
            background: var(--green);
            color: var(--bg);
        }
        .mode-toggle-btn.active-sell {
            background: var(--red);
            color: var(--text);
        }
        .mode-toggle-btn.active-lp {
            background: var(--blue);
            color: var(--text);
        }
        .mode-toggle-btn.active-mint {
            background: var(--amber);
            color: var(--bg);
        }
        .mode-toggle-btn.active-limit {
            background: #8b5cf6;
            color: var(--text);
        }

        /* LP mode toggle */
        .lp-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .lp-toggle-btn {
            flex: 1;
            padding: 0.5rem;
            font-weight: 600;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            font-family: inherit;
            font-size: var(--font-xs);
            transition: all 0.15s;
        }
        .lp-toggle-btn.active-add {
            background: var(--blue);
            color: var(--text);
            border-color: var(--blue);
        }
        .lp-toggle-btn.active-remove {
            background: var(--red);
            color: var(--text);
            border-color: var(--red);
        }
        .slip-btn {
            padding: 4px 8px;
            font-size: var(--font-xs);
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.15s;
        }
        .slip-btn:hover {
            border-color: var(--blue);
            color: var(--text);
        }
        .slip-btn.slip-active {
            background: var(--blue);
            border-color: var(--blue);
            color: var(--text);
        }

        @media (max-width: 768px) {
            .mode-toggle-btn, .lp-toggle-btn { min-height: 40px; }
        }
    </style>
</head>
<body>
    <!-- Toast Notifications Container -->
    <div id="toastContainer" class="toast-container"></div>

    <header class="header">
        <div class="logo">Gas<span>PM</span></div>
        <span class="tagline">Bet Gas on Gas Price</span>
        <div class="header-center">
            <div class="live-stat">
                <div class="live-stat-label">Live</div>
                <div class="live-stat-value green" id="liveGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">TWAP</div>
                <div class="live-stat-value cyan" id="twapGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Min</div>
                <div class="live-stat-value" id="minGas">--</div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Outlook</div>
                <div class="live-stat-value" id="predictionArrows" style="display:flex;gap:0.5rem;font-size:var(--font-sm);">
                    <span id="pred1H" title="Hourly prediction">1H --</span>
                    <span id="pred1D" title="Daily prediction">1D --</span>
                    <span id="pred1W" title="Weekly prediction">1W --</span>
                </div>
            </div>
            <div class="live-stat">
                <div class="live-stat-label">Max</div>
                <div class="live-stat-value" id="maxGas">--</div>
            </div>
        </div>
        <button class="btn" id="connectBtn" onclick="connectWallet()">Connect</button>
    </header>

    <main class="main">
        <!-- Chart Section -->
        <section class="chart-section">
            <div class="chart-container">
                <canvas id="gasChart" class="chart-canvas"></canvas>
                <div class="chart-tooltip" id="chartTooltip">
                    <div class="chart-tooltip-time" id="tooltipTime">--</div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot spot"></span>
                        <span class="chart-tooltip-key">Spot</span>
                        <span class="chart-tooltip-val" id="tooltipSpot">--</span>
                    </div>
                    <div class="chart-tooltip-row">
                        <span class="chart-tooltip-dot twap"></span>
                        <span class="chart-tooltip-key">TWAP</span>
                        <span class="chart-tooltip-val" id="tooltipTwap">--</span>
                    </div>
                </div>
                <div class="pred-tooltip" id="predTooltip">
                    <div class="pred-tooltip-header">
                        <span class="pred-tooltip-badge" id="predBadge">1H</span>
                        <span class="pred-tooltip-title" id="predTitle">Hourly Market</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Predicted TWAP</span>
                        <span class="pred-tooltip-value" id="predTwap">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Direction</span>
                        <span class="pred-tooltip-direction up" id="predDirection">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Market TVL</span>
                        <span class="pred-tooltip-value" id="predTvl">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">Closes in</span>
                        <span class="pred-tooltip-value" id="predCloses">--</span>
                    </div>
                    <div class="pred-tooltip-row" style="margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);">
                        <span class="pred-tooltip-label">Implied remaining avg</span>
                        <span class="pred-tooltip-value" id="predImpliedAvg">--</span>
                    </div>
                    <div class="pred-tooltip-row">
                        <span class="pred-tooltip-label">vs Current spot</span>
                        <span class="pred-tooltip-value" id="predVsSpot">--</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Bets Section -->
        <section class="bets-section">
            <h2 class="section-title">Active Bets</h2>
            <div class="stats-summary" style="display:flex;justify-content:center;gap:2rem;padding:0.875rem;margin-bottom:1rem;background:var(--surface);border-radius:var(--radius);">
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">TVL</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--blue);" id="totalPoolTvl">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Orderbook</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--amber);" id="totalOrderbookLiq">--</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Markets</div>
                    <div style="font-size:var(--font-lg);font-weight:600;color:var(--green);" id="activeMarketsCount">0</div>
                </div>
                <div style="text-align:center;">
                    <div style="font-size:var(--font-xs);color:var(--text-dim);">Resolved</div>
                    <a href="#" onclick="toggleResolved();return false;" id="resolvedMarketsCount" title="Click to view resolved markets" style="font-size:var(--font-lg);font-weight:600;color:var(--text-muted);text-decoration:none;cursor:pointer;transition:color 0.15s;" onmouseover="this.style.color='var(--green)'" onmouseout="this.style.color='var(--text-muted)'">0 â–¾</a>
                </div>
            </div>
            <div class="bets-grid">
                <!-- Hourly Card -->
                <div class="bet-card" id="hourlyCard">
                    <div class="bet-header">
                        <span class="bet-type hourly">Hourly</span>
                    </div>
                    <div class="bet-title">This Hour's Gas</div>
                    <div class="bet-question">Will gas go up or down this hour?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="hourlyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="hourlyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Now</div>
                            <div class="gas-compare-value" id="hourlyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('hourly', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="hourlyUpOdds">--</div>
                            <div class="bet-btn-price" id="hourlyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('hourly', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="hourlyDownOdds">--</div>
                            <div class="bet-btn-price" id="hourlyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends top of hour UTC</span>
                        <span class="countdown-value" id="hourlyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="hourlyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="hourlyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="hourlyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="hourlyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="hourlyDownBal">0</span></div>
                    </div>
                    <button id="hourlyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('hourly')">Resolve Market</button>
                </div>

                <!-- Daily Card -->
                <div class="bet-card" id="dailyCard">
                    <div class="bet-header">
                        <span class="bet-type daily">Daily</span>
                    </div>
                    <div class="bet-title">Today's Gas</div>
                    <div class="bet-question">Will gas go up or down today?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="dailyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="dailyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Now</div>
                            <div class="gas-compare-value" id="dailyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('daily', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="dailyUpOdds">--</div>
                            <div class="bet-btn-price" id="dailyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('daily', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="dailyDownOdds">--</div>
                            <div class="bet-btn-price" id="dailyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends midnight UTC</span>
                        <span class="countdown-value" id="dailyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="dailyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="dailyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="dailyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="dailyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="dailyDownBal">0</span></div>
                    </div>
                    <button id="dailyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('daily')">Resolve Market</button>
                </div>

                <!-- Weekly Card -->
                <div class="bet-card" id="weeklyCard">
                    <div class="bet-header">
                        <span class="bet-type weekly">Weekly</span>
                    </div>
                    <div class="bet-title">This Week's Gas</div>
                    <div class="bet-question">Will gas go up or down this week?</div>
                    <div class="gas-compare">
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Start</div>
                            <div class="gas-compare-value" id="weeklyStart">--</div>
                        </div>
                        <div class="gas-compare-arrow" id="weeklyArrow">--</div>
                        <div class="gas-compare-point">
                            <div class="gas-compare-label">Now</div>
                            <div class="gas-compare-value" id="weeklyNow">--</div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('weekly', true)">
                            <div class="bet-btn-label">Up</div>
                            <div class="bet-btn-odds" id="weeklyUpOdds">--</div>
                            <div class="bet-btn-price" id="weeklyUpPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('weekly', false)">
                            <div class="bet-btn-label">Down</div>
                            <div class="bet-btn-odds" id="weeklyDownOdds">--</div>
                            <div class="bet-btn-price" id="weeklyDownPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Ends Sunday UTC</span>
                        <span class="countdown-value" id="weeklyCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="weeklyPoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="weeklyOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="weeklyPosition" style="display:none;">
                        <div class="position-row"><span>Your UP</span><span id="weeklyUpBal">0</span></div>
                        <div class="position-row"><span>Your DOWN</span><span id="weeklyDownBal">0</span></div>
                    </div>
                    <button id="weeklyResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('weekly')">Resolve Market</button>
                </div>

                <!-- Extreme Card -->
                <div class="bet-card" id="extremeCard">
                    <div class="bet-header">
                        <span class="bet-type extreme">Extreme</span>
                    </div>
                    <div class="bet-title">100 Gwei Challenge</div>
                    <div class="bet-question">Will gas hit 100 gwei?</div>
                    <div class="target-display">100 gwei</div>
                    <div class="progress-container">
                        <div class="progress-labels">
                            <span>Max seen: <strong id="extremeMax">--</strong></span>
                            <span id="extremePercent">--%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="extremeProgress" style="width:0%"></div>
                        </div>
                    </div>
                    <div class="bet-buttons">
                        <button class="bet-btn up" onclick="openTrade('extreme', true)">
                            <div class="bet-btn-label">Yes</div>
                            <div class="bet-btn-odds" id="extremeYesOdds">--</div>
                            <div class="bet-btn-price" id="extremeYesPrice">--</div>
                        </button>
                        <button class="bet-btn down" onclick="openTrade('extreme', false)">
                            <div class="bet-btn-label">No</div>
                            <div class="bet-btn-odds" id="extremeNoOdds">--</div>
                            <div class="bet-btn-price" id="extremeNoPrice">--</div>
                        </button>
                    </div>
                    <div class="bet-countdown">
                        <span>Resolves early if touched!</span>
                        <span class="countdown-value" id="extremeCountdown">--</span>
                    </div>
                    <div class="liquidity-stats" style="display:flex;justify-content:space-between;padding:0.5rem 0;border-top:1px solid var(--border);margin-top:0.5rem;font-size:var(--font-xs);color:var(--text-muted);">
                        <span>TVL: <span id="extremePoolTvl" style="color:var(--blue);">--</span></span>
                        <span>Orders: <span id="extremeOrderbook" style="color:var(--amber);">--</span></span>
                    </div>
                    <div class="position-display" id="extremePosition" style="display:none;">
                        <div class="position-row"><span>Your YES</span><span id="extremeYesBal">0</span></div>
                        <div class="position-row"><span>Your NO</span><span id="extremeNoBal">0</span></div>
                    </div>
                    <button id="extremeResolveBtn" class="resolve-btn" style="display:none;width:100%;margin-top:0.5rem;padding:0.75rem;background:var(--amber);color:var(--black);border:none;border-radius:var(--radius);font-weight:600;cursor:pointer;" onclick="resolveMarket('extreme')">Resolve Market</button>
                </div>
            </div>
        </section>

        <!-- Create Section (Owner Only) -->
        <section class="create-section" id="createSection" style="display:none;">
            <h2 class="section-title">Create Markets</h2>
            <p style="color:var(--text-muted);font-size:var(--font-xs);margin-bottom:1rem;">
                Create new betting markets. Requires initial liquidity.
            </p>
            <div class="create-grid">
                <!-- Hourly -->
                <div class="create-card" id="createHourlyCard">
                    <div class="create-card-title">Hourly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this hour? Resolves at top of hour UTC.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="hourlySeed" value="0.01" step="0.001" min="0.001">
                    </div>
                    <button class="create-btn" onclick="createHourly()">Create Hourly</button>
                </div>

                <!-- Daily -->
                <div class="create-card" id="createDailyCard">
                    <div class="create-card-title">Daily Comparison</div>
                    <div class="create-card-desc">Will gas go up or down today? Resolves at midnight UTC.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="dailySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createDaily()">Create Daily</button>
                </div>

                <!-- Weekly -->
                <div class="create-card" id="createWeeklyCard">
                    <div class="create-card-title">Weekly Comparison</div>
                    <div class="create-card-desc">Will gas go up or down this week? Resolves Sunday midnight.</div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="weeklySeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createWeekly()">Create Weekly</button>
                </div>

                <!-- Extreme -->
                <div class="create-card" id="createExtremeCard">
                    <div class="create-card-title">100 Gwei Challenge</div>
                    <div class="create-card-desc">Will gas hit 100 gwei before end of 2025? Resolves early if hit.</div>
                    <div class="create-input-group">
                        <label class="create-label">Deadline</label>
                        <div style="color:var(--green);font-weight:600;">Dec 31, 2025 23:59:59 UTC</div>
                    </div>
                    <div class="create-input-group">
                        <label class="create-label">Seed Liquidity (ETH)</label>
                        <input type="number" class="create-input" id="extremeSeed" value="0.1" step="0.01" min="0.01">
                    </div>
                    <button class="create-btn" onclick="createExtreme()">Create Challenge</button>
                </div>
            </div>
            <p id="allMarketsActive" style="display:none;color:var(--green);text-align:center;margin-top:1.5rem;">
                âœ“ All market types are currently active
            </p>
        </section>

        <!-- Info -->
        <section class="info-section">
            <h2 class="section-title">How It Works</h2>
            <div class="info-text">
                <strong>Hourly, Daily &amp; Weekly:</strong> Bet on whether the gas TWAP (time-weighted average) will be higher when the market closes compared to when it was created. UP wins if TWAP increased, DOWN wins if it stayed the same or decreased.<br><br>
                <strong>100 Gwei Challenge:</strong> Bet on whether gas will spike to 100 gwei before the deadline. If it touches 100 gwei at any point, YES wins and the market can resolve early. If the deadline passes without reaching 100 gwei, NO wins.<br><br>
                <strong>Trading:</strong> Prices reflect implied probability. If UP shows 30%, it costs ~0.30 ETH to win 1 ETH if UP wins. Losing shares pay nothing. Trade anytime or hold to resolution.
            </div>
        </section>

        <!-- Resolved Markets (hidden by default) -->
        <section class="bets-section" id="resolvedSection" style="display:none;">
            <h2 class="section-title" style="display:flex;justify-content:space-between;align-items:center;">
                Resolved Markets
                <a href="#" onclick="toggleResolved();return false;" style="font-size:var(--font-xs);color:var(--text-muted);text-decoration:none;">Hide</a>
            </h2>
            <div class="bets-grid" id="resolvedGrid"></div>
        </section>

        <!-- Footer -->
        <footer style="text-align:center;padding:2rem 0;margin-top:1rem;border-top:1px solid var(--border);color:var(--text-dim);font-size:var(--font-xs);">
            <div style="display:flex;justify-content:center;align-items:center;gap:1.5rem;">
                <a href="https://zamm.finance/" target="_blank" style="display:flex;align-items:center;gap:0.5rem;color:var(--text-muted);text-decoration:none;">
                    <img src="https://content.wrappr.wtf/ipfs/bafybeibuct6mftnmgzkbn4tq47elpokbkahkjxq7z6qceptlcsvpxletou" style="width:20px;height:20px;border-radius:4px;">
                    Built on zAMM
                </a>
                <a href="https://github.com/zammdefi/pm" target="_blank" style="color:var(--text-muted);text-decoration:none;">Code</a>
            </div>
        </footer>
    </main>

    <!-- Wallet Modal -->
    <div class="modal-overlay" id="walletModal">
        <div class="modal" style="max-width:360px;">
            <div class="modal-header">
                <div class="modal-title">Connect Wallet</div>
                <button class="modal-close" onclick="closeWalletModal()">&times;</button>
            </div>
            <div class="modal-body" id="walletOptions"></div>
        </div>
    </div>

    <!-- Trade Modal -->
    <div class="modal-overlay" id="tradeModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title" id="tradeTitle">Trade Shares</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="status-message" id="tradeStatus"></div>
            <!-- Buy/Sell/LP Toggle -->
            <div class="mode-toggle">
                <button id="buyModeBtn" class="mode-toggle-btn active-buy" onclick="setTradeMode('buy')">Buy</button>
                <button id="sellModeBtn" class="mode-toggle-btn" onclick="setTradeMode('sell')">Sell</button>
                <button id="limitModeBtn" class="mode-toggle-btn" onclick="setTradeMode('limit')">Limit</button>
                <button id="lpModeBtn" class="mode-toggle-btn" onclick="setTradeMode('lp')">LP</button>
                <button id="mintModeBtn" class="mode-toggle-btn" onclick="setTradeMode('mint')">Mint</button>
            </div>
            <!-- Position Display -->
            <div id="tradePositionDisplay" style="background:var(--surface-2);padding:0.75rem;margin-bottom:1rem;font-size:var(--font-xs);border-radius:var(--radius);">
                <div style="color:var(--text-dim);margin-bottom:4px;">Your Position</div>
                <div style="display:flex;gap:1.5rem;">
                    <span style="color:var(--green);">YES: <span id="tradeModalYes">0</span></span>
                    <span style="color:var(--red);">NO: <span id="tradeModalNo">0</span></span>
                    <span style="color:var(--blue);">LP: <span id="tradeModalLP">0</span></span>
                </div>
            </div>
            <!-- Orderbook -->
            <div class="orderbook" id="orderbookContainer">
                <div class="orderbook-header">
                    <span>Price</span>
                    <span>Size</span>
                    <span>Total</span>
                </div>
                <div class="orderbook-body">
                    <div class="orderbook-side asks" id="orderbookAsks">
                        <!-- Asks (sell orders) populate here -->
                    </div>
                    <div class="orderbook-spread" id="orderbookSpread">
                        Spread: --
                    </div>
                    <div class="orderbook-side bids" id="orderbookBids">
                        <!-- Bids (buy orders) populate here -->
                    </div>
                </div>
                <div class="orderbook-empty" id="orderbookEmpty" style="display:none;">
                    No limit orders yet
                </div>
            </div>
            <div class="trade-input-group">
                <div class="trade-label">
                    <span id="tradeInputLabel">Amount (ETH)</span>
                    <span>Balance: <span id="tradeBalance">--</span> <span id="tradeBalanceUnit">ETH</span></span>
                </div>
                <div style="display:flex;background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;">
                    <input type="number" class="trade-input" id="tradeAmount" placeholder="0.01" step="0.001" min="0" oninput="currentTradeMode === 'lp' ? updateLpPreview() : (currentTradeMode === 'mint' ? updateMintPreview() : updatePreview())" style="flex:1;background:transparent;border:none;border-radius:0;">
                    <button onclick="setMaxTrade()" style="padding:0.5rem 1rem;background:var(--surface-2);border:none;border-left:1px solid var(--border);color:var(--green);font-weight:600;cursor:pointer;font-size:var(--font-xs);">MAX</button>
                </div>
            </div>
            <!-- Trade Section (Buy/Sell) -->
            <div id="tradeSection">
                <!-- Slippage Settings -->
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;padding:0.5rem;background:var(--surface-2);border-radius:var(--radius);">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);">Slippage</span>
                    <div style="display:flex;gap:4px;">
                        <button onclick="setSlippage(0.5)" id="slip05" class="slip-btn slip-active">0.5%</button>
                        <button onclick="setSlippage(1)" id="slip1" class="slip-btn">1%</button>
                        <button onclick="setSlippage(2)" id="slip2" class="slip-btn">2%</button>
                        <input type="number" id="slipCustom" placeholder="Custom" step="0.1" min="0.1" max="50" style="width:60px;padding:4px 6px;font-size:var(--font-xs);background:var(--bg);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);" onchange="setSlippage(parseFloat(this.value))">
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="previewSharesLabel">Est. shares</span>
                        <span id="previewShares">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Price per share</span>
                        <span id="previewPrice">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="previewPayoutLabel">Potential payout</span>
                        <span id="previewPayout">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Route</span>
                        <span id="previewRoute" style="color:var(--blue);">AMM</span>
                    </div>
                    <div id="previewBreakdown" class="trade-preview-row" style="display:none;flex-direction:column;align-items:flex-start;gap:2px;padding-top:0.5rem;border-top:1px solid var(--border);margin-top:0.5rem;">
                        <span style="font-size:var(--font-xs);color:var(--text-dim);width:100%;">Execution breakdown:</span>
                        <div id="breakdownDetails" style="font-size:var(--font-xs);color:var(--text-muted);width:100%;"></div>
                    </div>
                    <div id="previewSavings" class="trade-preview-row" style="display:none;">
                        <span style="color:var(--text-dim);">vs pure AMM</span>
                        <span id="savingsAmount" style="color:var(--green);">--</span>
                    </div>
                </div>
                <button class="trade-submit" id="tradeSubmit" onclick="executeTrade()">Buy</button>
            </div>
            <!-- LP Section -->
            <div id="lpSection" style="display:none;">
                <div class="lp-toggle">
                    <button id="addLpBtn" class="lp-toggle-btn active-add" onclick="setLpMode('add')">Deposit</button>
                    <button id="removeLpBtn" class="lp-toggle-btn" onclick="setLpMode('remove')">Withdraw</button>
                </div>
                <div id="lpExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.
                </div>
                <!-- Your Position Summary -->
                <div id="lpPositionSummary" style="background:var(--surface-2);padding:0.75rem;margin-bottom:0.75rem;border-radius:var(--radius);font-size:var(--font-xs);">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span style="color:var(--text-dim);">Your LP Position</span>
                        <span id="lpPositionValue" style="color:var(--text);">-- ETH</span>
                    </div>
                    <div style="display:flex;justify-content:space-between;">
                        <span style="color:var(--text-dim);">Pool Share</span>
                        <span id="lpCurrentShare" style="color:var(--text-muted);">--%</span>
                    </div>
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>Pool TVL</span>
                        <span id="lpPoolReserves">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Pool Price</span>
                        <span id="lpPoolPrice">-- (--% YES)</span>
                    </div>
                    <div class="trade-preview-row">
                        <span id="lpPreviewLabel">You receive</span>
                        <span id="lpPreview">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>New pool share</span>
                        <span id="lpPoolShare">--%</span>
                    </div>
                </div>
                <div id="lpWarning" style="display:none;font-size:var(--font-xs);color:var(--amber);padding:0.5rem;background:rgba(245,158,11,0.1);border-radius:var(--radius);margin-bottom:0.75rem;">
                </div>
                <button class="trade-submit" id="lpSubmit" style="background:var(--blue);" onclick="executeLp()">Deposit Liquidity</button>
            </div>
            <!-- Mint & List Section -->
            <div id="mintSection" style="display:none;">
                <div id="mintExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Mint YES + NO shares from ETH, keep one side and list the other at your price. Useful for low liquidity markets.
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="keepYesBtn" class="lp-toggle-btn active-add" onclick="setMintKeep(true)">Keep YES</button>
                    <button id="keepNoBtn" class="lp-toggle-btn" onclick="setMintKeep(false)">Keep NO</button>
                </div>
                <div style="margin-bottom:1rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Sell price (ETH per share)</label>
                    <input type="number" id="mintLimitPrice" placeholder="0.40" step="0.01" min="0.01" max="0.99"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateMintPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span>You deposit</span>
                        <span id="mintDeposit">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You receive</span>
                        <span id="mintReceive">-- YES + -- NO</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You keep</span>
                        <span id="mintKeep">-- YES</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>You list for sale</span>
                        <span id="mintList">-- NO @ -- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>If order fills</span>
                        <span id="mintProfit" style="color:var(--green);">Net cost: -- ETH</span>
                    </div>
                </div>
                <button class="trade-submit" id="mintSubmit" style="background:var(--amber);color:var(--bg);" onclick="executeMintAndList()">Mint & List</button>
            </div>
            <!-- Limit Order Section -->
            <div id="limitSection" style="display:none;">
                <div id="limitExplainer" style="font-size:var(--font-xs);color:var(--text-muted);margin-bottom:0.75rem;padding:0.5rem;background:var(--bg);border-radius:var(--radius);">
                    Place a limit order at your price. Order stays open until filled or market closes.
                </div>
                <div class="lp-toggle" style="margin-bottom:0.75rem;">
                    <button id="limitBuyBtn" class="lp-toggle-btn active-add" onclick="setLimitSide('buy')">Buy Order</button>
                    <button id="limitSellBtn" class="lp-toggle-btn" onclick="setLimitSide('sell')">Sell Order</button>
                </div>
                <div style="margin-bottom:0.75rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Limit Price (ETH per share)</label>
                    <input type="number" id="limitPrice" placeholder="0.50" step="0.01" min="0.01" max="0.99"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateLimitPreview()">
                </div>
                <div style="margin-bottom:0.75rem;">
                    <label style="font-size:var(--font-xs);color:var(--text-muted);display:block;margin-bottom:4px;">Shares</label>
                    <input type="number" id="limitShares" placeholder="1.0" step="0.1" min="0.01"
                        style="width:100%;padding:0.75rem;background:var(--surface-2);border:1px solid var(--border);border-radius:var(--radius);color:var(--text);font-size:var(--font-base);"
                        oninput="updateLimitPreview()">
                </div>
                <div class="trade-preview">
                    <div class="trade-preview-row">
                        <span id="limitCostLabel">You escrow</span>
                        <span id="limitCost">-- ETH</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>If filled, you get</span>
                        <span id="limitReceive">-- shares</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>vs AMM price</span>
                        <span id="limitVsAmm">--</span>
                    </div>
                    <div class="trade-preview-row">
                        <span>Expires</span>
                        <span id="limitExpires">Market close</span>
                    </div>
                </div>
                <button class="trade-submit" id="limitSubmit" style="background:#8b5cf6;" onclick="executeLimitOrder()">Place Buy Order</button>
            </div>
            <!-- Your Orders Section -->
            <div id="yourOrdersSection" style="margin-top:1rem;padding-top:1rem;border-top:1px solid var(--border);display:none;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
                    <span style="font-size:var(--font-xs);color:var(--text-dim);font-weight:600;">YOUR OPEN ORDERS</span>
                    <button onclick="refreshUserOrders()" style="font-size:var(--font-xs);padding:2px 8px;background:transparent;border:1px solid var(--border);border-radius:var(--radius);color:var(--text-muted);cursor:pointer;">â†»</button>
                </div>
                <div id="yourOrdersList" style="font-size:var(--font-xs);">
                    <!-- Orders populate here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======================== CONSTANTS ========================
        const GASPM_ADDRESS = '0x0000000000ee3d4294438093EaA34308f47Bc0b4';
        const PAMM_ADDRESS = '0x000000000044bfe6c2BBFeD8862973E0612f07C0';
        const PMROUTER_ADDRESS = '0x000000000055ff709f26efb262fba8b0ae8c35dc';
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        const FEE_TIER = 30n; // 30 bps = 0.30% fee

        // Public RPC fallbacks
        const RPC_ENDPOINTS = [
            'https://1rpc.io/eth',
            'https://eth.llamarpc.com',
            'https://ethereum.publicnode.com'
        ];

        async function getRpcProvider() {
            for (const rpc of RPC_ENDPOINTS) {
                try {
                    const p = new ethers.JsonRpcProvider(rpc);
                    await p.getBlockNumber(); // test connection
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc} failed, trying next...`);
                }
            }
            throw new Error('All RPC endpoints failed');
        }

        const RESOLVER_ADDRESS = '0x00000000002205020E387b6a378c05639047BcFB';
        const RESOLVER_ABI = [
            'function resolveMarket(uint256 marketId) public'
        ];

        const GASPM_ABI = [
            'function baseFeeAverage() public view returns (uint256)',
            'function baseFeeMax() public view returns (uint256)',
            'function baseFeeMin() public view returns (uint256)',
            'function startTime() public view returns (uint64)',
            'function baseFeeMaxSince(uint256 marketId) public view returns (uint256)',
            'function comparisonStartValue(uint256 marketId) public view returns (uint256)',
            'function marketCount() public view returns (uint256)',
            'function getMarkets(uint256 start, uint256 count) public view returns (uint256[])',
            'function getMarketInfos(uint256 start, uint256 count) public view returns (tuple(uint256 marketId, uint64 close, bool resolved, bool outcome, uint256 currentValue, bool conditionMet, bool ready)[])',
            'function observationCount() public view returns (uint256)',
            'function getObservations(uint256 start, uint256 count) public view returns (tuple(uint64 timestamp, uint64 baseFee, uint128 cumulativeBaseFee)[])',
            'function createComparisonMarket(address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function createWindowPeakMarket(uint256 threshold, address collateral, uint64 close, uint256 collateralIn, uint256 feeOrHook, uint256 minLiquidity, address lpRecipient) public payable returns (uint256)',
            'function owner() public view returns (address)'
        ];

        const PAMM_ABI = [
            'function getMarket(uint256 marketId) public view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
            'function getPoolState(uint256 marketId, uint256 feeOrHook) public view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
            'function poolKey(uint256 marketId, uint256 feeOrHook) public view returns (tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook))',
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function getNoId(uint256 marketId) public pure returns (uint256)',
            'function claim(uint256 marketId, address to) public returns (uint256 shares, uint256 payout)',
            'function claimMany(uint256[] marketIds, address to) public returns (uint256 totalPayout)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)',
            'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) public payable returns (uint256 shares, uint256 liquidity)',
            'function removeLiquidityToCollateral(uint256 marketId, uint256 feeOrHook, uint256 liquidity, uint256 amount0Min, uint256 amount1Min, uint256 minCollateralOut, address to, uint256 deadline) public returns (uint256 collateralOut, uint256 leftoverYes, uint256 leftoverNo)',
            'function multicall(bytes[] data) public returns (bytes[])'
        ];

        const ZAMM_ADDRESS = '0x000000000000040470635EB91b7CE4D132D616eD';
        const ZAMM_ABI = [
            'function balanceOf(address owner, uint256 id) public view returns (uint256)',
            'function isOperator(address owner, address operator) public view returns (bool)',
            'function setOperator(address operator, bool approved) public returns (bool)'
        ];

        const PMROUTER_ABI = [
            'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
            'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)',
            'function claim(uint256 marketId, address to) returns (uint256 payout)',
            'function getOrderbook(uint256 marketId, bool isYes, uint256 depth) view returns (bytes32[] bidHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] bidOrders, bytes32[] askHashes, tuple(address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)[] askOrders)',
            'function fillOrder(bytes32 orderHash, uint96 sharesToFill, address to) payable returns (uint96 sharesFilled, uint96 collateralFilled)',
            'function fillOrdersThenSwap(uint256 marketId, bool isYes, bool isBuy, uint256 totalAmount, uint256 minOutput, bytes32[] orderHashes, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256 totalOutput)',
            'function split(uint256 marketId, uint256 amount, address to) payable',
            'function placeOrder(uint256 marketId, bool isYes, bool isBuy, uint96 shares, uint96 collateral, uint56 deadline, bool partialFill) payable returns (bytes32)',
            'function multicall(bytes[] data) payable returns (bytes[])',
            'function cancelOrder(bytes32 orderHash)',
            'function getUserOrderCount(address user) view returns (uint256)',
            'function getUserOrderHashes(address user, uint256 offset, uint256 limit) view returns (bytes32[])',
            'function orders(bytes32 orderHash) view returns (address owner, uint56 deadline, bool isYes, bool isBuy, bool partialFill, uint96 shares, uint96 collateral, uint256 marketId)'
        ];

        const MULTICALL3_ABI = [
            'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
        ];

        // ======================== STATE ========================
        let provider = null;
        let signer = null;
        let connectedAddress = null;
        let isOwner = false;
        let connectedWalletProvider = null;
        let walletConnectProvider = null;
        let isConnecting = false;
        const eip6963Providers = new Map();

        let markets = { hourly: null, daily: null, weekly: null, extreme: null };
        let resolvedMarkets = [];
        let currentTrade = { type: null, isYes: true, marketId: null };
        let currentTradeMode = 'buy'; // 'buy' or 'sell'
        let currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
        let slippageTolerance = 0.5; // 0.5% default slippage tolerance

        // Chart data (like GasPM.html)
        let chartDataPoints = [];   // Historical baseFee in gwei
        let chartTimestamps = [];   // Timestamps for each observation
        let chartCumulatives = [];  // Cumulative base fee for rolling TWAP
        let chartState = {};
        let cachedGasData = { twap: 0, current: 0, startTime: 0 };
        let lastLoadedObsCount = 0; // Track for incremental loading
        let lastCanvasSize = { width: 0, height: 0 }; // Track canvas size to avoid unnecessary resizes
        let predictionMarkerPositions = []; // Store prediction marker hit areas for hover detection
        let hoveredPrediction = null; // Currently hovered prediction market type
        let priceChangeBadgeArea = null; // Store price change badge hit area for hover

        // ======================== DOM CACHE ========================
        // Cache frequently accessed DOM elements to avoid repeated lookups
        const DOM = {};
        function initDOMCache() {
            DOM.liveGas = document.getElementById('liveGas');
            DOM.twapGas = document.getElementById('twapGas');
            DOM.minGas = document.getElementById('minGas');
            DOM.maxGas = document.getElementById('maxGas');
            DOM.extremeMax = document.getElementById('extremeMax');
            DOM.extremeProgress = document.getElementById('extremeProgress');
            DOM.extremePercent = document.getElementById('extremePercent');
            DOM.hourlyCountdown = document.getElementById('hourlyCountdown');
            DOM.dailyCountdown = document.getElementById('dailyCountdown');
            DOM.weeklyCountdown = document.getElementById('weeklyCountdown');
            DOM.extremeCountdown = document.getElementById('extremeCountdown');
            DOM.totalPoolTvl = document.getElementById('totalPoolTvl');
            DOM.totalOrderbookLiq = document.getElementById('totalOrderbookLiq');
            DOM.activeMarketsCount = document.getElementById('activeMarketsCount');
            DOM.gasChart = document.getElementById('gasChart');
            DOM.chartTooltip = document.getElementById('chartTooltip');
            DOM.predTooltip = document.getElementById('predTooltip');
            DOM.connectBtn = document.getElementById('connectBtn');
            DOM.createSection = document.getElementById('createSection');
        }

        // ======================== INIT ========================
        async function init() {
            initDOMCache();
            initEIP6963();

            // Auto-reconnect wallet if previously connected
            const savedWallet = localStorage.getItem('gaspm_wallet');
            if (savedWallet) {
                // Small delay to let EIP-6963 providers announce themselves
                setTimeout(async () => {
                    try {
                        await connectWithWallet(savedWallet);
                    } catch (e) {
                        console.warn('Auto-reconnect failed:', e);
                        localStorage.removeItem('gaspm_wallet');
                    }
                }, 100);
            }

            await loadData();
            updateCountdowns();
            setInterval(updateCountdowns, 1000);
            setInterval(loadData, 60000);
            setupChart();
            startPulseAnimation();
        }

        function startPulseAnimation() {
            // Only animate pulse for small datasets; skip for large ones (too expensive)
            let lastPulseTime = 0;
            const pulseInterval = 66; // ~15fps for pulse animation

            function animatePulse(timestamp) {
                if (timestamp - lastPulseTime >= pulseInterval) {
                    if (chartDataPoints.length > 0 && chartDataPoints.length <= 200 && cachedGasData.current && hoverIndex < 0) {
                        drawChart(cachedGasData);
                    }
                    lastPulseTime = timestamp;
                }
                requestAnimationFrame(animatePulse);
            }
            requestAnimationFrame(animatePulse);
        }

        // ======================== WALLET ========================
        const WALLET_CONFIG = {
            metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => window.ethereum?.isMetaMask, getProvider: () => window.ethereum },
            coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => window.ethereum?.isCoinbaseWallet, getProvider: () => window.ethereum },
            rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => window.ethereum?.isRabby, getProvider: () => window.ethereum },
            rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => window.ethereum?.isRainbow, getProvider: () => window.ethereum },
            walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
        };

        function initEIP6963() {
            if (typeof window === 'undefined') return;
            window.addEventListener('eip6963:announceProvider', (event) => {
                const { info, provider } = event.detail;
                eip6963Providers.set(info.uuid, { info, provider });
            });
            window.dispatchEvent(new Event('eip6963:requestProvider'));
        }

        function detectWallets() {
            const detected = [];
            const seenNames = new Set();

            for (const [key, config] of Object.entries(WALLET_CONFIG)) {
                if (key === 'walletconnect') continue;
                if (config.detect && config.detect()) {
                    detected.push({ key, ...config });
                    seenNames.add(config.name.toLowerCase());
                }
            }

            for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
                if (!seenNames.has(info.name.toLowerCase())) {
                    // Sanitize wallet name to prevent XSS
                    const safeName = (info.name || 'Unknown').replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c]));
                    // Only allow data: or https: URLs for icons
                    const iconUrl = info.icon && (info.icon.startsWith('data:') || info.icon.startsWith('https://')) ? info.icon : null;
                    detected.push({
                        key: `eip6963_${uuid}`,
                        name: safeName,
                        icon: iconUrl ? `<img src="${iconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'ðŸ”Œ',
                        getProvider: () => provider
                    });
                    seenNames.add(info.name.toLowerCase());
                }
            }

            if (detected.length === 0 && window.ethereum) {
                detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'ðŸ”—', getProvider: () => window.ethereum });
            }

            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            if (wcModule?.EthereumProvider) {
                detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'ðŸ“±', isWalletConnect: true });
            }

            return detected;
        }

        function showWalletModal() {
            const wallets = detectWallets();
            const container = document.getElementById('walletOptions');

            if (connectedAddress) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: var(--gray); border-radius: var(--radius); margin-bottom: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Connected</div>
                        <div style="font-size: 0.9rem; word-break: break-all; color: var(--green);">${connectedAddress}</div>
                    </div>
                    <div class="wallet-option disconnect" onclick="disconnectWallet()">
                        <span class="wallet-option-name">Disconnect</span>
                    </div>
                `;
            } else {
                container.innerHTML = wallets.length > 0 ? wallets.map(w => `
                    <div class="wallet-option" onclick="connectWithWallet('${w.key}')">
                        <span class="wallet-option-icon">${w.icon}</span>
                        <span class="wallet-option-name">${w.name}</span>
                    </div>
                `).join('') : '<div style="padding:1rem;text-align:center;color:var(--text-muted);">No wallets detected. Install MetaMask or use WalletConnect.</div>';
            }

            document.getElementById('walletModal').classList.add('active');
        }

        function closeWalletModal() {
            document.getElementById('walletModal').classList.remove('active');
        }

        async function connectWallet() {
            showWalletModal();
        }

        async function connectWithWallet(walletKey) {
            if (isConnecting) return;
            isConnecting = true;

            try {
                closeWalletModal();
                let walletProvider;

                if (walletKey === 'walletconnect') {
                    const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
                    const WCProvider = wcModule?.EthereumProvider;

                    if (!WCProvider?.init) throw new Error('WalletConnect not available');

                    if (walletConnectProvider) {
                        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
                        walletConnectProvider = null;
                    }

                    walletConnectProvider = await WCProvider.init({
                        projectId: '1e8390ef1c1d8a185e035912a1409749',
                        chains: [1],
                        showQrModal: true,
                        rpcMap: { 1: 'https://1rpc.io/eth' },
                        metadata: {
                            name: 'GasPM',
                            description: 'Ethereum Gas Prediction Markets',
                            url: window.location.origin,
                            icons: []
                        }
                    });

                    await walletConnectProvider.enable();
                    walletProvider = walletConnectProvider;
                } else if (walletKey.startsWith('eip6963_')) {
                    const uuid = walletKey.replace('eip6963_', '');
                    walletProvider = eip6963Providers.get(uuid)?.provider;
                } else {
                    walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
                }

                if (!walletProvider) throw new Error('Wallet not found');

                if (walletKey !== 'walletconnect') {
                    await walletProvider.request({ method: 'eth_requestAccounts' });
                }

                provider = new ethers.BrowserProvider(walletProvider);
                signer = await provider.getSigner();
                connectedAddress = await signer.getAddress();
                connectedWalletProvider = walletProvider;

                DOM.connectBtn.textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
                DOM.connectBtn.classList.add('connected');

                walletProvider.on('accountsChanged', () => window.location.reload());
                walletProvider.on('chainChanged', () => window.location.reload());

                // Check if owner
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, provider);
                const owner = await gasPm.owner();
                isOwner = owner.toLowerCase() === connectedAddress.toLowerCase();
                if (isOwner) DOM.createSection.style.display = 'block';

                await loadPositions();

                // Save wallet preference for auto-reconnect on page refresh
                localStorage.setItem('gaspm_wallet', walletKey);

            } catch (error) {
                console.error('Connection failed:', error);
                if (!isUserRejection(error)) {
                    showToast('Connection Failed', error.message || 'Could not connect wallet', 'error', 4000);
                }
            } finally {
                isConnecting = false;
            }
        }

        function disconnectWallet() {
            if (walletConnectProvider) {
                try { walletConnectProvider.disconnect(); } catch (e) {}
                walletConnectProvider = null;
            }
            provider = null;
            signer = null;
            connectedAddress = null;
            connectedWalletProvider = null;
            isOwner = false;
            DOM.connectBtn.textContent = 'Connect';
            DOM.connectBtn.classList.remove('connected');
            DOM.createSection.style.display = 'none';
            hidePositions();
            closeWalletModal();

            // Clear saved wallet preference
            localStorage.removeItem('gaspm_wallet');
        }

        // Check if error is a user rejection (wallet popup cancelled)
        function isUserRejection(error) {
            const msg = (error.message || '').toLowerCase();
            const reason = (error.reason || '').toLowerCase();
            const code = error.code;
            return msg.includes('user rejected') ||
                   msg.includes('user denied') ||
                   msg.includes('rejected the request') ||
                   reason.includes('rejected') ||
                   code === 'ACTION_REJECTED' ||
                   code === 4001;
        }

        // ======================== DATA LOADING ========================
        const MAX_MARKETS = 1000;

        async function loadData() {
            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const gasPmInterface = new ethers.Interface(GASPM_ABI);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Batch gas data + market infos with block fetch (like GasPM.html)
                const [results, block] = await Promise.all([
                    multicall.aggregate3([
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeAverage') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMax') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('baseFeeMin') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('startTime') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('observationCount') },
                        { target: GASPM_ADDRESS, allowFailure: true, callData: gasPmInterface.encodeFunctionData('getMarketInfos', [0, MAX_MARKETS]) }
                    ]),
                    rpc.getBlock('latest')
                ]);

                // Live gas from block (baseFeePerGas is in wei)
                const liveWei = block.baseFeePerGas || 0n;
                const liveGwei = Number(liveWei) / 1e9;
                DOM.liveGas.textContent = formatGwei(liveWei) + ' gwei';

                // Decode oracle data (returns wei, convert to gwei)
                let twapWei = 0n, maxWei = 0n, minWei = 0n, startTime = 0, obsCount = 0;

                if (results[0].success) {
                    twapWei = gasPmInterface.decodeFunctionResult('baseFeeAverage', results[0].returnData)[0];
                } else {
                    console.warn('baseFeeAverage call failed');
                }

                if (results[1].success) {
                    maxWei = gasPmInterface.decodeFunctionResult('baseFeeMax', results[1].returnData)[0];
                } else {
                    console.warn('baseFeeMax call failed');
                }

                if (results[2].success) {
                    minWei = gasPmInterface.decodeFunctionResult('baseFeeMin', results[2].returnData)[0];
                } else {
                    console.warn('baseFeeMin call failed');
                }

                if (results[3].success) {
                    startTime = Number(gasPmInterface.decodeFunctionResult('startTime', results[3].returnData)[0]);
                } else {
                    console.warn('startTime call failed');
                }

                if (results[4].success) {
                    obsCount = Number(gasPmInterface.decodeFunctionResult('observationCount', results[4].returnData)[0]);
                } else {
                    console.warn('observationCount call failed');
                }

                const twapGwei = Number(twapWei) / 1e9;
                const maxGwei = Number(maxWei) / 1e9;

                DOM.twapGas.textContent = formatGwei(twapWei) + ' gwei';
                DOM.minGas.textContent = formatGwei(minWei) + ' gwei';
                DOM.maxGas.textContent = formatGwei(maxWei) + ' gwei';

                // Update extreme progress
                DOM.extremeMax.textContent = formatGwei(maxWei) + ' gwei';
                const pct = Math.min(100, (maxGwei / 100) * 100);
                DOM.extremeProgress.style.width = pct + '%';
                DOM.extremePercent.textContent = pct.toFixed(0) + '%';

                // Note: Start/Now values are set in updateCard() when markets are loaded

                // Cache gas data for chart
                cachedGasData = { twap: twapGwei, current: liveGwei, startTime };

                // Fetch observations for chart (incremental loading for efficiency)
                if (obsCount > 0) {
                    const batchSize = 500;
                    let fetchStart = 0;
                    let newObservations = [];

                    if (lastLoadedObsCount === 0) {
                        // First load: only fetch last 500 observations (don't need ancient history)
                        fetchStart = Math.max(0, obsCount - batchSize);
                    } else if (obsCount > lastLoadedObsCount) {
                        // Incremental load: only fetch new observations
                        fetchStart = lastLoadedObsCount;
                    } else {
                        // No new observations, skip fetch
                        fetchStart = obsCount; // Will skip the loop
                    }

                    if (fetchStart < obsCount) {
                        const obsCalls = [];
                        for (let start = fetchStart; start < obsCount; start += batchSize) {
                            obsCalls.push({
                                target: GASPM_ADDRESS,
                                allowFailure: true,
                                callData: gasPmInterface.encodeFunctionData('getObservations', [start, Math.min(batchSize, obsCount - start)])
                            });
                        }
                        const obsResults = await multicall.aggregate3(obsCalls);
                        for (const res of obsResults) {
                            if (res.success) {
                                const batch = gasPmInterface.decodeFunctionResult('getObservations', res.returnData)[0];
                                newObservations.push(...batch);
                            }
                        }

                        // Append new observations to existing arrays (or replace on first load)
                        const newPoints = newObservations.map(o => Number(o.baseFee) / 1e9);
                        const newTimestamps = newObservations.map(o => Number(o.timestamp));
                        const newCumulatives = newObservations.map(o => Number(o.cumulativeBaseFee));

                        if (lastLoadedObsCount === 0) {
                            // First load - replace
                            chartDataPoints = newPoints;
                            chartTimestamps = newTimestamps;
                            chartCumulatives = newCumulatives;
                        } else {
                            // Incremental - append
                            chartDataPoints.push(...newPoints);
                            chartTimestamps.push(...newTimestamps);
                            chartCumulatives.push(...newCumulatives);
                        }
                        lastLoadedObsCount = obsCount;
                    }
                }

                // Decode market infos
                let marketInfos = [];
                if (results[5].success) {
                    try {
                        marketInfos = gasPmInterface.decodeFunctionResult('getMarketInfos', results[5].returnData)[0];
                    } catch (e) {
                        console.warn('No markets or failed to decode:', e);
                    }
                }

                // Load markets using marketInfos (this also calls updatePredictions)
                await loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei);

                // Draw chart AFTER markets loaded so predictions are available
                drawChart(cachedGasData);

            } catch (e) {
                console.error('Load failed:', e);
            }
        }

        async function loadMarkets(rpc, multicall, gasPmInterface, pammInterface, marketInfos, twapGwei) {
            // Reset markets on each load to handle expiry
            markets = { hourly: null, daily: null, weekly: null, extreme: null };
            resolvedMarkets = [];

            try {
                if (marketInfos.length === 0) return;

                const now = Math.floor(Date.now() / 1000);

                // Batch all PAMM.getMarket calls for descriptions
                const marketCalls = marketInfos.map(info => ({
                    target: PAMM_ADDRESS,
                    allowFailure: true,
                    callData: pammInterface.encodeFunctionData('getMarket', [info.marketId])
                }));
                const marketResults = await multicall.aggregate3(marketCalls);

                // Find comparison markets (including expired-but-unresolved) and batch their startValue calls
                const comparisonIds = [];
                const comparisonMarketIndices = []; // Maps back to marketInfos index
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    // Skip only resolved markets - include expired-but-unresolved
                    if (info.resolved) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const desc = data.description || data[10];
                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        comparisonIds.push(info.marketId);
                        comparisonMarketIndices.push(i);
                    }
                }

                // Batch comparisonStartValue calls AND getPoolState calls for unresolved markets
                let startValuesMap = new Map(); // marketId -> startValue
                let poolStateMap = new Map(); // marketId -> { rYes, rNo }

                // Collect all unresolved market IDs for pool state (including expired)
                const activeMarketIds = [];
                const activeMarketIndices = [];
                for (let i = 0; i < marketInfos.length; i++) {
                    if (!marketResults[i].success) continue;
                    const info = marketInfos[i];
                    // Include expired-but-unresolved markets
                    if (info.resolved) continue;
                    activeMarketIds.push(info.marketId);
                    activeMarketIndices.push(i);
                }

                if (activeMarketIds.length > 0) {
                    // Batch: startValue for comparison markets + poolState for all active markets
                    const batchCalls = [];

                    // Add startValue calls for comparison markets
                    for (const id of comparisonIds) {
                        batchCalls.push({
                            target: GASPM_ADDRESS,
                            allowFailure: true,
                            callData: gasPmInterface.encodeFunctionData('comparisonStartValue', [id])
                        });
                    }

                    // Add getPoolState calls for all active markets
                    for (const id of activeMarketIds) {
                        batchCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('getPoolState', [id, FEE_TIER])
                        });
                    }

                    const batchResults = await multicall.aggregate3(batchCalls);

                    // Parse startValue results
                    for (let i = 0; i < comparisonIds.length; i++) {
                        const val = batchResults[i].success ? gasPmInterface.decodeFunctionResult('comparisonStartValue', batchResults[i].returnData)[0] : 0n;
                        startValuesMap.set(comparisonIds[i].toString(), val);
                    }

                    // Parse poolState results
                    const poolStateOffset = comparisonIds.length;
                    for (let i = 0; i < activeMarketIds.length; i++) {
                        const res = batchResults[poolStateOffset + i];
                        if (res.success) {
                            const [rYes, rNo] = pammInterface.decodeFunctionResult('getPoolState', res.returnData);
                            poolStateMap.set(activeMarketIds[i].toString(), { rYes, rNo });
                        }
                    }
                }

                // Process markets
                let collateralMap = new Map(); // marketId -> collateralLocked
                for (let i = 0; i < marketInfos.length; i++) {
                    const info = marketInfos[i];
                    if (!marketResults[i].success) continue;

                    const data = pammInterface.decodeFunctionResult('getMarket', marketResults[i].returnData);
                    const resolved = info.resolved;
                    const close = Number(info.close);
                    const desc = data.description || data[10];
                    const collateralLocked = data.collateralLocked || data[6] || 0n;

                    // Collect resolved markets for history display
                    if (resolved) {
                        const outcome = info.outcome; // 0 = no, 1 = yes
                        // Only distinguish extreme (spike) vs comparison (TWAP) markets
                        const isExtreme = desc.includes('spikes to') || desc.includes('Gas spikes');
                        resolvedMarkets.push({
                            id: info.marketId,
                            isExtreme,
                            close,
                            outcome,
                            desc,
                            collateralLocked
                        });
                        continue;
                    }

                    const isExpired = close <= now;
                    // info.ready accounts for canClose markets (true if condition met early OR expired)
                    const needsResolve = info.ready;

                    // Store collateralLocked for TVL display (total ETH backing all tokens)
                    collateralMap.set(info.marketId.toString(), collateralLocked);

                    // Use pool reserves for price (reflects AMM state, not just supply)
                    const poolState = poolStateMap.get(info.marketId.toString());
                    let yesPrice = 0.5, noPrice = 0.5;

                    if (poolState && poolState.rYes > 0n && poolState.rNo > 0n) {
                        // AMM price: yesPrice = rNo / (rYes + rNo)
                        const rYesNum = Number(poolState.rYes);
                        const rNoNum = Number(poolState.rNo);
                        const total = rYesNum + rNoNum;
                        yesPrice = rNoNum / total;
                        noPrice = rYesNum / total;
                    } else {
                        // Fallback to supply-based calculation if no pool
                        const yesSupply = data.yesSupply || data[8];
                        const noSupply = data.noSupply || data[9];
                        const total = Number(yesSupply) + Number(noSupply);
                        if (total > 0) {
                            yesPrice = Number(noSupply) / total;
                            noPrice = Number(yesSupply) / total;
                        }
                    }

                    if (desc.includes('TWAP higher than') && desc.includes('start')) {
                        const startValue = startValuesMap.get(info.marketId.toString()) || 0n;
                        const startGwei = Number(startValue) / 1e9;
                        const timeToClose = close - now;

                        // For expired markets, use negative timeToClose to determine original category
                        // Hourly: expired within last hour or closes within next hour
                        // Daily: expired within last day or closes within next day
                        // Weekly: expired within last week or closes within next week
                        if (timeToClose <= 3600 && timeToClose > -3600 && !markets.hourly) {
                            markets.hourly = { id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve };
                            updateCard('hourly', startGwei, twapGwei, yesPrice, noPrice, needsResolve);
                        } else if (timeToClose <= 86400 && timeToClose > -86400 && !markets.daily) {
                            markets.daily = { id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve };
                            updateCard('daily', startGwei, twapGwei, yesPrice, noPrice, needsResolve);
                        } else if (timeToClose <= 604800 && timeToClose > -604800 && !markets.weekly) {
                            markets.weekly = { id: info.marketId, close, startGwei, yesPrice, noPrice, needsResolve };
                            updateCard('weekly', startGwei, twapGwei, yesPrice, noPrice, needsResolve);
                        }
                    } else if (desc.includes('spikes to') || desc.includes('Gas spikes')) {
                        if (!markets.extreme) {
                            markets.extreme = { id: info.marketId, close, yesPrice, noPrice, needsResolve, conditionMet: info.conditionMet };
                            document.getElementById('extremeYesOdds').textContent = formatOdds(yesPrice);
                            document.getElementById('extremeNoOdds').textContent = formatOdds(noPrice);
                            document.getElementById('extremeYesPrice').textContent = formatEth(yesPrice, '');
                            document.getElementById('extremeNoPrice').textContent = formatEth(noPrice, '');
                            // Show resolve button for extreme if ready (condition met OR expired)
                            const resolveBtn = document.getElementById('extremeResolveBtn');
                            if (resolveBtn) {
                                resolveBtn.style.display = needsResolve ? 'block' : 'none';
                                // Update button text if condition met early
                                if (info.conditionMet && !isExpired) {
                                    resolveBtn.textContent = '100 GWEI HIT! Resolve Now';
                                    resolveBtn.style.background = 'var(--green)';
                                }
                            }
                        }
                    }
                }

                // Update create cards visibility
                updateCreateCardsVisibility();
                // Load liquidity stats after markets are loaded (pass collateralMap for TVL)
                loadLiquidityStats(collateralMap);
                // Update predictions based on market odds
                updatePredictions();
                // Update resolved markets count and render if visible
                const isExpanded = document.getElementById('resolvedSection').style.display !== 'none';
                document.getElementById('resolvedMarketsCount').textContent = resolvedMarkets.length + (isExpanded ? ' â–´' : ' â–¾');
                renderResolvedMarkets();
            } catch (e) {
                console.error('Load markets failed:', e);
            }
        }

        async function loadLiquidityStats(collateralMap = null) {
            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                let totalTvl = 0;
                let totalOrderbookLiq = 0;
                let activeCount = 0;

                // Load stats for each active market
                const marketTypes = ['hourly', 'daily', 'weekly', 'extreme'];
                for (const type of marketTypes) {
                    const market = markets[type];
                    if (!market || !market.id) continue;

                    activeCount++;

                    try {
                        // Use collateralMap if available (from loadMarkets), otherwise fetch
                        let collateralLocked;
                        const cachedCollateral = collateralMap?.get(market.id.toString());
                        if (cachedCollateral !== undefined) {
                            collateralLocked = cachedCollateral;
                        } else {
                            const marketData = await pamm.getMarket(market.id);
                            collateralLocked = marketData.collateralLocked || marketData[6] || 0n;
                        }

                        // Market TVL = total collateral locked (ETH backing all tokens)
                        const marketTvl = Number(collateralLocked) / 1e18;
                        totalTvl += marketTvl;

                        // Update individual card
                        const poolEl = document.getElementById(`${type}PoolTvl`);
                        if (poolEl) poolEl.textContent = formatEth(marketTvl);

                        // Get orderbook depth
                        try {
                            const [bidHashes, bidOrders, askHashes, askOrders] = await pmRouter.getOrderbook(market.id, true, 20);
                            const orderCount = bidHashes.length + askHashes.length;

                            // Sum orderbook liquidity (collateral in orders)
                            let orderbookLiq = 0;
                            for (const o of bidOrders) orderbookLiq += Number(o.collateral) / 1e18;
                            for (const o of askOrders) orderbookLiq += Number(o.collateral) / 1e18;
                            totalOrderbookLiq += orderbookLiq;

                            const orderbookEl = document.getElementById(`${type}Orderbook`);
                            if (orderbookEl) {
                                if (orderCount > 0) {
                                    orderbookEl.textContent = formatEth(orderbookLiq);
                                } else {
                                    orderbookEl.textContent = 'none';
                                }
                            }
                        } catch (e) {
                            // PMRouter may not be deployed yet
                            const orderbookEl = document.getElementById(`${type}Orderbook`);
                            if (orderbookEl) orderbookEl.textContent = '--';
                        }

                    } catch (e) {
                        console.warn(`Failed to load liquidity for ${type}:`, e);
                    }
                }

                // Update global stats
                DOM.totalPoolTvl.textContent = formatEth(totalTvl);
                DOM.totalOrderbookLiq.textContent = totalOrderbookLiq > 0 ? formatEth(totalOrderbookLiq) : '--';
                DOM.activeMarketsCount.textContent = activeCount.toString();

            } catch (e) {
                console.error('Failed to load liquidity stats:', e);
            }
        }

        // Hide create cards for market types that already have active markets
        function updateCreateCardsVisibility() {
            const cards = {
                hourly: document.getElementById('createHourlyCard'),
                daily: document.getElementById('createDailyCard'),
                weekly: document.getElementById('createWeeklyCard'),
                extreme: document.getElementById('createExtremeCard')
            };

            let allActive = true;
            for (const [type, card] of Object.entries(cards)) {
                if (card) {
                    if (markets[type]) {
                        card.style.display = 'none';
                    } else {
                        card.style.display = '';
                        allActive = false;
                    }
                }
            }

            // Show message if all markets are active
            const allActiveMsg = document.getElementById('allMarketsActive');
            if (allActiveMsg) {
                allActiveMsg.style.display = allActive ? 'block' : 'none';
            }
        }

        // ======================== RESOLVED MARKETS ========================
        async function toggleResolved() {
            const section = document.getElementById('resolvedSection');
            const countEl = document.getElementById('resolvedMarketsCount');
            if (section) {
                const willShow = section.style.display === 'none';
                section.style.display = willShow ? 'block' : 'none';
                // Update arrow direction
                if (countEl) {
                    countEl.textContent = resolvedMarkets.length + (willShow ? ' â–´' : ' â–¾');
                }
                // Re-render when opening to fetch fresh balances (e.g., if wallet connected after initial load)
                if (willShow) {
                    await renderResolvedMarkets();
                }
            }
        }

        async function renderResolvedMarkets() {
            const grid = document.getElementById('resolvedGrid');
            if (!grid) return;

            if (resolvedMarkets.length === 0) {
                grid.innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:2rem;">No resolved markets yet</div>';
                return;
            }

            // Sort by close time (most recent first)
            const sorted = [...resolvedMarkets].sort((a, b) => b.close - a.close);

            // Load user's winning shares AND LP balances if connected
            let userWinnings = new Map(); // marketId -> winning token balance
            let userLpBalances = new Map(); // marketId -> { lpBalance, poolId }
            if (connectedAddress) {
                try {
                    const rpc = provider || await getRpcProvider();
                    const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                    const pammInterface = new ethers.Interface(PAMM_ABI);
                    const zammInterface = new ethers.Interface(ZAMM_ABI);

                    // First batch: get poolKeys for all markets
                    const poolKeyCalls = sorted.map(m => ({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('poolKey', [m.id, FEE_TIER])
                    }));
                    const poolKeyResults = await multicall.aggregate3(poolKeyCalls);

                    // Compute pool IDs and build balance calls
                    // Query BOTH YES and NO token balances for each market
                    const poolIds = new Map();
                    const noTokenIds = new Map();
                    const balanceCalls = [];
                    for (let i = 0; i < sorted.length; i++) {
                        const m = sorted[i];
                        const noId = ethers.solidityPackedKeccak256(['string', 'uint256'], ['PMARKET:NO', m.id]);
                        noTokenIds.set(m.id.toString(), noId);

                        // YES token balance (marketId)
                        balanceCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                        });
                        // NO token balance (derived)
                        balanceCalls.push({
                            target: PAMM_ADDRESS,
                            allowFailure: true,
                            callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                        });

                        // LP token balance
                        if (poolKeyResults[i].success) {
                            const poolKey = pammInterface.decodeFunctionResult('poolKey', poolKeyResults[i].returnData)[0];
                            const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                                ['uint256', 'uint256', 'address', 'address', 'uint256'],
                                [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                            ));
                            poolIds.set(m.id.toString(), poolId);
                            balanceCalls.push({
                                target: ZAMM_ADDRESS,
                                allowFailure: true,
                                callData: zammInterface.encodeFunctionData('balanceOf', [connectedAddress, poolId])
                            });
                        } else {
                            // Placeholder for failed poolKey
                            balanceCalls.push({ target: ZAMM_ADDRESS, allowFailure: true, callData: '0x' });
                        }
                    }

                    if (balanceCalls.length > 0) {
                        const balanceResults = await multicall.aggregate3(balanceCalls);
                        for (let i = 0; i < sorted.length; i++) {
                            const m = sorted[i];
                            // Each market has 3 calls: YES, NO, LP
                            const yesRes = balanceResults[i * 3];
                            const noRes = balanceResults[i * 3 + 1];
                            const lpRes = balanceResults[i * 3 + 2];

                            const yesBal = yesRes.success ? BigInt(pammInterface.decodeFunctionResult('balanceOf', yesRes.returnData)[0]) : 0n;
                            const noBal = noRes.success ? BigInt(pammInterface.decodeFunctionResult('balanceOf', noRes.returnData)[0]) : 0n;

                            // Determine winning balance based on outcome
                            // outcome truthy = YES won, outcome falsy = NO won
                            const winBal = m.outcome ? yesBal : noBal;
                            const loseBal = m.outcome ? noBal : yesBal;
                            userWinnings.set(m.id.toString(), { winBal, loseBal, yesBal, noBal });

                            const poolId = poolIds.get(m.id.toString());
                            if (lpRes.success && poolId) {
                                const lpBal = BigInt(zammInterface.decodeFunctionResult('balanceOf', lpRes.returnData)[0]);
                                userLpBalances.set(m.id.toString(), { lpBalance: lpBal, poolId });
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load resolved market balances:', e);
                }
            }

            // Helper to truncate market ID
            const truncateId = (id) => {
                const s = id.toString();
                if (s.length <= 12) return s;
                return s.slice(0, 6) + '...' + s.slice(-4);
            };

            grid.innerHTML = sorted.map(m => {
                const typeLabel = m.isExtreme ? 'Challenge' : 'TWAP';
                const typeClass = m.isExtreme ? 'extreme' : 'daily';
                const outcomeLabel = m.isExtreme ? (m.outcome ? 'YES' : 'NO') : (m.outcome ? 'UP' : 'DOWN');
                const outcomeColor = m.outcome ? 'var(--green)' : 'var(--red)';
                const closeDate = new Date(m.close * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                const tvl = Number(m.collateralLocked) / 1e18;

                // User positions
                const posData = userWinnings.get(m.id.toString()) || { winBal: 0n, loseBal: 0n };
                const winBal = posData.winBal || 0n;
                const loseBal = posData.loseBal || 0n;
                const winBalNum = Number(winBal) / 1e18;
                const loseBalNum = Number(loseBal) / 1e18;
                const hasWinnings = winBal > 0n;
                const hasLosing = loseBal > 0n;

                const lpData = userLpBalances.get(m.id.toString());
                const lpBal = lpData?.lpBalance || 0n;
                const lpBalNum = Number(lpBal) / 1e18;
                const hasLp = lpBal > 0n;

                const hasPosition = hasWinnings || hasLp || hasLosing;

                return `
                    <div class="bet-card resolved" style="opacity:0.9;">
                        <div class="bet-header">
                            <span class="bet-type ${typeClass}">${typeLabel}</span>
                            <span style="font-size:var(--font-xs);color:var(--text-dim);">${closeDate}</span>
                        </div>
                        <div class="bet-title" style="font-size:var(--font-sm);" title="Market #${m.id}">Market #${truncateId(m.id)}</div>
                        <div style="text-align:center;padding:0.75rem 0;">
                            <div style="font-size:var(--font-xs);color:var(--text-dim);">Outcome</div>
                            <div style="font-size:var(--font-lg);font-weight:700;color:${outcomeColor};">${outcomeLabel} Won</div>
                        </div>
                        ${hasPosition ? `
                            <div style="background:var(--gray);border-radius:var(--radius);padding:0.75rem;margin:0.5rem 0;">
                                ${hasWinnings ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);${hasLp || hasLosing ? 'margin-bottom:0.5rem;' : ''}">
                                        <span style="color:var(--text-muted);">Winnings</span>
                                        <span style="color:var(--green);font-weight:600;">${winBalNum.toFixed(4)} ETH</span>
                                    </div>
                                ` : ''}
                                ${hasLosing && !hasWinnings && !hasLp ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);">
                                        <span style="color:var(--text-muted);">Position</span>
                                        <span style="color:var(--text-dim);font-weight:600;">Claimed âœ“</span>
                                    </div>
                                ` : ''}
                                ${hasLp ? `
                                    <div style="display:flex;justify-content:space-between;align-items:center;font-size:var(--font-xs);">
                                        <span style="color:var(--text-muted);">LP Position</span>
                                        <span style="color:var(--blue);font-weight:600;">${lpBalNum.toFixed(4)}</span>
                                    </div>
                                ` : ''}
                            </div>
                            ${hasWinnings && !hasLp ? `
                                <button class="bet-btn up" style="width:100%;margin-top:0.5rem;" onclick="claimWinnings('${m.id}')">
                                    <div class="bet-btn-label">Claim ${winBalNum.toFixed(4)} ETH</div>
                                </button>
                            ` : ''}
                            ${hasLp ? `
                                <button class="bet-btn up" style="width:100%;margin-top:0.5rem;" onclick="withdrawLP('${m.id}', ${hasWinnings})">
                                    <div class="bet-btn-label">Withdraw All</div>
                                </button>
                            ` : ''}
                        ` : `
                            <div style="font-size:var(--font-xs);color:var(--text-dim);text-align:center;padding-top:0.5rem;">TVL: ${formatEth(tvl)}</div>
                        `}
                    </div>
                `;
            }).join('');
        }

        async function claimWinnings(marketId) {
            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                await monitorTransaction(
                    pamm.claim(marketId, connectedAddress),
                    {
                        pending: { title: 'Claiming Winnings', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Claiming Winnings', body: 'Waiting for confirmation...' },
                        success: { title: 'Winnings Claimed!', body: 'Your winnings have been sent to your wallet' },
                        error: { title: 'Claim Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            renderResolvedMarkets();
                        }
                    }
                );
            } catch (e) {
                // monitorTransaction already shows toast for errors, so just log
                console.error('Claim failed:', e);
            }
        }

        async function withdrawLP(marketId, hasDirectWinnings = false) {
            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                // Get LP balance
                const poolKey = await pamm.poolKey(marketId, FEE_TIER);
                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                    [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                ));
                const lpBalance = await zamm.balanceOf(connectedAddress, poolId);

                if (lpBalance === 0n) {
                    showToast('No LP', 'No LP position to withdraw', 'error', 3000);
                    return;
                }

                // Ensure PAMM is approved as operator for ZAMM
                const isApproved = await zamm.isOperator(connectedAddress, PAMM_ADDRESS);
                if (!isApproved) {
                    let approved = false;
                    await monitorTransaction(zamm.setOperator(PAMM_ADDRESS, true), {
                        pending: { title: 'Approval Required', body: 'Approve PAMM as operator...' },
                        submitted: { title: 'Approval Required', body: 'Waiting for confirmation...' },
                        success: { title: 'Approved!', body: 'PAMM can now manage your LP tokens' },
                        error: { title: 'Approval Failed', body: '' },
                        onSuccess: () => { approved = true; }
                    });
                    if (!approved) return;
                }

                const deadline = Math.floor(Date.now() / 1000) + 600;
                const pammInterface = new ethers.Interface(PAMM_ABI);

                // Build calls array - removeLiquidityToCollateral already handles winning tokens from LP
                // Only add claim if user has direct winning token holdings (from trades)
                const calls = [
                    pammInterface.encodeFunctionData('removeLiquidityToCollateral', [
                        marketId,
                        FEE_TIER,
                        lpBalance,
                        0, // amount0Min
                        0, // amount1Min
                        0, // minCollateralOut
                        connectedAddress,
                        deadline
                    ])
                ];

                // Only claim if user has direct winning tokens (not from LP)
                if (hasDirectWinnings) {
                    calls.push(pammInterface.encodeFunctionData('claim', [marketId, connectedAddress]));
                }

                await monitorTransaction(
                    pamm.multicall(calls),
                    {
                        pending: { title: 'Withdrawing All', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Withdrawing All', body: 'Waiting for confirmation...' },
                        success: { title: 'Withdrawn!', body: 'LP and winnings returned to your wallet' },
                        error: { title: 'Withdraw Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            renderResolvedMarkets();
                        }
                    }
                );
            } catch (e) {
                console.error('Withdraw LP failed:', e);
            }
        }

        function updateCard(type, startGwei, nowGwei, yesPrice, noPrice, needsResolve = false) {
            // Format gwei values with appropriate precision
            const formatGweiValue = (gwei) => {
                if (gwei >= 10) return gwei.toFixed(1);
                if (gwei >= 1) return gwei.toFixed(2);
                return gwei.toFixed(3);
            };

            document.getElementById(`${type}Start`).textContent = formatGweiValue(startGwei);
            document.getElementById(`${type}Now`).textContent = formatGweiValue(nowGwei);

            const arrow = document.getElementById(`${type}Arrow`);
            const diff = nowGwei - startGwei;
            const pctChange = startGwei > 0 ? (diff / startGwei * 100) : 0;

            if (nowGwei > startGwei * 1.001) { // > 0.1% higher
                arrow.textContent = 'â–²';
                arrow.className = 'gas-compare-arrow up';
                arrow.title = `+${pctChange.toFixed(1)}% from start`;
            } else if (nowGwei < startGwei * 0.999) { // > 0.1% lower
                arrow.textContent = 'â–¼';
                arrow.className = 'gas-compare-arrow down';
                arrow.title = `${pctChange.toFixed(1)}% from start`;
            } else {
                arrow.textContent = '=';
                arrow.className = 'gas-compare-arrow';
                arrow.title = 'No significant change';
            }

            document.getElementById(`${type}UpOdds`).textContent = formatOdds(yesPrice);
            document.getElementById(`${type}DownOdds`).textContent = formatOdds(noPrice);
            document.getElementById(`${type}UpPrice`).textContent = formatEth(yesPrice, '');
            document.getElementById(`${type}DownPrice`).textContent = formatEth(noPrice, '');

            // Show/hide resolve button and update card state for expired markets
            const resolveBtn = document.getElementById(`${type}ResolveBtn`);
            const buttonsDiv = document.querySelector(`#${type}Card .bet-buttons`);
            const countdownEl = document.getElementById(`${type}Countdown`);

            if (needsResolve) {
                // Market expired - show resolve button, hide trade buttons
                if (resolveBtn) resolveBtn.style.display = 'block';
                if (buttonsDiv) buttonsDiv.style.opacity = '0.5';
                if (countdownEl) {
                    countdownEl.textContent = 'Ready to resolve';
                    countdownEl.style.color = 'var(--amber)';
                }
            } else {
                if (resolveBtn) resolveBtn.style.display = 'none';
                if (buttonsDiv) buttonsDiv.style.opacity = '1';
            }
        }

        async function loadPositions() {
            if (!connectedAddress) return;

            try {
                const rpc = provider || await getRpcProvider();
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, rpc);
                const pammInterface = new ethers.Interface(PAMM_ABI);

                const marketList = [];
                const types = [];
                if (markets.hourly) { marketList.push(markets.hourly); types.push('hourly'); }
                if (markets.daily) { marketList.push(markets.daily); types.push('daily'); }
                if (markets.weekly) { marketList.push(markets.weekly); types.push('weekly'); }
                if (markets.extreme) { marketList.push(markets.extreme); types.push('extreme'); }

                if (marketList.length === 0) return;

                // Build multicall for YES and NO balances
                const calls = [];
                for (const m of marketList) {
                    // YES balance (marketId is the YES token id)
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, m.id])
                    });
                    // NO balance (need to compute noId = keccak256(abi.encodePacked("PMARKET:NO", marketId)))
                    const noId = ethers.solidityPackedKeccak256(
                        ['string', 'uint256'],
                        ['PMARKET:NO', m.id]
                    );
                    calls.push({
                        target: PAMM_ADDRESS,
                        allowFailure: true,
                        callData: pammInterface.encodeFunctionData('balanceOf', [connectedAddress, noId])
                    });
                }

                const results = await multicall.aggregate3(calls);

                for (let i = 0; i < types.length; i++) {
                    const t = types[i];
                    const yesResult = results[i * 2];
                    const noResult = results[i * 2 + 1];

                    const yes = yesResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', yesResult.returnData)[0]) / 1e18 : 0;
                    const no = noResult.success ? Number(pammInterface.decodeFunctionResult('balanceOf', noResult.returnData)[0]) / 1e18 : 0;

                    if (yes > 0 || no > 0) {
                        document.getElementById(`${t}Position`).style.display = 'block';
                        document.getElementById(`${t}${t === 'extreme' ? 'Yes' : 'Up'}Bal`).textContent = yes.toFixed(4);
                        document.getElementById(`${t}${t === 'extreme' ? 'No' : 'Down'}Bal`).textContent = no.toFixed(4);
                    } else {
                        document.getElementById(`${t}Position`).style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Load positions failed:', e);
            }
        }

        function hidePositions() {
            ['hourly', 'daily', 'weekly', 'extreme'].forEach(t => {
                document.getElementById(`${t}Position`).style.display = 'none';
            });
        }

        // ======================== CHART ========================
        let hoverIndex = -1; // Track hovered data point for crosshair
        let resizeTimer = null; // For debouncing resize
        let tooltipSpotEl, tooltipTwapEl, tooltipTimeEl; // Cache tooltip elements

        function setupChart() {
            const canvas = DOM.gasChart;
            const tooltip = DOM.chartTooltip;
            const predTooltip = DOM.predTooltip;

            if (!canvas || !tooltip) {
                console.error('Chart elements not found');
                return;
            }

            // Cache tooltip sub-elements
            tooltipSpotEl = document.getElementById('tooltipSpot');
            tooltipTwapEl = document.getElementById('tooltipTwap');
            tooltipTimeEl = document.getElementById('tooltipTime');

            // Cache prediction tooltip elements
            const predBadge = document.getElementById('predBadge');
            const predTitle = document.getElementById('predTitle');
            const predTwap = document.getElementById('predTwap');
            const predDirection = document.getElementById('predDirection');
            const predTvl = document.getElementById('predTvl');
            const predCloses = document.getElementById('predCloses');
            const predImpliedAvg = document.getElementById('predImpliedAvg');
            const predVsSpot = document.getElementById('predVsSpot');

            canvas.addEventListener('mousemove', (e) => {
                if (!chartState.data || !chartState.data.length) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const { data, rollingTwap, padding, chartWidth, width, height } = chartState;

                // Check if hovering over price change badge first
                if (priceChangeBadgeArea) {
                    const b = priceChangeBadgeArea;
                    if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
                        // Show price change tooltip using the chart tooltip
                        tooltip.classList.remove('visible');
                        if (predTooltip) predTooltip.classList.remove('visible');
                        hoverIndex = -1;
                        hoveredPrediction = null;

                        // Format time span for display
                        let timeDesc = '';
                        if (b.timeSpan < 3600) {
                            timeDesc = 'Last ' + Math.round(b.timeSpan / 60) + ' minutes';
                        } else if (b.timeSpan < 86400) {
                            const hrs = Math.round(b.timeSpan / 3600);
                            timeDesc = 'Last ' + hrs + ' hour' + (hrs > 1 ? 's' : '');
                        } else {
                            const days = Math.round(b.timeSpan / 86400);
                            timeDesc = 'Last ' + days + ' day' + (days > 1 ? 's' : '');
                        }

                        // Update tooltip content for price change
                        tooltipTimeEl.textContent = timeDesc;
                        tooltipSpotEl.textContent = b.firstVal.toFixed(2) + ' â†’ ' + b.lastVal.toFixed(2) + ' gwei';
                        const changeSign = b.change >= 0 ? '+' : '';
                        tooltipTwapEl.textContent = changeSign + b.change.toFixed(2) + '% change';

                        // Position tooltip near badge
                        tooltip.style.left = (b.x + b.width + 10) + 'px';
                        tooltip.style.top = (b.y) + 'px';
                        tooltip.classList.add('visible');

                        canvas.style.cursor = 'help';
                        return;
                    }
                }

                // Check if hovering over a prediction marker
                let foundPrediction = null;
                for (const marker of predictionMarkerPositions) {
                    const dx = x - marker.x;
                    const dy = y - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        foundPrediction = marker;
                        break;
                    }
                }

                if (foundPrediction && predTooltip) {
                    // Hide chart tooltip, show prediction tooltip
                    tooltip.classList.remove('visible');
                    hoverIndex = -1;

                    // Update prediction tooltip content
                    const marketNames = { hourly: 'Hourly', daily: 'Daily', weekly: 'Weekly' };
                    const isUp = foundPrediction.yesPrice > 0.5;
                    const prob = Math.round(foundPrediction.yesPrice * 100);

                    if (predBadge) {
                        predBadge.textContent = foundPrediction.label;
                        predBadge.style.background = foundPrediction.color;
                        predBadge.style.color = '#18181b';
                    }
                    if (predTitle) predTitle.textContent = marketNames[foundPrediction.type] + ' Market';
                    predTooltip.style.borderColor = foundPrediction.color;
                    if (predTwap) predTwap.textContent = foundPrediction.predicted.toFixed(2) + ' gwei';

                    // Direction indicator - neutral if close to 50/50 (within 5%)
                    const isNeutral = prob >= 45 && prob <= 55;
                    if (predDirection) {
                        if (isNeutral) {
                            predDirection.className = 'pred-tooltip-direction neutral';
                            predDirection.innerHTML = `<span>â†”</span><span>~50%</span> EVEN`;
                        } else {
                            predDirection.className = 'pred-tooltip-direction ' + (isUp ? 'up' : 'down');
                            predDirection.innerHTML = `<span>${isUp ? 'â†‘' : 'â†“'}</span><span>${isUp ? prob : 100 - prob}%</span> ${isUp ? 'UP' : 'DOWN'}`;
                        }
                    }

                    // TVL - get from market if available
                    const tvlEl = document.getElementById(`${foundPrediction.type}Tvl`);
                    if (predTvl) predTvl.textContent = tvlEl ? tvlEl.textContent : '--';

                    // Time to close
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = foundPrediction.closeTime - now;
                    if (predCloses) predCloses.textContent = formatTime(remaining);

                    // Calculate implied remaining average base fee
                    // Formula: predictedTwap = (currentTwap * elapsed + impliedAvg * remaining) / total
                    // Solving: impliedAvg = (predictedTwap * total - currentTwap * elapsed) / remaining
                    const marketDurations = { hourly: 3600, daily: 86400, weekly: 604800 };
                    const totalDuration = marketDurations[foundPrediction.type] || 3600;
                    const marketStart = foundPrediction.closeTime - totalDuration;
                    const elapsed = Math.max(0, now - marketStart);
                    const currentTwap = cachedGasData.twap;
                    const currentSpot = cachedGasData.current;
                    const predictedTwap = foundPrediction.predicted;

                    if (remaining > 0 && elapsed > 0) {
                        // Calculate implied average for remaining time
                        const impliedAvg = (predictedTwap * totalDuration - currentTwap * elapsed) / remaining;

                        // Sanity check: implied avg should be positive and within reasonable bounds
                        if (impliedAvg > 0 && impliedAvg < currentTwap * 5) {
                            if (predImpliedAvg) predImpliedAvg.textContent = impliedAvg.toFixed(2) + ' gwei';

                            // Compare to current spot
                            const spotDiff = impliedAvg - currentSpot;
                            const spotDiffPct = (spotDiff / currentSpot * 100);
                            const spotSign = spotDiff >= 0 ? '+' : '';
                            const spotColor = spotDiff > 1 ? '#22c55e' : (spotDiff < -1 ? '#ef4444' : '#a1a1aa');
                            if (predVsSpot) predVsSpot.innerHTML = `<span style="color:${spotColor}">${spotSign}${spotDiffPct.toFixed(1)}%</span> (${currentSpot.toFixed(1)} now)`;
                        } else {
                            if (predImpliedAvg) predImpliedAvg.textContent = '--';
                            if (predVsSpot) predVsSpot.textContent = '--';
                        }
                    } else if (remaining <= 0) {
                        if (predImpliedAvg) predImpliedAvg.textContent = 'Market closing';
                        if (predVsSpot) predVsSpot.textContent = '--';
                    } else {
                        // Very early in period
                        if (predImpliedAvg) predImpliedAvg.textContent = '~' + predictedTwap.toFixed(2) + ' gwei';
                        if (predVsSpot) predVsSpot.textContent = 'Early in period';
                    }

                    // Position prediction tooltip - responsive
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    const isMobileTooltip = canvasWidth < 400;
                    // Mobile tooltip is more compact (hidden rows)
                    const predTooltipWidth = isMobileTooltip ? 160 : 210;
                    const predTooltipHeight = isMobileTooltip ? 100 : 180;
                    let tooltipX, tooltipY;

                    if (isMobileTooltip) {
                        // On mobile, position to left of marker (prediction zone is on right)
                        tooltipX = Math.max(5, x - predTooltipWidth - 10);
                        // Center vertically on marker, but clamp to canvas
                        tooltipY = Math.max(5, Math.min(y - predTooltipHeight / 2, canvasHeight - predTooltipHeight - 5));
                    } else {
                        // Desktop: position to left of marker to avoid going off right edge
                        tooltipX = x - predTooltipWidth - 15;
                        tooltipY = y - predTooltipHeight / 2;

                        // If not enough room on left, try right
                        if (tooltipX < 10) {
                            tooltipX = x + 15;
                        }
                        // Clamp to canvas edges
                        if (tooltipY + predTooltipHeight > canvasHeight) {
                            tooltipY = canvasHeight - predTooltipHeight - 5;
                        }
                        if (tooltipY < 5) {
                            tooltipY = 5;
                        }
                    }

                    predTooltip.style.left = tooltipX + 'px';
                    predTooltip.style.top = tooltipY + 'px';
                    predTooltip.classList.add('visible');

                    // Update hovered prediction state
                    if (hoveredPrediction !== foundPrediction.type) {
                        hoveredPrediction = foundPrediction.type;
                        drawChart(cachedGasData); // Redraw with highlight
                    }

                    canvas.style.cursor = 'pointer';
                    return;
                }

                // Not hovering over prediction - hide prediction tooltip
                if (hoveredPrediction) {
                    hoveredPrediction = null;
                    drawChart(cachedGasData);
                }
                if (predTooltip) predTooltip.classList.remove('visible');
                canvas.style.cursor = 'crosshair';

                // Regular chart hover logic
                const idx = Math.round((x - padding) / chartWidth * (data.length - 1));
                const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                // Update hover index and redraw for crosshair
                if (hoverIndex !== clampedIdx) {
                    hoverIndex = clampedIdx;
                    drawChart(cachedGasData);
                }

                if (clampedIdx >= 0 && clampedIdx < data.length) {
                    const spotVal = data[clampedIdx];
                    const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                    // Update tooltip content
                    tooltipSpotEl.textContent = spotVal.toFixed(2) + ' gwei';
                    tooltipTwapEl.textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                    // Time display
                    let timeText = '';
                    if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                        const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                        timeText = date.toLocaleString();
                    } else if (clampedIdx === data.length - 1) {
                        timeText = 'Now';
                    }
                    tooltipTimeEl.textContent = timeText;

                    // Position tooltip with edge clamping
                    const tooltipWidth = 160;
                    const tooltipHeight = 80;
                    let tooltipX = e.clientX - rect.left + 15;
                    let tooltipY = e.clientY - rect.top - 10;

                    // Clamp to right edge
                    if (tooltipX + tooltipWidth > width) {
                        tooltipX = e.clientX - rect.left - tooltipWidth - 15;
                    }
                    // Clamp to bottom edge
                    if (tooltipY + tooltipHeight > height) {
                        tooltipY = height - tooltipHeight - 10;
                    }
                    // Clamp to top edge
                    if (tooltipY < 10) {
                        tooltipY = 10;
                    }

                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                    tooltip.classList.add('visible');
                }
            });

            canvas.addEventListener('mouseleave', () => {
                tooltip.classList.remove('visible');
                if (predTooltip) predTooltip.classList.remove('visible');
                hoverIndex = -1;
                hoveredPrediction = null;
                canvas.style.cursor = 'default';
                drawChart(cachedGasData); // Clear crosshair
            });

            // Click handler for prediction markers - opens trade modal
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check if clicking on a prediction marker
                for (const marker of predictionMarkerPositions) {
                    const dx = x - marker.x;
                    const dy = y - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        // Open trade for this market (default to UP/YES)
                        const isUp = marker.yesPrice > 0.5;
                        openTrade(marker.type, isUp);
                        return;
                    }
                }
            });

            // Touch support for mobile - full chart interaction
            let touchTimeout = null;
            let isTouchingChart = false;

            function handleChartTouch(touchX, touchY, clientX, clientY) {
                if (!chartState.data || !chartState.data.length) return false;

                const { data, rollingTwap, padding, chartWidth, width, height } = chartState;

                // Check if touching a prediction marker first
                for (const marker of predictionMarkerPositions) {
                    const dx = touchX - marker.x;
                    const dy = touchY - marker.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < marker.radius) {
                        hoveredPrediction = marker.type;
                        if (cachedGasData) drawChart(cachedGasData);
                        // Trigger mousemove to show prediction tooltip
                        canvas.dispatchEvent(new MouseEvent('mousemove', { clientX, clientY }));
                        return true;
                    }
                }

                // Check if touching within chart area (not prediction zone)
                if (touchX >= padding && touchX <= padding + chartWidth) {
                    // Calculate data index from touch position
                    const idx = Math.round((touchX - padding) / chartWidth * (data.length - 1));
                    const clampedIdx = Math.max(0, Math.min(idx, data.length - 1));

                    if (clampedIdx >= 0 && clampedIdx < data.length) {
                        hoverIndex = clampedIdx;
                        if (cachedGasData) drawChart(cachedGasData);

                        const spotVal = data[clampedIdx];
                        const twapVal = rollingTwap && rollingTwap[clampedIdx] ? rollingTwap[clampedIdx] : null;

                        // Update tooltip content
                        tooltipSpotEl.textContent = spotVal.toFixed(2) + ' gwei';
                        tooltipTwapEl.textContent = twapVal ? twapVal.toFixed(2) + ' gwei' : '--';

                        // Time display
                        let timeText = '';
                        if (chartState.timestamps && chartState.timestamps[clampedIdx]) {
                            const date = new Date(chartState.timestamps[clampedIdx] * 1000);
                            timeText = date.toLocaleString();
                        } else if (clampedIdx === data.length - 1) {
                            timeText = 'Now';
                        }
                        tooltipTimeEl.textContent = timeText;

                        // Position tooltip - centered above touch point on mobile
                        const tooltipWidth = 140;
                        let tooltipX = Math.max(5, Math.min(touchX - tooltipWidth / 2, width - tooltipWidth - 5));
                        let tooltipY = Math.max(5, touchY - 70);

                        tooltip.style.left = tooltipX + 'px';
                        tooltip.style.top = tooltipY + 'px';
                        tooltip.classList.add('visible');
                        return true;
                    }
                }

                return false;
            }

            canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                // Clear any pending timeout
                if (touchTimeout) clearTimeout(touchTimeout);

                isTouchingChart = handleChartTouch(x, y, touch.clientX, touch.clientY);

                if (isTouchingChart) {
                    e.preventDefault(); // Prevent scroll while interacting
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (!isTouchingChart) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                handleChartTouch(x, y, touch.clientX, touch.clientY);
                e.preventDefault();
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                // Clear tooltip after a delay on touch release
                if (touchTimeout) clearTimeout(touchTimeout);
                touchTimeout = setTimeout(() => {
                    tooltip.classList.remove('visible');
                    if (predTooltip) predTooltip.classList.remove('visible');
                    hoverIndex = -1;
                    hoveredPrediction = null;
                    isTouchingChart = false;
                    if (cachedGasData) drawChart(cachedGasData);
                }, 2500); // Keep tooltip visible for 2.5s after touch ends
            });

            // Debounced resize handler
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    if (chartDataPoints.length) drawChart(cachedGasData);
                }, 150);
            });
        }

        // Cache canvas context
        let chartCtx = null;

        function drawChart(gasData) {
            const { twap, current, startTime } = gasData;

            const canvas = DOM.gasChart;
            if (!chartCtx) chartCtx = canvas.getContext('2d');
            const ctx = chartCtx;
            const container = canvas.parentElement;

            // Only resize canvas if dimensions actually changed (avoids clearing on every frame)
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;
            if (lastCanvasSize.width !== newWidth || lastCanvasSize.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                lastCanvasSize.width = newWidth;
                lastCanvasSize.height = newHeight;
            }

            const width = canvas.width;
            const height = canvas.height;

            // Responsive padding based on screen width
            const isMobile = width < 400;
            const isSmall = width < 600;
            const padding = isMobile ? 25 : (isSmall ? 32 : 40);
            const paddingRight = isMobile ? 60 : (isSmall ? 80 : 100); // Extra space for prediction zone
            const chartWidth = width - padding - paddingRight; // Chart area width

            // Clear
            ctx.fillStyle = '#18181b';
            ctx.fillRect(0, 0, width, height);

            // Use actual data points, or just current if no history
            // Note: We reference arrays directly for pulse animation, only copy when data changes
            let data = chartDataPoints.length > 0 ? chartDataPoints : [current];
            let timestamps = chartTimestamps;
            let cumulatives = chartCumulatives;

            // Ensure current is last point (only modify if needed)
            if (data.length === 0 || data[data.length - 1] !== current) {
                data = [...data, current];
                timestamps = [...timestamps, Math.floor(Date.now() / 1000)];
            }

            // Downsample for large datasets (keep max ~300 points for smooth rendering)
            const maxDisplayPoints = 300;
            let downsampleFactor = 1;
            if (data.length > maxDisplayPoints) {
                downsampleFactor = Math.ceil(data.length / maxDisplayPoints);
                const sampledData = [];
                const sampledTimestamps = [];
                const sampledCumulatives = [];
                for (let i = 0; i < data.length; i += downsampleFactor) {
                    sampledData.push(data[i]);
                    if (timestamps[i] !== undefined) sampledTimestamps.push(timestamps[i]);
                    if (cumulatives[i] !== undefined) sampledCumulatives.push(cumulatives[i]);
                }
                // Always include the last point
                if (sampledData[sampledData.length - 1] !== data[data.length - 1]) {
                    sampledData.push(data[data.length - 1]);
                    if (timestamps.length > 0) sampledTimestamps.push(timestamps[timestamps.length - 1]);
                    if (cumulatives.length > 0) sampledCumulatives.push(cumulatives[cumulatives.length - 1]);
                }
                data = sampledData;
                timestamps = sampledTimestamps;
                cumulatives = sampledCumulatives;
            }

            // Compute rolling TWAP from cumulative observations
            let rollingTwap = [];
            if (cumulatives.length >= 2 && startTime) {
                for (let i = 0; i < cumulatives.length; i++) {
                    const elapsed = timestamps[i] - startTime;
                    if (elapsed > 0) {
                        rollingTwap.push(cumulatives[i] / elapsed / 1e9);
                    } else {
                        rollingTwap.push(data[i]);
                    }
                }
            }
            // Add current TWAP as final point if needed
            if (rollingTwap.length > 0 && rollingTwap.length < data.length) {
                rollingTwap.push(twap);
            }

            // Calculate Y range (include rolling TWAP but only reasonable predictions)
            const allValues = [...data, twap];
            if (rollingTwap.length > 0) allValues.push(...rollingTwap);

            // Calculate base range from actual data first
            const dataMin = Math.min(...data);
            const dataMax = Math.max(...data);
            const dataRange = dataMax - dataMin;

            // Only include predictions if they're within 3x of the data range
            // This prevents extreme outliers from distorting the chart
            const addPredictionIfReasonable = (pred) => {
                if (!pred || pred <= 0) return;
                // Check if prediction is within reasonable bounds (within 3x range of data)
                const upperBound = dataMax + dataRange * 2;
                const lowerBound = Math.max(0, dataMin - dataRange * 2);
                if (pred >= lowerBound && pred <= upperBound) {
                    allValues.push(pred);
                }
            };
            addPredictionIfReasonable(markets.hourly?.predictedTwap);
            addPredictionIfReasonable(markets.daily?.predictedTwap);
            addPredictionIfReasonable(markets.weekly?.predictedTwap);

            let max = Math.max(...allValues) * 1.1;
            let min = Math.min(...allValues) * 0.9;

            // Ensure non-zero range to prevent division by zero
            const range = Math.max(max - min, 0.001);
            const gweiToY = (gwei) => padding + (height - padding * 2) * (1 - (gwei - min) / range);

            // Determine decimal places based on range
            const getDecimals = (r) => {
                if (r >= 10) return 0;
                if (r >= 1) return 1;
                if (r >= 0.1) return 2;
                if (r >= 0.01) return 3;
                return 4;
            };
            const decimals = getDecimals(range);

            // Draw grid - responsive Y-axis labels
            const axisFontSize = isMobile ? 8 : (isSmall ? 9 : 10);
            ctx.strokeStyle = '#27272a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = padding + (height - padding * 2) * i / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(padding + chartWidth, y);
                ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'right';
                ctx.fillText((max - range * i / 4).toFixed(decimals), padding - (isMobile ? 3 : 5), y + 4);
            }

            // Draw time axis labels (X-axis)
            if (timestamps.length > 1) {
                const firstTime = timestamps[0];
                const lastTime = timestamps[timestamps.length - 1];
                const timeSpan = lastTime - firstTime;

                // Determine time format based on span
                const formatTime = (ts) => {
                    const d = new Date(ts * 1000);
                    if (timeSpan < 86400) { // < 1 day: show hours
                        return d.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                    } else if (timeSpan < 604800) { // < 1 week: show day + hour
                        return d.toLocaleDateString(undefined, { weekday: 'short', hour: '2-digit' });
                    } else { // >= 1 week: show date
                        return d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                    }
                };

                // Draw 3-5 time labels evenly spaced - responsive
                const numLabels = isMobile ? Math.min(3, data.length) : Math.min(5, data.length);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.font = `${axisFontSize}px Helvetica`;
                ctx.textAlign = 'center';
                for (let i = 0; i < numLabels; i++) {
                    const idx = Math.floor(i * (timestamps.length - 1) / (numLabels - 1));
                    const x = padding + chartWidth * idx / Math.max(1, data.length - 1);
                    const label = formatTime(timestamps[idx]);
                    ctx.fillText(label, x, height - padding + (isMobile ? 18 : 28));
                }
            }

            // Draw rolling TWAP line (cyan, behind spot line)
            if (rollingTwap.length > 1) {
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);
                ctx.beginPath();
                for (let i = 0; i < rollingTwap.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(rollingTwap[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // Draw current TWAP reference (final value as horizontal dashed line) - responsive
            const twapY = gweiToY(twap);
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(padding, twapY);
            ctx.lineTo(padding + chartWidth, twapY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#3b82f6';
            ctx.font = `${axisFontSize}px Helvetica`;
            ctx.textAlign = 'left';
            // On mobile, show just value; on desktop show "TWAP" label
            const twapLabel = isMobile ? twap.toFixed(decimals) : ('TWAP ' + twap.toFixed(decimals));
            ctx.fillText(twapLabel, padding + chartWidth + (isMobile ? 3 : 5), twapY + 4);

            // Draw line chart connecting data points (spot prices)
            if (data.length > 0) {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw gradient fill under spot line
                const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
                gradient.addColorStop(0, 'rgba(34, 197, 94, 0.15)');
                gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.moveTo(padding, height - padding);
                for (let i = 0; i < data.length; i++) {
                    const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                    const y = gweiToY(data[i]);
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(padding + chartWidth, height - padding);
                ctx.closePath();
                ctx.fill();

                // Find min/max values and indices
                let minVal = Infinity, maxVal = -Infinity, minIdx = 0, maxIdx = 0;
                for (let i = 0; i < data.length; i++) {
                    if (data[i] < minVal) { minVal = data[i]; minIdx = i; }
                    if (data[i] > maxVal) { maxVal = data[i]; maxIdx = i; }
                }

                // Draw data points (skip for large datasets - line is enough)
                if (data.length <= 100) {
                    const pointSize = data.length > 50 ? 2 : (data.length > 20 ? 3 : 4);
                    ctx.fillStyle = '#22c55e';
                    for (let i = 0; i < data.length; i++) {
                        const x = padding + chartWidth * i / Math.max(1, data.length - 1);
                        const y = gweiToY(data[i]);
                        ctx.beginPath();
                        ctx.arc(x, y, i === data.length - 1 ? 6 : pointSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw min/max markers (subtle, just small indicators)
                if (data.length > 3) {
                    // Max marker - small diamond
                    const maxX = padding + chartWidth * maxIdx / Math.max(1, data.length - 1);
                    const maxY = gweiToY(maxVal);
                    if (maxIdx !== data.length - 1) { // Don't mark if it's the current point
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(maxX, maxY - 6);
                        ctx.lineTo(maxX + 4, maxY);
                        ctx.lineTo(maxX, maxY + 6);
                        ctx.lineTo(maxX - 4, maxY);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Min marker - small diamond (only if significantly different position)
                    if (Math.abs(minIdx - maxIdx) > 2 && minIdx !== data.length - 1) {
                        const minX = padding + chartWidth * minIdx / Math.max(1, data.length - 1);
                        const minY = gweiToY(minVal);
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.6)';
                        ctx.beginPath();
                        ctx.moveTo(minX, minY - 5);
                        ctx.lineTo(minX + 3, minY);
                        ctx.lineTo(minX, minY + 5);
                        ctx.lineTo(minX - 3, minY);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw crosshair on hover
                if (hoverIndex >= 0 && hoverIndex < data.length) {
                    const hoverX = padding + chartWidth * hoverIndex / Math.max(1, data.length - 1);
                    const hoverY = gweiToY(data[hoverIndex]);

                    // Vertical line
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(hoverX, padding);
                    ctx.lineTo(hoverX, height - padding);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Highlight circle on spot line
                    ctx.strokeStyle = '#22c55e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(hoverX, hoverY, 8, 0, Math.PI * 2);
                    ctx.stroke();

                    // Also highlight TWAP point if available
                    if (rollingTwap && rollingTwap[hoverIndex]) {
                        const twapHoverY = gweiToY(rollingTwap[hoverIndex]);
                        ctx.strokeStyle = '#3b82f6';
                        ctx.beginPath();
                        ctx.arc(hoverX, twapHoverY, 6, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }

                // Pulsing live point (outer glow) - responsive
                const lastX = padding + chartWidth;
                const lastY = gweiToY(data[data.length - 1]);
                const pulseTime = Date.now() / 1000;
                const pulseScale = 1 + 0.3 * Math.sin(pulseTime * 3);
                const pulseRadius = isMobile ? 8 : 12;
                ctx.fillStyle = 'rgba(34, 197, 94, 0.25)';
                ctx.beginPath();
                ctx.arc(lastX, lastY, pulseRadius * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                // White center on current point
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(lastX, lastY, isMobile ? 1.5 : 2, 0, Math.PI * 2);
                ctx.fill();

                // Current value label (next to live point) - responsive
                const currentLabel = data[data.length - 1].toFixed(decimals);
                ctx.font = `bold ${axisFontSize}px Helvetica`;
                ctx.textAlign = 'left';
                ctx.fillStyle = '#22c55e';
                const labelOffset = isMobile ? 12 : 18;
                const labelY = lastY < padding + 30 ? lastY + labelOffset : lastY - (isMobile ? 8 : 12);
                ctx.fillText(currentLabel, lastX + (isMobile ? 6 : 10), labelY);
            }

            // Price change badge (top-left, inside chart with subtle background)
            if (data.length > 1 && timestamps.length > 1) {
                const firstVal = data[0];
                const lastVal = data[data.length - 1];
                const change = ((lastVal - firstVal) / firstVal) * 100;
                const changeColor = change >= 0 ? '#22c55e' : '#ef4444';
                const changeSign = change >= 0 ? '+' : '';
                const changeText = changeSign + change.toFixed(1) + '%';

                // Calculate time period for context
                const timeSpan = timestamps[timestamps.length - 1] - timestamps[0];
                let periodLabel = '';
                if (timeSpan < 3600) {
                    periodLabel = Math.round(timeSpan / 60) + 'm';
                } else if (timeSpan < 86400) {
                    periodLabel = Math.round(timeSpan / 3600) + 'h';
                } else {
                    periodLabel = Math.round(timeSpan / 86400) + 'd';
                }

                // Responsive badge sizing
                const badgeFontBold = isMobile ? 8 : (isSmall ? 9 : 10);
                const badgeFontSmall = isMobile ? 7 : (isSmall ? 8 : 9);
                ctx.font = `bold ${badgeFontBold}px Helvetica`;
                const changeWidth = ctx.measureText(changeText).width;
                ctx.font = `${badgeFontSmall}px Helvetica`;
                const periodWidth = ctx.measureText(periodLabel).width;
                const totalWidth = changeWidth + periodWidth + (isMobile ? 4 : 6);

                // Draw subtle pill background - top left, above chart area - responsive
                const pillX = isMobile ? 4 : 8;
                const pillY = isMobile ? 10 : 12;
                const pillPadX = isMobile ? 4 : 6;
                const pillPadY = isMobile ? 3 : 4;
                const pillHeight = isMobile ? 13 : 16;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.roundRect(pillX - pillPadX, pillY - pillPadY - (isMobile ? 6 : 8), totalWidth + pillPadX * 2, pillHeight, 4);
                ctx.fill();

                // Draw change percentage
                ctx.textAlign = 'left';
                ctx.font = `bold ${badgeFontBold}px Helvetica`;
                ctx.fillStyle = changeColor;
                ctx.fillText(changeText, pillX, pillY);

                // Draw period label
                ctx.font = `${badgeFontSmall}px Helvetica`;
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText(periodLabel, pillX + changeWidth + (isMobile ? 3 : 4), pillY);

                // Store hit area for hover detection
                priceChangeBadgeArea = {
                    x: pillX - pillPadX,
                    y: pillY - pillPadY - (isMobile ? 6 : 8),
                    width: totalWidth + pillPadX * 2,
                    height: pillHeight,
                    change,
                    firstVal,
                    lastVal,
                    timeSpan,
                    periodLabel
                };
            } else {
                priceChangeBadgeArea = null;
            }

            // Legend - top-right corner, above chart area - responsive
            const legendFontSize = isMobile ? 7 : (isSmall ? 8 : 9);
            ctx.font = `${legendFontSize}px Helvetica`;
            ctx.textAlign = 'right';
            const legendY = isMobile ? 10 : 12;
            const legendSpacing = isMobile ? 30 : 40;
            ctx.fillStyle = 'rgba(34, 197, 94, 0.9)';
            ctx.fillText('â— Spot', width - legendSpacing * 2 - 5, legendY);
            ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
            ctx.fillText('â€• TWAP', width - legendSpacing - 5, legendY);
            ctx.fillStyle = 'rgba(245, 158, 11, 0.9)';
            ctx.fillText('â—† Pred', width - 5, legendY);

            // Draw prediction markers for each market
            drawPredictionMarkers(ctx, width, height, padding, chartWidth, gweiToY, timestamps, decimals);

            // Observation count (bottom-left) - show original count, not downsampled - responsive
            const originalCount = chartDataPoints.length || 1;
            ctx.textAlign = 'left';
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.font = `${legendFontSize}px Helvetica`;
            ctx.fillText(`${originalCount} obs`, padding, height - padding + (isMobile ? 8 : 12));

            // Store state for tooltips (include rolling TWAP for tooltip display)
            chartState = { data, rollingTwap, padding, chartWidth, min, max, width, height, twap, current, timestamps, downsampleFactor };
        }

        /**
         * Draw prediction markers on the chart for each market's close time
         */
        function drawPredictionMarkers(ctx, width, height, padding, chartWidth, gweiToY, timestamps, decimals) {
            // Clear previous marker positions for hover detection
            predictionMarkerPositions = [];

            if (!timestamps || timestamps.length < 2) return;

            const firstTime = timestamps[0];
            const lastTime = timestamps[timestamps.length - 1];
            const timeRange = lastTime - firstTime;
            if (timeRange <= 0) return;

            // Responsive sizing based on canvas width
            const isMobile = width < 400;
            const isSmall = width < 600;

            const chartRightEdge = padding + chartWidth;

            // Draw "NOW" separator line - vertical dashed line at chart edge
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(chartRightEdge, padding);
            ctx.lineTo(chartRightEdge, height - padding);
            ctx.stroke();
            ctx.setLineDash([]);

            // "NOW" label at top
            ctx.font = isMobile ? 'bold 7px Helvetica' : 'bold 9px Helvetica';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.textAlign = 'center';
            ctx.fillText('NOW', chartRightEdge, padding - (isMobile ? 4 : 6));

            // Subtle gradient overlay for prediction zone
            const predZoneGradient = ctx.createLinearGradient(chartRightEdge, 0, width, 0);
            predZoneGradient.addColorStop(0, 'rgba(255, 255, 255, 0.02)');
            predZoneGradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
            ctx.fillStyle = predZoneGradient;
            ctx.fillRect(chartRightEdge, padding, width - chartRightEdge - 5, height - padding * 2);

            // Colors for each market type
            const marketColors = {
                hourly: '#f59e0b',  // amber
                daily: '#8b5cf6',   // purple
                weekly: '#06b6d4'   // cyan
            };

            const marketLabels = {
                hourly: '1H',
                daily: '1D',
                weekly: '1W'
            };

            // Animation time for pulse effect
            const pulseTime = Date.now() / 1000;

            // Draw predictions for each market (reverse order so hourly renders on top)
            ['weekly', 'daily', 'hourly'].forEach(type => {
                const market = markets[type];
                if (!market || !market.predictedTwap || !market.close) return;

                const closeTime = market.close;
                const predicted = market.predictedTwap;
                const yesPrice = market.yesPrice;
                const isHourly = type === 'hourly';

                // Calculate X position: extend chart to show future predictions
                const timeOffset = closeTime - lastTime;
                const futureExtend = Math.min(timeOffset / timeRange, 0.35);

                // Position: right edge + proportional future offset
                const xPos = padding + chartWidth + futureExtend * chartWidth;

                // Only draw if within canvas bounds
                if (xPos > width - (isMobile ? 8 : 15)) return;

                // Calculate Y position - raw for line, clamped for marker/labels
                const rawYPos = gweiToY(predicted);
                // Clamp marker position to ensure labels fit (but line uses raw position)
                const minY = padding + (isMobile ? 25 : 35);
                const maxY = height - padding - (isMobile ? 30 : 45);
                const markerYPos = Math.max(minY, Math.min(rawYPos, maxY));

                const color = marketColors[type];
                const label = marketLabels[type];

                // Draw connecting line from current TWAP to ACTUAL prediction position (not clamped)
                // Gradient line that fades toward prediction
                const lineGradient = ctx.createLinearGradient(chartRightEdge, 0, xPos, 0);
                lineGradient.addColorStop(0, color);
                lineGradient.addColorStop(1, color + '80'); // 50% opacity at end
                ctx.strokeStyle = lineGradient;
                ctx.lineWidth = isHourly ? 2 : 1;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(chartRightEdge, gweiToY(cachedGasData.twap));
                ctx.lineTo(xPos, rawYPos); // Use raw position for accurate line direction
                ctx.stroke();
                ctx.setLineDash([]);

                // Marker size (hourly is larger and more prominent) - responsive
                // Increased sizes on mobile for better visibility
                const markerSize = isMobile
                    ? (isHourly ? 9 : 6)
                    : (isSmall ? (isHourly ? 9 : 7) : (isHourly ? 10 : 7));

                // Draw glow effect for markers - more prominent on mobile for visibility
                const glowSize = isMobile
                    ? (isHourly ? (markerSize + 8 + Math.sin(pulseTime * 3) * 3) : (markerSize + 5))
                    : (isHourly ? (markerSize + 8 + Math.sin(pulseTime * 3) * 3) : (markerSize + 4));
                const glowGradient = ctx.createRadialGradient(xPos, markerYPos, 0, xPos, markerYPos, glowSize);
                glowGradient.addColorStop(0, color + '40');
                glowGradient.addColorStop(1, color + '00');
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(xPos, markerYPos, glowSize, 0, Math.PI * 2);
                ctx.fill();

                // Draw prediction diamond marker
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(xPos, markerYPos - markerSize);
                ctx.lineTo(xPos + markerSize * 0.7, markerYPos);
                ctx.lineTo(xPos, markerYPos + markerSize);
                ctx.lineTo(xPos - markerSize * 0.7, markerYPos);
                ctx.closePath();
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#18181b';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Inner highlight
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(xPos, markerYPos - markerSize + 2);
                ctx.lineTo(xPos + markerSize * 0.5, markerYPos);
                ctx.stroke();

                // Hover highlight ring
                if (hoveredPrediction === type) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(xPos, markerYPos, markerSize + 6, 0, Math.PI * 2);
                    ctx.stroke();

                    // Extra glow on hover
                    const hoverGlow = ctx.createRadialGradient(xPos, markerYPos, markerSize, xPos, markerYPos, markerSize + 20);
                    hoverGlow.addColorStop(0, color + '60');
                    hoverGlow.addColorStop(1, color + '00');
                    ctx.fillStyle = hoverGlow;
                    ctx.beginPath();
                    ctx.arc(xPos, markerYPos, markerSize + 20, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw pill-style label badge - responsive sizing
                // On mobile, show value inline with label for better visibility
                // Use at least 2 decimals for small values (<1 gwei) to avoid misleading rounding
                const valueDecimals = predicted < 1 ? Math.max(2, decimals) : (decimals > 1 ? 1 : decimals);
                const valueText = predicted.toFixed(valueDecimals);
                const timeText = formatCloseTime(closeTime);

                const pillFontSize = isMobile ? 9 : (isSmall ? 9 : 10);
                const combinedLabel = isMobile ? `${label} ${valueText}` : label;
                ctx.font = `bold ${pillFontSize}px Helvetica`;
                const labelWidth = ctx.measureText(combinedLabel).width;
                const pillWidth = isMobile ? Math.max(labelWidth + 10, 45) : Math.max(labelWidth + 12, 28);
                const pillHeight = isMobile ? 16 : (isSmall ? 16 : 18);
                const pillX = xPos - pillWidth / 2;
                const pillY = markerYPos - markerSize - pillHeight - (isMobile ? 3 : 6);

                // Pill background
                ctx.fillStyle = color + 'E0';
                ctx.beginPath();
                ctx.roundRect(pillX, pillY, pillWidth, pillHeight, 4);
                ctx.fill();

                // Pill border
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Label text (on mobile includes value, on desktop just label)
                ctx.fillStyle = '#18181b';
                ctx.font = `bold ${pillFontSize}px Helvetica`;
                ctx.textAlign = 'center';
                ctx.fillText(combinedLabel, xPos, pillY + (isMobile ? 12 : 13));

                // Close time label (below pill) - hide on mobile to reduce clutter
                if (!isMobile) {
                    ctx.font = isSmall ? '8px Helvetica' : '9px Helvetica';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(timeText, xPos, pillY + pillHeight + 10);
                }

                // Predicted value (below marker) - on mobile just show "gwei" since value is in pill
                const valueFontSize = isMobile
                    ? (isHourly ? 10 : 9)
                    : (isSmall ? (isHourly ? 10 : 9) : (isHourly ? 11 : 10));
                ctx.font = isHourly ? `bold ${valueFontSize}px Helvetica` : `${valueFontSize}px Helvetica`;
                ctx.fillStyle = isHourly ? '#fff' : 'rgba(255,255,255,0.8)';
                // On mobile, value is already in the pill label
                if (isMobile) {
                    ctx.fillText('gwei', xPos, markerYPos + markerSize + 10);
                } else {
                    ctx.fillText(valueText + ' gwei', xPos, markerYPos + markerSize + 16);
                }

                // Draw odds indicator bar - responsive sizing
                const barWidth = isMobile
                    ? (isHourly ? 26 : 18)
                    : (isSmall ? (isHourly ? 26 : 20) : (isHourly ? 32 : 24));
                const barHeight = isMobile ? 4 : (isHourly ? 5 : 4);
                const barX = xPos - barWidth / 2;
                const barY = markerYPos + markerSize + (isMobile ? 14 : 22);

                // Bar background with rounded ends
                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.beginPath();
                ctx.roundRect(barX, barY, barWidth, barHeight, 2);
                ctx.fill();

                // Fill based on YES odds - neutral gray if near 50/50
                const yesPct = Math.round(yesPrice * 100);
                const isNeutralOdds = yesPct >= 45 && yesPct <= 55;
                const oddsColor = isNeutralOdds ? '#71717a' : (yesPrice > 0.5 ? '#22c55e' : '#ef4444');
                ctx.fillStyle = oddsColor;
                ctx.beginPath();
                ctx.roundRect(barX, barY, barWidth * yesPrice, barHeight, 2);
                ctx.fill();

                // Odds percentage label for hourly - hide on mobile to reduce clutter
                if (isHourly && !isMobile) {
                    ctx.font = isSmall ? '7px Helvetica' : '8px Helvetica';
                    ctx.fillStyle = 'rgba(255,255,255,0.5)';
                    if (isNeutralOdds) {
                        ctx.fillText('~50% EVEN', xPos, barY + barHeight + 10);
                    } else {
                        ctx.fillText(yesPct + '% UP', xPos, barY + barHeight + 10);
                    }
                }

                // Store marker position for hover detection
                // Hit area is the entire prediction card region (pill to odds bar)
                // Larger hit radius on mobile for easier touch targets
                const hitRadius = isMobile
                    ? (isHourly ? 28 : 22)
                    : (isHourly ? 35 : 28);
                predictionMarkerPositions.push({
                    type,
                    x: xPos,
                    y: markerYPos,
                    radius: hitRadius,
                    predicted,
                    yesPrice,
                    noPrice: market.noPrice,
                    closeTime,
                    color,
                    label
                });
            });
        }

        // Format close time for display
        function formatCloseTime(timestamp) {
            const date = new Date(timestamp * 1000);
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const ampm = hours >= 12 ? 'PM' : 'AM';
            const h = hours % 12 || 12;
            const m = minutes.toString().padStart(2, '0');
            return h + ':' + m + ' ' + ampm;
        }

        // ======================== COUNTDOWNS ========================
        // Cache next period timestamps to avoid creating Date objects every second
        let cachedPeriods = { nextHour: 0, nextDay: 0, nextWeek: 0 };

        function updateCountdowns() {
            const now = Math.floor(Date.now() / 1000);

            // Hourly
            if (markets.hourly) {
                DOM.hourlyCountdown.textContent = formatTime(markets.hourly.close - now);
            } else {
                if (cachedPeriods.nextHour <= now) {
                    const nextHour = new Date();
                    nextHour.setUTCMinutes(60, 0, 0);
                    cachedPeriods.nextHour = Math.floor(nextHour.getTime() / 1000);
                }
                DOM.hourlyCountdown.textContent = formatTime(cachedPeriods.nextHour - now);
            }

            // Daily
            if (markets.daily) {
                DOM.dailyCountdown.textContent = formatTime(markets.daily.close - now);
            } else {
                if (cachedPeriods.nextDay <= now) {
                    const tomorrow = new Date();
                    tomorrow.setUTCHours(24, 0, 0, 0);
                    cachedPeriods.nextDay = Math.floor(tomorrow.getTime() / 1000);
                }
                DOM.dailyCountdown.textContent = formatTime(cachedPeriods.nextDay - now);
            }

            // Weekly
            if (markets.weekly) {
                DOM.weeklyCountdown.textContent = formatTime(markets.weekly.close - now);
            } else {
                if (cachedPeriods.nextWeek <= now) {
                    const sun = new Date();
                    sun.setUTCDate(sun.getUTCDate() + (7 - sun.getUTCDay()));
                    sun.setUTCHours(0, 0, 0, 0);
                    cachedPeriods.nextWeek = Math.floor(sun.getTime() / 1000);
                }
                DOM.weeklyCountdown.textContent = formatTime(cachedPeriods.nextWeek - now);
            }

            // Extreme
            if (markets.extreme) {
                const remaining = markets.extreme.close - now;
                if (remaining <= 0) {
                    DOM.extremeCountdown.textContent = 'Ended';
                } else {
                    const days = Math.floor(remaining / 86400);
                    DOM.extremeCountdown.textContent = days + ' days';
                }
            }
        }

        function formatTime(s) {
            if (s <= 0) return 'Ended';
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h >= 24) return Math.floor(h / 24) + 'd ' + (h % 24) + 'h';
            if (h > 0) return h + 'h ' + m + 'm';
            if (m > 0) return m + 'm ' + sec + 's';
            return sec + 's';
        }

        // ======================== TRADING ========================
        async function openTrade(type, isYes) {
            const market = markets[type];
            if (!market) { alert('No active market'); return; }
            if (!connectedAddress) { alert('Connect wallet first'); return; }

            currentTrade = { type, isYes, marketId: market.id };
            currentTradeMode = 'buy';

            // Load user position and orderbook in parallel
            await Promise.all([
                loadUserPosition(market.id),
                loadOrderbook(market.id, isYes)
            ]);

            const label = isYes ? (type === 'extreme' ? 'YES' : 'UP') : (type === 'extreme' ? 'NO' : 'DOWN');
            document.getElementById('tradeTitle').textContent = 'Trade ' + label;

            // Reset to buy mode
            setTradeMode('buy');

            document.getElementById('tradeAmount').value = '';
            updatePreview();
            document.getElementById('tradeModal').classList.add('active');
        }

        async function loadUserPosition(marketId) {
            if (!connectedAddress) {
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                const zamm = new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, rpc);

                // Get noId and poolKey for LP balance
                const [noId, poolKey] = await Promise.all([
                    pamm.getNoId(marketId),
                    pamm.poolKey(marketId, FEE_TIER)
                ]);

                // Compute pool ID (LP token ID) = keccak256(abi.encode(id0, id1, token0, token1, feeOrHook))
                const poolId = ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
                    ['uint256', 'uint256', 'address', 'address', 'uint256'],
                    [poolKey.id0, poolKey.id1, poolKey.token0, poolKey.token1, poolKey.feeOrHook]
                ));

                const [yesBal, noBal, lpBal] = await Promise.all([
                    pamm.balanceOf(connectedAddress, marketId),
                    pamm.balanceOf(connectedAddress, noId),
                    zamm.balanceOf(connectedAddress, poolId)
                ]);
                currentUserPosition = { yesBalance: yesBal, noBalance: noBal, lpBalance: lpBal, poolId };
            } catch (e) {
                console.error('Failed to load position:', e);
                currentUserPosition = { yesBalance: 0n, noBalance: 0n, lpBalance: 0n };
            }

            // Update modal display
            document.getElementById('tradeModalYes').textContent = parseFloat(ethers.formatEther(currentUserPosition.yesBalance)).toFixed(4);
            document.getElementById('tradeModalNo').textContent = parseFloat(ethers.formatEther(currentUserPosition.noBalance)).toFixed(4);
            document.getElementById('tradeModalLP').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
        }

        let currentOrderbook = { bids: [], asks: [], bidHashes: [], askHashes: [], ammPrice: 0, rYes: 0n, rNo: 0n };

        async function loadOrderbook(marketId, isYes) {
            const asksContainer = document.getElementById('orderbookAsks');
            const bidsContainer = document.getElementById('orderbookBids');
            const spreadEl = document.getElementById('orderbookSpread');
            const emptyEl = document.getElementById('orderbookEmpty');
            const bodyEl = document.querySelector('.orderbook-body');

            // Clear and show loading state
            asksContainer.innerHTML = '<div class="orderbook-empty">Loading...</div>';
            bidsContainer.innerHTML = '';
            spreadEl.textContent = 'Spread: --';

            try {
                const rpc = provider || await getRpcProvider();

                // Always fetch AMM pool price first (available even without PMRouter)
                let ammPrice = 0;
                let rYesBigInt = 0n, rNoBigInt = 0n;
                try {
                    const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, rpc);
                    const [rYes, rNo, pYesNum, pYesDen] = await pamm.getPoolState(marketId, FEE_TIER);
                    rYesBigInt = rYes;
                    rNoBigInt = rNo;
                    // AMM price for YES = rNo / (rYes + rNo), for NO = rYes / (rYes + rNo)
                    ammPrice = isYes ?
                        Number(pYesNum) / Number(pYesDen) :
                        (Number(pYesDen) - Number(pYesNum)) / Number(pYesDen);
                } catch (e) {
                    console.warn('Could not get AMM price:', e);
                }

                currentOrderbook.ammPrice = ammPrice;
                currentOrderbook.rYes = rYesBigInt;
                currentOrderbook.rNo = rNoBigInt;

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                const depth = 10; // Max orders per side
                const [bidHashes, bidOrders, askHashes, askOrders] = await pmRouter.getOrderbook(marketId, isYes, depth);

                // Preserve rYes/rNo when updating orderbook
                currentOrderbook = {
                    bids: bidOrders.map((o, i) => ({ ...o, hash: bidHashes[i] })),
                    asks: askOrders.map((o, i) => ({ ...o, hash: askHashes[i] })),
                    bidHashes,
                    askHashes,
                    ammPrice,
                    rYes: rYesBigInt,
                    rNo: rNoBigInt
                };

                // Process and display orders
                const formatOrder = (order) => {
                    // Price = collateral / shares (guard against zero shares)
                    const shares = Number(order.shares);
                    const price = shares > 0 ? Number(order.collateral) / shares : 0;
                    const size = shares / 1e18;
                    return { price, size, order };
                };

                const bids = currentOrderbook.bids.map(o => formatOrder(o)).sort((a, b) => b.price - a.price);
                const asks = currentOrderbook.asks.map(o => formatOrder(o)).sort((a, b) => a.price - b.price);

                // Clear containers
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';

                bodyEl.style.display = 'block';
                emptyEl.style.display = 'none';

                // Render asks (sell orders) - displayed in reverse (lowest at bottom)
                // Asks that are cheaper than AMM are better deals for buyers
                // Calculate cumulative depth for asks (from lowest price up)
                let askCumulative = 0;
                const asksWithCumulative = asks.map(a => {
                    askCumulative += a.size;
                    return { ...a, cumulative: askCumulative };
                });

                // Render asks (sell orders) - note: asks are displayed in reverse order
                // So we need to reverse the cumulative calculation for display
                asksWithCumulative.forEach((a, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && a.price < ammPrice;
                    row.className = 'orderbook-row ask' + (isBetterDeal ? ' better-deal' : '');
                    row.innerHTML = `<span class="price">${a.price.toFixed(4)}${isBetterDeal ? ' â˜…' : ''}</span><span class="size">${a.size.toFixed(4)}</span><span class="total">${a.cumulative.toFixed(2)}</span>`;
                    row.title = isBetterDeal ? `Better than AMM (${ammPrice.toFixed(4)}) - Click to fill` : `Click to fill`;
                    row.onclick = () => fillOrderFromBook(a.order, false, idx);
                    asksContainer.appendChild(row);
                });

                // Calculate cumulative depth for bids (from highest price down)
                let bidCumulative = 0;
                const bidsWithCumulative = bids.map(b => {
                    bidCumulative += b.size;
                    return { ...b, cumulative: bidCumulative };
                });

                // Render bids (buy orders)
                // Bids that are higher than AMM are better deals for sellers
                bidsWithCumulative.forEach((b, idx) => {
                    const row = document.createElement('div');
                    const isBetterDeal = ammPrice > 0 && b.price > ammPrice;
                    row.className = 'orderbook-row bid' + (isBetterDeal ? ' better-deal' : '');
                    row.innerHTML = `<span class="price">${b.price.toFixed(4)}${isBetterDeal ? ' â˜…' : ''}</span><span class="size">${b.size.toFixed(4)}</span><span class="total">${b.cumulative.toFixed(2)}</span>`;
                    row.title = isBetterDeal ? `Better than AMM (${ammPrice.toFixed(4)}) - Click to fill` : `Click to fill`;
                    row.onclick = () => fillOrderFromBook(b.order, true, idx);
                    bidsContainer.appendChild(row);
                });

                // Show AMM price in spread area if no orders
                if (bids.length === 0 && asks.length === 0) {
                    if (ammPrice > 0) {
                        spreadEl.textContent = `AMM: ${ammPrice.toFixed(4)} ETH`;
                    } else {
                        bodyEl.style.display = 'none';
                        emptyEl.style.display = 'block';
                        emptyEl.textContent = 'No liquidity';
                    }
                    return;
                }

                // Calculate and display spread with AMM reference
                const bestAsk = asks.length > 0 ? asks[0].price : null;
                const bestBid = bids.length > 0 ? bids[0].price : null;

                if (bestAsk && bestBid) {
                    const spread = ((bestAsk - bestBid) / bestAsk * 100).toFixed(1);
                    spreadEl.innerHTML = ammPrice > 0 ?
                        `AMM: ${ammPrice.toFixed(4)} | Spread: ${spread}%` :
                        `Spread: ${spread}%`;
                } else if (ammPrice > 0) {
                    const ref = bestAsk ? `Ask: ${bestAsk.toFixed(4)}` : bestBid ? `Bid: ${bestBid.toFixed(4)}` : '';
                    spreadEl.textContent = `AMM: ${ammPrice.toFixed(4)} | ${ref}`;
                } else {
                    spreadEl.textContent = bestAsk ? `Best Ask: ${bestAsk.toFixed(4)}` :
                                          bestBid ? `Best Bid: ${bestBid.toFixed(4)}` : '--';
                }

            } catch (e) {
                console.error('Failed to load orderbook:', e);
                asksContainer.innerHTML = '';
                bidsContainer.innerHTML = '';
                bodyEl.style.display = 'none';
                emptyEl.style.display = 'block';
                emptyEl.textContent = 'Failed to load orderbook';
            }
        }

        async function fillOrderFromBook(order, isBid, idx) {
            if (!signer) {
                alert('Connect wallet to fill orders');
                return;
            }

            // Calculate order details
            const shares = Number(order.shares) / 1e18;
            const collateral = Number(order.collateral) / 1e18;
            if (shares <= 0) {
                showStatus('Invalid order (zero shares)', 'error');
                return;
            }
            const price = collateral / shares;

            // isBid means it's a BID order in the orderbook (maker wants to buy)
            // If user clicks a BID, they are selling shares to the maker
            // If user clicks an ASK, they are buying shares from the maker
            const userIsBuying = !isBid;

            // Validate user has sufficient balance
            if (userIsBuying) {
                // Check ETH balance
                const ethBal = await provider.getBalance(connectedAddress);
                if (order.collateral > ethBal) {
                    const needed = collateral.toFixed(4);
                    const have = parseFloat(ethers.formatEther(ethBal)).toFixed(4);
                    showStatus(`Insufficient ETH. Need ${needed}, have ${have}`, 'error');
                    return;
                }
            } else {
                // Check shares balance
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                if (order.shares > userShares) {
                    const needed = shares.toFixed(4);
                    const have = parseFloat(ethers.formatEther(userShares)).toFixed(4);
                    showStatus(`Insufficient shares. Need ${needed}, have ${have}`, 'error');
                    return;
                }
            }

            const actionText = userIsBuying ?
                `Buy ${shares.toFixed(4)} shares for ${collateral.toFixed(4)} ETH (${price.toFixed(4)} ETH/share)?` :
                `Sell ${shares.toFixed(4)} shares for ${collateral.toFixed(4)} ETH (${price.toFixed(4)} ETH/share)?`;

            if (!confirm(actionText)) return;

            try {
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const orderHash = order.hash;
                const sharesToFill = 0; // 0 = fill all available

                let txPromise;
                if (userIsBuying) {
                    // User buying shares: send collateral as msg.value (for ETH markets)
                    txPromise = pmRouter.fillOrder(
                        orderHash,
                        sharesToFill,
                        connectedAddress,
                        { value: order.collateral }
                    );
                } else {
                    // User selling shares: need PMRouter approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    txPromise = pmRouter.fillOrder(
                        orderHash,
                        sharesToFill,
                        connectedAddress
                    );
                }

                const actionLabel = userIsBuying ? 'Buying' : 'Selling';
                await monitorTransaction(txPromise, {
                    pending: { title: `${actionLabel} Shares`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${actionLabel} Shares`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Filled!', body: `${actionLabel} ${shares.toFixed(4)} shares` },
                    error: { title: 'Fill Failed', body: '' },
                    onSuccess: async () => {
                        await Promise.all([
                            loadOrderbook(currentTrade.marketId, currentTrade.isYes),
                            loadUserPosition(currentTrade.marketId),
                            loadBalance()
                        ]);
                    }
                });

            } catch (e) {
                if (!isUserRejection(e)) {
                    console.error('Fill order failed:', e);
                }
            }
        }

        let currentLpMode = 'add'; // 'add' or 'remove'
        let mintKeepYes = true; // true = keep YES, false = keep NO
        let limitIsBuy = true; // true = buy order, false = sell order
        let userOrders = []; // User's active orders for this market

        function setSlippage(pct) {
            if (!pct || pct <= 0) pct = 0.5;
            slippageTolerance = pct;

            // Update button states
            document.getElementById('slip05').className = pct === 0.5 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip1').className = pct === 1 ? 'slip-btn slip-active' : 'slip-btn';
            document.getElementById('slip2').className = pct === 2 ? 'slip-btn slip-active' : 'slip-btn';

            // Clear custom if using preset
            if (pct === 0.5 || pct === 1 || pct === 2) {
                document.getElementById('slipCustom').value = '';
            }

            updatePreview();
        }

        function setTradeMode(mode) {
            currentTradeMode = mode;

            const buyBtn = document.getElementById('buyModeBtn');
            const sellBtn = document.getElementById('sellModeBtn');
            const limitBtn = document.getElementById('limitModeBtn');
            const lpBtn = document.getElementById('lpModeBtn');
            const mintBtn = document.getElementById('mintModeBtn');
            const submitBtn = document.getElementById('tradeSubmit');
            const tradeSection = document.getElementById('tradeSection');
            const lpSection = document.getElementById('lpSection');
            const mintSection = document.getElementById('mintSection');
            const limitSection = document.getElementById('limitSection');
            const yourOrdersSection = document.getElementById('yourOrdersSection');
            const orderbookContainer = document.getElementById('orderbookContainer');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            // Reset all buttons using CSS classes
            buyBtn.className = 'mode-toggle-btn';
            sellBtn.className = 'mode-toggle-btn';
            limitBtn.className = 'mode-toggle-btn';
            lpBtn.className = 'mode-toggle-btn';
            mintBtn.className = 'mode-toggle-btn';

            // Hide your orders section by default
            yourOrdersSection.style.display = 'none';

            if (mode === 'buy') {
                buyBtn.className = 'mode-toggle-btn active-buy';
                tradeSection.style.display = 'block';
                lpSection.style.display = 'none';
                mintSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'block';
                document.getElementById('tradeInputLabel').textContent = 'Amount (ETH)';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Payout if win';
                submitBtn.textContent = 'Buy ' + label;
                submitBtn.className = 'trade-submit ' + (currentTrade.isYes ? 'buy-up' : 'buy-down');
            } else if (mode === 'sell') {
                sellBtn.className = 'mode-toggle-btn active-sell';
                tradeSection.style.display = 'block';
                lpSection.style.display = 'none';
                mintSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'block';
                document.getElementById('tradeInputLabel').textContent = 'Shares to sell';
                document.getElementById('tradeBalanceUnit').textContent = 'shares';
                document.getElementById('previewSharesLabel').textContent = 'You receive';
                document.getElementById('previewPayoutLabel').textContent = 'Min receive';
                submitBtn.textContent = 'Sell ' + label;
                submitBtn.className = 'trade-submit buy-down';
            } else if (mode === 'limit') {
                limitBtn.className = 'mode-toggle-btn active-limit';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                mintSection.style.display = 'none';
                limitSection.style.display = 'block';
                orderbookContainer.style.display = 'block';
                yourOrdersSection.style.display = 'block';
                updateLimitPreview();
                refreshUserOrders();
            } else if (mode === 'lp') {
                lpBtn.className = 'mode-toggle-btn active-lp';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'block';
                mintSection.style.display = 'none';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                document.getElementById('tradeInputLabel').textContent = currentLpMode === 'add' ? 'ETH to deposit' : 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = currentLpMode === 'add' ? 'ETH' : 'LP';
                updateLpPreview();
            } else if (mode === 'mint') {
                mintBtn.className = 'mode-toggle-btn active-mint';
                tradeSection.style.display = 'none';
                lpSection.style.display = 'none';
                mintSection.style.display = 'block';
                limitSection.style.display = 'none';
                orderbookContainer.style.display = 'none';
                document.getElementById('tradeInputLabel').textContent = 'ETH to mint';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                updateMintPreview();
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            if (mode !== 'lp' && mode !== 'mint' && mode !== 'limit') updatePreview();
        }

        function setLpMode(mode) {
            currentLpMode = mode;
            const addBtn = document.getElementById('addLpBtn');
            const removeBtn = document.getElementById('removeLpBtn');
            const lpSubmit = document.getElementById('lpSubmit');
            const explainer = document.getElementById('lpExplainer');

            if (mode === 'add') {
                addBtn.className = 'lp-toggle-btn active-add';
                removeBtn.className = 'lp-toggle-btn';
                document.getElementById('tradeInputLabel').textContent = 'ETH to deposit';
                document.getElementById('tradeBalanceUnit').textContent = 'ETH';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Earn 0.30% fees on every trade. Your ETH is split into YES + NO shares and deposited to the pool.';
                lpSubmit.textContent = 'Deposit Liquidity';
                lpSubmit.style.background = 'var(--blue)';
            } else {
                addBtn.className = 'lp-toggle-btn';
                removeBtn.className = 'lp-toggle-btn active-remove';
                document.getElementById('tradeInputLabel').textContent = 'LP to withdraw';
                document.getElementById('tradeBalanceUnit').textContent = 'LP';
                document.getElementById('lpPreviewLabel').textContent = 'You receive';
                explainer.textContent = 'Withdraw your liquidity. Your LP tokens are burned and you receive ETH back.';
                lpSubmit.textContent = 'Withdraw Liquidity';
                lpSubmit.style.background = 'var(--red)';
            }

            loadBalance();
            document.getElementById('tradeAmount').value = '';
            updateLpPreview();
        }

        function updateLpPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;
            const userLp = Number(currentUserPosition.lpBalance || 0n) / 1e18;
            const warningEl = document.getElementById('lpWarning');

            // Calculate pool metrics
            const rYesNum = Number(rYes) / 1e18;
            const rNoNum = Number(rNo) / 1e18;
            const poolTvl = (rYesNum + rNoNum) / 2; // ETH value (YES + NO = 2 * collateral)
            const totalLpSupply = Math.sqrt(rYesNum * rNoNum); // LP = sqrt(rYes * rNo)

            // Pool price (YES probability)
            const yesPrice = rYesNum > 0 && rNoNum > 0 ? rNoNum / (rYesNum + rNoNum) : 0.5;

            // Display pool TVL and price
            if (rYes > 0n && rNo > 0n) {
                document.getElementById('lpPoolReserves').textContent = formatEth(poolTvl);
                document.getElementById('lpPoolPrice').textContent = yesPrice.toFixed(3) + ' (' + formatOdds(yesPrice) + ' YES)';
            } else {
                document.getElementById('lpPoolReserves').textContent = '--';
                document.getElementById('lpPoolPrice').textContent = '-- (--% YES)';
            }

            // Current user position value and share
            if (userLp > 0 && totalLpSupply > 0) {
                const userShare = userLp / totalLpSupply;
                const positionValue = userShare * poolTvl * 2; // Value in ETH terms
                document.getElementById('lpPositionValue').textContent = formatEth(positionValue);
                document.getElementById('lpCurrentShare').textContent = (userShare * 100).toFixed(2) + '%';
            } else {
                document.getElementById('lpPositionValue').textContent = userLp > 0 ? formatEth(userLp, ' LP') : '0 ETH';
                document.getElementById('lpCurrentShare').textContent = '0%';
            }

            // Hide warning by default
            warningEl.style.display = 'none';

            if (amt === 0) {
                document.getElementById('lpPreview').textContent = '--';
                document.getElementById('lpPoolShare').textContent = '--%';
                return;
            }

            if (rYes === 0n || rNo === 0n) {
                // New pool - first LP
                document.getElementById('lpPreview').textContent = amt.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = '100%';
                return;
            }

            if (currentLpMode === 'add') {
                // Adding liquidity: ETH -> split -> add to pool
                // User gets LP tokens proportional to their contribution
                // New LP = (amt / poolTvl) * totalLpSupply (simplified)
                const estLp = (amt / poolTvl) * totalLpSupply;
                const newTotalLp = totalLpSupply + estLp;
                const newUserLp = userLp + estLp;
                const newShare = (newUserLp / newTotalLp) * 100;

                document.getElementById('lpPreview').textContent = estLp.toFixed(4) + ' LP tokens';
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';

                // Show IL warning for imbalanced pools
                if (yesPrice < 0.2 || yesPrice > 0.8) {
                    warningEl.textContent = 'âš ï¸ Pool is imbalanced (' + formatOdds(yesPrice) + ' YES). Higher impermanent loss risk if price moves toward 50%.';
                    warningEl.style.display = 'block';
                }
            } else {
                // Removing liquidity: LP tokens -> YES + NO -> merge -> ETH
                if (amt > userLp) {
                    document.getElementById('lpPreview').textContent = 'Exceeds balance';
                    document.getElementById('lpPoolShare').textContent = '--%';
                    return;
                }

                // Calculate how much YES + NO user gets from burning LP
                const shareOfPool = amt / totalLpSupply;
                const yesOut = shareOfPool * rYesNum;
                const noOut = shareOfPool * rNoNum;

                // Merge gives min(yesOut, noOut) ETH back, leftover shares remain
                const ethOut = Math.min(yesOut, noOut);
                const leftoverYes = yesOut - ethOut;
                const leftoverNo = noOut - ethOut;

                // Display estimated ETH back
                document.getElementById('lpPreview').textContent = ethOut.toFixed(4) + ' ETH';

                // Calculate new share
                const newUserLp = userLp - amt;
                const newTotalLp = totalLpSupply - amt;
                const newShare = newTotalLp > 0 ? (newUserLp / newTotalLp) * 100 : 0;
                document.getElementById('lpPoolShare').textContent = newShare.toFixed(2) + '%';

                // Show leftover warning if pool is imbalanced
                if (leftoverYes > 0.0001 || leftoverNo > 0.0001) {
                    const leftover = leftoverYes > leftoverNo ?
                        leftoverYes.toFixed(4) + ' YES' :
                        leftoverNo.toFixed(4) + ' NO';
                    warningEl.textContent = 'âš ï¸ Pool imbalanced. You\'ll also receive ~' + leftover + ' shares (can\'t merge).';
                    warningEl.style.display = 'block';
                }
            }
        }

        // ======================== MINT & LIST ========================
        function setMintKeep(keepYes) {
            mintKeepYes = keepYes;
            const keepYesBtn = document.getElementById('keepYesBtn');
            const keepNoBtn = document.getElementById('keepNoBtn');

            if (keepYes) {
                keepYesBtn.className = 'lp-toggle-btn active-add';
                keepNoBtn.className = 'lp-toggle-btn';
            } else {
                keepYesBtn.className = 'lp-toggle-btn';
                keepNoBtn.className = 'lp-toggle-btn active-remove';
            }
            updateMintPreview();
        }

        function updateMintPreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value) || 0;

            const keepLabel = mintKeepYes ? 'YES' : 'NO';
            const sellLabel = mintKeepYes ? 'NO' : 'YES';

            document.getElementById('mintDeposit').textContent = amt > 0 ? amt.toFixed(4) + ' ETH' : '-- ETH';
            document.getElementById('mintReceive').textContent = amt > 0 ? amt.toFixed(4) + ' YES + ' + amt.toFixed(4) + ' NO' : '-- YES + -- NO';
            document.getElementById('mintKeep').textContent = amt > 0 ? amt.toFixed(4) + ' ' + keepLabel : '-- ' + keepLabel;

            if (amt > 0 && limitPrice > 0) {
                const sellShares = amt;
                const expectedReturn = sellShares * limitPrice;
                const netCost = amt - expectedReturn;

                document.getElementById('mintList').textContent = sellShares.toFixed(4) + ' ' + sellLabel + ' @ ' + limitPrice.toFixed(2) + ' ETH';

                if (netCost > 0) {
                    document.getElementById('mintProfit').textContent = 'Net cost: ' + netCost.toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--text-muted)';
                } else {
                    document.getElementById('mintProfit').textContent = 'Net profit: ' + Math.abs(netCost).toFixed(4) + ' ETH';
                    document.getElementById('mintProfit').style.color = 'var(--green)';
                }
            } else {
                document.getElementById('mintList').textContent = '-- ' + sellLabel + ' @ -- ETH';
                document.getElementById('mintProfit').textContent = 'Net cost: -- ETH';
                document.getElementById('mintProfit').style.color = 'var(--text-muted)';
            }
        }

        async function executeMintAndList() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            const limitPrice = parseFloat(document.getElementById('mintLimitPrice').value);

            if (!amt || amt <= 0) {
                showStatus('Please enter an amount', 'error');
                return;
            }
            if (!limitPrice || limitPrice <= 0 || limitPrice >= 1) {
                showStatus('Please enter a valid limit price (0.01 - 0.99)', 'error');
                return;
            }

            try {
                // Check approvals first
                const approved = await checkAndRequestApprovals('mint');
                if (!approved) return;

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                const marketId = currentTrade.marketId;
                const amountWei = ethers.parseEther(amt.toString());
                const sharesWei = amountWei; // 1 ETH = 1 YES + 1 NO
                const collateralWei = ethers.parseEther((amt * limitPrice).toString());

                // Get market close time for deadline
                const market = await pamm.getMarket(marketId);
                const closeTime = market[5]; // close timestamp
                const deadline = closeTime;

                // Encode multicall data:
                // 1. split(marketId, amount, address(0)) - sends to msg.sender
                // 2. placeOrder(marketId, isYes, isBuy=false, shares, collateral, deadline, partialFill=true)
                const splitData = pmRouter.interface.encodeFunctionData('split', [
                    marketId,
                    amountWei,
                    ethers.ZeroAddress // defaults to msg.sender
                ]);

                const placeOrderData = pmRouter.interface.encodeFunctionData('placeOrder', [
                    marketId,
                    !mintKeepYes, // isYes = opposite of what we keep (sell the other side)
                    false, // isBuy = false (sell order)
                    sharesWei, // shares to sell
                    collateralWei, // price in ETH
                    deadline,
                    true // partialFill
                ]);

                const keepSide = mintKeepYes ? 'YES' : 'NO';
                await monitorTransaction(
                    pmRouter.multicall([splitData, placeOrderData], { value: amountWei }),
                    {
                        pending: { title: 'Mint & List', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Mint & List', body: 'Minting shares and placing order...' },
                        success: { title: 'Mint & List Success!', body: `Keeping ${amt} ${keepSide} shares, listed ${amt} at ${limitPrice.toFixed(2)}` },
                        error: { title: 'Mint & List Failed', body: '' },
                        onSuccess: async () => {
                            await loadUserPosition();
                            await loadOrderbook(marketId, currentTrade.isYes);
                            document.getElementById('tradeAmount').value = '';
                            document.getElementById('mintLimitPrice').value = '';
                            updateMintPreview();
                        }
                    }
                );
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Mint & List error:', err);
                }
            }
        }

        // ======================== LIMIT ORDERS ========================
        function setLimitSide(side) {
            limitIsBuy = (side === 'buy');
            const buyBtn = document.getElementById('limitBuyBtn');
            const sellBtn = document.getElementById('limitSellBtn');
            const submitBtn = document.getElementById('limitSubmit');
            const costLabel = document.getElementById('limitCostLabel');
            const label = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

            if (limitIsBuy) {
                buyBtn.className = 'lp-toggle-btn active-add';
                sellBtn.className = 'lp-toggle-btn';
                costLabel.textContent = 'You escrow';
                submitBtn.textContent = 'Place Buy Order';
                submitBtn.style.background = 'var(--green)';
            } else {
                buyBtn.className = 'lp-toggle-btn';
                sellBtn.className = 'lp-toggle-btn active-remove';
                costLabel.textContent = 'You escrow';
                submitBtn.textContent = 'Place Sell Order';
                submitBtn.style.background = 'var(--red)';
            }
            updateLimitPreview();
        }

        function updateLimitPreview() {
            const price = parseFloat(document.getElementById('limitPrice').value) || 0;
            const shares = parseFloat(document.getElementById('limitShares').value) || 0;
            const ammPrice = currentOrderbook.ammPrice || 0;

            const label = currentTrade.isYes ? 'YES' : 'NO';

            if (price <= 0 || shares <= 0) {
                document.getElementById('limitCost').textContent = '-- ETH';
                document.getElementById('limitReceive').textContent = '-- ' + label;
                document.getElementById('limitVsAmm').textContent = '--';
                return;
            }

            const totalCost = price * shares;

            if (limitIsBuy) {
                // Buy order: escrow ETH, receive shares when filled
                document.getElementById('limitCost').textContent = totalCost.toFixed(4) + ' ETH';
                document.getElementById('limitReceive').textContent = shares.toFixed(4) + ' ' + label;
            } else {
                // Sell order: escrow shares, receive ETH when filled
                document.getElementById('limitCost').textContent = shares.toFixed(4) + ' ' + label;
                document.getElementById('limitReceive').textContent = totalCost.toFixed(4) + ' ETH';
            }

            // Compare to AMM price
            if (ammPrice > 0) {
                const diff = ((price - ammPrice) / ammPrice * 100).toFixed(1);
                const isBetter = limitIsBuy ? price < ammPrice : price > ammPrice;
                const color = isBetter ? 'var(--green)' : 'var(--red)';
                const sign = price > ammPrice ? '+' : '';
                document.getElementById('limitVsAmm').innerHTML =
                    `<span style="color:${color}">${sign}${diff}% vs ${ammPrice.toFixed(4)}</span>`;
            } else {
                document.getElementById('limitVsAmm').textContent = 'No AMM price';
            }
        }

        async function executeLimitOrder() {
            if (!signer || !currentTrade.marketId) {
                showStatus('Please connect wallet and select a market', 'error');
                return;
            }

            const price = parseFloat(document.getElementById('limitPrice').value);
            const shares = parseFloat(document.getElementById('limitShares').value);

            if (!price || price <= 0 || price >= 1) {
                showStatus('Enter valid price (0.01 - 0.99)', 'error');
                return;
            }
            if (!shares || shares <= 0) {
                showStatus('Enter valid shares amount', 'error');
                return;
            }

            // For sell orders, validate user has enough shares
            if (!limitIsBuy) {
                const userShares = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                const sharesNeeded = ethers.parseEther(shares.toString());
                if (sharesNeeded > userShares) {
                    const available = parseFloat(ethers.formatEther(userShares)).toFixed(4);
                    showStatus(`Insufficient shares. You have ${available}`, 'error');
                    return;
                }
            }

            try {
                // For sell orders, need approval
                if (!limitIsBuy) {
                    const approved = await checkAndRequestApprovals('limit');
                    if (!approved) return;
                }

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);

                const marketId = currentTrade.marketId;
                const sharesWei = ethers.parseEther(shares.toString());
                const collateralWei = ethers.parseEther((price * shares).toString());

                // Get market close time for deadline
                const market = await pamm.getMarket(marketId);
                const closeTime = market[5];

                let txPromise;
                if (limitIsBuy) {
                    // Buy order: send ETH as value
                    txPromise = pmRouter.placeOrder(
                        marketId,
                        currentTrade.isYes,
                        true, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true, // partialFill
                        { value: collateralWei }
                    );
                } else {
                    // Sell order: no ETH value
                    txPromise = pmRouter.placeOrder(
                        marketId,
                        currentTrade.isYes,
                        false, // isBuy
                        sharesWei,
                        collateralWei,
                        closeTime,
                        true // partialFill
                    );
                }

                const orderType = limitIsBuy ? 'Buy' : 'Sell';
                await monitorTransaction(txPromise, {
                    pending: { title: `Placing ${orderType} Order`, body: 'Confirm in your wallet...' },
                    submitted: { title: `Placing ${orderType} Order`, body: 'Waiting for confirmation...' },
                    success: { title: 'Order Placed!', body: `${orderType} ${shares} shares at ${price.toFixed(2)}` },
                    error: { title: 'Order Failed', body: '' },
                    onSuccess: async () => {
                        document.getElementById('limitPrice').value = '';
                        document.getElementById('limitShares').value = '';
                        updateLimitPreview();
                        await loadOrderbook(marketId, currentTrade.isYes);
                        await refreshUserOrders();
                    }
                });
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Limit order error:', err);
                }
            }
        }

        async function refreshUserOrders() {
            const listEl = document.getElementById('yourOrdersList');

            if (!connectedAddress || !currentTrade.marketId) {
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Connect wallet to see orders</div>';
                return;
            }

            try {
                const rpc = provider || await getRpcProvider();
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, rpc);

                // Get user's order hashes
                const orderCount = await pmRouter.getUserOrderCount(connectedAddress);
                if (orderCount === 0n) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No open orders</div>';
                    userOrders = [];
                    return;
                }

                const orderHashes = await pmRouter.getUserOrderHashes(connectedAddress, 0, 50);

                // Fetch order details and filter for current market
                const orders = [];
                for (const hash of orderHashes) {
                    try {
                        const order = await pmRouter.orders(hash);
                        // Filter: same market AND (order not fully filled, i.e., owner still set)
                        if (order.owner !== ethers.ZeroAddress &&
                            order.marketId.toString() === currentTrade.marketId.toString()) {
                            // Convert ethers Result to plain object
                            orders.push({
                                hash,
                                owner: order.owner,
                                deadline: order.deadline,
                                isYes: order.isYes,
                                isBuy: order.isBuy,
                                partialFill: order.partialFill,
                                shares: order.shares,
                                collateral: order.collateral,
                                marketId: order.marketId
                            });
                        }
                    } catch (e) {
                        // Order might be cancelled/filled
                    }
                }

                userOrders = orders;

                if (orders.length === 0) {
                    listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">No open orders for this market</div>';
                    return;
                }

                // Render orders
                listEl.innerHTML = orders.map(o => {
                    const shares = Number(o.shares) / 1e18;
                    const collateral = Number(o.collateral) / 1e18;
                    const price = shares > 0 ? collateral / shares : 0;
                    const side = o.isBuy ? 'BUY' : 'SELL';
                    const sideColor = o.isBuy ? 'var(--green)' : 'var(--red)';
                    const shareType = o.isYes ? 'YES' : 'NO';

                    return `
                        <div style="display:flex;justify-content:space-between;align-items:center;padding:0.5rem 0;border-bottom:1px solid var(--border);">
                            <div>
                                <span style="color:${sideColor};font-weight:600;">${side}</span>
                                <span style="color:var(--text-muted);">${shares.toFixed(2)} ${shareType} @ ${price.toFixed(4)}</span>
                            </div>
                            <button onclick="cancelUserOrder('${o.hash}')"
                                style="padding:2px 8px;font-size:var(--font-xs);background:transparent;border:1px solid var(--red);color:var(--red);border-radius:var(--radius);cursor:pointer;">
                                Cancel
                            </button>
                        </div>
                    `;
                }).join('');

            } catch (e) {
                console.error('Failed to load user orders:', e);
                listEl.innerHTML = '<div style="color:var(--text-dim);padding:0.5rem 0;">Failed to load orders</div>';
            }
        }

        async function cancelUserOrder(orderHash) {
            if (!signer) {
                showStatus('Connect wallet first', 'error');
                return;
            }

            if (!confirm('Cancel this order?')) return;

            try {
                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);

                await monitorTransaction(pmRouter.cancelOrder(orderHash), {
                    pending: { title: 'Cancelling Order', body: 'Confirm in your wallet...' },
                    submitted: { title: 'Cancelling Order', body: 'Waiting for confirmation...' },
                    success: { title: 'Order Cancelled!', body: 'Your order has been cancelled' },
                    error: { title: 'Cancel Failed', body: '' },
                    onSuccess: async () => {
                        await loadOrderbook(currentTrade.marketId, currentTrade.isYes);
                        await refreshUserOrders();
                        await loadUserPosition();
                    }
                });

            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Cancel order error:', err);
                }
            }
        }

        async function setMaxTrade() {
            if (currentTradeMode === 'lp') {
                if (currentLpMode === 'add') {
                    // Set max ETH for adding LP
                    if (provider && connectedAddress) {
                        try {
                            const bal = await provider.getBalance(connectedAddress);
                            const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                            document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                            updateLpPreview();
                        } catch (e) {}
                    }
                } else {
                    // Set max LP tokens for removing
                    document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    updateLpPreview();
                }
            } else if (currentTradeMode === 'buy' || currentTradeMode === 'mint') {
                // Set max ETH balance (leave some for gas)
                if (provider && connectedAddress) {
                    try {
                        const bal = await provider.getBalance(connectedAddress);
                        const maxBal = bal > ethers.parseEther('0.01') ? bal - ethers.parseEther('0.01') : bal;
                        document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(maxBal)).toFixed(4);
                        if (currentTradeMode === 'mint') {
                            updateMintPreview();
                        } else {
                            updatePreview();
                        }
                    } catch (e) {}
                }
            } else {
                // Set max shares
                const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                document.getElementById('tradeAmount').value = parseFloat(ethers.formatEther(sharesBal)).toFixed(4);
                updatePreview();
            }
        }

        function closeModal() {
            document.getElementById('tradeModal').classList.remove('active');
            document.getElementById('tradeStatus').className = 'status-message';
        }

        async function executeLp() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            try {
                const pamm = new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                // 1% slippage protection for LP operations
                const lpSlippage = 0.01;
                const minAmount = amtWei * BigInt(Math.floor((1 - lpSlippage) * 10000)) / 10000n;

                let txPromise;
                if (currentLpMode === 'add') {
                    // Add liquidity: splitAndAddLiquidity
                    txPromise = pamm.splitAndAddLiquidity(
                        currentTrade.marketId,
                        amtWei,
                        FEE_TIER,
                        0, // amount0Min - tokens go to pool, less critical
                        0, // amount1Min
                        minAmount / 2n, // minLiquidity - protect against sandwich
                        connectedAddress,
                        0, // deadline
                        { value: amtWei }
                    );

                    await monitorTransaction(txPromise, {
                        pending: { title: 'Adding Liquidity', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Adding Liquidity', body: 'Waiting for confirmation...' },
                        success: { title: 'Liquidity Added!', body: `Added ${amt} ETH to the pool` },
                        error: { title: 'Add Liquidity Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([
                                loadUserPosition(currentTrade.marketId),
                                loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                            ]);
                            loadBalance();
                            updateLpPreview();
                        }
                    });
                } else {
                    // Remove liquidity: need PAMM approved as operator on ZAMM
                    const approved = await checkAndRequestApprovals('lp_remove');
                    if (!approved) return;

                    txPromise = pamm.removeLiquidityToCollateral(
                        currentTrade.marketId,
                        FEE_TIER,
                        amtWei,
                        0, // amount0Min
                        0, // amount1Min
                        minAmount, // minCollateralOut - protect against sandwich
                        connectedAddress,
                        0 // deadline
                    );

                    await monitorTransaction(txPromise, {
                        pending: { title: 'Removing Liquidity', body: 'Confirm in your wallet...' },
                        submitted: { title: 'Removing Liquidity', body: 'Waiting for confirmation...' },
                        success: { title: 'Liquidity Removed!', body: `Withdrew liquidity from the pool` },
                        error: { title: 'Remove Liquidity Failed', body: '' },
                        onSuccess: async () => {
                            await Promise.all([
                                loadUserPosition(currentTrade.marketId),
                                loadOrderbook(currentTrade.marketId, currentTrade.isYes)
                            ]);
                            loadBalance();
                            updateLpPreview();
                        }
                    });
                }

            } catch (e) {
                // monitorTransaction handles errors, but catch user rejection before tx submission
                if (!isUserRejection(e)) {
                    console.error('LP operation failed:', e);
                }
            }
        }

        async function loadBalance() {
            if (!provider || !connectedAddress) return;
            try {
                if (currentTradeMode === 'lp') {
                    if (currentLpMode === 'add') {
                        const bal = await provider.getBalance(connectedAddress);
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                    } else {
                        document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(currentUserPosition.lpBalance)).toFixed(4);
                    }
                } else if (currentTradeMode === 'buy' || currentTradeMode === 'mint') {
                    const bal = await provider.getBalance(connectedAddress);
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(bal)).toFixed(4);
                } else {
                    const sharesBal = currentTrade.isYes ? currentUserPosition.yesBalance : currentUserPosition.noBalance;
                    document.getElementById('tradeBalance').textContent = parseFloat(ethers.formatEther(sharesBal)).toFixed(4);
                }
            } catch (e) {
                document.getElementById('tradeBalance').textContent = '--';
            }
        }

        function updatePreview() {
            const amt = parseFloat(document.getElementById('tradeAmount').value) || 0;
            const m = markets[currentTrade.type];
            const routeEl = document.getElementById('previewRoute');
            const breakdownEl = document.getElementById('previewBreakdown');
            const savingsEl = document.getElementById('previewSavings');
            const breakdownDetails = document.getElementById('breakdownDetails');

            if (!m || amt === 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = '--';
                routeEl.textContent = 'AMM';
                routeEl.style.color = 'var(--blue)';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            const price = currentTrade.isYes ? m.yesPrice : m.noPrice;
            const ammPrice = currentOrderbook.ammPrice || price;
            const rYes = currentOrderbook.rYes || 0n;
            const rNo = currentOrderbook.rNo || 0n;

            // Simulate mixed fill execution
            const execution = simulateMixedFill(amt, currentTradeMode === 'buy', rYes, rNo, ammPrice);

            // Update route indicator
            if (execution.orderbookFills.length > 0) {
                routeEl.innerHTML = `Orderbook + AMM <span style="color:var(--green);">â˜…</span>`;
                routeEl.style.color = 'var(--green)';
            } else {
                routeEl.textContent = 'AMM only';
                routeEl.style.color = 'var(--blue)';
            }

            // Update main preview
            if (execution.totalOutput <= 0) {
                document.getElementById('previewShares').textContent = '--';
                document.getElementById('previewPrice').textContent = '--';
                document.getElementById('previewPayout').textContent = 'No liquidity';
                breakdownEl.style.display = 'none';
                savingsEl.style.display = 'none';
                return;
            }

            if (currentTradeMode === 'buy') {
                // Buy: spend ETH, receive shares (1 share = 1 ETH if win)
                const effectivePrice = amt / execution.totalOutput;
                const payout = execution.totalOutput; // Shares redeem at 1 ETH each
                const profit = payout - amt;
                const roi = (profit / amt) * 100;

                document.getElementById('previewShares').textContent = formatEth(execution.totalOutput, ' shares');
                document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH/share');
                document.getElementById('previewPayout').textContent = `${formatEth(payout, '')} ETH (+${roi.toFixed(0)}%)`;
            } else {
                // Sell: spend shares, receive ETH
                const effectivePrice = execution.totalOutput / amt;
                const minReceive = execution.totalOutput * (1 - slippageTolerance / 100);

                document.getElementById('previewShares').textContent = formatEth(execution.totalOutput);
                document.getElementById('previewPrice').textContent = formatEth(effectivePrice, ' ETH/share');
                document.getElementById('previewPayout').textContent = formatEth(minReceive);
            }

            // Show execution breakdown if using orderbook
            if (execution.orderbookFills.length > 0) {
                breakdownEl.style.display = 'flex';
                let breakdownHtml = '';
                execution.orderbookFills.forEach(fill => {
                    if (currentTradeMode === 'buy') {
                        breakdownHtml += `<div>â€¢ ${formatEth(fill.sharesOut, '')} @ ${formatEth(fill.price, '')} (OB)</div>`;
                    } else {
                        breakdownHtml += `<div>â€¢ ${formatEth(fill.sharesIn, '')} @ ${formatEth(fill.price, '')} (OB)</div>`;
                    }
                });
                if (execution.ammOutput > 0) {
                    if (currentTradeMode === 'buy') {
                        breakdownHtml += `<div>â€¢ ${formatEth(execution.ammOutput, '')} @ ~${formatEth(execution.ammEffectivePrice, '')} (AMM)</div>`;
                    } else {
                        breakdownHtml += `<div>â€¢ ${formatEth(execution.ammSharesIn, '')} â†’ ${formatEth(execution.ammOutput)} (AMM)</div>`;
                    }
                }
                breakdownDetails.innerHTML = breakdownHtml;
            } else {
                breakdownEl.style.display = 'none';
            }

            // Show savings vs pure AMM
            if (execution.savings > 0.0001) {
                savingsEl.style.display = 'flex';
                const savingsPct = (execution.savings / execution.pureAmmOutput * 100).toFixed(1);
                document.getElementById('savingsAmount').textContent = `+${execution.savings.toFixed(4)} (+${savingsPct}%)`;
                document.getElementById('savingsAmount').style.color = 'var(--green)';
            } else {
                savingsEl.style.display = 'none';
            }
        }

        // Simulate execution through orderbook first, then AMM for remainder
        function simulateMixedFill(inputAmt, isBuy, rYes, rNo, ammPrice) {
            const result = {
                orderbookFills: [],
                ammInput: 0,
                ammOutput: 0,
                ammSharesIn: 0,
                ammEffectivePrice: 0,
                totalOutput: 0,
                pureAmmOutput: 0,
                savings: 0
            };

            let remaining = inputAmt;
            const amtWei = BigInt(Math.floor(inputAmt * 1e18));

            // Calculate pure AMM output for comparison
            if (rYes > 0n && rNo > 0n) {
                if (isBuy) {
                    const pureAmm = currentTrade.isYes ?
                        quoteBuyYes(amtWei, rYes, rNo, FEE_TIER) :
                        quoteBuyNo(amtWei, rYes, rNo, FEE_TIER);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                } else {
                    const pureAmm = currentTrade.isYes ?
                        quoteSellYes(amtWei, rYes, rNo, FEE_TIER) :
                        quoteSellNo(amtWei, rYes, rNo, FEE_TIER);
                    result.pureAmmOutput = Number(pureAmm) / 1e18;
                }
            }

            // Get orders better than AMM
            let betterOrders = [];
            if (isBuy) {
                // For buying: asks cheaper than AMM, sorted by price ascending
                betterOrders = (currentOrderbook.asks || [])
                    .map(o => ({
                        price: Number(o.collateral) / Number(o.shares),
                        shares: Number(o.shares) / 1e18,
                        collateral: Number(o.collateral) / 1e18,
                        hash: o.hash
                    }))
                    .filter(o => ammPrice > 0 ? o.price < ammPrice : true)
                    .sort((a, b) => a.price - b.price);
            } else {
                // For selling: bids higher than AMM, sorted by price descending
                betterOrders = (currentOrderbook.bids || [])
                    .map(o => ({
                        price: Number(o.collateral) / Number(o.shares),
                        shares: Number(o.shares) / 1e18,
                        collateral: Number(o.collateral) / 1e18,
                        hash: o.hash
                    }))
                    .filter(o => ammPrice > 0 ? o.price > ammPrice : true)
                    .sort((a, b) => b.price - a.price);
            }

            // Fill through orderbook
            for (const order of betterOrders) {
                if (remaining <= 0) break;

                if (isBuy) {
                    // Buying: we spend ETH, get shares
                    const maxEthForOrder = order.collateral;
                    const ethToSpend = Math.min(remaining, maxEthForOrder);
                    const sharesOut = ethToSpend / order.price;

                    result.orderbookFills.push({
                        price: order.price,
                        ethSpent: ethToSpend,
                        sharesOut: sharesOut,
                        hash: order.hash
                    });
                    result.totalOutput += sharesOut;
                    remaining -= ethToSpend;
                } else {
                    // Selling: we spend shares, get ETH
                    const maxSharesForOrder = order.shares;
                    const sharesToSell = Math.min(remaining, maxSharesForOrder);
                    const ethOut = sharesToSell * order.price;

                    result.orderbookFills.push({
                        price: order.price,
                        sharesIn: sharesToSell,
                        ethOut: ethOut,
                        hash: order.hash
                    });
                    result.totalOutput += ethOut;
                    remaining -= sharesToSell;
                }
            }

            // Remainder goes to AMM
            if (remaining > 0 && rYes > 0n && rNo > 0n) {
                const remainingWei = BigInt(Math.floor(remaining * 1e18));
                result.ammInput = remaining;

                if (isBuy) {
                    const ammOut = currentTrade.isYes ?
                        quoteBuyYes(remainingWei, rYes, rNo, FEE_TIER) :
                        quoteBuyNo(remainingWei, rYes, rNo, FEE_TIER);
                    result.ammOutput = Number(ammOut) / 1e18;
                    result.ammEffectivePrice = remaining / result.ammOutput;
                    result.totalOutput += result.ammOutput;
                } else {
                    const ammOut = currentTrade.isYes ?
                        quoteSellYes(remainingWei, rYes, rNo, FEE_TIER) :
                        quoteSellNo(remainingWei, rYes, rNo, FEE_TIER);
                    result.ammOutput = Number(ammOut) / 1e18;
                    result.ammSharesIn = remaining;
                    result.totalOutput += result.ammOutput;
                }
            } else if (remaining > 0) {
                // No AMM, use ammPrice as fallback
                if (isBuy) {
                    const shares = remaining / ammPrice;
                    result.ammOutput = shares;
                    result.ammEffectivePrice = ammPrice;
                    result.totalOutput += shares;
                } else {
                    const ethOut = remaining * ammPrice;
                    result.ammOutput = ethOut;
                    result.ammSharesIn = remaining;
                    result.totalOutput += ethOut;
                }
            }

            // Calculate savings vs pure AMM
            if (result.pureAmmOutput > 0) {
                result.savings = result.totalOutput - result.pureAmmOutput;
            }

            return result;
        }

        async function executeTrade() {
            if (!signer || !currentTrade.marketId) return;

            const amt = parseFloat(document.getElementById('tradeAmount').value);
            if (!amt || amt <= 0) { showStatus('Enter valid amount', 'error'); return; }

            try {
                showStatus('Preparing...', 'pending');

                const pmRouter = new ethers.Contract(PMROUTER_ADDRESS, PMROUTER_ABI, signer);
                const amtWei = ethers.parseEther(amt.toString());

                const ammPrice = currentOrderbook.ammPrice || 0;
                const rYes = currentOrderbook.rYes || 0n;
                const rNo = currentOrderbook.rNo || 0n;

                // Simulate execution to get expected output and order hashes
                const execution = simulateMixedFill(amt, currentTradeMode === 'buy', rYes, rNo, ammPrice);

                if (execution.totalOutput <= 0) {
                    showStatus('No liquidity available', 'error');
                    return;
                }

                // Calculate minOutput with slippage tolerance
                const minOutput = Math.max(0, execution.totalOutput * (1 - slippageTolerance / 100));
                const minOutputWei = ethers.parseEther(minOutput.toFixed(18));

                // Get order hashes from simulation
                const betterOrderHashes = execution.orderbookFills.map(f => f.hash);

                const tradeLabel = currentTradeMode === 'buy' ? 'Buying' : 'Selling';
                const side = currentTrade.isYes ? (currentTrade.type === 'extreme' ? 'YES' : 'UP') : (currentTrade.type === 'extreme' ? 'NO' : 'DOWN');

                let txPromise;
                if (currentTradeMode === 'buy') {
                    // Use fillOrdersThenSwap if we have better limit orders
                    if (betterOrderHashes.length > 0) {
                        txPromise = pmRouter.fillOrdersThenSwap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            true, // isBuy
                            amtWei,
                            minOutputWei, // slippage protected
                            betterOrderHashes,
                            FEE_TIER,
                            connectedAddress,
                            0, // deadline (0 = no deadline)
                            { value: amtWei }
                        );
                    } else {
                        txPromise = pmRouter.buy(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei, // slippage protected
                            FEE_TIER,
                            connectedAddress,
                            0,
                            { value: amtWei }
                        );
                    }
                } else {
                    // Sell - need PMRouter approved as operator on PAMM
                    const approved = await checkAndRequestApprovals('sell');
                    if (!approved) return;

                    // Use fillOrdersThenSwap if we have better limit orders
                    if (betterOrderHashes.length > 0) {
                        txPromise = pmRouter.fillOrdersThenSwap(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            false, // isBuy
                            amtWei,
                            minOutputWei, // slippage protected
                            betterOrderHashes,
                            FEE_TIER,
                            connectedAddress,
                            0 // deadline
                        );
                    } else {
                        txPromise = pmRouter.sell(
                            currentTrade.marketId,
                            currentTrade.isYes,
                            amtWei,
                            minOutputWei, // slippage protected
                            FEE_TIER,
                            connectedAddress,
                            0
                        );
                    }
                }

                await monitorTransaction(txPromise, {
                    pending: { title: `${tradeLabel} ${side}`, body: 'Confirm in your wallet...' },
                    submitted: { title: `${tradeLabel} ${side}`, body: 'Waiting for confirmation...' },
                    success: { title: 'Trade Successful!', body: `${tradeLabel} ${amt} ${currentTradeMode === 'buy' ? 'ETH worth of' : ''} ${side} shares` },
                    error: { title: 'Trade Failed', body: '' },
                    onSuccess: async () => {
                        await loadData();
                        await loadPositions();
                        setTimeout(closeModal, 1500);
                    }
                });

            } catch (e) {
                // monitorTransaction handles errors, but catch user rejection before tx submission
                if (!isUserRejection(e)) {
                    console.error('Trade failed:', e);
                }
            }
        }

        function showStatus(msg, type, isHtml = false) {
            const el = document.getElementById('tradeStatus');
            if (isHtml) {
                el.innerHTML = msg;
            } else {
                el.textContent = msg;
            }
            el.className = 'status-message show ' + type;
        }

        function txLink(hash, text = 'View tx') {
            return `<a href="https://etherscan.io/tx/${hash}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: underline;">${text}</a>`;
        }

        // ======================== TOAST NOTIFICATIONS ========================

        let activeToasts = new Map(); // Track active toasts by ID

        /**
         * Show a toast notification
         * @param {string} title - Toast title
         * @param {string} body - Toast body text (can include HTML)
         * @param {string} type - 'pending', 'success', or 'error'
         * @param {number} duration - Auto-dismiss duration in ms (0 = no auto-dismiss)
         * @param {string} id - Optional unique ID for updating existing toast
         * @returns {string} - Toast ID
         */
        function showToast(title, body = '', type = 'pending', duration = 0, id = null) {
            const container = document.getElementById('toastContainer');
            const toastId = id || `toast-${Date.now()}`;

            // If updating existing toast, remove old one first
            if (id && activeToasts.has(id)) {
                const existing = activeToasts.get(id);
                existing.element.remove();
                if (existing.timeout) clearTimeout(existing.timeout);
            }

            const icons = {
                pending: '<div class="spinner"></div>',
                success: '<span class="icon">âœ“</span>',
                error: '<span class="icon">âœ—</span>',
                info: '<span class="icon">â„¹</span>'
            };

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-header">
                    ${icons[type] || ''}
                    <span>${title}</span>
                </div>
                ${body ? `<div class="toast-body">${body}</div>` : ''}
                ${duration > 0 ? `<div class="toast-progress"><div class="toast-progress-bar" style="animation-duration: ${duration}ms;"></div></div>` : ''}
            `;

            container.appendChild(toast);

            let timeout = null;
            if (duration > 0) {
                timeout = setTimeout(() => {
                    dismissToast(toastId);
                }, duration);
            }

            activeToasts.set(toastId, { element: toast, timeout });
            return toastId;
        }

        function dismissToast(toastId) {
            if (!activeToasts.has(toastId)) return;

            const { element, timeout } = activeToasts.get(toastId);
            if (timeout) clearTimeout(timeout);

            element.classList.add('hiding');
            setTimeout(() => {
                element.remove();
                activeToasts.delete(toastId);
            }, 300);
        }

        function updateToast(toastId, title, body, type, duration = 0) {
            return showToast(title, body, type, duration, toastId);
        }

        /**
         * Helper for transaction monitoring with toast updates
         * @param {Promise} txPromise - The transaction promise
         * @param {object} options - { pending, success, error } message configs
         * @returns {Promise} - The transaction receipt
         */
        async function monitorTransaction(txPromise, options = {}) {
            const {
                pending = { title: 'Transaction Pending', body: 'Confirm in your wallet...' },
                submitted = { title: 'Transaction Submitted', body: 'Waiting for confirmation...' },
                success = { title: 'Transaction Confirmed', body: '' },
                error = { title: 'Transaction Failed', body: '' },
                onSuccess = null
            } = options;

            const toastId = showToast(pending.title, pending.body, 'pending');
            let txHash = null;

            try {
                const tx = await txPromise;

                // Transaction submitted to network
                txHash = tx.hash;
                const etherscanLink = `<a href="https://etherscan.io/tx/${txHash}" target="_blank">View on Etherscan</a>`;
                updateToast(toastId, submitted.title, `${submitted.body}<br>${etherscanLink}`, 'pending');

                // Wait for confirmation using dedicated RPC provider (more reliable than wallet's provider)
                const rpc = await getRpcProvider();
                const receipt = await Promise.race([
                    rpc.waitForTransaction(txHash, 1, 60000), // 1 confirmation, 60s timeout
                    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), 65000))
                ]);

                // Use Number() to handle BigInt or string status values
                if (receipt && Number(receipt.status) === 1) {
                    updateToast(toastId, success.title, `${success.body}${success.body ? '<br>' : ''}${etherscanLink}`, 'success', 5000);
                    if (onSuccess) await onSuccess(receipt);
                    return receipt;
                } else if (receipt && Number(receipt.status) === 0) {
                    updateToast(toastId, error.title, `Transaction reverted<br>${etherscanLink}`, 'error', 8000);
                    throw new Error('Transaction reverted');
                } else {
                    // Timeout or null receipt - tx may still be pending or succeeded
                    console.warn('Unexpected receipt state:', receipt);
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded<br>${etherscanLink}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                }
            } catch (e) {
                console.error('Transaction error:', e);
                if (isUserRejection(e)) {
                    updateToast(toastId, 'Transaction Cancelled', 'You rejected the transaction', 'error', 4000);
                } else if (e.message === 'timeout') {
                    const etherscanLink = txHash ? `<a href="https://etherscan.io/tx/${txHash}" target="_blank">View on Etherscan</a>` : '';
                    updateToast(toastId, 'Check Status', `Transaction may have succeeded${etherscanLink ? '<br>' + etherscanLink : ''}`, 'info', 10000);
                    if (onSuccess) await onSuccess(null);
                    return null;
                } else {
                    const errMsg = e.reason || e.message || 'Unknown error';
                    updateToast(toastId, error.title, errMsg, 'error', 8000);
                }
                throw e;
            }
        }

        // ======================== APPROVALS ========================

        /**
         * Ensure operator approval for a contract.
         * @param {string} tokenContract - 'pamm' or 'zamm'
         * @param {string} operatorAddress - Address to approve as operator
         * @param {string} operatorName - Human-readable name for status messages
         * @returns {Promise<boolean>} - true if approved (or already approved), false if rejected
         */
        async function ensureOperatorApproval(tokenContract, operatorAddress, operatorName) {
            if (!signer || !connectedAddress) return false;

            try {
                const contract = tokenContract === 'pamm'
                    ? new ethers.Contract(PAMM_ADDRESS, PAMM_ABI, signer)
                    : new ethers.Contract(ZAMM_ADDRESS, ZAMM_ABI, signer);

                const isApproved = await contract.isOperator(connectedAddress, operatorAddress);
                if (isApproved) return true;

                let success = false;
                await monitorTransaction(contract.setOperator(operatorAddress, true), {
                    pending: { title: 'Approval Required', body: `Approve ${operatorName} as operator...` },
                    submitted: { title: 'Approval Required', body: 'Waiting for confirmation...' },
                    success: { title: 'Approved!', body: `${operatorName} can now manage your tokens` },
                    error: { title: 'Approval Failed', body: '' },
                    onSuccess: () => { success = true; }
                });
                return success;
            } catch (err) {
                if (!isUserRejection(err)) {
                    console.error('Approval error:', err);
                }
                return false;
            }
        }

        /**
         * Check all required approvals for the current operation
         * @param {string} operation - 'sell', 'lp', 'mint', 'limit'
         * @returns {Promise<boolean>} - true if all approvals granted
         */
        async function checkAndRequestApprovals(operation) {
            if (!signer || !connectedAddress) {
                showStatus('Please connect wallet first', 'error');
                return false;
            }

            // PMRouter needs to be operator on PAMM for: sell, mint & list, limit orders
            if (operation === 'sell' || operation === 'mint' || operation === 'limit') {
                const approved = await ensureOperatorApproval('pamm', PMROUTER_ADDRESS, 'PMRouter');
                if (!approved) return false;
            }

            // PAMM needs to be operator on ZAMM for: LP remove
            if (operation === 'lp_remove') {
                const approved = await ensureOperatorApproval('zamm', PAMM_ADDRESS, 'PAMM');
                if (!approved) return false;
            }

            return true;
        }

        // ======================== HELPERS ========================

        // AMM constant product formula (matches ZAMM._getAmountOut)
        function getAmountOut(amountIn, reserveIn, reserveOut, feeBps = 30n) {
            if (amountIn === 0n || reserveIn === 0n || reserveOut === 0n) return 0n;
            const amountInWithFee = amountIn * (10000n - feeBps);
            const numerator = amountInWithFee * reserveOut;
            const denominator = (reserveIn * 10000n) + amountInWithFee;
            return numerator / denominator;
        }

        // AMM reverse calculation (matches ZAMM._getAmountIn)
        function getAmountIn(amountOut, reserveIn, reserveOut, feeBps = 30n) {
            if (amountOut === 0n || reserveIn === 0n || amountOut >= reserveOut) return 0n;
            const numerator = reserveIn * amountOut * 10000n;
            const denominator = (reserveOut - amountOut) * (10000n - feeBps);
            return (numerator / denominator) + 1n;
        }

        // Quote buying YES shares with collateral
        // PAMM buyYes: split collateral â†’ YES + NO, then swap NO â†’ YES
        function quoteBuyYes(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn â†’ collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn NO â†’ yesFromSwap YES (pool: NO in, YES out)
            const yesFromSwap = getAmountOut(collateralIn, rNo, rYes, feeBps);
            // Total YES = from split + from swap
            return collateralIn + yesFromSwap;
        }

        // Quote buying NO shares with collateral
        // PAMM buyNo: split collateral â†’ YES + NO, then swap YES â†’ NO
        function quoteBuyNo(collateralIn, rYes, rNo, feeBps = 30n) {
            // 1. Split: collateralIn â†’ collateralIn YES + collateralIn NO
            // 2. Swap: collateralIn YES â†’ noFromSwap NO (pool: YES in, NO out)
            const noFromSwap = getAmountOut(collateralIn, rYes, rNo, feeBps);
            // Total NO = from split + from swap
            return collateralIn + noFromSwap;
        }

        // Quote selling YES shares for collateral
        // PAMM sellYes: swap some YES â†’ NO, then merge YES + NO â†’ collateral
        function quoteSellYes(yesIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of YES â†’ NO, then merge
            // Actual: swap yesIn/2 â†’ NO, merge min(yesIn/2, noFromSwap)
            const yesToSwap = yesIn / 2n;
            const noFromSwap = getAmountOut(yesToSwap, rYes, rNo, feeBps);
            const yesRemaining = yesIn - yesToSwap;
            // Merge: min(yesRemaining, noFromSwap) â†’ collateral
            const merged = yesRemaining < noFromSwap ? yesRemaining : noFromSwap;
            return merged;
        }

        // Quote selling NO shares for collateral
        // PAMM sellNo: swap some NO â†’ YES, then merge YES + NO â†’ collateral
        function quoteSellNo(noIn, rYes, rNo, feeBps = 30n) {
            // Strategy: swap half of NO â†’ YES, then merge
            const noToSwap = noIn / 2n;
            const yesFromSwap = getAmountOut(noToSwap, rNo, rYes, feeBps);
            const noRemaining = noIn - noToSwap;
            // Merge: min(yesFromSwap, noRemaining) â†’ collateral
            const merged = yesFromSwap < noRemaining ? yesFromSwap : noRemaining;
            return merged;
        }

        function formatGwei(wei) {
            const gwei = Number(wei) / 1e9;
            if (gwei >= 100) return Math.round(gwei).toString();
            if (gwei >= 10) return gwei.toFixed(1);
            return gwei.toFixed(2);
        }

        // Smart ETH formatting - shows appropriate precision for amount size
        function formatEth(eth, suffix = ' ETH') {
            if (eth === 0) return '0' + suffix;
            if (eth >= 100) return eth.toFixed(1) + suffix;
            if (eth >= 10) return eth.toFixed(2) + suffix;
            if (eth >= 1) return eth.toFixed(3) + suffix;
            if (eth >= 0.1) return eth.toFixed(4) + suffix;
            if (eth >= 0.01) return eth.toFixed(4) + suffix;
            if (eth >= 0.001) return eth.toFixed(5) + suffix;
            return eth.toFixed(6) + suffix; // For very small amounts
        }

        // Format odds/probability with appropriate precision
        function formatOdds(price, asPercent = true) {
            if (asPercent) {
                const pct = price * 100;
                if (pct >= 99 || pct <= 1) return pct.toFixed(1) + '%';
                if (pct >= 90 || pct <= 10) return pct.toFixed(1) + '%';
                return pct.toFixed(1) + '%';
            }
            return price.toFixed(4);
        }

        /**
         * Calculate predicted TWAP at market close based on:
         * - Current TWAP (partially locked in based on elapsed time)
         * - Market odds indicating expected direction for remaining time
         * - Time remaining until market close
         */
        function calculatePredictedTwap(currentTwap, startTwap, yesPrice, marketClose, marketStart) {
            // Safety check - if no valid TWAP data, return 0 (will skip drawing)
            if (!currentTwap || currentTwap <= 0) return 0;

            const now = Math.floor(Date.now() / 1000);
            const totalDuration = marketClose - marketStart;
            if (totalDuration <= 0) return currentTwap; // Invalid duration, use current

            const elapsed = Math.max(0, now - marketStart);
            const elapsedRatio = Math.min(1, elapsed / totalDuration);

            // How much TWAP is "locked in" vs still to be determined
            // Early in market: mostly speculation. Late in market: mostly locked.
            const lockedWeight = elapsedRatio;
            const speculativeWeight = 1 - lockedWeight;

            // Market's expected direction: odds above/below 50% indicate UP/DOWN expectation
            // Scale the expected future average based on odds
            // At 100% YES: expect future avg to be ~20% above current
            // At 0% YES: expect future avg to be ~20% below current
            const oddsDirection = (yesPrice - 0.5) * 2; // -1 to +1
            const futureMultiplier = 1 + oddsDirection * 0.15; // Â±15% swing
            const expectedFutureAvg = currentTwap * futureMultiplier;

            // Blend locked-in TWAP with speculative future
            const predicted = currentTwap * lockedWeight + expectedFutureAvg * speculativeWeight;

            return predicted;
        }

        /**
         * Update market predictions and the header stats
         */
        function updatePredictions() {
            const predictions = [];
            const now = Math.floor(Date.now() / 1000);

            // Helper to estimate market start time (close minus typical duration)
            const estimateStart = (close, type) => {
                if (type === 'hourly') return close - 3600;
                if (type === 'daily') return close - 86400;
                if (type === 'weekly') return close - 604800;
                return close - 3600;
            };

            // Hourly market prediction
            if (markets.hourly && markets.hourly.yesPrice !== undefined) {
                const m = markets.hourly;
                const start = estimateStart(m.close, 'hourly');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.hourly.predictedTwap = predicted;
                predictions.push({ type: 'hourly', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Daily market prediction
            if (markets.daily && markets.daily.yesPrice !== undefined) {
                const m = markets.daily;
                const start = estimateStart(m.close, 'daily');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.daily.predictedTwap = predicted;
                predictions.push({ type: 'daily', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Weekly market prediction
            if (markets.weekly && markets.weekly.yesPrice !== undefined) {
                const m = markets.weekly;
                const start = estimateStart(m.close, 'weekly');
                const predicted = calculatePredictedTwap(cachedGasData.twap, m.startGwei, m.yesPrice, m.close, start);
                markets.weekly.predictedTwap = predicted;
                predictions.push({ type: 'weekly', close: m.close, predicted, yesPrice: m.yesPrice });
            }

            // Update prediction arrows for each timeframe
            const updateArrow = (elId, market, label) => {
                const el = document.getElementById(elId);
                if (!el) return;

                if (market && market.yesPrice !== undefined) {
                    const yesOdds = market.yesPrice;
                    const arrow = yesOdds > 0.5 ? 'â†‘' : yesOdds < 0.5 ? 'â†“' : 'â†’';
                    const color = yesOdds > 0.5 ? 'var(--green)' : yesOdds < 0.5 ? 'var(--red)' : 'var(--text-muted)';
                    const pct = Math.round(Math.max(yesOdds, 1 - yesOdds) * 100);
                    const direction = yesOdds > 0.5 ? 'UP' : 'DOWN';
                    el.innerHTML = `${label}<span style="color:${color};font-weight:700;">${arrow}</span>`;
                    el.title = `${pct}% ${direction} (from ${market.startGwei?.toFixed(2) || '--'} gwei)`;
                } else {
                    el.innerHTML = `${label}<span style="color:var(--text-dim);">--</span>`;
                    el.title = 'No active market';
                }
            };

            updateArrow('pred1H', markets.hourly, '1H ');
            updateArrow('pred1D', markets.daily, '1D ');
            updateArrow('pred1W', markets.weekly, '1W ');

            return predictions;
        }

        // ======================== MARKET RESOLUTION ========================
        async function resolveMarket(type) {
            const market = markets[type];
            if (!market || !market.id) {
                showToast('No Market', 'No market to resolve', 'error', 3000);
                return;
            }

            if (!signer) {
                showToast('Connect Wallet', 'Please connect your wallet first', 'error', 3000);
                return;
            }

            try {
                const resolver = new ethers.Contract(RESOLVER_ADDRESS, RESOLVER_ABI, signer);

                await monitorTransaction(
                    resolver.resolveMarket(market.id),
                    {
                        pending: { title: 'Resolving Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Resolving Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Resolved!', body: `${type.charAt(0).toUpperCase() + type.slice(1)} market has been resolved` },
                        error: { title: 'Resolution Failed', body: '' },
                        onSuccess: async () => {
                            await loadData();
                            await loadPositions();
                        }
                    }
                );
            } catch (e) {
                // monitorTransaction already shows toast for errors, so just log
                console.error('Resolve failed:', e);
            }
        }

        // ======================== MARKET CREATION ========================
        async function createHourly() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('hourlySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close at next top of hour UTC
                const close = new Date();
                close.setUTCMinutes(60, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000', // ETH
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Hourly Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Hourly Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Hourly market seeded with ${seed} ETH` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('hourlySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createDaily() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('dailySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close at next midnight UTC
                const close = new Date();
                close.setUTCHours(24, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000', // ETH
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Daily Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Daily Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Daily market seeded with ${seed} ETH` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('dailySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createWeekly() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('weeklySeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Close next Sunday midnight UTC
                const close = new Date();
                close.setUTCDate(close.getUTCDate() + (7 - close.getUTCDay()));
                close.setUTCHours(0, 0, 0, 0);
                const closeTs = Math.floor(close.getTime() / 1000);

                await monitorTransaction(
                    gasPm.createComparisonMarket(
                        '0x0000000000000000000000000000000000000000',
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating Weekly Market', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating Weekly Market', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: `Weekly market seeded with ${seed} ETH` },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('weeklySeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        async function createExtreme() {
            if (!signer || !isOwner) return;

            const seed = parseFloat(document.getElementById('extremeSeed').value);
            if (!seed || seed <= 0) { showToast('Invalid Seed', 'Enter a seed amount greater than 0', 'error', 4000); return; }

            try {
                const gasPm = new ethers.Contract(GASPM_ADDRESS, GASPM_ABI, signer);

                // Fixed deadline: Dec 31, 2025 23:59:59 UTC
                const closeTs = 1767225599;
                const threshold = ethers.parseUnits('100', 'gwei'); // 100 gwei

                await monitorTransaction(
                    gasPm.createWindowPeakMarket(
                        threshold,
                        '0x0000000000000000000000000000000000000000',
                        closeTs,
                        ethers.parseEther(seed.toString()),
                        FEE_TIER,
                        0,
                        connectedAddress,
                        { value: ethers.parseEther(seed.toString()) }
                    ),
                    {
                        pending: { title: 'Creating 100 Gwei Challenge', body: 'Confirm transaction in your wallet...' },
                        submitted: { title: 'Creating 100 Gwei Challenge', body: 'Waiting for confirmation...' },
                        success: { title: 'Market Created!', body: '100 Gwei Challenge - Deadline: Dec 31, 2025' },
                        error: { title: 'Create Failed', body: '' },
                        onSuccess: async () => {
                            document.getElementById('extremeSeed').value = '';
                            await loadData();
                        }
                    }
                );
            } catch (e) {
                // Error already handled by monitorTransaction
            }
        }

        // ======================== START ========================
        init();
    </script>
</body>
</html>
